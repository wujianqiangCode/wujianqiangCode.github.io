<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CUDA学习笔记</title>
      <link href="/2023/01/19/CUDA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/19/CUDA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="CUDA介绍"><a href="#CUDA介绍" class="headerlink" title="CUDA介绍"></a>CUDA介绍</h1><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CUDA是2016年Nvida发布的一种建立在NVIDA的CPUs上的一个通用并行技术平台和编程模型。</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;基于CUDA编程可以利用GPUs的并行计算引擎来更高效率的解决复杂的计算难题，因此被广泛应用于深度学习领域。现如今基于GPU的并行计算已经成为了训练深度学习模型的标配，要是实验室连一块GPU都没有，怕是连论文都发不了。</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;需要注意的GPU并不是一个独立运行的计算平台，而需要与CPU协同工作，可以看成是CPU的<font color =red>协处理器</font>，因此当我们在说GPU并行计算时，其实是指的基于CPU+GPU的异构计算架构。在异构计算架构中，GPU与CPU通过PCIe总线连接在一起来协同工作，CPU所在位置称为为主机端（host），而GPU所在位置称为设备端（device）,具体示意图如下：</p><p><img src="/./picture/CUDA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/CPU+GPU%E7%9A%84%E5%BC%82%E6%9E%84.png"></p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;从上图可以看出<font color =red>GPU包括更多的运算核心，其特别适合数据并行的计算密集型任务，如大型矩阵运算，而CPU的运算核心较少，但是其可以实现复杂的逻辑运算，因此其适合控制密集型任务。另外，CPU上的线程是重量级的，上下文切换开销大，但是GPU由于存在很多核心，其线程是轻量级的</font>。因此，基于CPU+GPU的异构计算平台可以优势互补，CPU负责处理逻辑复杂的串行程序，而GPU重点处理数据密集型的并行计算程序，从而发挥最大功效。</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CUDA是NVIDIA公司所开发的GPU编程模型，它提供了GPU编程的简易接口，基于CUDA编程可以构建基于GPU计算的应用程序。CUDA提供了对其它编程语言的支持，如C&#x2F;C++，Python，Fortran等语言，这里我们选择CUDA C&#x2F;C++接口对CUDA编程进行讲解。</p><h1 id="CUDA编程模型基础"><a href="#CUDA编程模型基础" class="headerlink" title="CUDA编程模型基础"></a>CUDA编程模型基础</h1><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CUDA编程模型是一个异构模型，<font color =red>需要CPU和GPU协同工作</font>。在CUDA中，host和device是两个重要的概念，我们用<font color = red>host指代CPU及其内存，而用device指代GPU及其内存</font>。<font color = yellow>CUDA程序中既包含host程序，又包含device程序，它们分别在CPU和GPU上运行</font>。同时，host与device之间可以进行通信，这样它们之间可以进行数据拷贝。典型的CUDA程序的执行流程如下：</p><ul><li>在CPU上分配host内存，并进行数据初始化；(Allocate CPU memory and init data)</li><li>在GPU上分配device内存，并从host将数据拷贝到device上；((Allocate GPU memory,CPU data copy to GPU)</li><li>调用CUDA的核函数在device上完成指定的运算；(GPU Working)</li><li>将device上的运算结果拷贝到host上；（GPU -&gt; CPU）</li><li>释放device和host上分配的内存。 (free CPU memory and GPU memory)</li></ul><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;上面流程中最重要的一个过程是调用CUDA的核函数来执行并行计算.这边涉及到CUDA中一个重要的概念kernel。</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;kernel是在GPU的device上线程中并行执行的一个函数。核函数用__global__符号声明，在调用时需要用&lt;&lt;&lt;grid, block&gt;&gt;&gt;来指定kernel要执行的线程数量，在CUDA中，每一个线程都要执行核函数，并且每个线程会分配一个唯一的线程号thread ID，这个ID值可以通过核函数的内置变量threadIdx来获得。</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;由于GPU实际上是异构模型，所以需要区分host和device上的代码，在CUDA中是通过函数类型限定词开区别host和device上的函数，主要的<font color = red>三个函数类型</font>限定词如下：</p><ul><li>__global__：在device上执行，从host中调用（一些特定的GPU也可以从device上调用），返回类型必须是void，不支持可变参数参数，不能成为类成员函数。注意用__global__定义的kernel是异步的，这意味着host不会等待kernel执行完就执行下一步。</li><li>__device__：在device上执行，单仅可以从device中调用，不可以和__global__同时用。</li><li>__host__：在host上执行，仅可以从host上调用，一般省略不写，不可以和__global__同时用，但可和__device__，此时函数会在device和host都编译。</li></ul><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;由于GPU上面有很多并行化的轻量级线程，因此借助了线程间切换花销小这一特点。kernel在GPU上分配的device上执行的时候，实际上也是启动了非常多的线程，这里将一个kernel所启动的所有线程称为一个网格（grid）。grid内的所有线程共享相同的全局内存空间。<br>同时每个grid又可以分成很多个线程块（block）。而一个线程块里面又包含了很多的线程。</p><p><img src="/./picture/CUDA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kerne%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dim3 grid(3, 2);</span><br><span class="line">dim3 block(5, 3);</span><br><span class="line">kernel_fun&lt;&lt;&lt; grid, block &gt;&gt;&gt;(prams...);</span><br></pre></td></tr></table></figure><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如图所示，这是一个gird和block均为2-dim的线程组织。grid和block都是定义为dim3类型的变量，dim3可以看成是包含三个无符号整数（x，y，z）成员的结构体变量，在定义时，缺省值初始化为1。因此grid和block可以灵活地定义为1-dim，2-dim以及3-dim结构，对于图中结构（主要水平方向为x轴），定义的grid和block如下所示，kernel在调用时也必须通过执行配置&lt;&lt;&lt;grid, block&gt;&gt;&gt;来指定kernel所使用的线程数及结构。</p><p><a href="https://zhuanlan.zhihu.com/p/34587739">https://zhuanlan.zhihu.com/p/34587739</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于NvDec+CUDA+OpenGL+NvEnc的全流程GPU加速方案</title>
      <link href="/2023/01/19/%E5%9F%BA%E4%BA%8ENvDec+CUDA+OpenGL+NvEnc%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8BGPU%E5%8A%A0%E9%80%9F%E6%96%B9%E6%A1%88/"/>
      <url>/2023/01/19/%E5%9F%BA%E4%BA%8ENvDec+CUDA+OpenGL+NvEnc%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8BGPU%E5%8A%A0%E9%80%9F%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="0-介绍："><a href="#0-介绍：" class="headerlink" title="0 介绍："></a>0 介绍：</h1><p>在编解码领域中，对音视频文件进行解码编码主要有两种方式：</p><ul><li>软件解码编码</li><li>硬件解码编码</li></ul><p>软件解码编码实际上就是直接用CPU进行解码编码，硬件解码编码则是采用GPU进行解码编码．<br>两种方式的区别在于：GPU解码编码的效率高于CPU解码编码，但是CPU解码编码的质量确高于GPU解码编码．</p><p>当处理较大数据量的时候，往往会用GPU进行运算，比如OpenGL或者CUDA。在实际的操作中，往往CUDA实现并行计算会比OpenGL更加方便，而OpenGL在进行后期渲染更具有优势。由于CUDA中的运算结果存储在GPU中，如果将数据download到CPU，然后再将CPU中的数据上传到GPU，使用OpenGL进行渲染，中间的GPU与CPU的交互会很耗时，毕竟使用GPU的目的就是为了加速，这样的数据传输会降低效率。</p><p>所以我们在进行编解码时，在某些注重时间效率的场景下，如何提高解码渲染编码的速度，就绕开CPU，直接通过CUDA和OpenGL进行GPU全流程加速（硬件解码－＞硬件渲染－＞硬件编码），则成了我们的一个研究重点．</p><p>而作为GPU第一大厂的Nvidia，则刚好有一套方案满足我们的需求．<br>CUDA是Nvidia推出的一个通用GPU计算平台，对于提升并行任务的效率非常有帮助。CUDA支持与OpenGL和D3D等图形API的互操作。NVIDIA还提供了一些示例来展示它的工作原理，包括设备到主机复制和零复制（仅限设备到设备）。显然，从设备复制到主机并再次上传进行渲染会影响性能。但是所有零拷贝示例都依赖于CUDA内核将NV12转换为RGB。结果是我们必须使用nvcc编译器来构建代码，并且我们的构建环境会很复杂（CUDA7 支持在线编译器），有时是不可能的（我使用CUDA驱动程序API在任何构建环境中为所有平台构建支持CUDA的代码）。</p><p>是否有任何解决方案可以仅使用图形API实现零拷贝？回答是肯定的。</p><p>由于D3D只支持Win系统，因此接下来我们将以FFmpeg+CUDA+NvDec+OpenGL+NvEnc的方式，来演示GPU全流程</p><p>PS:<br>NVDEC(硬件加速的视频解码):NVIDIA GPU 包含基于硬件的解码器 (NVDEC)，可为几种热门的编解码器提供基于硬件的全加速视频解码。由于解码工作流完全卸载至 NVDEC，图形引擎和 CPU 可以有更多的时间执行其他操作。NVDEC 比实时解码速度更快，非常适合用于转码应用以及视频播放应用。借助 NVDECODE API，软件开发者能够配置此专用硬件视频解码器。此专用加速器支持在 Windows 和 Linux 平台上对以下视频编解码器进行硬件加速解码：MPEG-2、VC-1、H.264 (AVCHD)、H.265 (HEVC)、VP8、VP9 和 AV1。</p><p>NVENC(硬件加速的视频编码):从 Kepler 这一代开始，NVIDIA GPU 包含基于硬件的编码器（简称为 NVENC），可提供基于硬件的全加速视频编码，且独立于图形性能。由于计算复杂的编码工作流完全卸载至 NVENC，图形引擎和 CPU 可以有更多的时间执行其他操作。例如，在游戏录制和直播过程中（如使用 Open Broadcaster Software (OBS) 在 Twitch.tv 上直播），编码工作流完全卸载至 NVENC，从而使图形引擎带宽可全部用于游戏渲染。借助 NVENC，我们可以：</p><ul><li>在不使用 CPU 的情况下以高质量和超低延迟对游戏和应用进行编码和串流</li><li>针对存档、OTT 串流、网络视频进行高质量编码</li><li>以超低功耗对每个流进行编码（瓦特&#x2F;流）</li></ul><p>现在我们通过FFmpeg来介绍基于OpenGL的Nvida硬件解码和编码功能，从而实现一套全流程GPU的加速方案</p><h1 id="1-前期准备："><a href="#1-前期准备：" class="headerlink" title="1 前期准备："></a>1 前期准备：</h1><p>先阅读完Nvida的这个<a href="https://docs.nvidia.com/video-technologies/video-codec-sdk/ffmpeg-with-nvidia-gpu/index.html">文档</a></p><p>接着进行编译工作</p><h2 id="1-1-安装CUDA-Toolkit"><a href="#1-1-安装CUDA-Toolkit" class="headerlink" title="1.1 安装CUDA Toolkit"></a>1.1 安装CUDA Toolkit</h2><p><a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux&target_arch=x86_64&Distribution=Ubuntu&target_version=20.04">下载CUDA Toolkit</a><br>PS:这个是Ubuntu20.04版本的，其他版本请对应下载</p><h2 id="1-1-Nvida驱动程序"><a href="#1-1-Nvida驱动程序" class="headerlink" title="1.1 Nvida驱动程序"></a>1.1 Nvida驱动程序</h2><p><a href="https://www.nvidia.com/Download/index.aspx?lang=en-us">下载对应的Nvida驱动程序</a></p><p><a href="https://wujianqiangcode.github.io/Linux%E4%B8%8BNvidia%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4">安装Nvidia驱动教程</a></p><h2 id="1-2-验证"><a href="#1-2-验证" class="headerlink" title="1.2 验证"></a>1.2 验证</h2><p>接下来来就是验证环节：</p><h3 id="1-2-1-验证cuda是否能正常使用"><a href="#1-2-1-验证cuda是否能正常使用" class="headerlink" title="1.2.1 验证cuda是否能正常使用"></a>1.2.1 验证cuda是否能正常使用</h3><p>下载CUDA演示样例验证是否成功安装：</p><p>首先在命令行窗口输入一下命令查看cuda版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>例如显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ws@wujianqiang-ubuntu-18:~$ nvidia-smi</span><br><span class="line">Thu Jan 12 13:43:47 2023       </span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 520.61.05    Driver Version: 520.61.05    CUDA Version: 11.8     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                               |                      |               MIG M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  NVIDIA GeForce ...  On   | 00000000:65:00.0  On |                  N/A |</span><br><span class="line">|  0%   55C    P8    15W / 200W |   1250MiB /  8192MiB |      2%      Default |</span><br><span class="line">|                               |                      |                  N/A |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">                                                                               </span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                                  |</span><br><span class="line">|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |</span><br><span class="line">|        ID   ID                                                   Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">|    0   N/A  N/A      1294      G   /usr/lib/xorg/Xorg                 24MiB |</span><br><span class="line">|    0   N/A  N/A      1401      G   /usr/bin/gnome-shell               82MiB |</span><br><span class="line">|    0   N/A  N/A      1823      G   /usr/lib/xorg/Xorg                573MiB |</span><br><span class="line">|    0   N/A  N/A      1953      G   /usr/bin/gnome-shell              129MiB |</span><br><span class="line">|    0   N/A  N/A      2341      G   ...AAAAAAAAA= --shared-files       60MiB |</span><br><span class="line">|    0   N/A  N/A      2743      G   ...RendererForSitePerProcess      181MiB |</span><br><span class="line">|    0   N/A  N/A      9243      C   ...ffice/program/soffice.bin      128MiB |</span><br><span class="line">|    0   N/A  N/A     22138      G   ...377498332981217288,131072       61MiB |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>则代表cuda的版本是11.8,因此我们要将cuda-samples切换到对应版本进行编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b v11.8 https://github.com/NVIDIA/cuda-samples.git</span><br></pre></td></tr></table></figure><p>注：如果make后提示找不到glut的话，输入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install libgl1-mesa-dev</span><br><span class="line">sudo apt-get install libglu1-mesa-dev</span><br><span class="line">sudo apt-get install libglut-dev</span><br></pre></td></tr></table></figure><p>出现：E: 无法定位软件包 libglut-dev，执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install freeglut3-dev</span><br></pre></td></tr></table></figure><p>如果成功显示该画面就说明CUDA Toolkit安装成功：<br><img src="/./picture/%E5%9F%BA%E4%BA%8ENvDec+CUDA+OpenGL+NvEnc%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8BGPU%E5%8A%A0%E9%80%9F%E6%96%B9%E6%A1%88/CUDA%E6%BC%94%E7%A4%BA%E6%A0%B7%E4%BE%8B%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5.png"></p><h3 id="1-2-2-验证NvDec和NvEnc是否能正常使用"><a href="#1-2-2-验证NvDec和NvEnc是否能正常使用" class="headerlink" title="1.2.2 验证NvDec和NvEnc是否能正常使用"></a>1.2.2 验证NvDec和NvEnc是否能正常使用</h3><p><a href="https://developer.nvidia.com/nvidia-video-codec-sdk/download">下载Nvida的Video_Codec_SDK</a></p><p>接着可以用cmake工具构建一下Video_Codec_SDK里面的Samples，如果能成功构建，那么就代表Nvidia的NvDec和NvEnc都安装成功了。<br><img src="/./picture/%E5%9F%BA%E4%BA%8ENvDec+CUDA+OpenGL+NvEnc%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8BGPU%E5%8A%A0%E9%80%9F%E6%96%B9%E6%A1%88/%E9%AA%8C%E8%AF%81CUDA%20Toolkit%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png"></p><p>PS:如果想学习Nvidia提供的Video_Codec_SDK中的样例，请查看这篇(文章)[]</p><h2 id="1-3-安装FFmpeg和对应的nv-codec-headers"><a href="#1-3-安装FFmpeg和对应的nv-codec-headers" class="headerlink" title="1.3 安装FFmpeg和对应的nv-codec-headers"></a>1.3 安装FFmpeg和对应的nv-codec-headers</h2><p>由于我们进行解码操作使用还需要对音视频文件进行Demux操作，分离出视频流出来进行NvDec的硬件解码，因此，我们还需要使用第三方软件(如FFMPEG)进行Demux操作，所以我们还要下载一下FFmpeg进行编译</p><p>接着下载FFmpeg以及与Nvidia编解码器API接口所需的FFmpeg版本的标头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone -b release/xx  https://git.ffmpeg.org/ffmpeg.git</span><br><span class="line">git clone -b sdk/xx https://github.com/FFmpeg/nv-codec-headers.git</span><br></pre></td></tr></table></figure><h1 id="2-具体解码流程步骤"><a href="#2-具体解码流程步骤" class="headerlink" title="2 具体解码流程步骤"></a>2 具体解码流程步骤</h1><p>首先我们根据Nvidia官方的<a href="https://docs.nvidia.com/video-technologies/video-codec-sdk/nvdec-video-decoder-api-prog-guide/index.html">NVDEC API</a>指南进行学习．</p><p>其硬件解码流程，具体过程如下所示：</p><ul><li>初始化设置</li><li>创建CUDA上下文</li><li>查询硬件解码器解码能力</li><li>创建解码器实例</li><li>使用第三方软件(如FFMPEG)进行Demux</li><li>使用NVDECODE API提供的解析器或第三方解析器（如FFmpeg）解析视频比特流</li><li>使用NVDECODE API启动解码</li><li>获取解码后的YUV进行进一步处理</li><li>查询解码帧状态</li><li>根据解码状态，使用解码后的输出进行进一步的处理(如渲染、后处理等)<br>  如果应用程序需要显示输出：<br>- a、将解码后的YUV转化为RGB格式<br>- b、将RGB映射到DirectX或OpenGL纹理<br>- c、将纹理绘制到屏幕上</li><li>在译码过程完成后销毁解码器实例</li><li>销毁CUDA上下文</li></ul><h2 id="2-1-初始化设置"><a href="#2-1-初始化设置" class="headerlink" title="2.1 初始化设置"></a>2.1 初始化设置</h2><p>首先进行初始化，需要初始化的地方有三个：</p><ul><li>加载对应头文件和动态库</li><li>CUDA初始化</li><li>解码器初始化</li></ul><h3 id="2-1-1-加载对应头文件和动态库"><a href="#2-1-1-加载对应头文件和动态库" class="headerlink" title="2.1.1 加载对应头文件和动态库"></a>2.1.1 加载对应头文件和动态库</h3><p>根据官方的操作指南提示：所有 NVDECODE API 都暴露在两个头文件中：cuviddec.h和 nvcuvid.h. 这两个文件可以在Nvidia提供的Video_Codec_SDK包中的Interface文件夹中找到。NVIDIA的Video_Codec_SDK中的示例静态加载库（作为 Windows SDK 包的一部分提供）函数并包括cuviddec.h和 nvcuvid.h在源文件中。Windows DLLnvcuvid.dll 包含在适用于 Windows 的 NVIDIA 显示驱动程序中。Linux 库 libnvcuvid.so包含在用于 Linux 的 NVIDIA 显示驱动程序中。</p><p>我们在工程中一般是通过动态库的方式进行加载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cuviddec.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nvcuvid.h&quot;</span></span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line"><span class="type">void</span>* hrnvcuda = <span class="built_in">LoadLibrary</span>(<span class="string">L&quot;NVCUDA.DLL&quot;</span>);</span><br><span class="line"><span class="type">void</span>* hrnvcuvid = <span class="built_in">LoadLibrary</span>(<span class="string">L&quot;NVCUVID.DLL&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__    </span></span><br><span class="line">    <span class="type">void</span>* hrnvcuda = <span class="built_in">dlopen</span>(<span class="string">&quot;libcuda.so&quot;</span>,RTLD_LAZY );</span><br><span class="line">    <span class="type">void</span>* hrnvcuvid = <span class="built_in">dlopen</span>(<span class="string">&quot;libnvcuvid.so&quot;</span>,RTLD_LAZY );</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>    </span></span><br></pre></td></tr></table></figure><h3 id="2-1-2-CUDA初始化"><a href="#2-1-2-CUDA初始化" class="headerlink" title="2.1.2 CUDA初始化"></a>2.1.2 CUDA初始化</h3><p>在cuda的api中，采用的是cuda.h中的cuInit进行初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CUresult CUDAAPI <span class="title">cuInit</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Flags)</span></span>;</span><br></pre></td></tr></table></figure><p>这里的flags目前必须给0，对于cuda的所有函数，必须先调用cuInit，否则其他API都会返CUDA_ERROR_NOT_INITIALIZED．<br>但是我们在实际的生成开发环境中，只调用cuInit进行初始化是远远不够的，因此在我们下载的nv-codec-headers的include文件夹的dynlink_cuda.h文件中对这个函数进行了一层封装：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cuInit</span>(<span class="type">unsigned</span> <span class="type">int</span> Flags, <span class="type">int</span> cudaVersion, <span class="type">void</span> *pHandleDriver,<span class="type">int</span> dxtype);</span><br></pre></td></tr></table></figure><p>该封装的函数除了调用cuInit进行初始化以外，还做了两件事：</p><ul><li>调用cuDriverGetVersion函数得到此时设备的cuda驱动版本信息，从而针对性的进行对应版本的相关函数的加载</li><li>通过设定的宏和输入参数类型，来确定是加载cuGraphicsGLRegisterImage等cuda和OpenGL交互的接口还是cuda和哪个版本的DX交互的接口</li></ul><p><font color =red>注：没有对应的cuDestroy，不需要释放，程序销毁自动释放；</font></p><h4 id="相关参数的具体含义："><a href="#相关参数的具体含义：" class="headerlink" title="相关参数的具体含义："></a>相关参数的具体含义：</h4><h5 id="Flags："><a href="#Flags：" class="headerlink" title="Flags："></a>Flags：</h5><p>目前，Flags参数必须为 0。如果尚未调用cuInit()，则驱动程序 API 中的任何函数都将返回CUDA_ERROR_NOT_INITIALIZED。</p><h5 id="cudaVersion：："><a href="#cudaVersion：：" class="headerlink" title="cudaVersion：："></a>cudaVersion：：</h5><p>这个值直接设计成0就行，我们用不到v2接口,所以也不需要指定cudaVersion来针对性进行_v2相关接口的加载，只需要加载默认的接口就可以了</p><h5 id="pHandleDriver："><a href="#pHandleDriver：" class="headerlink" title="pHandleDriver："></a>pHandleDriver：</h5><p>CUDADRIVER cudadriver &#x3D; 0;<br>将cudadriver作为参数传递进去，函数内部会将cuda驱动的句柄值赋值给cudadriver（这个值对我们实际应用时，一般用不到，因此无需特别在意）</p><h5 id="dxtype："><a href="#dxtype：" class="headerlink" title="dxtype："></a>dxtype：</h5><p>该参数只在Win下调用DX的时候使用，如果用OpenGL的话，该参数无实际含义,只需记得打开INIT_CUDA_GL这个宏即可。</p><p>注意需要根据使用的DX类型和宏的开关与否进行参数设置。</p><p>可设置dxtype结构体为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">D3DX_SUPPORT_TYPE</span></span><br><span class="line">&#123;</span><br><span class="line">    SUPPORT_D3D9EX,</span><br><span class="line">    SUPPORT_D3D10,</span><br><span class="line">    SUPPORT_D3D11,</span><br><span class="line">    SUPPORT_UNKOWN,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过宏和dxtype来针对性的进行初始化设置的具体代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> INIT_CUDA_GL</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cuInitGL</span>(<span class="number">0</span>, __CUDA_API_VERSION, CudaDrvLib) != CUDA_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> CUDA_ERROR_INVALID_DEVICE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> INIT_CUDA_D3D9</span></span><br><span class="line"><span class="keyword">if</span> (dxtype == <span class="number">0</span> &amp;&amp;  <span class="built_in">cuInitD3D9</span>(<span class="number">0</span>, __CUDA_API_VERSION, CudaDrvLib) != CUDA_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> CUDA_ERROR_INVALID_DEVICE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> INIT_CUDA_D3D10</span></span><br><span class="line"><span class="keyword">if</span> (dxtype == <span class="number">1</span> &amp;&amp; <span class="built_in">cuInitD3D10</span>(<span class="number">0</span>, __CUDA_API_VERSION, CudaDrvLib) != CUDA_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> CUDA_ERROR_INVALID_DEVICE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> INIT_CUDA_D3D11</span></span><br><span class="line"><span class="keyword">if</span> (dxtype == <span class="number">2</span> &amp;&amp; <span class="built_in">cuInitD3D11</span>(<span class="number">0</span>, __CUDA_API_VERSION, CudaDrvLib) != CUDA_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> CUDA_ERROR_INVALID_DEVICE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="2-1-3-解码器初始化"><a href="#2-1-3-解码器初始化" class="headerlink" title="2.1.3 解码器初始化"></a>2.1.3 解码器初始化</h3><p>同样的，我们对NvDec解码器也得进行初始化操作．我们调用的还是之前下载的nv-codec-headers的include文件夹中的dynlink_nvcuvid.h文件里的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CUresult  CUDAAPI <span class="title">cuvidInit</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Flags)</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以看下dynlink_nvcuvid.cpp中这个函数的源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CUresult CUDAAPI <span class="title">cuvidInit</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLLDRIVER DriverLib;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CHECKED_CALL</span>(<span class="built_in">LOAD_LIBRARY</span>(&amp;DriverLib));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fetch all function pointers</span></span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCreateVideoSource);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCreateVideoSourceW);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidDestroyVideoSource);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidSetVideoSourceState);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidGetVideoSourceState);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidGetSourceVideoFormat);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidGetSourceAudioFormat);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCreateVideoParser);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidParseVideoData);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidDestroyVideoParser);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCreateDecoder);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidDestroyDecoder);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidDecodePicture);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(WIN64) || defined(_WIN64) || defined(__x86_64) || defined(AMD64) || defined(_M_AMD64)</span></span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidMapVideoFrame64);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidUnmapVideoFrame64);</span><br><span class="line">    cuvidMapVideoFrame #  = cuvidMapVideoFrame64;</span><br><span class="line">    cuvidUnmapVideoFrame = cuvidUnmapVideoFrame64;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidMapVideoFrame);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidUnmapVideoFrame);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    GET_PROC(cuvidGetVideoFrameSurface);</span></span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCtxLockCreate);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCtxLockDestroy);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCtxLock);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCtxUnlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CUDA_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出其实就做了一件事情，就是加载对应的函数接口．其中输入参数Flags默认设置为0就行了</p><h2 id="2-2-创建CUDA上下文"><a href="#2-2-创建CUDA上下文" class="headerlink" title="2.2 创建CUDA上下文"></a>2.2 创建CUDA上下文</h2><p>通过2.1的步骤，我们已经将该加载的h文件和动态库文件都加载了，对应的接口函数我们也都加载完成了，接下来就是对cuda进行创建了，而在创建cuda之前，我们需要对电脑的硬件进行检测，我们得知道是哪个型号的gpu后，才能进行CUDA上下文的创建．</p><h3 id="2-2-1-显卡设备信息的获取以及显卡的选择"><a href="#2-2-1-显卡设备信息的获取以及显卡的选择" class="headerlink" title="2.2.1 显卡设备信息的获取以及显卡的选择"></a>2.2.1 显卡设备信息的获取以及显卡的选择</h3><p>首先我们要知道设备有多少张显卡，通过cuDeviceGetCount(int *count)函数，得到设备的显卡数量。<br>具体API定义如下(nv-codec-headers的include文件夹中的dynlink_cuda.h文件里)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuDeviceGetCount</span><span class="params">(<span class="type">int</span> *count)</span></span>;</span><br><span class="line">tcuDeviceGetCount                     *cuDeviceGetCount;</span><br></pre></td></tr></table></figure><p>接着我们需要得到这些显卡的具体信息。</p><p>此时就用到cuDeviceGet和cuDeviceGetName函数；<br>其中cuDeviceGet通过for循环输入1～count来得到每张显卡设备的设备句柄：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcuDeviceGet                          *cuDeviceGet;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuDeviceGet</span><span class="params">(CUdevice *device, <span class="type">int</span> ordinal)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="相关参数的具体含义：-1"><a href="#相关参数的具体含义：-1" class="headerlink" title="相关参数的具体含义："></a>相关参数的具体含义：</h4><h5 id="device："><a href="#device：" class="headerlink" title="device："></a>device：</h5><p>设备句柄</p><h5 id="ordinal："><a href="#ordinal：" class="headerlink" title="ordinal："></a>ordinal：</h5><p>设备id号</p><p>cuDeviceGetName通过输入设备句柄得到每张显卡的名称</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuDeviceGetName</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> len, CUdevice dev)</span></span>;</span><br><span class="line">tcuDeviceGetName                      *cuDeviceGetName;</span><br></pre></td></tr></table></figure><p>相关参数信息：</p><h5 id="dev："><a href="#dev：" class="headerlink" title="dev："></a>dev：</h5><p>设备句柄</p><h5 id="len："><a href="#len：" class="headerlink" title="len："></a>len：</h5><p>默认输入为256</p><p>然后调用helper_cuda_drvapi.h文件中的checkCudaCapabilitiesDRV函数，来进行CUDA GPU SM功能的常规检查</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">checkCudaCapabilitiesDRV</span>(<span class="type">int</span> major_version, <span class="type">int</span> minor_version, <span class="type">int</span> devID)</span><br></pre></td></tr></table></figure><p>Streaming Multiprocessor (SM)的具体含义参考这篇<a href="https://blog.csdn.net/asasasaababab/article/details/80447254">文章</a></p><p><font color = red>注：major_version和minor_version默认输入为1，若想了解checkCudaCapabilitiesDRV函数的具体实现，详见helper_cuda_drvapi.h文件。</font></p><p>最后调用cuDeviceGetAttribute来返回返回有关设备的信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuDeviceGetAttribute</span><span class="params">(<span class="type">int</span> *pi, CUdevice_attribute attrib, CUdevice dev)</span></span>;</span><br><span class="line">tcuDeviceGetAttribute           *cuDeviceGetAttribute;</span><br></pre></td></tr></table></figure><h4 id="相关参数的具体含义：-2"><a href="#相关参数的具体含义：-2" class="headerlink" title="相关参数的具体含义："></a>相关参数的具体含义：</h4><h5 id="pi"><a href="#pi" class="headerlink" title="pi:"></a>pi:</h5><p>返回设备属性值</p><h5 id="attrib"><a href="#attrib" class="headerlink" title="attrib:"></a>attrib:</h5><p>要查询的设备属性，详见dynlink_cuda_cuda.h文件的CUdevice_attribute_enum结构体内容</p><h5 id="dev"><a href="#dev" class="headerlink" title="dev:"></a>dev:</h5><p>设备句柄</p><hr><p>这里有个使用技巧，通过checkCUDADecodecErrors来接收各个API接口返回的CUresult值，从而查看是否成功调用各API接口。<br>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">checkCUDADecodecErrors</span>(<span class="built_in">cuDeviceGetAttribute</span>(xx,xx,xx)))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><hr><p>此时经过上面步骤后，我们已经成功获取到了每一张Nvida显卡设备的相关信息，紧接着我们就需要从中挑选出性能最好的一张来使用。</p><p>我们可以通过<a href="https://github.com/NVIDIA/cuda-samples/blob/master/Common/helper_cuda_drvapi.h">helper_cuda_drvapi.h文件</a>的gpuGetMaxGflopsGLDeviceIdDRV函数，来挑选出最好的一张显卡。当我们调用<br>gpuGetMaxGflopsGLDeviceIdDRV()函数时，返回的值是最佳显卡的id值，此时我们再调用cuDeviceGet函数，将id值作为输入参数，即可得到该张显卡的设备句柄。</p><p>接着我们调用cuDeviceComputeCapability函数查看一下这张最佳显卡的算力情况，以及通过cuDeviceTotalMem返回设备上的内存总量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuDeviceComputeCapability</span><span class="params">(<span class="type">int</span> *major, <span class="type">int</span> *minor, CUdevice dev)</span></span>;</span><br><span class="line">tcuDeviceComputeCapability            *cuDeviceComputeCapability;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __CUDA_API_VERSION &gt;= 3020</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuDeviceTotalMem</span><span class="params">(<span class="type">size_t</span> *bytes, CUdevice dev)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuDeviceTotalMem</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *bytes, CUdevice dev)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">tcuDeviceTotalMem                     *cuDeviceTotalMem;</span><br></pre></td></tr></table></figure><h4 id="相关参数的具体设置："><a href="#相关参数的具体设置：" class="headerlink" title="相关参数的具体设置："></a>相关参数的具体设置：</h4><h5 id="major、minor：："><a href="#major、minor：：" class="headerlink" title="major、minor：："></a>major、minor：：</h5><p>在major和minor中返回定义设备dev计算能力的主要和次要修订号</p><h5 id="dev：-1"><a href="#dev：-1" class="headerlink" title="dev："></a>dev：</h5><p>设备句柄</p><h3 id="2-2-2-创建CUDA上下文"><a href="#2-2-2-创建CUDA上下文" class="headerlink" title="2.2.2 创建CUDA上下文"></a>2.2.2 创建CUDA上下文</h3><p>当我们完成上面步骤后，我们就可以创建CUDA上下文咯！</p><p>在低CUDA版本我们需要将这张显卡与OpenGL的互操作性创建CUDA上下文，此时调用cuGLCtxCreate函数进行最终的CUDA上下文的创建</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult CUDAAPI <span class="title">tcuGLCtxCreate</span><span class="params">(CUcontext *pCtx, <span class="type">unsigned</span> <span class="type">int</span> Flags, CUdevice device)</span></span>;</span><br><span class="line">tcuGLCtxCreate                        *cuGLCtxCreate;</span><br></pre></td></tr></table></figure><h4 id="相关参数的具体设置：-1"><a href="#相关参数的具体设置：-1" class="headerlink" title="相关参数的具体设置："></a>相关参数的具体设置：</h4><h5 id="pCtx："><a href="#pCtx：" class="headerlink" title="pCtx："></a>pCtx：</h5><p>返回所创建的CUDA上下文</p><h5 id="Flags：-1"><a href="#Flags：-1" class="headerlink" title="Flags："></a>Flags：</h5><p>CUDA 上下文创建选项，默认输入：CU_CTX_SCHED_BLOCKING_SYNC</p><h5 id="CUdevice："><a href="#CUdevice：" class="headerlink" title="CUdevice："></a>CUdevice：</h5><p>创建的上下文的设备句柄</p><p>在Nvidia的cuda<a href="https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1g931f6d260d7db412b37497cb4b2fdf5d">操作文档</a>中也有写到：</p><h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="Deprecated"></a>Deprecated</h4><p>This function is deprecated as of Cuda 3.0.</p><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>Maps the buffer object specified by buffer into the address space of the current CUDA context and returns in *dptr and *size the base pointer and size of the resulting mapping.</p><p>There must be a valid OpenGL context bound to the current thread when this function is called. This must be the same context, or a member of the same shareGroup, as the context that was bound when the buffer was registered.</p><p>All streams in the current CUDA context are synchronized with the current GL context.</p><h4 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h4><p>Note that this function may also return error codes from previous, asynchronous launches.</p><p>因此在CUDA版本大于5的时候，我们就不需要专门去调用这个接口了，而是直接采用cuCtxCreate接口进行上下文创建：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuCtxCreate</span><span class="params">(CUcontext *pctx, <span class="type">unsigned</span> <span class="type">int</span> flags, CUdevice dev)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> tcuCtxCreate                    *cuCtxCreate;</span><br></pre></td></tr></table></figure><h4 id="相关参数的具体设置：-2"><a href="#相关参数的具体设置：-2" class="headerlink" title="相关参数的具体设置："></a>相关参数的具体设置：</h4><h5 id="pCtx：-1"><a href="#pCtx：-1" class="headerlink" title="pCtx："></a>pCtx：</h5><p>返回所创建的CUDA上下文</p><h5 id="Flags：-2"><a href="#Flags：-2" class="headerlink" title="Flags："></a>Flags：</h5><p>CUDA 上下文创建选项，默认输入：CU_CTX_SCHED_BLOCKING_SYNC</p><h5 id="CUdevice：-1"><a href="#CUdevice：-1" class="headerlink" title="CUdevice："></a>CUdevice：</h5><p>创建的上下文的设备句柄，也就是我们之前通过gpuGetMaxGflopsGLDeviceIdDRV拿到的最好设备的id号后，再将该id号作为输入参数设置到cuDeviceGet函数中得到的对应的dev值</p><h3 id="2-2-3-验证CUDA上下文是否成功创建以及当前上下文可用的内存总量是否充足"><a href="#2-2-3-验证CUDA上下文是否成功创建以及当前上下文可用的内存总量是否充足" class="headerlink" title="2.2.3 验证CUDA上下文是否成功创建以及当前上下文可用的内存总量是否充足"></a>2.2.3 验证CUDA上下文是否成功创建以及当前上下文可用的内存总量是否充足</h3><p>按道理，此时我们已经完成了CUDA上下文的创建，但是为了保险起见，我们还需要验证一下</p><p>接着从当前CPU线程中弹出当前CUDA上下文，看一下是否已经成功创建了，如果成功的话，我们再将其push进去。</p><p>cuCtxPushCurrent():将给定的上下文ctx推送到CPU线程的当前上下文堆栈中。指定的上下文成为CPU线程的当前上下文，因此所有对当前上下文进行操作的CUDA函数都会受到影响。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuCtxPopCurrent</span><span class="params">(CUcontext *pctx)</span></span>;</span><br><span class="line">tcuCtxPopCurrent                      *cuCtxPopCurrent;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuCtxPushCurrent</span><span class="params">(CUcontext ctx)</span></span>;</span><br><span class="line">tcuCtxPushCurrent                     *cuCtxPushCurrent;</span><br></pre></td></tr></table></figure><p>然后我们通过cuMemGetInfo函数得到可用内存和总内存（以字节为单位）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult CUDAAPI <span class="title">tcuMemGetInfo</span><span class="params">(<span class="type">size_t</span> *free, <span class="type">size_t</span> *total)</span></span>;</span><br><span class="line">tcuMemGetInfo                         *cuMemGetInfo;</span><br></pre></td></tr></table></figure><p>在total中返回当前上下文可用的内存总量。在free中返回设备上根据操作系统空闲的内存量。不保证 CUDA 能够分配操作系统报告为空闲的所有内存。在多原则的情况下，返回的空闲估计容易出现竞争条件，在估计和报告空闲内存之间由不同进程或同一进程中的不同线程完成的新分配&#x2F;释放，将导致偏差报告的可用值和实际可用内存。</p><p>Tegra 上的集成 GPU 与 CPU 和 SoC 的其他组件共享内存。API 返回的可用值和总值不包括某些平台上操作系统维护的 SWAP 内存空间。当 GPU 或 CPU 分配或访问内存时，操作系统可能会将一些内存页面移动到交换区域。请参阅 Tegra 应用说明，了解如何计算 Tegra 上的总内存和可用内存。</p><p>当满足可用内存不小于300<em>1024</em>1024，总内存不小于512 <em>1024</em>1024时，我们认为此时是足够用的（这边可以用if语句来判断，满足则返回true，不满足则返回false）。</p><p>此时为了为了方便多线程实现，我们调用dynlink_nvcuvid.h中的cuvidCtxLockCreate函数来进行上下文的锁定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult CUDAAPI <span class="title">tcuvidCtxLockCreate</span><span class="params">(CUvideoctxlock *pLock, CUcontext ctx)</span></span>;</span><br><span class="line">tcuvidCtxLockCreate                   *cuvidCtxLockCreate;</span><br></pre></td></tr></table></figure><h2 id="2-3-查询硬件解码器解码能力"><a href="#2-3-查询硬件解码器解码能力" class="headerlink" title="2.3 查询硬件解码器解码能力"></a>2.3 查询硬件解码器解码能力</h2><p>不同的GPU包含不同的能力. 因此，为了确保你的应用能在所有的GPU硬件上运行，很有必要查询硬件能力(当然你也可以调过这个流程，反正解不了就崩嘛，没啥区别)，然后根据所需的能力是否满足进行合适的操作</p><p>可以参考NVIDIA的Video_Codec_SDK中的NvDecoder.cpp中的HandleVideoSequence函数内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">CUVIDDECODECAPS decodecaps;</span><br><span class="line"><span class="built_in">memset</span>(&amp;decodecaps, <span class="number">0</span>, <span class="built_in">sizeof</span>(decodecaps));</span><br><span class="line"></span><br><span class="line">decodecaps.eCodecType = pVideoFormat-&gt;codec;</span><br><span class="line">decodecaps.eChromaFormat = pVideoFormat-&gt;chroma_format;</span><br><span class="line">decodecaps.nBitDepthMinus8 = pVideoFormat-&gt;bit_depth_luma_minus8;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPushCurrent</span>(m_cuContext)); <span class="comment">//启用context</span></span><br><span class="line"><span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidGetDecoderCaps</span>(&amp;decodecaps));</span><br><span class="line"><span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!decodecaps.bIsSupported)&#123;</span><br><span class="line">    <span class="built_in">NVDEC_THROW_ERROR</span>(<span class="string">&quot;Codec not supported on this GPU&quot;</span>, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">    <span class="keyword">return</span> nDecodeSurface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pVideoFormat-&gt;coded_width &gt; decodecaps.nMaxWidth) ||</span><br><span class="line">    (pVideoFormat-&gt;coded_height &gt; decodecaps.nMaxHeight))&#123;</span><br><span class="line"></span><br><span class="line">    std::ostringstream errorString;</span><br><span class="line">    errorString &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;Resolution          : &quot;</span> &lt;&lt; pVideoFormat-&gt;coded_width &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; pVideoFormat-&gt;coded_height &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;Max Supported (wxh) : &quot;</span> &lt;&lt; decodecaps.nMaxWidth &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; decodecaps.nMaxHeight &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;Resolution not supported on this GPU&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::string cErr = errorString.<span class="built_in">str</span>();</span><br><span class="line">    <span class="built_in">NVDEC_THROW_ERROR</span>(cErr, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">    <span class="keyword">return</span> nDecodeSurface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pVideoFormat-&gt;coded_width&gt;&gt;<span class="number">4</span>)*(pVideoFormat-&gt;coded_height&gt;&gt;<span class="number">4</span>) &gt; decodecaps.nMaxMBCount)&#123;</span><br><span class="line"></span><br><span class="line">    std::ostringstream errorString;</span><br><span class="line">    errorString &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;MBCount             : &quot;</span> &lt;&lt; (pVideoFormat-&gt;coded_width &gt;&gt; <span class="number">4</span>)*(pVideoFormat-&gt;coded_height &gt;&gt; <span class="number">4</span>) &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;Max Supported mbcnt : &quot;</span> &lt;&lt; decodecaps.nMaxMBCount &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;MBCount not supported on this GPU&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::string cErr = errorString.<span class="built_in">str</span>();</span><br><span class="line">    <span class="built_in">NVDEC_THROW_ERROR</span>(cErr, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">    <span class="keyword">return</span> nDecodeSurface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_nWidth &amp;&amp; m_nLumaHeight &amp;&amp; m_nChromaHeight) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cuvidCreateDecoder() has been called before, and now there&#x27;s possible config change</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ReconfigureDecoder</span>(pVideoFormat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// eCodec has been set in the constructor (for parser). Here it&#x27;s set again for potential correction</span></span><br><span class="line">m_eCodec = pVideoFormat-&gt;codec;</span><br><span class="line">m_eChromaFormat = pVideoFormat-&gt;chroma_format;</span><br><span class="line">m_nBitDepthMinus8 = pVideoFormat-&gt;bit_depth_luma_minus8;</span><br><span class="line">m_nBPP = m_nBitDepthMinus8 &gt; <span class="number">0</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the output surface format same as chroma format</span></span><br><span class="line"><span class="keyword">if</span> (m_eChromaFormat == cudaVideoChromaFormat_420 || cudaVideoChromaFormat_Monochrome)</span><br><span class="line">    m_eOutputFormat = pVideoFormat-&gt;bit_depth_luma_minus8 ? cudaVideoSurfaceFormat_P016 : cudaVideoSurfaceFormat_NV12;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_eChromaFormat == cudaVideoChromaFormat_444)</span><br><span class="line">    m_eOutputFormat = pVideoFormat-&gt;bit_depth_luma_minus8 ? cudaVideoSurfaceFormat_YUV444_16Bit : cudaVideoSurfaceFormat_YUV444;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_eChromaFormat == cudaVideoChromaFormat_422)</span><br><span class="line">    m_eOutputFormat = cudaVideoSurfaceFormat_NV12;  <span class="comment">// no 4:2:2 output format supported yet so make 420 default</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if output format supported. If not, check falback options</span></span><br><span class="line"><span class="keyword">if</span> (!(decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; m_eOutputFormat)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_NV12))</span><br><span class="line">        m_eOutputFormat = cudaVideoSurfaceFormat_NV12;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_P016))</span><br><span class="line">        m_eOutputFormat = cudaVideoSurfaceFormat_P016;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_YUV444))</span><br><span class="line">        m_eOutputFormat = cudaVideoSurfaceFormat_YUV444;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_YUV444_16Bit))</span><br><span class="line">        m_eOutputFormat = cudaVideoSurfaceFormat_YUV444_16Bit;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">NVDEC_THROW_ERROR</span>(<span class="string">&quot;No supported output format found&quot;</span>, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">&#125;</span><br><span class="line">m_videoFormat = *pVideoFormat;</span><br></pre></td></tr></table></figure><h2 id="2-4-创建解码器实例"><a href="#2-4-创建解码器实例" class="headerlink" title="2.4 创建解码器实例"></a>2.4 创建解码器实例</h2><p>分为两个部分：</p><ul><li>CUVIDDECODECREATEINFO信息的获取</li><li>创建视频解码器</li></ul><h3 id="2-4-1-CUVIDDECODECREATEINFO信息的获取"><a href="#2-4-1-CUVIDDECODECREATEINFO信息的获取" class="headerlink" title="2.4.1 CUVIDDECODECREATEINFO信息的获取"></a>2.4.1 CUVIDDECODECREATEINFO信息的获取</h3><p>首先我们需要进行CUVIDDECODECREATEINFO信息的填充。CUVIDDECODECREATEINFO结构如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* \struct CUVIDDECODECREATEINFO</span></span><br><span class="line"><span class="comment">* Struct used in create decoder</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CUVIDDECODECREATEINFO</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulWidth;              <span class="comment">/**&lt; Coded Sequence Width */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulHeight;             <span class="comment">/**&lt; Coded Sequence Height */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulNumDecodeSurfaces;  <span class="comment">/**&lt; Maximum number of internal decode surfaces */</span></span><br><span class="line">    cudaVideoCodec CodecType;           <span class="comment">/**&lt; cudaVideoCodec_XXX */</span></span><br><span class="line">    cudaVideoChromaFormat ChromaFormat; <span class="comment">/**&lt; cudaVideoChromaFormat_XXX (only 4:2:0 is currently supported) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulCreationFlags;      <span class="comment">/**&lt; Decoder creation flags (cudaVideoCreateFlags_XXX解析器的创建;         /**&lt; Reserved for future use - set to zero */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * area of the frame thcuvidCreateDecoderat should be displayed</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">short</span> left;</span><br><span class="line">        <span class="type">short</span> top;</span><br><span class="line">        <span class="type">short</span> right;</span><br><span class="line">        <span class="type">short</span> bottom;</span><br><span class="line">    &#125; display_area;</span><br><span class="line">    cudaVideoSurfaceFormat OutputFormat;       <span class="comment">/**&lt; cudaVideoSurfaceFormat_XXX */</span></span><br><span class="line">    cudaVideoDeinterlaceMode DeinterlaceMode;  <span class="comment">/**&lt; cudaVideoDeinterlaceMode_XXX */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulTargetWidth;               <span class="comment">/**&lt; Post-processed Output Width (Should be aligned to 2) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulTargetHeight;              <span class="comment">/**&lt; Post-processed Output Height (Should be aligbed to 2) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulNumOutputSurfaces;         <span class="comment">/**&lt; Maximum number of output surfaces simultaneously mapped */</span></span><br><span class="line">    CUvideoctxlock vidLock;                    <span class="comment">/**&lt; If non-NULL, context lock used for synchronizing ownership of the cuda context */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * target rectangle in the output frame (for aspect ratio conversion)</span></span><br><span class="line"><span class="comment">    * if a null rectangle is specified, &#123;0,0,ulTargetWidth,ulTargetHeight&#125; will be used</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">short</span> left;</span><br><span class="line">        <span class="type">short</span> top;</span><br><span class="line">        <span class="type">short</span> right;</span><br><span class="line">        <span class="type">short</span> bottom;</span><br><span class="line">    &#125; target_rect;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> Reserved2[<span class="number">5</span>];                <span class="comment">/**&lt; Reserved for future use - set to zero */</span></span><br><span class="line">&#125; CUVIDDECODECREATEINFO;</span><br></pre></td></tr></table></figure><h4 id="相关参数具体设置："><a href="#相关参数具体设置：" class="headerlink" title="相关参数具体设置："></a>相关参数具体设置：</h4><h5 id="ulWidth、ulHeight："><a href="#ulWidth、ulHeight：" class="headerlink" title="ulWidth、ulHeight："></a>ulWidth、ulHeight：</h5><p>通过解码得到的视频流信息来获取，与视频文件的宽高保持一致</p><h5 id="ulNumDecodeSurfaces："><a href="#ulNumDecodeSurfaces：" class="headerlink" title="ulNumDecodeSurfaces："></a>ulNumDecodeSurfaces：</h5><p>默认值为：MAX_FRAME_COUNT（这是驱动程序将在内部分配用于存储解码帧的表面数。使用更高的数字可确保更好的流水线，但会增加 GPU 内存消耗。为了正确操作，最小值定义在 CUVIDEOFORMAT::min_num_decode_surfaces并且可以从 Nvidia 解析器的第一个序列回调中获得。NVDEC 引擎将解码数据写入这些表面之一。NVDECODE API 的用户无法访问这些表面，但 映射阶段（包括解码器输出格式转换、缩放、裁剪等）使用这些表面作为输入表面。）</p><h5 id="CodecType："><a href="#CodecType：" class="headerlink" title="CodecType："></a>CodecType：</h5><p>CodecType需要根据文件的FourCC来进行确认。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* \enum cudaVideoCodec</span></span><br><span class="line"><span class="comment">* Video Codec Enums</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">cudaVideoCodec_enum</span> &#123;</span><br><span class="line">    cudaVideoCodec_MPEG1=<span class="number">0</span>,                 <span class="comment">/**&lt;  MPEG1   */</span></span><br><span class="line">    cudaVideoCodec_MPEG2, <span class="number">4</span>                  <span class="comment">/**&lt;  HEVC   */</span></span><br><span class="line">    cudaVideoCodec_VP8,                     <span class="comment">/**&lt;  VP8   */</span></span><br><span class="line">    cudaVideoCodec_VP9,                     <span class="comment">/**&lt;  VP9   */</span></span><br><span class="line">    cudaVideoCodec_NumCodecs,               <span class="comment">/**&lt;  Max COdecs   */</span></span><br><span class="line">    <span class="comment">// Uncompressed YUV</span></span><br><span class="line">    cudaVideoCodec_YUV420 = ((<span class="string">&#x27;I&#x27;</span>&lt;&lt;<span class="number">24</span>)|(<span class="string">&#x27;Y&#x27;</span>&lt;&lt;<span class="number">16</span>)|(<span class="string">&#x27;U&#x27;</span>&lt;&lt;<span class="number">8</span>)|(<span class="string">&#x27;V&#x27;</span>)),   <span class="comment">/**&lt; Y,U,V (4:2:0)  */</span></span><br><span class="line">    cudaVideoCodec_YV12   = ((<span class="string">&#x27;Y&#x27;</span>&lt;&lt;<span class="number">24</span>)|(<span class="string">&#x27;V&#x27;</span>&lt;&lt;<span class="number">16</span>)|(<span class="string">&#x27;1&#x27;</span>&lt;&lt;<span class="number">8</span>)|(<span class="string">&#x27;2&#x27;</span>)),   <span class="comment">/**&lt; Y,V,U (4:2:0)  */</span></span><br><span class="line">    cudaVideoCodec_NV12   = ((<span class="string">&#x27;N&#x27;</span>&lt;&lt;<span class="number">24</span>)|(<span class="string">&#x27;V&#x27;</span>&lt;&lt;<span class="number">16</span>)|(<span class="string">&#x27;1&#x27;</span>&lt;&lt;<span class="number">8</span>)|(<span class="string">&#x27;2&#x27;</span>)),   <span class="comment">/**&lt; Y,UV  (4:2:0)  */</span></span><br><span class="line">    cudaVideoCodec_YUYV   = ((<span class="string">&#x27;Y&#x27;</span>&lt;&lt;<span class="number">24</span>)|(<span class="string">&#x27;U&#x27;</span>&lt;&lt;<span class="number">16</span>)|(<span class="string">&#x27;Y&#x27;</span>&lt;&lt;<span class="number">8</span>)|(<span class="string">&#x27;V&#x27;</span>)),   <span class="comment">/**&lt; YUYV/YUY2 (4:2:2)  */</span></span><br><span class="line">    cudaVideoCodec_UYVY   = ((<span class="string">&#x27;U&#x27;</span>&lt;&lt;<span class="number">24</span>)|(<span class="string">&#x27;Y&#x27;</span>&lt;&lt;<span class="number">16</span>)|(<span class="string">&#x27;V&#x27;</span>&lt;&lt;<span class="number">8</span>)|(<span class="string">&#x27;Y&#x27;</span>))    <span class="comment">/**&lt; UYVY (4:2:2)  */</span></span><br><span class="line">&#125; cudaVideoCodec;</span><br></pre></td></tr></table></figure><p>我们一般只需要通过FourCC来区分Cuda支持的这四种解码类型：</p><ul><li>H264（FourCC:’462H’、’462T’、’462X’、’ CVA’、’1CVA’、’1cva’）</li><li>H265（FourCC:’2VPM’）</li><li>MPEG2（FourCC:’CVEH’）</li><li>VP9（FourCC:’ 9PV’）</li></ul><p>其余的根据实际应用场景也可以进行适当的增加。</p><h5 id="ChromaFormat："><a href="#ChromaFormat：" class="headerlink" title="ChromaFormat："></a>ChromaFormat：</h5><p>默认设置为：cudaVideoChromaFormat_420</p><h5 id="ulCreationFlags："><a href="#ulCreationFlags：" class="headerlink" title="ulCreationFlags："></a>ulCreationFlags：</h5><p>默认设置为：cudaVideoCreate_PreferCUVID</p><p>接下来是CUVIDDECODECREATEINFO内一些输出格式的相关参数设置</p><h5 id="OutputFormat："><a href="#OutputFormat：" class="headerlink" title="OutputFormat："></a>OutputFormat：</h5><p>默认设置为：cudaVideoSurfaceFoCreatOpenGLTextruermat_NV12</p><h5 id="DeinterlaceMode："><a href="#DeinterlaceMode：" class="headerlink" title="DeinterlaceMode："></a>DeinterlaceMode：</h5><p>默认设置为：cudaVideoDeinterlaceMode_Weave</p><h5 id="bitDepthMinus8："><a href="#bitDepthMinus8：" class="headerlink" title="bitDepthMinus8："></a>bitDepthMinus8：</h5><p>该参数需要根据文件的bitdepth来进行设置。<br>如果不小30,设置为2,否则设置为0</p><h5 id="ulTargetWidth，ulTargetHeight："><a href="#ulTargetWidth，ulTargetHeight：" class="headerlink" title="ulTargetWidth，ulTargetHeight："></a>ulTargetWidth，ulTargetHeight：</h5><p>ulTargetWidth，ulTargetHeight与ulWidth、ulHeight的值一致<br>即：ulTargetWidth &#x3D; ulWidth；ulTargetWidth &#x3D; ulHeight；</p><h5 id="ulNumOutputSurfaces："><a href="#ulNumOutputSurfaces：" class="headerlink" title="ulNumOutputSurfaces："></a>ulNumOutputSurfaces：</h5><p>默认为2（这是用户将同时映射到解码表面以进行进一步处理 的输出表面的最大数量cuvidMapVideoFrame()。这些表面具有经过后处理的解码输出以供用户使用。驱动程序在内部分配相应数量的表面。用户将有权访问输出表面。请参阅准备解码帧以进行进一步处理以了解map的定义。）</p><h5 id="vidLock："><a href="#vidLock：" class="headerlink" title="vidLock："></a>vidLock：</h5><p>该参数值为之前调用cuvidCtxLockCreate函数得到的pLock</p><h4 id="target-rect"><a href="#target-rect" class="headerlink" title="target_rect:"></a>target_rect:</h4><p>arget_rect.left &#x3D; 0;<br>target_rect.top &#x3D; 0;<br>target_rect.right &#x3D; ulWidth;<br>target_rect.bottom &#x3D; ulHeight;</p><p><a href="https://www.ffmpeg.org/doxygen/3.3/structCUVIDDECODECREATEINFO.html">CUVIDDECODECREATEINFO 结构参考</a></p><h3 id="2-4-2-创建视频解码器"><a href="#2-4-2-创建视频解码器" class="headerlink" title="2.4.2 创建视频解码器"></a>2.4.2 创建视频解码器</h3><p>然后调用cuvidCreateDecoder进行解码器的创建</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult CUDAAPI <span class="title">tcuvidCreateDecoder</span><span class="params">(CUvideodecoder *phDecoder, CUVIDDECODECREATEINFO *pdci)</span></span>;</span><br><span class="line">tcuvidCreateDecoder                   *cuvidCreateDecoder;</span><br></pre></td></tr></table></figure><h2 id="2-5-使用第三方软件-如FFMPEG-进行Demux"><a href="#2-5-使用第三方软件-如FFMPEG-进行Demux" class="headerlink" title="2.5 使用第三方软件(如FFMPEG)进行Demux"></a>2.5 使用第三方软件(如FFMPEG)进行Demux</h2><p>分为以下几个步骤：</p><ul><li>获取MediaInfo信息</li><li>创建解复用器</li><li>拿到额外数据信息</li><li>根据FourCC创建对应的硬件解码器</li><li>将其Seek到初始位置0<br>在Nvidia官方的<a href="https://docs.nvidia.com/video-technologies/video-codec-sdk/nvdec-video-decoder-api-prog-guide/index.html">NVDEC API</a>指南中，它采用的是cuvidCreateVideoParser()来创建解析器，而在我们实际的工程开发过程中，我们一般都是采用FFMPEG来进行音视频文件的Demux．<br>因此在解复用器这一块，我们以调用FFmpeg的API为准．<br>而调用FFmpeg进行Demux的基本流程可以参考NVIDIA的Video_Codec_SDK示例AppDecGL中FFmpegDemuxer类的创建:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Demux 解析,获得每一帧码流的数据存在pVideo中,nVideoBytes为数据的字节数</span></span><br><span class="line"><span class="comment">//Demux将pVideo存储的地址值改变为pkt.data，即改变了pVideo指向的地址！！！</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Demux</span><span class="params">(<span class="type">uint8_t</span> **ppVideo, <span class="type">int</span> *pnVideoBytes, <span class="type">int64_t</span> *pts = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!fmtc) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *pnVideoBytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pkt.data) &#123;</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(&amp;pkt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> e = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = <span class="built_in">av_read_frame</span>(fmtc, &amp;pkt)) &gt;= <span class="number">0</span> &amp;&amp; pkt.stream_index != iVideoStream) &#123;</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(&amp;pkt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bMp4H264 || bMp4HEVC) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pktFiltered.data) &#123;</span><br><span class="line">                <span class="built_in">av_packet_unref</span>(&amp;pktFiltered);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ck</span>(<span class="built_in">av_bsf_send_packet</span>(bsfc, &amp;pkt));</span><br><span class="line">            <span class="built_in">ck</span>(<span class="built_in">av_bsf_receive_packet</span>(bsfc, &amp;pktFiltered));</span><br><span class="line">            *ppVideo = pktFiltered.data;</span><br><span class="line">            *pnVideoBytes = pktFiltered.size;</span><br><span class="line">            <span class="keyword">if</span> (pts)</span><br><span class="line">                *pts = (<span class="type">int64_t</span>) (pktFiltered.pts * userTimeScale * timeBase);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bMp4MPEG4 &amp;&amp; (frameCount == <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> extraDataSize = fmtc-&gt;streams[iVideoStream]-&gt;codecpar-&gt;extradata_size;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (extraDataSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// extradata contains start codes 00 00 01. Subtract its size</span></span><br><span class="line">                    pDataWithHeader = (<span class="type">uint8_t</span> *)<span class="built_in">av_malloc</span>(extraDataSize + pkt.size - <span class="number">3</span>*<span class="built_in">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!pDataWithHeader) &#123;</span><br><span class="line">                        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;FFmpeg error: &quot;</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; __LINE__;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">memcpy</span>(pDataWithHeader, fmtc-&gt;streams[iVideoStream]-&gt;codecpar-&gt;extradata, extraDataSize);</span><br><span class="line">                    <span class="built_in">memcpy</span>(pDataWithHeader+extraDataSize, pkt.data+<span class="number">3</span>, pkt.size - <span class="number">3</span>*<span class="built_in">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line"></span><br><span class="line">                    *ppVideo = pDataWithHeader;</span><br><span class="line">                    *pnVideoBytes = extraDataSize + pkt.size - <span class="number">3</span>*<span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *ppVideo = pkt.data;</span><br><span class="line">                *pnVideoBytes = pkt.size;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pts)</span><br><span class="line">                *pts = (<span class="type">int64_t</span>)(pkt.pts * userTimeScale * timeBase);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        frameCount++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ReadPacket</span><span class="params">(<span class="type">void</span> *opaque, <span class="type">uint8_t</span> *pBuf, <span class="type">int</span> nBuf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((DataProvider *)opaque)-&gt;<span class="built_in">GetData</span>(pBuf, nBuf);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-6-使用NVDECODE-API提供的解析器或第三方解析器（如FFmpeg）解析视频比特流"><a href="#2-6-使用NVDECODE-API提供的解析器或第三方解析器（如FFmpeg）解析视频比特流" class="headerlink" title="2.6 使用NVDECODE API提供的解析器或第三方解析器（如FFmpeg）解析视频比特流"></a>2.6 使用NVDECODE API提供的解析器或第三方解析器（如FFmpeg）解析视频比特流</h2><p>在这里直接采用的是NVDECODE API提供的解析器来解析视频比特流．</p><p>分为以下几个部分：</p><ul><li>CUVIDPARSERPARAMS信息的获取</li><li>相关回调函数的设计</li><li>解析器的创建</li><li>从解复用器提取数据包进行解码</li></ul><h3 id="2-6-1-CUVIDPARSERPARAMS信息的获取"><a href="#2-6-1-CUVIDPARSERPARAMS信息的获取" class="headerlink" title="2.6.1 CUVIDPARSERPARAMS信息的获取"></a>2.6.1 CUVIDPARSERPARAMS信息的获取</h3><p>首先创建一个CUVIDPARSERPARAMS类型的变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dynlink_nvcuvid.h文件中定义</span></span><br><span class="line"><span class="comment">/***********************************************************************************************************************/</span></span><br><span class="line"><span class="comment">//! Parser callbacks</span></span><br><span class="line"><span class="comment">//! The parser will call these synchronously from within cuvidParseVideoData(), whenever there is sequence change or a picture</span></span><br><span class="line"><span class="comment">//! is ready to be decoded and/or displayed. First argument in functions is &quot;void *pUserData&quot; member of structure CUVIDSOURCEPARAMS</span></span><br><span class="line"><span class="comment">//! Return values from these callbacks are interpreted as below. If the callbacks return failure, it will be propagated by</span></span><br><span class="line"><span class="comment">//! cuvidParseVideoData() to the application.</span></span><br><span class="line"><span class="comment">//! Parser picks default operating point as 0 and outputAllLayers flag as 0 if PFNVIDOPPOINTCALLBACK is not set or return value is</span></span><br><span class="line"><span class="comment">//! -1 or invalid operating point.</span></span><br><span class="line"><span class="comment">//! PFNVIDSEQUENCECALLBACK : 0: fail, 1: succeeded, &gt; 1: override dpb size of parser (set by CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces</span></span><br><span class="line"><span class="comment">//! while creating parser)</span></span><br><span class="line"><span class="comment">//! PFNVIDDECODECALLBACK   : 0: fail, &gt;=1: succeeded</span></span><br><span class="line"><span class="comment">//! PFNVIDDISPLAYCALLBACK  : 0: fail, &gt;=1: succeeded</span></span><br><span class="line"><span class="comment">//! PFNVIDOPPOINTCALLBACK  : &lt;0: fail, &gt;=0: succeeded (bit 0-9: OperatingPoint, bit 10-10: outputAllLayers, bit 11-30: reserved)</span></span><br><span class="line"><span class="comment">//! PFNVIDSEIMSGCALLBACK   : 0: fail, &gt;=1: succeeded</span></span><br><span class="line"><span class="comment">/***********************************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(CUDAAPI *PFNVIDSEQUENCECALLBACK)</span><span class="params">(<span class="type">void</span> *, CUVIDEOFORMAT *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(CUDAAPI *PFNVIDDECODECALLBACK)</span><span class="params">(<span class="type">void</span> *, CUVIDPICPARAMS *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(CUDAAPI *PFNVIDDISPLAYCALLBACK)</span><span class="params">(<span class="type">void</span> *, CUVIDPARSERDISPINFO *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(CUDAAPI *PFNVIDOPPOINTCALLBACK)</span><span class="params">(<span class="type">void</span> *, CUVIDOPERATINGPOINTINFO*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(CUDAAPI *PFNVIDSEIMSGCALLBACK)</span> <span class="params">(<span class="type">void</span> *, CUVIDSEIMESSAGEINFO *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CUVIDPARSERPARAMS</span></span><br><span class="line">&#123;</span><br><span class="line">    cudaVideoCodec CodecType;                   <span class="comment">/**&lt; IN: cudaVideoCodec_XXX                                                  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ulMaxNumDecodeSurfaces;        <span class="comment">/**&lt; IN: Max # of decode surfaces (parser will cycle through these)          */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ulClockRate;                   <span class="comment">/**&lt; IN: Timestamp units in Hz (0=default=10000000Hz)                        */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ulErrorThreshold;              <span class="comment">/**&lt; IN: % Error threshold (0-100) for calling pfnDecodePicture (100=always</span></span><br><span class="line"><span class="comment">                                                     IN: call pfnDecodePicture even if picture bitstream is fully corrupted) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ulMaxDisplayDelay;             <span class="comment">/**&lt; IN: Max display queue delay (improves pipelining of decode with display)</span></span><br><span class="line"><span class="comment">                                                         0=no delay (recommended values: 2..4)                               */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bAnnexb : <span class="number">1</span>;                   <span class="comment">/**&lt; IN: AV1 annexB stream                                                   */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uReserved : <span class="number">31</span>;                <span class="comment">/**&lt; Reserved for future use - set to zero                                   */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uReserved1[<span class="number">4</span>];                 <span class="comment">/**&lt; IN: Reserved for future use - set to 0                                  */</span></span><br><span class="line">    <span class="type">void</span> *pUserData;                            <span class="comment">/**&lt; IN: User data for callbacks                                             */</span></span><br><span class="line">    PFNVIDSEQUENCECALLBACK pfnSequenceCallback; <span class="comment">/**&lt; IN: Called before decoding frames and/or whenever there is a fmt change */</span></span><br><span class="line">    PFNVIDDECODECALLBACK pfnDecodePicture;      <span class="comment">/**&lt; IN: Called when a picture is ready to be decoded (decode order)         */</span></span><br><span class="line">    PFNVIDDISPLAYCALLBACK pfnDisplayPicture;    <span class="comment">/**&lt; IN: Called whenever a picture is ready to be displayed (display order)  */</span></span><br><span class="line">    PFNVIDOPPOINTCALLBACK pfnGetOperatingPoint; <span class="comment">/**&lt; IN: Called from AV1 sequence header to get operating point of a AV1</span></span><br><span class="line"><span class="comment">                                                         scalable bitstream                                                  */</span></span><br><span class="line">    PFNVIDSEIMSGCALLBACK pfnGetSEIMsg;          <span class="comment">/**&lt; IN: Called when all SEI messages are parsed for particular frame        */</span></span><br><span class="line">    <span class="type">void</span> *pvReserved2[<span class="number">5</span>];                       <span class="comment">/**&lt; Reserved for future use - set to NULL                                   */</span></span><br><span class="line">    CUVIDEOFORMATEX *pExtVideoInfo;             <span class="comment">/**&lt; IN: [Optional] sequence header data from system layer                   */</span></span><br><span class="line">&#125; CUVIDPARSERPARAMS;</span><br></pre></td></tr></table></figure><h4 id="相关参数具体设置：-1"><a href="#相关参数具体设置：-1" class="headerlink" title="相关参数具体设置："></a>相关参数具体设置：</h4><h5 id="CodecType"><a href="#CodecType" class="headerlink" title="CodecType"></a>CodecType</h5><p>与前面的CUVIDDECODECREATEINFO中的CodecType保持一致（必须来自枚举 cudaVideoCodec, 指示内容的编解码器类型，如 H.264、HEVC、VP9 等）</p><h5 id="ulMaxNumDecodeSurfaces"><a href="#ulMaxNumDecodeSurfaces" class="headerlink" title="ulMaxNumDecodeSurfaces"></a>ulMaxNumDecodeSurfaces</h5><p>与前面的CUVIDDECODECREATEINFO中的ulNumDecodeSurfaces保持一致（这是解析器的 DPB（解码图片缓冲区）中的表面数。该值在解析器初始化时可能是未知的，可以将其设置为虚拟数字（如 1）以创建解析器对象。应用程序必须注册回调pfn序列回调与驱动程序一起使用，当解析器遇到第一个序列头或序列中的任何更改时，解析器将调用它。此回调报告解析器的 DPB 正确解码所需的最小表面数 CUVIDEOFORMAT::min_num_decode_surfaces. 如果想要更新，序列回调可能会将此值返回给解析器 CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces. 然后解析器覆盖CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces与序列回调返回的值，如果序列回调的返回值大于 1（见说明pfn序列回调以下）。因此，为了优化内存分配，解码器对象的创建应该推迟到CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces是已知的，因此可以使用所需数量的缓冲区创建解码器对象，这样 CUVIDDECODECREATEINFO::ulNumDecodeSurfaces&#x3D; CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces）</p><h5 id="ulClockRate："><a href="#ulClockRate：" class="headerlink" title="ulClockRate："></a>ulClockRate：</h5><p>默认为0</p><h5 id="ulErrorThreshold"><a href="#ulErrorThreshold" class="headerlink" title="ulErrorThreshold"></a>ulErrorThreshold</h5><p>默认为0</p><h5 id="ulMaxDisplayDelay"><a href="#ulMaxDisplayDelay" class="headerlink" title="ulMaxDisplayDelay"></a>ulMaxDisplayDelay</h5><p>最大显示回调延迟。0 &#x3D; 无延迟，一设置0或者1,稳妥点也可以设置为2</p><h5 id="uReserved1-5"><a href="#uReserved1-5" class="headerlink" title="uReserved1[5]"></a>uReserved1[5]</h5><p>默认全为0(0&#x3D;default&#x3D;10000000Hz)</p><h5 id="pUserData"><a href="#pUserData" class="headerlink" title="pUserData"></a>pUserData</h5><p>回调函数</p><h5 id="pfnSequenceCallback"><a href="#pfnSequenceCallback" class="headerlink" title="pfnSequenceCallback"></a>pfnSequenceCallback</h5><p>pfnSequenceCallback是parser解析到序列及图像参数信息时的回调函数，其传入的参数是parser解析好的视频参数，可以用于初始化解码器或重置解码器。<br>应用程序必须注册一个函数来处理任何序列更改。解析器为初始序列头或遇到视频格式更改时触发此回调。序列回调的返回值由驱动程序解释如下：</p><ul><li>0：失败</li><li>1：成功，但驱动程序不应覆盖 CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces</li><li>&gt;1：成功，驱动程序应该覆盖 CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces有了这个返回值</li></ul><h5 id="pfnDecodePicture"><a href="#pfnDecodePicture" class="headerlink" title="pfnDecodePicture"></a>pfnDecodePicture</h5><p>pfnDecodePicture是parser解析到视频编码数据后的回调函数，其传入的参数parser处理好待解码的视频编码数据，需要在该函数中调用decoder的接口进行解码操作。<br>当一帧的比特流数据准备就绪时，解析器触发此回调。在场图片的情况下，每个显示调用可能有两个解码调用，因为两个场构成一个帧。此回调的返回值解释为：</p><ul><li>0：失败</li><li>≥1：成功</li></ul><h5 id="pfnDisplayPicture"><a href="#pfnDisplayPicture" class="headerlink" title="pfnDisplayPicture"></a>pfnDisplayPicture</h5><p>pfnDisplayPicture是parser对解码后的数据处理的回调函数，可以在该回调中对已解码的数据进行获取（从显存到系统内存）并处理。<br>当显示顺序中的帧准备就绪时，解析器触发此回调。此回调的返回值解释为：</p><ul><li>0：失败</li><li>≥1：成功</li></ul><h5 id="pvReserved2"><a href="#pvReserved2" class="headerlink" title="pvReserved2"></a>pvReserved2</h5><p>默认为0</p><h5 id="pExtVideoInfo"><a href="#pExtVideoInfo" class="headerlink" title="pExtVideoInfo"></a>pExtVideoInfo</h5><p>默认为NULL</p><h5 id="pfnGetOperatingPoint（只针对avi）"><a href="#pfnGetOperatingPoint（只针对avi）" class="headerlink" title="pfnGetOperatingPoint（只针对avi）"></a>pfnGetOperatingPoint（只针对avi）</h5><h5 id="pfnGetSEIMsg-一般用不到"><a href="#pfnGetSEIMsg-一般用不到" class="headerlink" title="pfnGetSEIMsg(一般用不到)"></a>pfnGetSEIMsg(一般用不到)</h5><p>当一帧所有未注册的用户 SEI 消息或元数据 OBU 被解析时，解析器按解码顺序触发此回调。目前此回调支持 H264、HEVC 和 AV1 编解码器。此回调的返回值解释为：</p><ul><li>0：失败</li><li>≥1：成功</li></ul><h3 id="2-6-2-相关回调函数的设计"><a href="#2-6-2-相关回调函数的设计" class="headerlink" title="2.6.2 相关回调函数的设计"></a>2.6.2 相关回调函数的设计</h3><p>上面三个回调函数的设置的非常重要的，如果不清楚回调函数需要实现的具体内容，可以参考NVIDIA的Video_Codec_SDK中的NvDecoder.cpp的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">NvDecoder::<span class="built_in">NvDecoder</span>(CUcontext cuContext, <span class="type">bool</span> bUseDeviceFrame, cudaVideoCodec eCodec, <span class="type">bool</span> bLowLatency, </span><br><span class="line">    <span class="type">bool</span> bDeviceFramePitched, <span class="type">const</span> Rect *pCropRect, <span class="type">const</span> Dim *pResizeDim, <span class="type">int</span> maxWidth, <span class="type">int</span> maxHeight, <span class="type">unsigned</span> <span class="type">int</span> clkRate,</span><br><span class="line">    <span class="type">bool</span> force_zero_latency) :</span><br><span class="line">    <span class="built_in">m_cuContext</span>(cuContext), <span class="built_in">m_bUseDeviceFrame</span>(bUseDeviceFrame), <span class="built_in">m_eCodec</span>(eCodec), <span class="built_in">m_bDeviceFramePitched</span>(bDeviceFramePitched),</span><br><span class="line">    <span class="built_in">m_nMaxWidth</span> (maxWidth), <span class="built_in">m_nMaxHeight</span>(maxHeight), <span class="built_in">m_bForce_zero_latency</span>(force_zero_latency)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pCropRect) m_cropRect = *pCropRect;</span><br><span class="line">    <span class="keyword">if</span> (pResizeDim) m_resizeDim = *pResizeDim;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidCtxLockCreate</span>(&amp;m_ctxLock, cuContext));</span><br><span class="line"></span><br><span class="line">    decoderSessionID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CUVIDPARSERPARAMS：该接口用来创建VideoParser</span></span><br><span class="line">    <span class="comment">//主要参数是设置三个回调函数，实现对解析出来的数据的处理</span></span><br><span class="line">    CUVIDPARSERPARAMS videoParserParameters = &#123;&#125;;<span class="comment">//结构体</span></span><br><span class="line">    videoParserParameters.CodecType = eCodec; <span class="comment">//解码视频类型，如H264</span></span><br><span class="line">    videoParserParameters.ulMaxNumDecodeSurfaces = <span class="number">1</span>;<span class="comment">//解码表面的最大数量（解析器将循环遍历这些表面）</span></span><br><span class="line">    videoParserParameters.ulClockRate = clkRate;<span class="comment">//1000</span></span><br><span class="line">    videoParserParameters.ulMaxDisplayDelay = bLowLatency ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    videoParserParameters.pUserData = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//三个回调函数</span></span><br><span class="line">    videoParserParameters.pfnSequenceCallback = HandleVideoSequenceProc;<span class="comment">//解码序列时调用</span></span><br><span class="line">    videoParserParameters.pfnDecodePicture = HandlePictureDecodeProc;<span class="comment">//准备开始解码时调用</span></span><br><span class="line">    videoParserParameters.pfnDisplayPicture = m_bForce_zero_latency ? <span class="literal">NULL</span> : HandlePictureDisplayProc;<span class="comment">//解码出数据调用</span></span><br><span class="line"></span><br><span class="line">    videoParserParameters.pfnGetOperatingPoint = HandleOperatingPointProc;<span class="comment">//这个是新增的回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Create video parser object and initialize</span></span><br><span class="line">    <span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidCreateVideoParser</span>(&amp;m_hParser, &amp;videoParserParameters));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们通过NVIDIA的Video_Codec_SDK中的NvDecoder.cpp来着重讲解一下这几个回调函数应该怎么样去设计！！！</p><h4 id="2-6-2-1-pfnSequenceCallback回调函数的设计"><a href="#2-6-2-1-pfnSequenceCallback回调函数的设计" class="headerlink" title="2.6.2.1 pfnSequenceCallback回调函数的设计"></a>2.6.2.1 pfnSequenceCallback回调函数的设计</h4><p>这个回调函数是在解码序列时才会被调用．</p><p>整个HandleVideoSequence函数其实主要分为几个步骤：</p><ul><li>相关结构体参数的数据填充</li><li>调用cuvidGetDecoderCaps接口来查询解码帧的状态</li><li>调用cuvidCreateDecoder接口来创建视频解码器</li></ul><p><font color = red >而这两个步骤，其实就是我们在前面2.4章节所说的，所以只要把2.4章节的步骤操作封装成一个函数，然后赋值给pfnSequenceCallback回调函数就可以了！！！</font></p><p>具体可以参考例程中的HandleVideoSequence函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return value from HandleVideoSequence() are interpreted as   :</span></span><br><span class="line"><span class="comment">*  0: fail, 1: succeeded, &gt; 1: override dpb size of parser (set by CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces while creating parser)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NvDecoder::HandleVideoSequence</span><span class="params">(CUVIDEOFORMAT *pVideoFormat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    START_TIMER</span><br><span class="line">    m_videoInfo.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    m_videoInfo.<span class="built_in">clear</span>();</span><br><span class="line">    m_videoInfo &lt;&lt; <span class="string">&quot;Video Input Information&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tCodec        : &quot;</span> &lt;&lt; <span class="built_in">GetVideoCodecString</span>(pVideoFormat-&gt;codec) &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tFrame rate   : &quot;</span> &lt;&lt; pVideoFormat-&gt;frame_rate.numerator &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; pVideoFormat-&gt;frame_rate.denominator</span><br><span class="line">            &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; <span class="number">1.0</span> * pVideoFormat-&gt;frame_rate.numerator / pVideoFormat-&gt;frame_rate.denominator &lt;&lt; <span class="string">&quot; fps&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tSequence     : &quot;</span> &lt;&lt; (pVideoFormat-&gt;progressive_sequence ? <span class="string">&quot;Progressive&quot;</span> : <span class="string">&quot;Interlaced&quot;</span>) &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tCoded size   : [&quot;</span> &lt;&lt; pVideoFormat-&gt;coded_width &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pVideoFormat-&gt;coded_height &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tDisplay area : [&quot;</span> &lt;&lt; pVideoFormat-&gt;display_area.left &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pVideoFormat-&gt;display_area.top &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">            &lt;&lt; pVideoFormat-&gt;display_area.right &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pVideoFormat-&gt;display_area.bottom &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tChroma       : &quot;</span> &lt;&lt; <span class="built_in">GetVideoChromaFormatString</span>(pVideoFormat-&gt;chroma_format) &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tBit depth    : &quot;</span> &lt;&lt; pVideoFormat-&gt;bit_depth_luma_minus8 + <span class="number">8</span></span><br><span class="line">    ;</span><br><span class="line">    m_videoInfo &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nDecodeSurface = pVideoFormat-&gt;min_num_decode_surfaces;</span><br><span class="line"></span><br><span class="line">    CUVIDDECODECAPS decodecaps;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;decodecaps, <span class="number">0</span>, <span class="built_in">sizeof</span>(decodecaps));</span><br><span class="line"></span><br><span class="line">    decodecaps.eCodecType = pVideoFormat-&gt;codec;</span><br><span class="line">    decodecaps.eChromaFormat = pVideoFormat-&gt;chroma_format;</span><br><span class="line">    decodecaps.nBitDepthMinus8 = pVideoFormat-&gt;bit_depth_luma_minus8;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPushCurrent</span>(m_cuContext)); <span class="comment">//启用context</span></span><br><span class="line">    <span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidGetDecoderCaps</span>(&amp;decodecaps));</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!decodecaps.bIsSupported)&#123;</span><br><span class="line">        <span class="built_in">NVDEC_THROW_ERROR</span>(<span class="string">&quot;Codec not supported on this GPU&quot;</span>, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">        <span class="keyword">return</span> nDecodeSurface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pVideoFormat-&gt;coded_width &gt; decodecaps.nMaxWidth) ||</span><br><span class="line">        (pVideoFormat-&gt;coded_height &gt; decodecaps.nMaxHeight))&#123;</span><br><span class="line"></span><br><span class="line">        std::ostringstream errorString;</span><br><span class="line">        errorString &lt;&lt; std::endl</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;Resolution          : &quot;</span> &lt;&lt; pVideoFormat-&gt;coded_width &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; pVideoFormat-&gt;coded_height &lt;&lt; std::endl</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;Max Supported (wxh) : &quot;</span> &lt;&lt; decodecaps.nMaxWidth &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; decodecaps.nMaxHeight &lt;&lt; std::endl</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;Resolution not supported on this GPU&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> std::string cErr = errorString.<span class="built_in">str</span>();</span><br><span class="line">        <span class="built_in">NVDEC_THROW_ERROR</span>(cErr, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">        <span class="keyword">return</span> nDecodeSurface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pVideoFormat-&gt;coded_width&gt;&gt;<span class="number">4</span>)*(pVideoFormat-&gt;coded_height&gt;&gt;<span class="number">4</span>) &gt; decodecaps.nMaxMBCount)&#123;</span><br><span class="line"></span><br><span class="line">        std::ostringstream errorString;</span><br><span class="line">        errorString &lt;&lt; std::endl</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;MBCount             : &quot;</span> &lt;&lt; (pVideoFormat-&gt;coded_width &gt;&gt; <span class="number">4</span>)*(pVideoFormat-&gt;coded_height &gt;&gt; <span class="number">4</span>) &lt;&lt; std::endl</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;Max Supported mbcnt : &quot;</span> &lt;&lt; decodecaps.nMaxMBCount &lt;&lt; std::endl</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;MBCount not supported on this GPU&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> std::string cErr = errorString.<span class="built_in">str</span>();</span><br><span class="line">        <span class="built_in">NVDEC_THROW_ERROR</span>(cErr, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">        <span class="keyword">return</span> nDecodeSurface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_nWidth &amp;&amp; m_nLumaHeight &amp;&amp; m_nChromaHeight) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cuvidCreateDecoder() has been called before, and now there&#x27;s possible config change</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ReconfigureDecoder</span>(pVideoFormat);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// eCodec has been set in the constructor (for parser). Here it&#x27;s set again for potential correction</span></span><br><span class="line">    m_eCodec = pVideoFormat-&gt;codec;</span><br><span class="line">    m_eChromaFormat = pVideoFormat-&gt;chroma_format;</span><br><span class="line">    m_nBitDepthMinus8 = pVideoFormat-&gt;bit_depth_luma_minus8;</span><br><span class="line">    m_nBPP = m_nBitDepthMinus8 &gt; <span class="number">0</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the output surface format same as chroma format</span></span><br><span class="line">    <span class="keyword">if</span> (m_eChromaFormat == cudaVideoChromaFormat_420 || cudaVideoChromaFormat_Monochrome)</span><br><span class="line">        m_eOutputFormat = pVideoFormat-&gt;bit_depth_luma_minus8 ? cudaVideoSurfaceFormat_P016 : cudaVideoSurfaceFormat_NV12;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_eChromaFormat == cudaVideoChromaFormat_444)</span><br><span class="line">        m_eOutputFormat = pVideoFormat-&gt;bit_depth_luma_minus8 ? cudaVideoSurfaceFormat_YUV444_16Bit : cudaVideoSurfaceFormat_YUV444;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_eChromaFormat == cudaVideoChromaFormat_422)</span><br><span class="line">        m_eOutputFormat = cudaVideoSurfaceFormat_NV12;  <span class="comment">// no 4:2:2 output format supported yet so make 420 default</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if output format supported. If not, check falback options</span></span><br><span class="line">    <span class="keyword">if</span> (!(decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; m_eOutputFormat)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_NV12))</span><br><span class="line">            m_eOutputFormat = cudaVideoSurfaceFormat_NV12;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_P016))</span><br><span class="line">            m_eOutputFormat = cudaVideoSurfaceFormat_P016;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_YUV444))</span><br><span class="line">            m_eOutputFormat = cudaVideoSurfaceFormat_YUV444;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_YUV444_16Bit))</span><br><span class="line">            m_eOutputFormat = cudaVideoSurfaceFormat_YUV444_16Bit;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">NVDEC_THROW_ERROR</span>(<span class="string">&quot;No supported output format found&quot;</span>, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">    &#125;</span><br><span class="line">    m_videoFormat = *pVideoFormat;</span><br><span class="line"></span><br><span class="line">    CUVIDDECODECREATEINFO videoDecodeCreateInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    videoDecodeCreateInfo.CodecType = pVideoFormat-&gt;codec;</span><br><span class="line">    videoDecodeCreateInfo.ChromaFormat = pVideoFormat-&gt;chroma_format;</span><br><span class="line">    videoDecodeCreateInfo.OutputFormat = m_eOutputFormat;</span><br><span class="line">    videoDecodeCreateInfo.bitDepthMinus8 = pVideoFormat-&gt;bit_depth_luma_minus8;</span><br><span class="line">    <span class="keyword">if</span> (pVideoFormat-&gt;progressive_sequence)</span><br><span class="line">        videoDecodeCreateInfo.DeinterlaceMode = cudaVideoDeinterlaceMode_Weave;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        videoDecodeCreateInfo.DeinterlaceMode = cudaVideoDeinterlaceMode_Adaptive;</span><br><span class="line">    videoDecodeCreateInfo.ulNumOutputSurfaces = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// With PreferCUVID, JPEG is still decoded by CUDA while video is decoded by NVDEC hardware</span></span><br><span class="line">    videoDecodeCreateInfo.ulCreationFlags = cudaVideoCreate_PreferCUVID;</span><br><span class="line">    videoDecodeCreateInfo.ulNumDecodeSurfaces = nDecodeSurface;</span><br><span class="line">    videoDecodeCreateInfo.vidLock = m_ctxLock;</span><br><span class="line">    videoDecodeCreateInfo.ulWidth = pVideoFormat-&gt;coded_width;</span><br><span class="line">    videoDecodeCreateInfo.ulHeight = pVideoFormat-&gt;coded_height;</span><br><span class="line">    <span class="comment">// AV1 has max width/height of sequence in sequence header</span></span><br><span class="line">    <span class="keyword">if</span> (pVideoFormat-&gt;codec == cudaVideoCodec_AV1 &amp;&amp; pVideoFormat-&gt;seqhdr_data_length &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// dont overwrite if it is already set from cmdline or reconfig.txt</span></span><br><span class="line">        <span class="keyword">if</span> (!(m_nMaxWidth &gt; pVideoFormat-&gt;coded_width || m_nMaxHeight &gt; pVideoFormat-&gt;coded_height))</span><br><span class="line">        &#123;</span><br><span class="line">            CUVIDEOFORMATEX *vidFormatEx = (CUVIDEOFORMATEX *)pVideoFormat;</span><br><span class="line">            m_nMaxWidth = vidFormatEx-&gt;av1.max_width;</span><br><span class="line">            m_nMaxHeight = vidFormatEx-&gt;av1.max_height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_nMaxWidth &lt; (<span class="type">int</span>)pVideoFormat-&gt;coded_width)</span><br><span class="line">        m_nMaxWidth = pVideoFormat-&gt;coded_width;</span><br><span class="line">    <span class="keyword">if</span> (m_nMaxHeight &lt; (<span class="type">int</span>)pVideoFormat-&gt;coded_height)</span><br><span class="line">        m_nMaxHeight = pVideoFormat-&gt;coded_height;</span><br><span class="line">    videoDecodeCreateInfo.ulMaxWidth = m_nMaxWidth;</span><br><span class="line">    videoDecodeCreateInfo.ulMaxHeight = m_nMaxHeight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(m_cropRect.r &amp;&amp; m_cropRect.b) &amp;&amp; !(m_resizeDim.w &amp;&amp; m_resizeDim.h)) &#123;</span><br><span class="line">        m_nWidth = pVideoFormat-&gt;display_area.right - pVideoFormat-&gt;display_area.left;</span><br><span class="line">        m_nLumaHeight = pVideoFormat-&gt;display_area.bottom - pVideoFormat-&gt;display_area.top;</span><br><span class="line">        videoDecodeCreateInfo.ulTargetWidth = pVideoFormat-&gt;coded_width;</span><br><span class="line">        videoDecodeCreateInfo.ulTargetHeight = pVideoFormat-&gt;coded_height;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_resizeDim.w &amp;&amp; m_resizeDim.h) &#123;</span><br><span class="line">            videoDecodeCreateInfo.display_area.left = pVideoFormat-&gt;display_area.left;</span><br><span class="line">            videoDecodeCreateInfo.display_area.top = pVideoFormat-&gt;display_area.top;</span><br><span class="line">            videoDecodeCreateInfo.display_area.right = pVideoFormat-&gt;display_area.right;</span><br><span class="line">            videoDecodeCreateInfo.display_area.bottom = pVideoFormat-&gt;display_area.bottom;</span><br><span class="line">            m_nWidth = m_resizeDim.w;</span><br><span class="line">            m_nLumaHeight = m_resizeDim.h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_cropRect.r &amp;&amp; m_cropRect.b) &#123;</span><br><span class="line">            videoDecodeCreateInfo.display_area.left = m_cropRect.l;</span><br><span class="line">            videoDecodeCreateInfo.display_area.top = m_cropRect.t;</span><br><span class="line">            videoDecodeCreateInfo.display_area.right = m_cropRect.r;</span><br><span class="line">            videoDecodeCreateInfo.display_area.bottom = m_cropRect.b;</span><br><span class="line">            m_nWidth = m_cropRect.r - m_cropRect.l;</span><br><span class="line">            m_nLumaHeight = m_cropRect.b - m_cropRect.t;</span><br><span class="line">        &#125;</span><br><span class="line">        videoDecodeCreateInfo.ulTargetWidth = m_nWidth;</span><br><span class="line">        videoDecodeCreateInfo.ulTargetHeight = m_nLumaHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_nChromaHeight = (<span class="type">int</span>)(<span class="built_in">ceil</span>(m_nLumaHeight * <span class="built_in">GetChromaHeightFactor</span>(m_eOutputFormat)));</span><br><span class="line">    m_nNumChromaPlanes = <span class="built_in">GetChromaPlaneCount</span>(m_eOutputFormat);</span><br><span class="line">    m_nSurfaceHeight = videoDecodeCreateInfo.ulTargetHeight;</span><br><span class="line">    m_nSurfaceWidth = videoDecodeCreateInfo.ulTargetWidth;</span><br><span class="line">    m_displayRect.b = videoDecodeCreateInfo.display_area.bottom;</span><br><span class="line">    m_displayRect.t = videoDecodeCreateInfo.display_area.top;</span><br><span class="line">    m_displayRect.l = videoDecodeCreateInfo.display_area.left;</span><br><span class="line">    m_displayRect.r = videoDecodeCreateInfo.display_area.right;</span><br><span class="line"></span><br><span class="line">    m_videoInfo &lt;&lt; <span class="string">&quot;Video Decoding Params:&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tNum Surfaces : &quot;</span> &lt;&lt; videoDecodeCreateInfo.ulNumDecodeSurfaces &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tCrop         : [&quot;</span> &lt;&lt; videoDecodeCreateInfo.display_area.left &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; videoDecodeCreateInfo.display_area.top &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">        &lt;&lt; videoDecodeCreateInfo.display_area.right &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; videoDecodeCreateInfo.display_area.bottom &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tResize       : &quot;</span> &lt;&lt; videoDecodeCreateInfo.ulTargetWidth &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; videoDecodeCreateInfo.ulTargetHeight &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tDeinterlace  : &quot;</span> &lt;&lt; std::vector&lt;<span class="type">const</span> <span class="type">char</span> *&gt;&#123;<span class="string">&quot;Weave&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adaptive&quot;</span>&#125;[videoDecodeCreateInfo.DeinterlaceMode]</span><br><span class="line">    ;</span><br><span class="line">    m_videoInfo &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPushCurrent</span>(m_cuContext));</span><br><span class="line">    <span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidCreateDecoder</span>(&amp;m_hDecoder, &amp;videoDecodeCreateInfo));</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="built_in">STOP_TIMER</span>(<span class="string">&quot;Session Initialization Time: &quot;</span>);</span><br><span class="line">    NvDecoder::<span class="built_in">addDecoderSessionOverHead</span>(<span class="built_in">getDecoderSessionID</span>(), elapsedTime);</span><br><span class="line">    <span class="keyword">return</span> nDecodeSurface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-2-2-pfnDecodePicture回调函数的设计"><a href="#2-6-2-2-pfnDecodePicture回调函数的设计" class="headerlink" title="2.6.2.2 pfnDecodePicture回调函数的设计"></a>2.6.2.2 pfnDecodePicture回调函数的设计</h4><p>这个回调函数是在准备开始解码时才会被调用<br>整个HandleVideoSequence函数其实主要就是调用cuvidDecodePicture接口</p><p>在2.6.2.1章节中我们调用了cuvidCreateDecoder接口来创建视频解码器，而这个接口将会返回phDecoder这个句柄，而接下来我们就要将phDecoder作为hDecoder输入参数设置到cuvidDecodePicture接口中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************************************************/</span></span><br><span class="line"><span class="comment">//! \fn CUresult CUDAAPI cuvidCreateDecoder(CUvideodecoder *phDecoder, CUVIDDECODECREATEINFO *pdci)</span></span><br><span class="line"><span class="comment">//! Create the decoder object based on pdci. A handle to the created decoder is returned</span></span><br><span class="line"><span class="comment">/*****************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> CUresult CUDAAPI <span class="title">cuvidCreateDecoder</span><span class="params">(CUvideodecoder *phDecoder, CUVIDDECODECREATEINFO *pdci)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************************************************************/</span></span><br><span class="line"><span class="comment">//! \fn CUresult CUDAAPI cuvidDecodePicture(CUvideodecoder hDecoder, CUVIDPICPARAMS *pPicParams)</span></span><br><span class="line"><span class="comment">//! Decode a single picture (field or frame)</span></span><br><span class="line"><span class="comment">//! Kicks off HW decoding </span></span><br><span class="line"><span class="comment">/*****************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> CUresult CUDAAPI <span class="title">cuvidDecodePicture</span><span class="params">(CUvideodecoder hDecoder, CUVIDPICPARAMS *pPicParams)</span></span>;</span><br></pre></td></tr></table></figure><p>除了这个参数以外，我们还需要将CUVIDPICPARAMS结构体作为第二个参数直接设置进去</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return value from HandlePictureDecode() are interpreted as:</span></span><br><span class="line"><span class="comment">*  0: fail, &gt;=1: succeeded</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NvDecoder::HandlePictureDecode</span><span class="params">(CUVIDPICPARAMS *pPicParams)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_hDecoder)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NVDEC_THROW_ERROR</span>(<span class="string">&quot;Decoder not initialized.&quot;</span>, CUDA_ERROR_NOT_INITIALIZED);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_nPicNumInDecodeOrder[pPicParams-&gt;CurrPicIdx] = m_nDecodePicCnt++;</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPushCurrent</span>(m_cuContext));</span><br><span class="line">    <span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidDecodePicture</span>(m_hDecoder, pPicParams));</span><br><span class="line">    <span class="keyword">if</span> (m_bForce_zero_latency &amp;&amp; ((!pPicParams-&gt;field_pic_flag) || (pPicParams-&gt;second_field)))</span><br><span class="line">    &#123;</span><br><span class="line">        CUVIDPARSERDISPINFO dispInfo;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;dispInfo, <span class="number">0</span>, <span class="built_in">sizeof</span>(dispInfo));</span><br><span class="line">        dispInfo.picture_index = pPicParams-&gt;CurrPicIdx;</span><br><span class="line">        dispInfo.progressive_frame = !pPicParams-&gt;field_pic_flag;</span><br><span class="line">        dispInfo.top_field_first = pPicParams-&gt;bottom_field_flag ^ <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">HandlePictureDisplay</span>(&amp;dispInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-2-3-pfnDisplayPicture回调函数的设计"><a href="#2-6-2-3-pfnDisplayPicture回调函数的设计" class="headerlink" title="2.6.2.3 pfnDisplayPicture回调函数的设计"></a>2.6.2.3 pfnDisplayPicture回调函数的设计</h4><p>这个回调函数是在解码出数据时才会被调用</p><p>整个HandlePictureDisplay函数其实主要就做了以下几件事情：</p><ul><li>CUVIDPROCPARAMS结构体参数的数据填充</li><li>cuCtxPushCurrent</li><li>调用cuvidMapVideoFrame接口，获取到设备内存中指定的YUV数据地址</li><li>分配空间</li><li>NV12TORGB</li><li>cuCtxPopCurrent</li><li>cuvidUnmapVideoFrame</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Return value from HandlePictureDisplay() are interpreted as:</span></span><br><span class="line"><span class="comment">*  0: fail, &gt;=1: succeeded</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//目的是找到解码后数据在显存中的位置以及指针的指向，因此重点看了HandlePictureDisplay函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NvDecoder::HandlePictureDisplay</span><span class="params">(CUVIDPARSERDISPINFO *pDispInfo)</span> </span>&#123;</span><br><span class="line">    CUVIDPROCPARAMS videoProcessingParameters = &#123;&#125;;</span><br><span class="line">    videoProcessingParameters.progressive_frame = pDispInfo-&gt;progressive_frame;</span><br><span class="line">    videoProcessingParameters.second_field = pDispInfo-&gt;repeat_first_field + <span class="number">1</span>;</span><br><span class="line">    videoProcessingParameters.top_field_first = pDispInfo-&gt;top_field_first;</span><br><span class="line">    videoProcessingParameters.unpaired_field = pDispInfo-&gt;repeat_first_field &lt; <span class="number">0</span>;</span><br><span class="line">    videoProcessingParameters.output_stream = m_cuvidStream;</span><br><span class="line"></span><br><span class="line">    CUdeviceptr dpSrcFrame = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nSrcPitch = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPushCurrent</span>(m_cuContext));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cuvidMapVideoFrame:返回cuda设备指针和视频帧的Pitch，获取到设备内存中指定的YUV数据地址</span></span><br><span class="line">    <span class="comment">// MapVideoFrame: 拿到解码后数据在显存的指针 --&gt; dpSrcFrame</span></span><br><span class="line">    <span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidMapVideoFrame</span>(m_hDecoder, pDispInfo-&gt;picture_index, &amp;dpSrcFrame,</span><br><span class="line">        &amp;nSrcPitch, &amp;videoProcessingParameters));</span><br><span class="line"></span><br><span class="line">    CUVIDGETDECODESTATUS DecodeStatus;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;DecodeStatus, <span class="number">0</span>, <span class="built_in">sizeof</span>(DecodeStatus));</span><br><span class="line">    CUresult result = <span class="built_in">cuvidGetDecodeStatus</span>(m_hDecoder, pDispInfo-&gt;picture_index, &amp;DecodeStatus);</span><br><span class="line">    <span class="keyword">if</span> (result == CUDA_SUCCESS &amp;&amp; (DecodeStatus.decodeStatus == cuvidDecodeStatus_Error || DecodeStatus.decodeStatus == cuvidDecodeStatus_Error_Concealed))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Decode Error occurred for picture %d\n&quot;</span>, m_nPicNumInDecodeOrder[pDispInfo-&gt;picture_index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> *pDecodedFrame = <span class="literal">nullptr</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// lock_guard 自动解锁 当控件离开lock_guard创建对象的范围时，lock_guard被破坏并释放互斥体</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mtxVPFrame)</span></span>;</span><br><span class="line">        <span class="comment">// 解出一帧 m_nDecodedFrame+1,且若不够空间了,则开辟空间</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">unsigned</span>)++m_nDecodedFrame &gt; m_vpFrame.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Not enough frames in stock</span></span><br><span class="line">            m_nFrameAlloc++;</span><br><span class="line">            <span class="type">uint8_t</span> *pFrame = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (m_bUseDeviceFrame)<span class="comment">//初始化解码器的时候设置的,是否使用显卡内存,是得解码出来的数据不转到CPU内存</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (m_bDeviceFramePitched)<span class="comment">//分配显存空间，并返回指向该空间的指针pFrame</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuMemAllocPitch</span>((CUdeviceptr *)&amp;pFrame, &amp;m_nDeviceFramePitch, <span class="built_in">GetWidth</span>() * m_nBPP, m_nLumaHeight + (m_nChromaHeight * m_nNumChromaPlanes), <span class="number">16</span>));</span><br><span class="line">                cuvidCreateVideoParser&#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//CPU内存</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuMemAlloc</span>((CUdeviceptr *)&amp;pFrame, <span class="built_in">GetFrameSize</span>()));<span class="comment">// 开辟空间</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pFrame = <span class="keyword">new</span> <span class="type">uint8_t</span>[<span class="built_in">GetFrameSize</span>()];</span><br><span class="line">            &#125;</span><br><span class="line">            m_vpFrame.<span class="built_in">push_back</span>(pFrame);<span class="comment">//压进堆栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        pDecodedFrame = m_vpFrame[m_nDecodedFrame - <span class="number">1</span>];<span class="comment">// 取堆栈最后一个帧数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy luma plane</span></span><br><span class="line">    CUDA_MEMCPY2D m = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    m.srcMemoryType = CU_MEMORYTYPE_DEVICE;</span><br><span class="line">    m.srcDevice = dpSrcFrame;<span class="comment">//解码后数据在显存的指针</span></span><br><span class="line">    m.srcPitch = nSrcPitch;</span><br><span class="line">    m.dstMemoryType = m_bUseDeviceFrame ? CU_MEMORYTYPE_DEVICE : CU_MEMORYTYPE_HOST;</span><br><span class="line">    m.dstDevice = (CUdeviceptr)(m.dstHost = pDecodedFrame);</span><br><span class="line">    m.dstPitch = m_nDeviceFramePitch ? m_nDeviceFramePitch : <span class="built_in">GetWidth</span>() * m_nBPP;</span><br><span class="line">    m.WidthInBytes = <span class="built_in">GetWidth</span>() * m_nBPP;</span><br><span class="line">    m.Height = m_nLumaHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码完成,NV12格式 pDecodedFrame</span></span><br><span class="line">    <span class="comment">// NV12TORGB</span></span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuMemcpy2DAsync</span>(&amp;m, m_cuvidStream));<span class="comment">//复制二维数组的内存。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy chroma plane</span></span><br><span class="line">    <span class="comment">// NVDEC output has luma height aligned by 2. Adjust chroma offset by aligning height</span></span><br><span class="line">    m.srcDevice = (CUdeviceptr)((<span class="type">uint8_t</span> *)dpSrcFrame + m.srcPitch * ((m_nSurfaceHeight + <span class="number">1</span>) &amp; ~<span class="number">1</span>));</span><br><span class="line">    m.dstDevice = (CUdeviceptr)(m.dstHost = pDecodedFrame + m.dstPitch * m_nLumaHeight);</span><br><span class="line">    m.Height = m_nChromaHeight;</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuMemcpy2DAsync</span>(&amp;m, m_cuvidStream));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_nNumChromaPlanes == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m.srcDevice = (CUdeviceptr)((<span class="type">uint8_t</span> *)dpSrcFrame + m.srcPitch * ((m_nSurfaceHeight + <span class="number">1</span>) &amp; ~<span class="number">1</span>) * <span class="number">2</span>);</span><br><span class="line">        m.dstDevice = (CUdeviceptr)(m.dstHost = pDecodedFrame + m.dstPitch * m_nLumaHeight * <span class="number">2</span>);</span><br><span class="line">        m.Height = m_nChromaHeight;</span><br><span class="line">        <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuMemcpy2DAsync</span>(&amp;m, m_cuvidStream));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuStreamSynchronize</span>(m_cuvidStream));</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>));<span class="comment">// 拷贝结束,取消上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">int</span>)m_vTimestamp.<span class="built_in">size</span>() &lt; m_nDecodedFrame) &#123;</span><br><span class="line">        m_vTimestamp.<span class="built_in">resize</span>(m_vpFrame.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    m_vTimestamp[m_nDecodedFrame - <span class="number">1</span>] = pDispInfo-&gt;timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取消映射先前映射的视频帧</span></span><br><span class="line">    <span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidUnmapVideoFrame</span>(m_hDecoder, dpSrcFrame));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-2-4-pfnGetOperatingPoint回调函数的设计"><a href="#2-6-2-4-pfnGetOperatingPoint回调函数的设计" class="headerlink" title="2.6.2.4 pfnGetOperatingPoint回调函数的设计"></a>2.6.2.4 pfnGetOperatingPoint回调函数的设计</h4><h4 id="2-6-2-5-pfnGetSEIMsg回调函数的设计"><a href="#2-6-2-5-pfnGetSEIMsg回调函数的设计" class="headerlink" title="2.6.2.5 pfnGetSEIMsg回调函数的设计"></a>2.6.2.5 pfnGetSEIMsg回调函数的设计</h4><h3 id="2-6-3-解析器的创建"><a href="#2-6-3-解析器的创建" class="headerlink" title="2.6.3 解析器的创建"></a>2.6.3 解析器的创建</h3><p>当我们把CUVIDPARSERPARAMS结构体填充完成后，就可以调用cuvidCreateVideoParser函数，将CUVIDPARSERPARAMS作为输入参数，进行解析器的创建。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult CUDAAPI <span class="title">tcuvidCreateVideoParser</span><span class="params">(CUvideoparser *pObj, CUVIDPARSERPARAMS *pParams)</span></span>;</span><br><span class="line">tcuvidCreateVideoParser               *cuvidCreateVideoParser;</span><br></pre></td></tr></table></figure><p>Video_Codec_SDK样例中NvDecoder文件:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CUVIDPARSERPARAMS：该接口用来创建VideoParser</span></span><br><span class="line"><span class="comment">//主要参数是设置三个回调函数，实现对解析出来的数据的处理</span></span><br><span class="line">CUVIDPARSERPARAMS videoParserParameters = &#123;&#125;;<span class="comment">//结构体</span></span><br><span class="line">videoParserParameters.CodecType = eCodec; <span class="comment">//解码视频类型，如H264</span></span><br><span class="line">videoParserParameters.ulMaxNumDecodeSurfaces = <span class="number">1</span>;<span class="comment">//解码表面的最大数量（解析器将循环遍历这些表面）</span></span><br><span class="line">videoParserParameters.ulClockRate = clkRate;</span><br><span class="line">videoParserParameters.ulMaxDisplayDelay = bLowLatency ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">videoParserParameters.pUserData = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三个回调函数</span></span><br><span class="line">videoParserParameters.pfnSequenceCallback = HandleVideoSequenceProc;<span class="comment">//解码序列时调用</span></span><br><span class="line">videoParserParameters.pfnDecodePicture = HandlePictureDecodeProc;<span class="comment">//准备开始解码时调用</span></span><br><span class="line">videoParserParameters.pfnDisplayPicture = m_bForce_zero_latency ? <span class="literal">NULL</span> : HandlePictureDisplayProc;<span class="comment">//解码出数据调用</span></span><br><span class="line">videoParserParameters.pfnGetOperatingPoint = HandleOperatingPointProc;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create video parser object and initialize</span></span><br><span class="line"><span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidCreateVideoParser</span>(&amp;m_hParser, &amp;videoParserParameters));</span><br></pre></td></tr></table></figure><h3 id="2-6-4-从解复用器提取数据包进行解码"><a href="#2-6-4-从解复用器提取数据包进行解码" class="headerlink" title="2.6.4 从解复用器提取数据包进行解码"></a>2.6.4 从解复用器提取数据包进行解码</h3><p>解析器创建完成后，我们就可以开始真正的进行解码咯，而解码就需要通过调用cuvidParseVideoData从解复用器提取数据包：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult CUDAAPI <span class="title">tcuvidParseVideoData</span><span class="params">(CUvideoparser obj, CUVIDSOURCEDATAPACKET *pPacket)</span></span>;</span><br><span class="line">tcuvidParseVideoData                  *cuvidParseVideoData;</span><br></pre></td></tr></table></figure><p>首先定义一个CUVIDSOURCEDATAPACKET结构体类型的变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CUVIDSOURCEDATAPACKET</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;            <span class="comment">/**&lt; Combination of CUVID_PKT_XXX flags */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> payload_size;     <span class="comment">/**&lt; number of bytes in the payload (may be zero if EOS flag is set) */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *payload;   <span class="comment">/**&lt; Pointer to packet payload data (may be NULL if EOS flag is set) */</span></span><br><span class="line">    CUvideotimestamp timestamp;     <span class="comment">/**&lt; Presentation timestamp (10MHz clock), only valid if CUVID_PKT_TIMESTAMP flag is set */</span></span><br><span class="line">&#125; CUVIDSOURCEDATAPACKET;</span><br></pre></td></tr></table></figure><h4 id="相关参数具体设置：-2"><a href="#相关参数具体设置：-2" class="headerlink" title="相关参数具体设置："></a>相关参数具体设置：</h4><p>首先使用memset函数将结构体初始化（全置为0）</p><h5 id="flags："><a href="#flags：" class="headerlink" title="flags："></a>flags：</h5><p>默认为0</p><h5 id="payload-size"><a href="#payload-size" class="headerlink" title="payload_size"></a>payload_size</h5><p>payload_size等于之前CUVIDEOFORMATEX结构体中format.seqhdr_data_length的值</p><h5 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h5><p>payload等于之前CUVIDEOFORMATEX结构体中raw_seqhdr_data的值</p><h5 id="timestamp"><a href="#timestamp" class="headerlink" title="timestamp"></a>timestamp</h5><p>默认为0</p><p>通过上面的参数，我们可以知道还必须得到CUVIDEOFORMATEX结构体变量的信息<br>因此我们接着定义一个CUVIDEOFORMATEX结构体类型的变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包含原始序列头信息的视频格式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    CUVIDEOFORMAT format;<span class="comment">//Video format</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> raw_seqhdr_data[<span class="number">1024</span>];</span><br><span class="line">&#125; CUVIDEOFORMATEX;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="相关参数具体设置：-3"><a href="#相关参数具体设置：-3" class="headerlink" title="相关参数具体设置："></a>相关参数具体设置：</h4><p>首先使用memset函数将结构体初始化（全置为0）</p><h5 id="format："><a href="#format：" class="headerlink" title="format："></a>format：</h5><p>只需要设置format.seqhdr_data_length ，值等于额外数据的长度</p><h5 id="raw-seqhdr-data："><a href="#raw-seqhdr-data：" class="headerlink" title="raw_seqhdr_data："></a>raw_seqhdr_data：</h5><p>通过memcpy将额外数据copy到raw_seqhdr_data中，长度为seqhdr_data_length<br>即：memcpy(CuVideoFormatEx.raw_seqhdr_data, exdata, exdataLen);</p><p>接着我们通过调用cuvidParseVideoData从解复用器提取数据包，该接口是用来向parser塞数据，通过不断地塞h.264数据，parser会通过回调接口对解析出来的数据进行处理。</p><p>提取成功后，紧接着调用cuCtxPopCurrent函数，将给定的上下文ctx从当前CPU线程的上下文堆栈中弹出。</p><p>Video_Codec_SDK样例中NvDecoder文件:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//AVPacket转CUVIDSOURCEDATAPACKET，并交给cuvidParaseVideoData进行</span></span><br><span class="line">CUVIDSOURCEDATAPACKET packet = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">packet.payload = pData;<span class="comment">//指向数据包有效载荷数据的指针</span></span><br><span class="line">packet.payload_size = nSize;<span class="comment">//负载中的字节数</span></span><br><span class="line">packet.flags = nFlags | CUVID_PKT_TIMESTAMP;</span><br><span class="line">packet.timestamp = nTimestamp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否是stream的最后一个packet</span></span><br><span class="line"><span class="keyword">if</span> (!pData || nSize == <span class="number">0</span>) &#123;</span><br><span class="line">    packet.flags |= CUVID_PKT_ENDOFSTREAM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidParseVideoData</span>(m_hParser, &amp;packet));</span><br><span class="line">```    </span><br><span class="line">## <span class="number">2.7</span> 获取解码后的 YUV 以供进一步处理</span><br><span class="line">这一步骤是在pfnDisplayPicture指向的回调函数进行处理的，在前面的<span class="number">2.6</span><span class="number">.2</span><span class="number">.3</span>章节中，我们说了pfnDisplayPicture这个回调函数是在解码出数据时才会被调用</span><br><span class="line"></span><br><span class="line">而整个HandlePictureDisplay函数其实主要就做了以下几件事情：</span><br><span class="line">- CUVIDPROCPARAMS结构体参数的数据填充</span><br><span class="line">- cuCtxPushCurrent</span><br><span class="line">- 调用cuvidMapVideoFrame接口，获取到设备内存中指定的YUV数据地址</span><br><span class="line">- 分配空间</span><br><span class="line">- NV12TORGB</span><br><span class="line">- cuCtxPopCurrent</span><br><span class="line">- cuvidUnmapVideoFrame</span><br><span class="line"></span><br><span class="line">其中的：</span><br><span class="line">- 调用cuvidMapVideoFrame接口，获取到设备内存中指定的YUV数据地址</span><br><span class="line">- 分配空间</span><br><span class="line">- NV12TORGB</span><br><span class="line">就是获取解码后的 YUV 的相关处理步骤</span><br><span class="line"></span><br><span class="line">## <span class="number">2.8</span> 查询解码帧的状态</span><br><span class="line">通过应用程序接口<span class="built_in">cuvidGetDecoderCaps</span>()查询底层硬件视频解码器的功能。</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line"><span class="comment">/**********************************************************************************************************************/</span></span><br><span class="line"><span class="comment">//! \fn CUresult CUDAAPI cuvidGetDecoderCaps(CUVIDDECODECAPS *pdc)</span></span><br><span class="line"><span class="comment">//! Queries decode capabilities of NVDEC-HW based on CodecType, ChromaFormat and BitDepthMinus8 parameters.</span></span><br><span class="line"><span class="comment">//! 1. Application fills IN parameters CodecType, ChromaFormat and BitDepthMinus8 of CUVIDDECODECAPS structure</span></span><br><span class="line"><span class="comment">//! 2. On calling cuvidGetDecoderCaps, driver fills OUT parameters if the IN parameters are supported</span></span><br><span class="line"><span class="comment">//!    If IN parameters passed to the driver are not supported by NVDEC-HW, then all OUT params are set to 0.</span></span><br><span class="line"><span class="comment">//! E.g. on Geforce GTX 960:</span></span><br><span class="line"><span class="comment">//!   App fills - eCodecType = cudaVideoCodec_H264; eChromaFormat = cudaVideoChromaFormat_420; nBitDepthMinus8 = 0;</span></span><br><span class="line"><span class="comment">//!   Given IN parameters are supported, hence driver fills: bIsSupported = 1; nMinWidth   = 48; nMinHeight  = 16; </span></span><br><span class="line"><span class="comment">//!   nMaxWidth = 4096; nMaxHeight = 4096; nMaxMBCount = 65536;</span></span><br><span class="line"><span class="comment">//! CodedWidth*CodedHeight/256 must be less than or equal to nMaxMBCount</span></span><br><span class="line"><span class="comment">/**********************************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> CUresult CUDAAPI <span class="title">cuvidGetDecoderCaps</span><span class="params">(CUVIDDECODECAPS *pdc)</span></span>;</span><br></pre></td></tr></table></figure><p>具体调用方式可以参考2.6.2.1章节pfnSequenceCallback回调函数的设计</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CUVIDDECODECAPS decodecaps;</span><br><span class="line"><span class="built_in">memset</span>(&amp;decodecaps, <span class="number">0</span>, <span class="built_in">sizeof</span>(decodecaps));</span><br><span class="line"></span><br><span class="line">decodecaps.eCodecType = pVideoFormat-&gt;codec;</span><br><span class="line">decodecaps.eChromaFormat = pVideoFormat-&gt;chroma_format;</span><br><span class="line">decodecaps.nBitDepthMinus8 = pVideoFormat-&gt;bit_depth_luma_minus8;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPushCurrent</span>(m_cuContext)); <span class="comment">//启用context</span></span><br><span class="line"><span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidGetDecoderCaps</span>(&amp;decodecaps));</span><br><span class="line"><span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure><hr><p>此时关于硬件解码的部分我们已经基本上完成了，接下来就是如何使用OpenGL与CUDA进行交互操作了．</p><hr><h2 id="2-9-根据解码状态，使用解码后的输出进行进一步的处理-如渲染、后处理等"><a href="#2-9-根据解码状态，使用解码后的输出进行进一步的处理-如渲染、后处理等" class="headerlink" title="2.9 根据解码状态，使用解码后的输出进行进一步的处理(如渲染、后处理等)"></a>2.9 根据解码状态，使用解码后的输出进行进一步的处理(如渲染、后处理等)</h2><p>我们知道从解码器解码出来的数据格式是NV12，而我们如果想对该数据进行进一步的处理(如渲染、后处理等)的话，NV12数据无论是进行OpenGL的播放渲染还是进行相关特效处理（大部分OpenGL的filter都是对RGBA数据进行处理的）都不太适合，因此，我们拿到NV12数据后还需要进行一个步骤：将数据转换成容易处理的格式，也就是RGBA或者BGRA格式（每个像素用32比特位表示，占4个字节 ，R，G，B,A分量分别用8个bit表示）．</p><p>而如何将解码后的NV12数据转化为RGBA格式呢？</p><p>此时有两种方案:</p><ul><li>将解码后的NV12数据通过cuda的Kernel Functions转成了BGRA等格式</li><li>让OpeGL或者DX将获取到的NV12数据，通过使用特定shader实现RGB到YUV的图像格式</li></ul><p>这两者的区别就在于我们是让CUDA进行格式转换，还是通过OpenGL进行格式转换？</p><p>现在摆在我们面前的是：</p><p>我们的目的是：实现NvDec硬件解码-&gt;OpenGL渲染和filter处理-&gt;NvDec硬件编码的全流程GPU加速方案</p><p>NvDec解码后的数据是存放在GPU上的NV12数据，我们在渲染和filter功能实现上需要通过OpenGL来实现</p><p>因此我们需要OpenGL能够直接操作NvDec解码后在GPU上的地址数据，这一点就需要借助CUDA来实现，NVidia的CUDA提供了和OpenGL以及各版本DX的交互接口，这使得，通过OpenGL直接对NvDec解码后的数据进行操作成为了可能．详见NVidia相关<a href="https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__OPENGL.html">官方文档</a></p><h3 id="2-9-1-为什么要采用OpenGL与CUDA互操作的方式"><a href="#2-9-1-为什么要采用OpenGL与CUDA互操作的方式" class="headerlink" title="2.9.1 为什么要采用OpenGL与CUDA互操作的方式"></a>2.9.1 为什么要采用OpenGL与CUDA互操作的方式</h3><p>其实传统的渲染方式一般是：</p><ul><li>将硬解码得到的NV12数据拷贝回CPU内存，</li><li>然后再将NV12格式转成YUV420格式，</li><li>进而再调用OpenGL渲染。</li></ul><p>缺点：GPU到CPU的数据拷贝在时间上花销过大，NV12格式转成YUV420格式计算花销大，因此造成解码渲染耗时较大，容易出现卡顿现象。</p><p>因此我们其实是有以下两个方案：<br>方案一：</p><ul><li>使用CUDA与OpenGL互操作，无需将数据传入CPU，将硬解码取得的NV12数据直接通过CUDA的Kernel Functions转成RGBA或BGRA。</li><li>然后再利用内存映射的方法，让OpeGL直接进行渲染和相关特效处理。<br>方案二：</li><li>使用CUDA与OpenGL互操作，无需将数据传入CPU，利用内存映射的方法，将CUDA与OpenGL进行绑定</li><li>让OpeGL将获取到的NV12数据，通过使用shader进行格式转换，最后再进行渲染。</li></ul><p>这两个方案的区别在于是让CUDA的核函数进行NV12-&gt;RGB的转换，还是通过OpenGL的shader进行NV12-&gt;RGB的转换．</p><p>而如果我们采用第二种方案的话，比较麻烦的问题在于，我们需要两条OpenGL纹理(一条存放Y数据，一体存放UV数据)来跟CUDA进行互操作．这样的操作太过于麻烦，且容易出错，因此我们一般还是参考例程的代码，统一采用的是第一种方案．当然，如果你想了解一下第二种方案的实现，可以参考这篇<a href="">博客</a></p><h3 id="2-9-2-CUDA与OpenGL互操作"><a href="#2-9-2-CUDA与OpenGL互操作" class="headerlink" title="2.9.2 CUDA与OpenGL互操作"></a>2.9.2 CUDA与OpenGL互操作</h3><p>OpenGL与CUDA互操作可以分成两种方法:</p><p>方法一：<br>OpenGL将Buffer对象注册到CUDA中去，供CUDA读写操作，然后再在OpenGL中使用。一般这种情况下注册的是<font color = red>VBO和PBO</font>，VBO一般用于存储顶点坐标、索引等数据；PBO则一般用于存储图像数据，因此称作Pixel Buffer Object。</p><p>方法二：<br>OpenGL将<font color =red>Texture</font>注册到CUDA中去，经CUDA处理后得到纹理内容，然后在OpenGL中渲染出来。</p><p>二者的操作流程一致：</p><ul><li>在OpenGL里面初始化Buffer Object</li><li>在CUDA中注册OpenGL中的Buffer Object</li><li>CUDA锁定资源，获取操作资源的指针，在<font color =red>CUDA核函数</font>中进行数据处理</li><li>CUDA释放资源，在OpenGL中使用Buffer Object进行渲染和显示</li></ul><p>接下来，我们将分别讲述一下这两种方法的实现步骤</p><h4 id="2-9-2-1-方法一-VBO-VAO-："><a href="#2-9-2-1-方法一-VBO-VAO-：" class="headerlink" title="2.9.2.1 方法一(VBO+VAO)："></a>2.9.2.1 方法一(VBO+VAO)：</h4><h5 id="2-9-2-1-1-VBO-VAO基础概念介绍"><a href="#2-9-2-1-1-VBO-VAO基础概念介绍" class="headerlink" title="2.9.2.1.1 VBO+VAO基础概念介绍"></a>2.9.2.1.1 VBO+VAO基础概念介绍</h5><p>VBO:顶点缓冲对象VBO<font color =red>是在显卡存储空间中开辟出的一块内存缓存区，用于存储顶点的各类属性信息，如顶点坐标，顶点法向量，顶点颜色数据等</font>。在渲染时，可以直接从VBO中取出顶点的各类属性数据，由于VBO在显存而不是在内存中，不需要从CPU传输数据，处理效率更高。<br>所以可以理解为VBO就是显存中的一个存储区域，可以保持大量的顶点属性信息。并且可以开辟很多个VBO，每个VBO在OpenGL中有它的唯一标识ID，这个ID对应着具体的VBO的显存地址，通过这个ID可以对特定的VBO内的数据进行存取操作。</p><p>VAO:是一个保存了所有顶点数据属性的状态结合，它存储了顶点数据的格式以及顶点数据所需的VBO对象的引用。<br>VAO本身并没有存储顶点的相关属性数据，这些信息是存储在VBO中的，<font color =red>VAO相当于是对很多个VBO的引用，把一些VBO组合在一起作为一个对象统一管理</font>。</p><p>EBO:索引缓冲对象EBO相当于OpenGL中的顶点数组的概念，，<font color =red>是为了解决同一个顶点多次重复调用的问题</font>，可以减少内存空间浪费，提高执行效率。当需要使用重复的顶点时，通过顶点的位置索引来调用顶点，而不是对重复的顶点信息重复记录，重复调用。<font color =red>EBO中存储的内容就是顶点位置的索引indices，EBO跟VBO类似，也是在显存中的一块内存缓冲器，只不过EBO保存的是顶点的索引</font>。</p><p>综上所述：<br>VBO存放的是顶点信息（坐标，颜色，法向量．．．．）；VAO是对多个VBO的管理器，也就是相当于VBO的集合，EBO也就是VBO中顶点信息中的坐标的索引集合</p><p>我们用C++语言来表达就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    Coordinates xyz;</span><br><span class="line">    Color color;</span><br><span class="line">    NormalVectors normal_vectors;</span><br><span class="line">    .....</span><br><span class="line">&#125;VBO;</span><br><span class="line">VBO* pVAO =<span class="keyword">new</span> VBO[n]();</span><br><span class="line">Coordinates* pEBO = nwe Coordinates[n]();</span><br></pre></td></tr></table></figure><p>例程AppDecGL中对NV12转BGRA的CUDA操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Launch cuda kernels for colorspace conversion from raw video to raw image formats which OpenGL textures can work with</span></span><br><span class="line"><span class="keyword">if</span> (dec.<span class="built_in">GetBitDepth</span>() == <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dec.<span class="built_in">GetOutputFormat</span>() == cudaVideoSurfaceFormat_YUV444)</span><br><span class="line">        <span class="built_in">YUV444ToColor32</span>&lt;BGRA32&gt;(pFrame, dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// default assumed NV12</span></span><br><span class="line">        <span class="built_in">Nv12ToColor32</span>&lt;BGRA32&gt;(pFrame, dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dec.<span class="built_in">GetOutputFormat</span>() == cudaVideoSurfaceFormat_YUV444)</span><br><span class="line">        <span class="built_in">YUV444P16ToColor32</span>&lt;BGRA32&gt;(pFrame, <span class="number">2</span> * dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// default assumed P016</span></span><br><span class="line">        <span class="built_in">P016ToColor32</span>&lt;BGRA32&gt;(pFrame, <span class="number">2</span> * dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-9-2-1-2-代码实现（为了提高效率，同时操作两个VBO数据）"><a href="#2-9-2-1-2-代码实现（为了提高效率，同时操作两个VBO数据）" class="headerlink" title="2.9.2.1.2 代码实现（为了提高效率，同时操作两个VBO数据）"></a>2.9.2.1.2 代码实现（为了提高效率，同时操作两个VBO数据）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化Buffer Object</span></span><br><span class="line"><span class="comment">//vertex array object</span></span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;VAO);</span><br><span class="line"><span class="comment">//Create vertex buffer object</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">2</span>, <span class="keyword">this</span>-&gt;VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create Element Buffer Objects</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;EBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bind the Vertex Array Object first, then bind and set vertex buffer(s) and attribute pointer(s).</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="keyword">this</span>-&gt;VAO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定VBO后即在CUDA中注册Buffer Object</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="keyword">this</span>-&gt;VBO[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(*<span class="keyword">this</span>-&gt;malla)*<span class="keyword">this</span>-&gt;numPoints, <span class="keyword">this</span>-&gt;malla, GL_DYNAMIC_COPY);</span><br><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>(&amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>], <span class="keyword">this</span>-&gt;VBO[<span class="number">0</span>], cudaGraphicsRegisterFlagsNone);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="keyword">this</span>-&gt;VBO[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(*<span class="keyword">this</span>-&gt;malla)*<span class="keyword">this</span>-&gt;numPoints, <span class="keyword">this</span>-&gt;malla, GL_DYNAMIC_COPY);</span><br><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>(&amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">1</span>], <span class="keyword">this</span>-&gt;VBO[<span class="number">1</span>], cudaGraphicsRegisterFlagsNone);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在CUDA中映射资源，锁定资源</span></span><br><span class="line"><span class="built_in">cudaGraphicsMapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cudaGraphicsMapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">point *devicePoints1;</span><br><span class="line">point *devicePoints2;</span><br><span class="line"><span class="type">size_t</span> size = <span class="built_in">sizeof</span>(*<span class="keyword">this</span>-&gt;malla)*<span class="keyword">this</span>-&gt;numPoints;</span><br><span class="line"><span class="comment">// 获取操作资源的指针，以便在CUDA核函数中使用</span></span><br><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>((<span class="type">void</span> **)&amp;devicePoints1, &amp;size, <span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">cudaGraphicsResourceGetMappedPointer</span>((<span class="type">void</span> **)&amp;devicePoints2, &amp;size, <span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行CUDA的内核操作Nv12-&gt;BGRA操作．这边请参考例程</span></span><br><span class="line"><span class="built_in">Nv12ToColor32</span>&lt;BGRA32&gt;(pFrame, dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理完了即可解除资源锁定，OpenGL可以开始利用处理结果了。</span></span><br><span class="line"><span class="comment">// 注意在CUDA处理过程中，OpenGL如果访问这些锁定的资源会出错。</span></span><br><span class="line"><span class="built_in">cudaGraphicsUnmapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cudaGraphicsUnmapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">1</span>], <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>值得注意的是，由于这里绑定的是VBO，属于Buffer对象，因此调用的CUDA API是这两个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>();</span><br><span class="line"><span class="built_in">cudaGraphicsResourceGetMappedPointer</span>();</span><br></pre></td></tr></table></figure><h4 id="2-9-2-2-方法二-texture-："><a href="#2-9-2-2-方法二-texture-：" class="headerlink" title="2.9.2.2 方法二(texture)："></a>2.9.2.2 方法二(texture)：</h4><h5 id="2-9-2-2-2-代码实现（为了提高效率，同时操作两个Texture数据）"><a href="#2-9-2-2-2-代码实现（为了提高效率，同时操作两个Texture数据）" class="headerlink" title="2.9.2.2.2 代码实现（为了提高效率，同时操作两个Texture数据）"></a>2.9.2.2.2 代码实现（为了提高效率，同时操作两个Texture数据）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化两个Texture并绑定</span></span><br><span class="line">cudaGraphicsResource_t cudaResources[<span class="number">2</span>];</span><br><span class="line">GLuint textureID[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">glEnable</span>(GL_TEXTURE_2D);</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">2</span>, textureID);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在CUDA中注册这两个Texture</span></span><br><span class="line">cudaError_t err = <span class="built_in">cudaGraphicsGLRegisterImage</span>(&amp;cudaResources[<span class="number">0</span>], textureID[<span class="number">0</span>], GL_TEXTURE_2D, cudaGraphicsRegisterFlagsWriteDiscard);</span><br><span class="line"><span class="keyword">if</span> (err != cudaSuccess)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;cudaGraphicsGLRegisterImage: &quot;</span> &lt;&lt; err &lt;&lt; <span class="string">&quot;Line: &quot;</span> &lt;&lt; __LINE__;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">err = <span class="built_in">cudaGraphicsGLRegisterImage</span>(&amp;cudaResources[<span class="number">1</span>], textureID[<span class="number">1</span>], GL_TEXTURE_2D, cudaGraphicsRegisterFlagsWriteDiscard);</span><br><span class="line"><span class="keyword">if</span> (err != cudaSuccess)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;cudaGraphicsGLRegisterImage: &quot;</span> &lt;&lt; err &lt;&lt; <span class="string">&quot;Line: &quot;</span> &lt;&lt; __LINE__;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在CUDA中锁定资源，获得操作Texture的指针，这里是CudaArray*类型</span></span><br><span class="line">cudaError_t err = <span class="built_in">cudaGraphicsMapResources</span>(<span class="number">2</span>, cudaResource, <span class="number">0</span>);</span><br><span class="line">err = <span class="built_in">cudaGraphicsSubResourceGetMappedArray</span>(&amp;<span class="keyword">this</span>-&gt;cuArrayL, cudaResource[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">err = <span class="built_in">cudaGraphicsSubResourceGetMappedArray</span>(&amp;<span class="keyword">this</span>-&gt;cuArrayR, cudaResource[<span class="number">1</span>], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据拷贝至CudaArray。这里因为得到的是CudaArray，处理时不方便操作，于是先在设备内存中</span></span><br><span class="line"><span class="comment">// 分配缓冲区处理，处理完后再把结果存到CudaArray中，仅仅是GPU内存中的操作。</span></span><br><span class="line"><span class="built_in">cudaMemcpyToArray</span>(cuArrayL, <span class="number">0</span>, <span class="number">0</span>, pHostDataL, imgWidth*imgHeight * <span class="built_in">sizeof</span>(uchar4), cudaMemcpyDeviceToDevice);</span><br><span class="line"><span class="built_in">cudaMemcpyToArray</span>(cuArrayR, <span class="number">0</span>, <span class="number">0</span>, pHostDataR, imgWidth*imgHeight * <span class="built_in">sizeof</span>(uchar4), cudaMemcpyDeviceToDevice);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行CUDA的内核操作Nv12-&gt;BGRA操作．这边请参考例程</span></span><br><span class="line"><span class="built_in">Nv12ToColor32</span>&lt;BGRA32&gt;(pFrame, dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理完后即解除资源锁定，OpenGL可以利用得到的Texture对象进行纹理贴图操作了。</span></span><br><span class="line"><span class="built_in">cudaGraphicsUnmapResources</span>(<span class="number">1</span>, &amp;cudaResource[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cudaGraphicsUnmapResources</span>(<span class="number">1</span>, &amp;cudaResource[<span class="number">1</span>], <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>注意这里因为使用的是Texture对象，因此使用了不同的API：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cudaGraphicsGLRegisterImage</span>();</span><br><span class="line"><span class="built_in">cudaGraphicsSubResourceGetMappedArray</span>();</span><br></pre></td></tr></table></figure><p>由于NvDec解码出来的是Nv12数据，也就是一个个像素数据，因此显然我们是没办法采用VBO+VAO方式的，所以也只有第二种方法适合我们，</p><p>但是，我们查看例程会发现，NVidia提供的例程压根就没采用这两种方式，而是采用了PBO进行映射！！！</p><p>因此我们这里引入pbo概念：PBO一般用于存储图像数据，因此称作Pixel Buffer Object</p><p>而我们的例程中用到的也是这种方案（PBO＋Texture），其本质就是将NvDec解码后的数据的地址与PBO进行绑定，这样我们就能通过PBO来跟CUDA进行互操作，等到NvDec解码后的数据通过CUDA的的Kernel Functions转成了BGRA等格式后，我们再从PBO将数据读到纹理上，之后我们就可以通过对纹理id进行操作，来实现各种特效处理和渲染操作啦！</p><p>至于为啥我们不直接通过OpenGL的纹理和CUDA进行交互的原因就是PBO可以通过 DMA (Direct Memory Access) 快速地在显卡上传递像素数据，而不影响CPU的时钟周期（中断）。同时它还具备异步 DMA 传输的优势。说到底就是这样干效率会高一点！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在OpenGL中分配和图像相同大小的pbo和texture</span></span><br><span class="line">GLuint pbo[<span class="number">2</span>];</span><br><span class="line">GLuint textureID[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//双pbo模式</span></span><br><span class="line"><span class="built_in">glGenBuffersARB</span>(<span class="number">2</span>, pbo);</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">2</span>, textureID);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个pbo存放第一个texture</span></span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, pbo[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">glBufferDataARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, nTexWidth*nTexHeight*<span class="number">4</span>, <span class="literal">NULL</span>, GL_STREAM_DRAW_ARB);</span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA8, width, height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>(&amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>], <span class="keyword">this</span>-&gt;pbo[<span class="number">0</span>], cudaGraphicsRegisterFlagsNone);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个pbo存放第二个texture</span></span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, pbo[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">glBufferDataARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, nTexWidth*nTexHeight*<span class="number">4</span>, <span class="literal">NULL</span>, GL_STREAM_DRAW_ARB);</span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA8, width, height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>(&amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>], <span class="keyword">this</span>-&gt;pbo[<span class="number">1</span>], cudaGraphicsRegisterFlagsNone);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在CUDA中映射资源，锁定资源</span></span><br><span class="line"><span class="built_in">cudaGraphicsMapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cudaGraphicsMapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">point *devicePoints1;</span><br><span class="line">point *devicePoints2;</span><br><span class="line"><span class="type">size_t</span> size = <span class="built_in">sizeof</span>(*<span class="keyword">this</span>-&gt;malla)*<span class="keyword">this</span>-&gt;numPoints;</span><br><span class="line"><span class="comment">// 获取操作资源的指针，以便在CUDA核函数中使用</span></span><br><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>((<span class="type">void</span> **)&amp;devicePoints1, &amp;size, <span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">cudaGraphicsResourceGetMappedPointer</span>((<span class="type">void</span> **)&amp;devicePoints2, &amp;size, <span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行CUDA的内核操作Nv12-&gt;BGRA操作．这边请参考例程</span></span><br><span class="line"><span class="built_in">Nv12ToColor32</span>&lt;BGRA32&gt;(pFrame, dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理完了即可解除资源锁定，OpenGL可以开始利用处理结果了。</span></span><br><span class="line"><span class="comment">// 注意在CUDA处理过程中，OpenGL如果访问这些锁定的资源会出错。</span></span><br><span class="line"><span class="built_in">cudaGraphicsUnmapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cudaGraphicsUnmapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从OpenGL在CUDA映射的PBO中将数据读取到对应的OpenGL纹理上</span></span><br><span class="line"><span class="comment">// load texture from pbo</span></span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, pbo[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_TYPE, textureID[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">glTexSubImage2D</span>(GL_TEXTURE_TYPE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, width, height, GL_BGRA, GL_UNSIGNED_BYTE, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_TYPE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, pbo[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_TYPE, textureID[<span class="number">1</span>]));</span><br><span class="line"><span class="built_in">glTexSubImage2D</span>(GL_TEXTURE_TYPE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, width, height, GL_BGRA, GL_UNSIGNED_BYTE, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_TYPE, <span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>值得注意的是，由于这里绑定的是PBO，属于Buffer对象，而不是Texture对象（可以理解成用PBO对Texture对象进行了封装），因此调用的CUDA API是这两个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>();</span><br><span class="line"><span class="built_in">cudaGraphicsResourceGetMappedPointer</span>();</span><br></pre></td></tr></table></figure><p>在上述的代码中都有一段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行CUDA的内核操作Nv12-&gt;BGRA操作．这边请参考例程</span></span><br><span class="line"><span class="built_in">Nv12ToColor32</span>&lt;BGRA32&gt;(pFrame, dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br></pre></td></tr></table></figure><p>其实这段就是CUDA的内核的操作，通过启动 cuda 内核，用于从原始视频到 OpenGL 纹理可以使用的原始图像格式的色彩空间转换，而因为我这里有NV12ToARGB_drvapi.cu文件，因此我也可以通过执行这个文件的NV12ToARGB_drvapi函数来进行CUDA的内核操作（CUDA kernel for outputing the final ARGB output from NV12）；<br>当然你也可以像Nvidia给的例程中一样，通过NvCodecUtils.h这个文件的Nv12ToColor32接口来进行CUDA的内核操作，从而实现NV12-&gt;RGB32的转换．这个本质上是一样的，没啥区别．</p><p>当然为了我们后面进行OpenGL的渲染和特效处理，从上面的代码可以看出，我们在进行从OpenGL在CUDA映射的PBO中将数据读取到对应的OpenGL纹理上时，我们调用的glTexSubImage2D函数的第七个参数不是GL_RGBA而是GL_BGRA，知道为啥这样吗？<br>因为我们一开始创建纹理在调用glTexImage2D的时候，用的是GL_RGBA参数，而我们进行的CUDA的内核的操作是将Nv12转成了BGRA数据，也就是说现在我们PBO中存放的数据是BGRA排列的数据，而我们一般是习惯用RGBA数据来进行OpenGL操作的，所以如果我们调用glTexSubImage2D函数进行PBO到Texture的操作时，我们还是采用的GL_RGBA参数的话，那么此时Texture上的数据就是BGRA排列的数据了，但是我们如果偷偷的将glTexSubImage2D第七个参数从GL_RGBA改成GL_BGRA的话，那么B和R的数据将会被OpenGL自动进行调换，此时，我们OpenGL的Texture上对应的数据排列就是RGBARGBA了，这操作是不是很秀！</p><h1 id="３-中间渲染和filter链路的构建的具体流程步骤"><a href="#３-中间渲染和filter链路的构建的具体流程步骤" class="headerlink" title="３ 中间渲染和filter链路的构建的具体流程步骤"></a>３ 中间渲染和filter链路的构建的具体流程步骤</h1><h2 id="3-1-OpenGL的屏幕绘制和filter链路的构建"><a href="#3-1-OpenGL的屏幕绘制和filter链路的构建" class="headerlink" title="3.1 OpenGL的屏幕绘制和filter链路的构建"></a>3.1 OpenGL的屏幕绘制和filter链路的构建</h2><h2 id="3-2-OpenGL的filter链路的构建"><a href="#3-2-OpenGL的filter链路的构建" class="headerlink" title="3.2 OpenGL的filter链路的构建"></a>3.2 OpenGL的filter链路的构建</h2><h1 id="4-具体编码流程步骤"><a href="#4-具体编码流程步骤" class="headerlink" title="4 具体编码流程步骤"></a>4 具体编码流程步骤</h1><p>首先我们根据Nvidia官方的<a href="https://docs.nvidia.com/video-technologies/video-codec-sdk/nvenc-video-encoder-api-prog-guide/">NVENC API</a>指南进行学习．</p><p>通过上面的文档我们可以知道NVENC将YUV&#x2F;RGB作为输入并生成符合H.264&#x2F;HEVC&#x2F;AV1标准的视频比特流。<br>而我们则是要通过使用 NVIDIA Video Codec SDK 中提供的 NVENCODE API来实现硬件编码功能．<br>NVENCODE API 函数、结构和其他参数被公开在NVIDIA Video Codec SDK 中提供的nvEncodeAPI.h中，因此我们在进行编码操作时，就需要将该文件include进去，同时还需要加载对应的动态库（Windows上调用的是nvEncodeAPI.dll；linux上调用的是libnvidia-encode.so）．头文件和动态库导入的大致流程如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nvEncodeAPI.h&quot;</span></span></span><br><span class="line">...... </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line"><span class="type">static</span> <span class="type">wchar_t</span> __NVEncodeLibName32[] = <span class="string">L&quot;nvEncodeAPI.dll&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">wchar_t</span> __NVEncodeLibName64[] = <span class="string">L&quot;nvEncodeAPI64.dll&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined __linux__</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> __NVEncodeLibName[] = <span class="string">&quot;libnvidia-encode.so&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">...... </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> BOOL <span class="title">Is64Bit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">sizeof</span>(<span class="type">void</span> *)!=<span class="built_in">sizeof</span>(DWORD));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...... </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Is64Bit</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        m_hinstLib = <span class="built_in">LoadLibrary</span>(__NVEncodeLibName64);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_hinstLib = <span class="built_in">LoadLibrary</span>(__NVEncodeLibName32);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    m_hinstLib = <span class="built_in">dlopen</span>(__NVEncodeLibName, RTLD_LAZY);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>其硬件编码流程，具体过程如下所示：</p><ul><li>初始化编码器</li><li>设置所需的编码参数</li><li>分配输入&#x2F;输出缓冲区</li><li>将帧复制到输入缓冲区并从输出缓冲区读取比特流。这可以同步（Windows 和 Linux）或异步（仅限 Windows 7 及更高版本）完成。</li><li>清理&#x2F;释放所有分配的输入&#x2F;输出缓冲区</li><li>关闭编码会话</li></ul><h2 id="4-1-初始化编码器"><a href="#4-1-初始化编码器" class="headerlink" title="4.1 初始化编码器"></a>4.1 初始化编码器</h2><p>接下来的讲解，我们将基于在<a href="https://community.adobe.com/t5/adobe-media-encoder-discussions/nvidia-gpu-accelerated-h264-encoder-plugin-ready-for-public-testing/td-p/5213367">Adobe Support Community</a>网站上一位名叫Guest的作者在2013年提供的<a href="https://github.com/jetkiwi/NVENC_export">NVENC_export</a>作为参考来进行适当修改，来实现我们的功能．</p><p>当我们加载完nvEncodeAPI对应的库文件后，第一步就是调用NvEncodeAPICreateInstance．这个接口会将动态库中的函数加载到对应的函数指针中，这样我们在后续的操作中才能调用NVENCODE中的其他API接口．</p><p>具体的参考代码在NVENC_export&#x2F;Samples&#x2F;nvEncode2&#x2F;src文件夹中的CNVEncoder.cpp文件中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    NVENCSTATUS nvStatus;</span><br><span class="line">    MYPROC nvEncodeAPICreateInstance; <span class="comment">// function pointer to create instance in nvEncodeAPI</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Is64Bit</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        m_hinstLib = <span class="built_in">LoadLibrary</span>(<span class="built_in">TEXT</span>(__NVEncodeLibName64));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_hinstLib = <span class="built_in">LoadLibrary</span>(<span class="built_in">TEXT</span>(__NVEncodeLibName32));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    m_hinstLib = <span class="built_in">dlopen</span>(__NVEncodeLibName, RTLD_LAZY);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_hinstLib != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line">        nvEncodeAPICreateInstance = (MYPROC) <span class="built_in">GetProcAddress</span>(m_hinstLib, <span class="string">&quot;NvEncodeAPICreateInstance&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        nvEncodeAPICreateInstance = (MYPROC) <span class="built_in">dlsym</span>(m_hinstLib, <span class="string">&quot;NvEncodeAPICreateInstance&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != nvEncodeAPICreateInstance) </span><br><span class="line">        &#123;</span><br><span class="line">            m_pEncodeAPI = <span class="keyword">new</span> NV_ENCODE_API_FUNCTION_LIST;</span><br><span class="line">            <span class="keyword">if</span> (m_pEncodeAPI)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(m_pEncodeAPI, <span class="number">0</span>, <span class="built_in">sizeof</span>(NV_ENCODE_API_FUNCTION_LIST));</span><br><span class="line">                m_pEncodeAPI-&gt;version = NV_ENCODE_API_FUNCTION_LIST_VER;</span><br><span class="line">                nvStatus = <span class="built_in">nvEncodeAPICreateInstance</span>(m_pEncodeAPI);</span><br><span class="line">                m_bEncodeAPIFound = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_bEncodeAPIFound = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">PRINTERR</span>((<span class="string">&quot;CNvEncoder::CNvEncoder() failed to find NvEncodeAPICreateInstance&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在上面代码中，我们拿到m_pEncodeAPI后(也就是执行完nvStatus &#x3D; nvEncodeAPICreateInstance(m_pEncodeAPI)语句后)，为了确保拿到的m_pEncodeAPI可以调用到我们后续需要的nvEncodeAPI接口，其实我们可以在加个if语句进行判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!m_pEncodeAPI-&gt;nvEncCreateBitstreamBuffer || !m_pEncodeAPI-&gt;nvEncOpenEncodeSession || !m_pEncodeAPI-&gt;nvEncGetEncodeGUIDCount || !m_pEncodeAPI-&gt;nvEncGetEncodeProfileGUIDCount ||</span><br><span class="line">!m_pEncodeAPI-&gt;nvEncGetEncodeProfileGUIDs || !m_pEncodeAPI-&gt;nvEncGetEncodeGUIDs || !m_pEncodeAPI-&gt;nvEncGetInputFormatCount || !m_pEncodeAPI-&gt;nvEncGetInputFormats ||</span><br><span class="line">!m_pEncodeAPI-&gt;nvEncGetEncodeCaps || !m_pEncodeAPI-&gt;nvEncGetEncodePresetCount || !m_pEncodeAPI-&gt;nvEncGetEncodePresetGUIDs || !m_pEncodeAPI-&gt;nvEncGetEncodePresetConfig ||</span><br><span class="line">!m_pEncodeAPI-&gt;nvEncInitializeEncoder || !m_pEncodeAPI-&gt;nvEncCreateInputBuffer || !m_pEncodeAPI-&gt;nvEncDestroyInputBuffer || !m_pEncodeAPI-&gt;nvEncCreateBitstreamBuffer ||</span><br><span class="line">!m_pEncodeAPI-&gt;nvEncDestroyBitstreamBuffer || !m_pEncodeAPI-&gt;nvEncEncodePicture || !m_pEncodeAPI-&gt;nvEncLockBitstream || !m_pEncodeAPI-&gt;nvEncUnlockBitstream ||</span><br><span class="line">!m_pEncodeAPI-&gt;nvEncLockInputBuffer || !m_pEncodeAPI-&gt;nvEncUnlockInputBuffer || !m_pEncodeAPI-&gt;nvEncGetEncodeStats || !m_pEncodeAPI-&gt;nvEncGetSequenceParams ||</span><br><span class="line">!m_pEncodeAPI-&gt;nvEncRegisterAsyncEvent || !m_pEncodeAPI-&gt;nvEncUnregisterAsyncEvent || !m_pEncodeAPI-&gt;nvEncMapInputResource || !m_pEncodeAPI-&gt;nvEncUnmapInputResource ||</span><br><span class="line">!m_pEncodeAPI-&gt;nvEncDestroyEncoder || !m_pEncodeAPI-&gt;nvEncInvalidateRefFrames || !m_pEncodeAPI-&gt;nvEncOpenEncodeSessionEx || !m_pEncodeAPI-&gt;nvEncRegisterResource ||</span><br><span class="line">!m_pEncodeAPI-&gt;nvEncUnregisterResource || !m_pEncodeAPI-&gt;nvEncReconfigureEncoder)</span><br><span class="line">                        &#123;</span><br><span class="line">                            m_bEncodeAPIFound = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            m_bEncodeAPIFound = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure><p>此时，如果m_bEncodeAPIFound为true就代表着我们已经成功的加载了我们后续需要的所有nvEncodeAPI接口（｡♥‿♥｡）</p><h2 id="4-2-设置所需的编码参数"><a href="#4-2-设置所需的编码参数" class="headerlink" title="4.2 设置所需的编码参数"></a>4.2 设置所需的编码参数</h2><p>至此，我们已经成功完成了编码器的初始化，接下来就需要对编码器的参数进行设置了．<br>具体步骤如下：</p><ul><li>获取编码会话句柄</li><li>选择编码器GUID</li><li>获取编码器信息</li><li>选择编码器预设配置</li><li>选择编码器配置文件</li><li>获取支持的输入格式列表</li></ul><h3 id="4-2-1-获取编码会话句柄"><a href="#4-2-1-获取编码会话句柄" class="headerlink" title="4.2.1 获取编码会话句柄"></a>4.2.1 获取编码会话句柄</h3><p>当我们成功加载 NVENC 接口后，还必须要调用NvEncOpenEncodeSessionEx打开编码会话。此函数返回一个编码会话句柄，该句柄必须用于当前会话中对 API 函数的所有后续调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NVENCSTATUS</span> <span class="params">(NVENCAPI* PNVENCOPENENCODESESSIONEX)</span>       <span class="params">(NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS *openSessionExParams, </span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">PNVENCOPENENCODESESSIONEX       nvEncOpenEncodeSessionEx;    </span></span></span><br></pre></td></tr></table></figure><p>在NVENC_export&#x2F;Samples&#x2F;nvEncode2&#x2F;src文件夹中的CNVEncoder.cpp文件中的CNvEncoder::OpenEncodeSession函数中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">    HRESULT hr = S_OK;</span><br><span class="line">    <span class="comment">//NVENCSTATUS nvStatus = NV_ENC_SUCCESS;</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;m_stEncoderInput, &amp;encodeConfig, <span class="built_in">sizeof</span>(m_stEncoderInput));</span><br><span class="line">    m_fOutput = m_stEncoderInput.fOutput;</span><br><span class="line">    <span class="type">bool</span> bCodecFound = <span class="literal">false</span>;</span><br><span class="line">    NV_ENC_CAPS_PARAM stCapsParam = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS stEncodeSessionParams = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uArraysize = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">SET_VER</span>(stCapsParam, NV_ENC_CAPS_PARAM);</span><br><span class="line">    <span class="built_in">SET_VER</span>(stEncodeSessionParams, NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If another NVENC session is already open, close it (to avoid mem-leak)</span></span><br><span class="line"><span class="built_in">DestroyEncodeSession</span>();</span><br><span class="line"></span><br><span class="line">nvStatus = NV_ENC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (m_stEncoderInput.interfaceType)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line">        <span class="keyword">case</span> NV_ENC_DX9:</span><br><span class="line">            <span class="built_in">InitD3D9</span>(deviceID);</span><br><span class="line">            stEncodeSessionParams.device = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(m_pD3D9Device);</span><br><span class="line">            stEncodeSessionParams.deviceType = NV_ENC_DEVICE_TYPE_DIRECTX;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> NV_ENC_DX10:</span><br><span class="line">            <span class="built_in">InitD3D10</span>(deviceID);</span><br><span class="line">            stEncodeSessionParams.device = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(m_pD3D10Device);</span><br><span class="line">            stEncodeSessionParams.deviceType = NV_ENC_DEVICE_TYPE_DIRECTX;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> NV_ENC_DX11:</span><br><span class="line">            <span class="built_in">InitD3D11</span>(deviceID);</span><br><span class="line">            stEncodeSessionParams.device = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(m_pD3D11Device);</span><br><span class="line">            stEncodeSessionParams.deviceType = NV_ENC_DEVICE_TYPE_DIRECTX;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">case</span> NV_ENC_CUDA:</span><br><span class="line"><span class="keyword">if</span> ( !m_useExternalContext )</span><br><span class="line"><span class="built_in">InitCuda</span>(deviceID);</span><br><span class="line">            stEncodeSessionParams.device = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(m_cuContext);</span><br><span class="line">            stEncodeSessionParams.deviceType = NV_ENC_DEVICE_TYPE_CUDA;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">assert</span>(<span class="string">&quot;Encoder interface not supported&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="comment">// switch</span></span><br><span class="line"></span><br><span class="line">    nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncOpenEncodeSessionEx</span>( &amp;stEncodeSessionParams, &amp;m_hEncoder);</span><br><span class="line">    <span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">my_printf</span>(<span class="string">&quot;nvEncOpenEncodeSessionEx() returned with error %d\n&quot;</span>, nvStatus);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Note: GUID key may be invalid or incorrect.  Recommend to upgrade your drivers and obtain a new key\n&quot;</span>);</span><br><span class="line">        <span class="comment">//checkNVENCErrors(nvStatus);// prevent NVNEC-plugin from exiting prematurely</span></span><br><span class="line"><span class="keyword">return</span> E_FAIL;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以从上面的代码看出，由于Guest的作者在2013年提供的<a href="https://github.com/jetkiwi/NVENC_export">NVENC_export</a>只适用于Win端，因此在上面的switch判断中，我们还需要加上一段针对Linux端的判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line">        <span class="keyword">case</span> NV_ENC_OPENGL:</span><br><span class="line">            <span class="comment">//NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS::device must be NULL if type is NV_ENC_OPENGL</span></span><br><span class="line">            stEncodeSessionParams.device = <span class="literal">nullptr</span>;</span><br><span class="line">            stEncodeSessionParams.deviceType = NV_ENC_DEVICE_TYPE_OPENGL;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>对应的将修改成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_NvEncodeInterfaceType</span></span><br><span class="line">&#123;</span><br><span class="line">    NV_ENC_DX9=<span class="number">0</span>,</span><br><span class="line">    NV_ENC_DX11=<span class="number">1</span>,</span><br><span class="line">    NV_ENC_CUDA=<span class="number">2</span>, <span class="comment">// On Linux, CUDA is the only NVENC interface available</span></span><br><span class="line">    NV_ENC_DX10=<span class="number">3</span>,</span><br><span class="line">    NV_ENC_OPENGL=<span class="number">4</span>,</span><br><span class="line">&#125; NvEncodeInterfaceType;</span><br></pre></td></tr></table></figure><p>至于为什么将device参数设置为nullptr，其实在官方提供的<a href="https://docs.nvidia.com/video-technologies/video-codec-sdk/nvenc-video-encoder-api-prog-guide/">文档</a>里面是有说明的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">OpenGL</span><br><span class="line">    The client should create an OpenGL context and make it current (in order to associate the context with the thread/process that is making calls to NVENCODE API) to the thread calling into NVENCODE API. NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS::device must be NULL and NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS::deviceType must be set to NV_ENC_DEVICE_TYPE_OPENGL. Use of the OpenGL device type for encoding is supported only on Linux.</span><br><span class="line">```   </span><br><span class="line">### 4.2.2 选择编码器GUID</span><br><span class="line">大致的设置流程分为以下几个部分：</span><br><span class="line">- 调用NvEncGetEncodeGUIDCount从 NVIDIA 视频编码器接口获取支持的编码器 GUID 的数量。</span><br><span class="line">- 使用获取到的支持的编码器 GUID 的数量结果来分配一个足够大的缓冲区，来容纳支持的编码器 GUID</span><br><span class="line">- 调用NvEncGetEncodeGUIDs填充此列表。</span><br><span class="line"></span><br><span class="line">PS:一般来说调用nvEncGetEncodeGUIDCount接口后，m_dwEncodeGUIDCount返回的值应该为2，也就是支持H264和HEVC这两种编码方式，如果返回的值不是2，那就需要你自己去查一下你的显卡到底咋回事了；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">// Enumerate the codec support by the HW Encoder</span><br><span class="line">    nvStatus = m_pEncodeAPI-&gt;nvEncGetEncodeGUIDCount(m_hEncoder, &amp;m_dwEncodeGUIDCount);</span><br><span class="line">    if (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        my_printf(&quot;nvEncGetEncodeGUIDCount() returned with error %d\n&quot;, nvStatus);</span><br><span class="line">        checkNVENCErrors(nvStatus);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">delete_array( m_stEncodeGUIDArray );</span><br><span class="line">        m_stEncodeGUIDArray       = new GUID[m_dwEncodeGUIDCount];</span><br><span class="line">        memset(m_stEncodeGUIDArray, 0, sizeof(GUID) * m_dwEncodeGUIDCount);</span><br><span class="line">        uArraysize = 0;</span><br><span class="line">        nvStatus = m_pEncodeAPI-&gt;nvEncGetEncodeGUIDs(m_hEncoder, m_stEncodeGUIDArray, m_dwEncodeGUIDCount, &amp;uArraysize);</span><br><span class="line">        assert(uArraysize &lt;= m_dwEncodeGUIDCount);</span><br><span class="line">        if (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            my_printf(&quot;nvEncGetEncodeGUIDs() returned with error %d\n&quot;, nvStatus);</span><br><span class="line">            checkNVENCErrors(nvStatus);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            for (unsigned int i = 0; i &lt; uArraysize; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                // check if HW encoder supports the particular codec -</span><br><span class="line">                if (GetCodecType(m_stEncodeGUIDArray[i]) == (unsigned int)m_stEncoderInput.codec)</span><br><span class="line">                &#123;</span><br><span class="line">// Found the desired codec GUID - store it as &quot;m_stEncodeGUID&quot;</span><br><span class="line">                    bCodecFound = true;</span><br><span class="line">                    memcpy(&amp;m_stEncodeGUID, &amp;m_stEncodeGUIDArray[i], sizeof(GUID));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    if (bCodecFound == false)</span><br><span class="line">    &#123;</span><br><span class="line">// Hardware doesn&#x27;t support our requested codec-type &lt;m_stEncoderInput.codec&gt;</span><br><span class="line">        assert(0);</span><br><span class="line">        return E_FAIL;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-3-获取编码器信息"><a href="#4-2-3-获取编码器信息" class="headerlink" title="4.2.3 获取编码器信息"></a>4.2.3 获取编码器信息</h3><p>NVIDIA 编码器接口公开了四种不同的调整信息枚举（高质量、低延迟、超低延迟和无损）来满足不同的视频编码应用场景<br>对于每个调整信息，提供了从 P1（最高性能）到 P7（最低性能）的七个预设来控制性能&#x2F;质量权衡。使用这些预设将自动为所选调谐信息设置所有相关编码参数。这是 API 公开的粗略控制级别。如果需要，可以调整预设中的特定属性&#x2F;参数。</p><p>获取编码器信息和预设配置的大致的设置流程分为以下几个部分：</p><ul><li>调用NvEncGetEncodePresetCount获取支持的编码器 GUID 的数量。</li><li>使用这个计数来分配一个足够大的缓冲区来保存支持的预设GUID。</li><li>调用NvEncGetEncodePresetGUIDs填充此列表。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetPresetConfig():</span></span><br><span class="line"><span class="comment">//    Gets the requested NVENC preset and stores it in this.m_stPresetConfig </span></span><br><span class="line"><span class="comment">//    Note, if requested preset is &#x27;default&#x27; (0), then allow any preset to be returned.</span></span><br><span class="line"><span class="comment">//    (This is a workaround for Geforce WHQL driver 314.21, where nvEncGetEncodePresetGUIDs returns</span></span><br><span class="line"><span class="comment">//    DEFAULT_GUID as a supported preset, but nvEncGetEncodePresetConfig returns ERROR for the</span></span><br><span class="line"><span class="comment">//    same DEFAULT_GUID.)</span></span><br><span class="line"><span class="function">HRESULT <span class="title">CNvEncoder::GetPresetConfig</span><span class="params">(<span class="type">const</span> <span class="type">int</span> iPresetIdx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NVENCSTATUS nvStatus = NV_ENC_SUCCESS;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uPresetCount2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncGetEncodePresetCount</span>(m_hEncoder, m_stEncodeGUID, &amp;m_dwCodecPresetGUIDCount);</span><br><span class="line">    <span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line"><span class="keyword">return</span> E_FAIL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete_array</span>(m_stCodecPresetGUIDArray);</span><br><span class="line">    m_stCodecPresetGUIDArray = <span class="keyword">new</span> GUID[m_dwCodecPresetGUIDCount];</span><br><span class="line">    nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncGetEncodePresetGUIDs</span>(m_hEncoder, m_stEncodeGUID, m_stCodecPresetGUIDArray, m_dwCodecPresetGUIDCount, &amp;uPresetCount2);</span><br><span class="line">    <span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line"><span class="keyword">return</span> E_FAIL;</span><br><span class="line"></span><br><span class="line">nvStatus = NV_ENC_ERR_GENERIC;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; m_dwCodecPresetGUIDCount; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// hack: if ( iPresetIdx == 0 &quot;default&quot;), then return the first valid preset.</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">int</span>)i == iPresetIdx || (iPresetIdx == <span class="number">0</span>) )</span><br><span class="line">&#123;</span><br><span class="line">nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncGetEncodePresetConfig</span>(m_hEncoder, m_stEncodeGUID, m_stCodecPresetGUIDArray[i], &amp;m_stPresetConfig);</span><br><span class="line"><span class="keyword">if</span> (nvStatus == NV_ENC_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">m_stPresetIdx  = iPresetIdx;</span><br><span class="line">m_stPresetGUID = m_stCodecPresetGUIDArray[m_stPresetIdx];</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( iPresetIdx != <span class="number">0</span> )</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nvStatus == NV_ENC_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> E_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-4-选择编码器预设配置"><a href="#4-2-4-选择编码器预设配置" class="headerlink" title="4.2.4 选择编码器预设配置"></a>4.2.4 选择编码器预设配置</h3><p>以下是获取预设编码配置并可选择更改选择配置参数的步骤：</p><ul><li>调用NvEncGetEncodePresetConfigEx与选定的 encodeGUID，调整信息和预设GUID作为输入</li><li>可以通过以下方式检索所需的预设编码器配置 NV_ENC_PRESET_CONFIG::presetCfg.</li><li>如果需要，使用相应的配置 API 覆盖默认编码器参数。</li></ul><p>这个可以不选择设置，直接采用默认的就行了，正常来说默认参数就够用了．</p><h3 id="4-2-5-选择编码器配置文件"><a href="#4-2-5-选择编码器配置文件" class="headerlink" title="4.2.5 选择编码器配置文件"></a>4.2.5 选择编码器配置文件</h3><p>大致的设置流程分为以下几个部分：</p><ul><li>调用NvEncGetEncodeProfileGUIDCount从 NVIDIA 视频编码器接口获取支持的编码器 GUID 的数量。</li><li>使用此计数来分配足够大小的缓冲区以容纳支持的编码配置文件 GUID。</li><li>调用NvEncGetEncodeProfileGUIDs填充此列表。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Enumerate the profile(s) available for selected codec &lt;m_stEncodeGUID&gt;</span></span><br><span class="line">  nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncGetEncodeProfileGUIDCount</span>(m_hEncoder, m_stEncodeGUID, &amp;m_dwCodecProfileGUIDCount);</span><br><span class="line">  <span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">my_printf</span>( <span class="string">&quot;nvEncGetEncodeProfileGUIDCount() returned with error %d\n&quot;</span>, nvStatus);</span><br><span class="line">      <span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">delete_array</span>( m_stCodecProfileGUIDArray );</span><br><span class="line">      m_stCodecProfileGUIDArray = <span class="keyword">new</span> GUID[m_dwCodecProfileGUIDCount];</span><br><span class="line">      <span class="built_in">memset</span>(m_stCodecProfileGUIDArray, <span class="number">0</span>, <span class="built_in">sizeof</span>(GUID) * m_dwCodecProfileGUIDCount);</span><br><span class="line">      uArraysize = <span class="number">0</span>;</span><br><span class="line">      nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncGetEncodeProfileGUIDs</span>(m_hEncoder,  m_stEncodeGUID, m_stCodecProfileGUIDArray, m_dwCodecProfileGUIDCount, &amp;uArraysize);</span><br><span class="line">      <span class="built_in">assert</span>(uArraysize &lt;= m_dwCodecProfileGUIDCount);</span><br><span class="line">      <span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">my_printf</span>( <span class="string">&quot;nvEncGetEncodeProfileGUIDs() returned with error %d\n&quot;</span>, nvStatus);</span><br><span class="line">          <span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          bCodecFound = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; uArraysize; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">// check if this HW-codec supports the requested profile &lt;m_stEncoderInput.profile&gt;</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">GetCodecProfile</span>(m_stCodecProfileGUIDArray[i]) == m_stEncoderInput.profile)</span><br><span class="line">              &#123;</span><br><span class="line"><span class="comment">// Found the desired Profile - store it as &quot;m_stCodecProfileGUID&quot;</span></span><br><span class="line">                  bCodecFound = <span class="literal">true</span>;</span><br><span class="line">                  <span class="built_in">memcpy</span>(&amp;m_stCodecProfileGUID, &amp;m_stCodecProfileGUIDArray[i], <span class="built_in">sizeof</span>(GUID));</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bCodecFound == <span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="comment">// Codec doesn&#x27;t support our requested profile &lt;m_stEncoderInput.profile&gt;</span></span><br><span class="line">      <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> E_FAIL;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-2-6-获取支持的输入格式列表"><a href="#4-2-6-获取支持的输入格式列表" class="headerlink" title="4.2.6 获取支持的输入格式列表"></a>4.2.6 获取支持的输入格式列表</h3><p>NVENCODE API 接受几种不同格式的输入帧，例如特定格式的 YUV 和 RGB。</p><p>可以按如下方式检索支持的输入格式列表：</p><ul><li>调用NvEncGetInputFormatCount获取支持的输入格式的数量。</li><li>使用这个计数来分配一个缓冲区来保存支持的输入缓冲区格式列表（它们是类型的列表元素NV_ENC_BUFFER_FORMAT).</li><li>通过调用NvEncGetInputFormats检索支持的输入缓冲区格式.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// Enumerate the (framebuffer) InputFormats available for selected codec &lt;m_stEncodeGUID&gt;</span></span><br><span class="line">   nvStatus =  m_pEncodeAPI-&gt;<span class="built_in">nvEncGetInputFormatCount</span>(m_hEncoder, m_stEncodeGUID, &amp;m_dwInputFmtCount);</span><br><span class="line">   <span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">my_printf</span>(<span class="string">&quot;nvEncGetInputFormatCount() returned with error %d\n&quot;</span>, nvStatus);</span><br><span class="line">       <span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">delete_array</span>( m_pAvailableSurfaceFmts );</span><br><span class="line">       m_pAvailableSurfaceFmts = <span class="keyword">new</span> NV_ENC_BUFFER_FORMAT[m_dwInputFmtCount];</span><br><span class="line">       <span class="built_in">memset</span>(m_pAvailableSurfaceFmts, <span class="number">0</span>, <span class="built_in">sizeof</span>(NV_ENC_BUFFER_FORMAT) * m_dwInputFmtCount);</span><br><span class="line">       nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncGetInputFormats</span>(m_hEncoder, m_stEncodeGUID, m_pAvailableSurfaceFmts, m_dwInputFmtCount, &amp;uArraysize);</span><br><span class="line">       <span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">my_printf</span>(<span class="string">&quot;nvEncGetInputFormats() returned with error %d\n&quot;</span>, nvStatus);</span><br><span class="line">           <span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>  &#123;</span><br><span class="line">           <span class="type">bool</span> bFmtFound = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> bFound_420 = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> bFound_444 = <span class="literal">false</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> idx;</span><br><span class="line">           <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; m_dwInputFmtCount; idx++)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// check if this HW-codec supports the requested (framebuffer) InputFormat </span></span><br><span class="line">               bFound_420 = encodeConfig.chromaFormatIDC == cudaVideoChromaFormat_420 &amp;&amp;</span><br><span class="line">(m_pAvailableSurfaceFmts[idx] == NV_ENC_BUFFER_FORMAT_NV12);</span><br><span class="line"></span><br><span class="line">bFound_444 = encodeConfig.chromaFormatIDC == cudaVideoChromaFormat_444 &amp;&amp;</span><br><span class="line">     ## <span class="number">4.3</span> 分配输入/输出缓冲区                  (m_pAvailableSurfaceFmts[idx] == NV_ENC_BUFFER_FORMAT_YUV444);</span><br><span class="line"><span class="keyword">if</span> ( bFound_420 || bFound_444 )</span><br><span class="line">&#123;</span><br><span class="line">            m_dwInputFormat = m_pAvailableSurfaceFmts[idx];</span><br><span class="line">bFmtFound = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="keyword">if</span> ( !bFmtFound ) &#123;</span><br><span class="line"><span class="built_in">my_printf</span>(<span class="string">&quot;ERROR, Unable to locate a compatible chromaformatIDC\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">           <span class="built_in">assert</span>(bFmtFound == <span class="literal">true</span>);</span><br><span class="line">           <span class="built_in">assert</span>(uArraysize &lt;= m_dwInputFmtCount);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (encodeConfig.preset &gt; <span class="number">-1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       hr = <span class="built_in">GetPresetConfig</span>(encodeConfig.preset);</span><br><span class="line">       <span class="keyword">if</span> (hr == S_OK)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">memcpy</span>(&amp;m_stEncodeConfig, &amp;m_stPresetConfig.presetCfg, <span class="built_in">sizeof</span>(NV_ENC_CONFIG));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if this HW-codec supports the requested (framebuffer) InputFormat </span></span><br><span class="line"><span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (Premiere Pro only): setup which optimizations the format-repacker </span></span><br><span class="line"><span class="comment">//                      is allowed to use</span></span><br><span class="line">m_Repackyuv.<span class="built_in">set_cpu_allow_avx</span>(m_stEncoderInput.CPU_enableAVX);</span><br><span class="line">m_Repackyuv.<span class="built_in">set_cpu_allow_avx2</span>(m_stEncoderInput.CPU_enableAVX2);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-2-7-初始化硬件编码器会话"><a href="#4-2-7-初始化硬件编码器会话" class="headerlink" title="4.2.7 初始化硬件编码器会话"></a>4.2.7 初始化硬件编码器会话</h3><p>大致的设置流程分为以下几个部分：</p><ul><li>编码会话属性的配置</li><li>初始化硬件编码器会话</li></ul><h4 id="4-2-7-1-编码会话属性的配置"><a href="#4-2-7-1-编码会话属性的配置" class="headerlink" title="4.2.7.1 编码会话属性的配置"></a>4.2.7.1 编码会话属性的配置</h4><p>编码会话参数配置分为三部分：</p><ul><li>基本的编码会话参数</li><li>高级编码器级参数</li></ul><h5 id="4-2-7-1-1-基本的编码会话参数"><a href="#4-2-7-1-1-基本的编码会话参数" class="headerlink" title="4.2.7.1.1 基本的编码会话参数"></a>4.2.7.1.1 基本的编码会话参数</h5><p>输入格式、输出尺寸、显示纵横比、帧率、平均码率等常用参数在NV_ENC_INITIALIZE_PARAMS结构体。用户应使用此结构的实例作为输入 NvEnc初始化编码器.</p><p>必须填充以下成员 NV_ENC_INITIALIZE_PARAMS成功初始化编码会话的结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NV_ENC_INITALIZE_PARAMS::encodeGUID：必须选择合适的编解码器 GUID，如选择编码器GUID部分所述。</span><br><span class="line">NV_ENC_INITIALIZE_PARAMS::编码宽度：必须指定编码视频的所需宽度。</span><br><span class="line">NV_ENC_INITIALIZE_PARAMS::encodeHeight：必须指定编码视频的所需高度。</span><br><span class="line">NV_ENC_INITALIZE_PARAMS::reportSliceOffsets：可用于启用切片偏移的报告。此功能需要NV_ENC_INITALIZE_PARAMS::enableEncodeAsync设置为<span class="number">0</span>，并且不适用于Kepler GPU上基于MB和基于字节的切片。</span><br></pre></td></tr></table></figure><h5 id="4-2-7-1-2-高级编解码器级参数"><a href="#4-2-7-1-2-高级编解码器级参数" class="headerlink" title="4.2.7.1.2 高级编解码器级参数"></a>4.2.7.1.2 高级编解码器级参数</h5><p>参数NV_ENC_INITIALIZE_PARAMS::NV_ENC_CONFIG encodeConfig：处理编码比特流的参数，如 GOP 长度、编码器配置文件、速率控制模式等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_NV_ENC_CONFIG</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span>                        version;           </span><br><span class="line">    GUID                            profileGUID;       </span><br><span class="line">    <span class="type">uint32_t</span>                        gopLength;         </span><br><span class="line">    <span class="type">int32_t</span>                         frameIntervalP;    </span><br><span class="line">    <span class="type">uint32_t</span>                        monoChromeEncoding;</span><br><span class="line">    NV_ENC_PARAMS_FRAME_FIELD_MODE  frameFieldMode;    </span><br><span class="line">                                                                                                              </span><br><span class="line">    NV_ENC_MV_PRECISION             mvPrecision;       </span><br><span class="line">    NV_ENC_RC_PARAMS                rcParams;          </span><br><span class="line">    NV_ENC_CODEC_CONFIG             encodeCodecConfig; </span><br><span class="line">    <span class="type">uint32_t</span>                        reserved [<span class="number">278</span>];    </span><br><span class="line">    <span class="type">void</span>*                           reserved2[<span class="number">64</span>];     </span><br><span class="line">&#125; NV_ENC_CONFIG;</span><br></pre></td></tr></table></figure><p>结构中提供高级 H.264、HEVC 和 AV1 特定参数 NV_ENC_CONFIG_H264,NV_ENC_CONFIG_HEVC和NV_ENC_CONFIG_AV1分别。用户可以通过该结构传递特定于编解码器的参数 NV_ENC_CONFIG::encodeCodecConfig.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \struct _NV_ENC_CODEC_CONFIG</span></span><br><span class="line"><span class="comment"> * Codec-specific encoder configuration parameters to be set during initialization.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">_NV_ENC_CODEC_CONFIG</span></span><br><span class="line">&#123;</span><br><span class="line">    NV_ENC_CONFIG_H264        h264Config;                <span class="comment">/**&lt; [in]: Specifies the H.264-specific encoder configuration. */</span></span><br><span class="line">    NV_ENC_CONFIG_HEVC        hevcConfig;                <span class="comment">/**&lt; [in]: Specifies the HEVC-specific encoder configuration. */</span></span><br><span class="line">    NV_ENC_CONFIG_H264_MEONLY h264MeOnlyConfig;          <span class="comment">/**&lt; [in]: Specifies the H.264-specific ME only encoder configuration. */</span></span><br><span class="line">    NV_ENC_CONFIG_HEVC_MEONLY hevcMeOnlyConfig;          <span class="comment">/**&lt; [in]: Specifies the HEVC-specific ME only encoder configuration. */</span></span><br><span class="line">    <span class="type">uint32_t</span>                reserved[<span class="number">320</span>];               <span class="comment">/**&lt; [in]: Reserved and must be set to 0 */</span></span><br><span class="line">&#125; NV_ENC_CODEC_CONFIG;</span><br></pre></td></tr></table></figure><p>具体的参考代码在NVENC_export&#x2F;Samples&#x2F;nvEncode2&#x2F;src文件夹中的CNvEncoderH264.cpp文件中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">HRESULT <span class="title">CNvEncoderH264::InitializeEncoderCodec</span><span class="params">(<span class="type">void</span> * <span class="type">const</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NV_ENC_CONFIG_H264_VUI_PARAMETERS *pvui;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> x264_sei_uuid[<span class="number">16</span>] = <span class="comment">// X264&#x27;s unregistered_user SEI</span></span><br><span class="line">&#123;   <span class="comment">// random ID number generated according to ISO-11578</span></span><br><span class="line"><span class="number">0xdc</span>, <span class="number">0x45</span>, <span class="number">0xe9</span>, <span class="number">0xbd</span>, <span class="number">0xe6</span>, <span class="number">0xd9</span>, <span class="number">0x48</span>, <span class="number">0xb7</span>,</span><br><span class="line"><span class="number">0x96</span>, <span class="number">0x2c</span>, <span class="number">0xd8</span>, <span class="number">0x20</span>, <span class="number">0xd9</span>, <span class="number">0x23</span>, <span class="number">0xee</span>, <span class="number">0xef</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    HRESULT hr           = S_OK;</span><br><span class="line">    <span class="type">int</span> numFrames        = <span class="number">0</span>;</span><br><span class="line">    NVENCSTATUS nvStatus = NV_ENC_SUCCESS;</span><br><span class="line">    <span class="type">bool</span> bMVCEncoding    = m_stEncoderInput.profile == NV_ENC_H264_PROFILE_STEREO ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    m_bAsyncModeEncoding = ((m_stEncoderInput.syncMode==<span class="number">0</span>) ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">string            s; <span class="comment">// text-buffer</span></span><br><span class="line">ostringstream   oss; <span class="comment">// text-buffer to generate encoder-settings</span></span><br><span class="line"></span><br><span class="line">    m_uMaxHeight         = m_stEncoderInput.maxHeight;</span><br><span class="line">    m_uMaxWidth          = m_stEncoderInput.maxWidth;</span><br><span class="line">    m_dwFrameWidth       = m_stEncoderInput.width;</span><br><span class="line">    m_dwFrameHeight      = m_stEncoderInput.height;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;m_stInitEncParams, <span class="number">0</span>, <span class="built_in">sizeof</span>(NV_ENC_INITIALIZE_PARAMS));</span><br><span class="line">    <span class="built_in">SET_VER</span>(m_stInitEncParams, NV_ENC_INITIALIZE_PARAMS);</span><br><span class="line">    m_stInitEncParams.encodeConfig = &amp;m_stEncodeConfig;</span><br><span class="line">    <span class="built_in">SET_VER</span>(m_stEncodeConfig, NV_ENC_CONFIG);</span><br><span class="line"></span><br><span class="line">pvui = <span class="built_in">reinterpret_cast</span>&lt;NV_ENC_CONFIG_H264_VUI_PARAMETERS *&gt;(p);</span><br><span class="line"></span><br><span class="line">    m_stInitEncParams.darHeight           = m_stEncoderInput.darRatioY;</span><br><span class="line">    m_stInitEncParams.darWidth            = m_stEncoderInput.darRatioX;</span><br><span class="line"><span class="comment">//    m_stInitEncParams.encodeHeight        = m_uMaxHeight;</span></span><br><span class="line"><span class="comment">//    m_stInitEncParams.encodeWidth         = m_uMaxWidth;</span></span><br><span class="line">    m_stInitEncParams.encodeHeight        = m_dwFrameHeight;</span><br><span class="line">    m_stInitEncParams.encodeWidth         = m_dwFrameWidth;</span><br><span class="line">    </span><br><span class="line">    m_uCurHeight                          = m_stInitEncParams.encodeHeight;</span><br><span class="line">    m_uCurWidth                           = m_stInitEncParams.encodeWidth;</span><br><span class="line">    </span><br><span class="line">    m_stInitEncParams.maxEncodeHeight     = m_uMaxHeight;</span><br><span class="line">    m_stInitEncParams.maxEncodeWidth      = m_uMaxWidth;</span><br><span class="line"></span><br><span class="line">    m_stInitEncParams.frameRateNum        = m_stEncoderInput.frameRateNum;</span><br><span class="line">    m_stInitEncParams.frameRateDen        = m_stEncoderInput.frameRateDen;</span><br><span class="line">    <span class="comment">//Fix me add theading model</span></span><br><span class="line">    m_stInitEncParams.enableEncodeAsync   = m_bAsyncModeEncoding;</span><br><span class="line">    m_stInitEncParams.enablePTD           = !m_stEncoderInput.disable_ptd;</span><br><span class="line">    m_stInitEncParams.reportSliceOffsets  = m_stEncoderInput.report_slice_offsets;</span><br><span class="line">    m_stInitEncParams.enableSubFrameWrite = m_stEncoderInput.enableSubFrameWrite;</span><br><span class="line">    m_stInitEncParams.encodeGUID          = m_stEncodeGUID;</span><br><span class="line">    m_stInitEncParams.presetGUID          = m_stPresetGUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user_SEI: (1) Create 16-byte UUID header (this is x264&#x27;s uuid)</span></span><br><span class="line"><span class="keyword">for</span>( <span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(x264_sei_uuid)/<span class="built_in">sizeof</span>(x264_sei_uuid[<span class="number">0</span>]); ++i ) </span><br><span class="line">oss &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(x264_sei_uuid[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// user_SEI: (2) start putting NVENC&#x27;s encoder-settings</span></span><br><span class="line">    CUresult        cuResult = CUDA_SUCCESS;</span><br><span class="line">    CUdevice        cuDevice = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>            gpu_name[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">checkCudaErrors</span>(<span class="built_in">cuDeviceGet</span>(&amp;cuDevice, m_deviceID));</span><br><span class="line"><span class="built_in">checkCudaErrors</span>(<span class="built_in">cuDeviceGetName</span>(gpu_name, <span class="number">100</span>, cuDevice));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the Geforce driver-version using NVAPI -</span></span><br><span class="line"><span class="comment">//   NVENC functionality is a hardware+firmware implementation, so it is important</span></span><br><span class="line"><span class="comment">//   to report both the GPU-hardware and the Geforce driver revision.</span></span><br><span class="line">NvU32             NVidia_DriverVersion;</span><br><span class="line">NvAPI_ShortString szBuildBranchString;</span><br><span class="line">NvAPI_Status      nvs = <span class="built_in">NvAPI_SYS_GetDriverAndBranchVersion</span>( &amp;NVidia_DriverVersion, szBuildBranchString);</span><br><span class="line"></span><br><span class="line"><span class="comment">//oss &lt;&lt; &quot;x264 - core 141 - H.264/MPEG-4 AVC codec - Copyleft 2003-2012 - &quot; &lt;&lt; __DATE__ &quot;&#125;, NVENC API &quot; &lt;&lt; std::dec &lt;&lt; NVENCAPI_MAJOR_VERSION</span></span><br><span class="line">oss &lt;&lt; <span class="string">&quot;CNvEncoderH264[&quot;</span> &lt;&lt; __DATE__  &lt;&lt; <span class="string">&quot;, NVENC API &quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; NVENCAPI_MAJOR_VERSION &lt;&lt; <span class="string">&quot;.&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; NVENCAPI_MINOR_VERSION &lt;&lt; <span class="string">&quot;]&quot;</span></span><br><span class="line">&lt;&lt; gpu_name;</span><br><span class="line"><span class="keyword">if</span> ( nvs == NVAPI_OK )</span><br><span class="line">oss &lt;&lt; <span class="string">&quot; (driver &quot;</span> &lt;&lt; szBuildBranchString &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; std::dec </span><br><span class="line">&lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span>&gt;(NVidia_DriverVersion)  &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">oss &lt;&lt; <span class="string">&quot; (driver ???)&quot;</span>; <span class="comment">// unknown driver version</span></span><br><span class="line">oss&lt;&lt; <span class="string">&quot; - options: &quot;</span>;</span><br><span class="line"></span><br><span class="line">oss &lt;&lt; <span class="string">&quot; / PROFILE=&quot;</span> &lt;&lt; std::dec &lt;&lt; m_stEncoderInput.profile;</span><br><span class="line"><span class="comment">// NVENC PRESET - print the index-value instead of the actual GUID (which isn&#x27;t really informative)</span></span><br><span class="line">desc_nv_enc_preset_names.<span class="built_in">value2string</span>(m_stPresetIdx, s);</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;,PRESET=&quot;</span> &lt;&lt; std::dec &lt;&lt; m_stPresetIdx;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;)&quot;</span>; <span class="comment">// show ascii-name of the preset</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//速率控制</span></span><br><span class="line">    <span class="keyword">if</span> (m_stEncoderInput.disableCodecCfg == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;profileGUID                  = m_stCodecProfileGUID;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.averageBitRate      = m_stEncoderInput.avgBitRate;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.maxBitRate          = m_stEncoderInput.peakBitRate;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.constQP.qpIntra     = m_stEncoderInput.qpI;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.constQP.qpInterP    = m_stEncoderInput.qpP;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.constQP.qpInterB    = m_stEncoderInput.qpB;</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;rcParams.enableMinQP       = m_stEncoderInput.min_qp_ena;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.minQP.qpIntra     = m_stEncoderInput.min_qpI;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.minQP.qpInterP    = m_stEncoderInput.min_qpP;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.minQP.qpInterB    = m_stEncoderInput.min_qpB;</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;rcParams.enableMaxQP       = m_stEncoderInput.max_qp_ena;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.maxQP.qpIntra     = m_stEncoderInput.max_qpI;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.maxQP.qpInterP    = m_stEncoderInput.max_qpP;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.maxQP.qpInterB    = m_stEncoderInput.max_qpB;</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;rcParams.enableInitialRCQP    = m_stEncoderInput.initial_qp_ena;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.initialRCQP.qpIntra  = m_stEncoderInput.initial_qpI;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.initialRCQP.qpInterP = m_stEncoderInput.initial_qpP;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.initialRCQP.qpInterB = m_stEncoderInput.initial_qpB;</span><br><span class="line"></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.rateControlMode     = (NV_ENC_PARAMS_RC_MODE)m_stEncoderInput.rateControl;</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;rcParams.vbvBufferSize       =  m_stEncoderInput.vbvBufferSize;</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;rcParams.vbvInitialDelay     =  m_stEncoderInput.vbvInitialDelay;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// user_SEI: (3) more NVENC&#x27;s encoder-settings</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">oss 创建保存输入/输出数据所需的资源&lt;&lt; <span class="string">&quot; / rateMode=&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>( m_stInitEncParams.encodeConfig-&gt;rcParams.rateControlMode ) &#123;</span><br><span class="line"><span class="keyword">case</span> NV_ENC_PARAMS_RC_CONSTQP:        <span class="comment">/**&lt; Constant QP mode */</span></span><br><span class="line">oss &lt;&lt; <span class="string">&quot;CONSTQP(I:P:B)=&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.qpI &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.qpP &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.qpB;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> NV_ENC_PARAMS_RC_VBR:            <span class="comment">/**&lt; Variable bitrate mode */</span></span><br><span class="line">oss &lt;&lt; <span class="string">&quot;VBR(avg:max)=&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.avgBitRate &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.peakBitRate;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> NV_ENC_PARAMS_RC_CBR:            <span class="comment">/**&lt; Constant bitrate mode */</span></span><br><span class="line">oss &lt;&lt; <span class="string">&quot;CBR(avg)=&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.avgBitRate;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> NV_ENC_PARAMS_RC_VBR_MINQP:      <span class="comment">/**&lt; Variable bitrate mode with MinQP */</span></span><br><span class="line"><span class="comment">// ASSUME min_qp_ena is set!</span></span><br><span class="line">oss &lt;&lt; <span class="string">&quot;VBR_MINQP(avg:max)=&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.avgBitRate &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.peakBitRate;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> NV_ENC_PARAMS_RC_2_PASS_QUALITY: <span class="comment">/**&lt; Multi pass CBR encoding optimized for image quality and works only with low latency mode */</span></span><br><span class="line">oss &lt;&lt; <span class="string">&quot;2_PASS_QUALITY(avg)=&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.avgBitRate;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> NV_ENC_PARAMS_RC_2_PASS_FRAMESIZE_CAP: <span class="comment">/**&lt; Multi pass CBR encoding optimized for maintaining frame size and works only with low latency mode */</span></span><br><span class="line">oss &lt;&lt; <span class="string">&quot;2_PASS_FRAMESIZE_CAP(avg)=&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.avgBitRate;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> NV_ENC_PARAMS_RC_2_PASS_VBR: <span class="comment">/**&lt; Multi pass VBR encoding for higher quality */</span></span><br><span class="line">oss &lt;&lt; <span class="string">&quot;2_PASS_VBR(avg:max)=&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.avgBitRate &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.peakBitRate;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( m_stEncoderInput.initial_qp_ena ) &#123;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;,IniQP(I:P:B)=&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.initial_qpI &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.initial_qpP &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.initial_qpB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_stEncoderInput.min_qp_ena &amp;&amp; m_stEncoderInput.max_qp_ena) &#123;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;,Min*MaxQP(I:P:B)=&quot;</span> </span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.min_qpI &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.min_qpP &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.min_qpB &lt;&lt; <span class="string">&quot;*&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.max_qpI &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.max_qpP &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.max_qpB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_stEncoderInput.min_qp_ena) &#123;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;,MinQP(I:P:B)=&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.min_qpI &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.min_qpP &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.min_qpB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_stEncoderInput.max_qp_ena) &#123;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;,MaxQP(I:P:B)=&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.max_qpI &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.max_qpP &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.max_qpB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// report adaptive-quantization for everything, &#x27;cause I don&#x27;t know its effect</span></span><br><span class="line"><span class="keyword">if</span> (m_stInitEncParams.encodeConfig-&gt;rcParams.enableAQ )</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;,AQ&quot;</span>; <span class="comment">// adaptive quantization</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIG_RCPARAM_2_OSS2(var,name) \</span></span><br><span class="line"><span class="meta">oss <span class="string">&lt;&lt; &quot; / &quot; &lt;&lt; name &lt;&lt; &quot;=&quot; &lt;&lt; std::dec &lt;&lt; (unsigned) m_stInitEncParams.encodeConfig-&gt;</span>rcParams. ## var</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIG_RCPARAM_2_OSS( var ) ADD_ENCODECONFIG_RCPARAM_2_OSS2(var,#var) </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ADD_ENCODECONFIG_RCPARAM_2_OSS2</span>(vbvBufferSize,<span class="string">&quot;vbvBS&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIG_RCPARAM_2_OSS2</span>(vbvInitialDelay,<span class="string">&quot;vbvID&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// user_SEI: (3) more NVENC&#x27;s encoder-settings</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;frameIntervalP       = m_stEncoderInput.numBFrames + <span class="number">1</span>;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;gopLength            = (m_stEncoderInput.gopLength &gt; <span class="number">0</span>) ?  m_stEncoderInput.gopLength : <span class="number">30</span>;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;monoChromeEncoding   = m_stEncoderInput.monoChromeEncoding;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;frameFieldMode       = m_stEncoderInput.FieldEncoding ;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;mvPrecision          = m_stEncoderInput.mvPrecision;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIG_2_OSS2( var, name ) \</span></span><br><span class="line"><span class="meta">oss <span class="string">&lt;&lt; &quot; / &quot; &lt;&lt; name &lt;&lt; &quot;=&quot; &lt;&lt; std::dec &lt;&lt; (unsigned) m_stInitEncParams.encodeConfig-&gt;</span> ## var</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIG_2_OSS(var) ADD_ENCODECONFIG_2_OSS2(var,#var)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIG_2_OSS2_if_nz( var, name ) \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> ( m_stInitEncParams.encodeConfig-&gt; ## var ) \</span></span><br><span class="line"><span class="meta">oss <span class="string">&lt;&lt; &quot; / &quot; &lt;&lt; name &lt;&lt; &quot;=&quot; &lt;&lt; std::dec &lt;&lt; (unsigned) m_stInitEncParams.encodeConfig-&gt;</span> ## var</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIG_2_OSS_if_nz( var ) ADD_ENCODECONFIG_2_OSS2_if_nz(var,#var)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ADD_ENCODECONFIG_2_OSS2</span>(frameIntervalP,<span class="string">&quot;IntervalP&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( m_stEncoderInput.numBFrames )</span><br><span class="line">oss &lt;&lt; <span class="string">&quot; (BFrames=&quot;</span> &lt;&lt; std::dec &lt;&lt; m_stEncoderInput.numBFrames &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIG_2_OSS2</span>(gopLength,<span class="string">&quot;gop&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIG_2_OSS2_if_nz</span>(monoChromeEncoding,<span class="string">&quot;mono&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIG_2_OSS2</span>(frameFieldMode,<span class="string">&quot;frameMode&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIG_2_OSS2</span>(mvPrecision,<span class="string">&quot;mv&quot;</span>);</span><br><span class="line"></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.disableDeblockingFilterIDC = m_stEncoderInput.disableDeblock; <span class="comment">// alawys enable deblk filter for h264</span></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.adaptiveTransformMode      = (m_stEncoderInput.profile &gt;= NV_ENC_H264_PROFILE_HIGH) ? m_stEncoderInput.adaptive_transform_mode : NV_ENC_H264_ADAPTIVE_TRANSFORM_AUTOSELECT;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.fmoMode                    = m_stEncoderInput.enableFMO;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.bdirectMode                = m_stEncoderInput.numBFrames &gt; <span class="number">0</span> ? m_stEncoderInput.bdirectMode : NV_ENC_H264_BDIRECT_MODE_DISABLE;</span><br><span class="line"><span class="comment">//        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.bdirectMode                = m_stEncoderInput.numBFrames &gt; 0 ? NV_ENC_H264_BDIRECT_MODE_TEMPORAL : NV_ENC_H264_BDIRECT_MODE_DISABLE;</span></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.outputAUD                  = m_stEncoderInput.aud_enable;</span><br><span class="line"><span class="comment">//      m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.entropyCodingMode        = (m_stEncoderInput.profile &gt; NV_ENC_H264_PROFILE_BASELINE) ? m_stEncoderInput.vle_entropy_mode : NV_ENC_H264_ENTROPY_CODING_MODE_CAVLC;</span></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.idrPeriod                = m_stInitEncParams.encodeConfig-&gt;gopLength ;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.level                    = m_stEncoderInput.level;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.numTemporalLayers        = m_stEncoderInput.numlayers;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if (m_stEncoderInput.svcTemporal)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.enableTemporalSVC = 1;</span></span><br><span class="line"><span class="comment">            m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.h264Extension.svcTemporalConfig.basePriorityID           = 0;</span></span><br><span class="line"><span class="comment">            m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.h264Extension.svcTemporalConfig.numTemporalLayers = m_stEncoderInput.numlayers;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NVENC 4.0 API</span></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="comment">// From documentation, setting the chromaFromatIDC to 3 will select</span></span><br><span class="line"><span class="comment">// 4:4:4 chroma-format!</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Don&#x27;t need to specify &#x27;separate color planes&#x27;</span></span><br><span class="line"><span class="keyword">switch</span> (m_stEncoderInput.chromaFormatIDC) &#123;</span><br><span class="line"><span class="keyword">case</span> cudaVideoChromaFormat_444:</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.chromaFormatIDC = <span class="number">3</span>; <span class="comment">// YUV444</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// cudaVideoChromaFormat_420:</span></span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.chromaFormatIDC = <span class="number">1</span>; <span class="comment">// YUV420</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIGH264_2_OSS2(var,name) \</span></span><br><span class="line"><span class="meta">oss <span class="string">&lt;&lt; &quot; / &quot; &lt;&lt; name &lt;&lt; &quot;=&quot; &lt;&lt; std::dec &lt;&lt; (unsigned) m_stInitEncParams.encodeConfig-&gt;</span>encodeCodecConfig.h264Config. ## var</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIGH264_2_OSS( var ) ADD_ENCODECONFIGH264_2_OSS2(var,#var)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIGH264_2_OSS2_if_nz(var,name) \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> ( m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config. ## var ) \</span></span><br><span class="line"><span class="meta">oss <span class="string">&lt;&lt; &quot; / &quot; &lt;&lt; name &lt;&lt; &quot;=&quot; &lt;&lt; std::dec &lt;&lt; (unsigned) m_stInitEncParams.encodeConfig-&gt;</span>encodeCodecConfig.h264Config. ## var</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIGH264_2_OSS_if_nz(var,name) ADD_ENCODECONFIGH264_2_OSS2_if_nz(var,#var)</span></span><br><span class="line"></span><br><span class="line">desc_nv_enc_buffer_format_names.<span class="built_in">value2string</span>(</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.chromaFormatIDC, s</span><br><span class="line">);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2</span>(chromaFormatIDC,<span class="string">&quot;chroma&quot;</span>);</span><br><span class="line"><span class="comment">//oss &lt;&lt; &quot;(&quot; &lt;&lt; s &lt;&lt; &quot;)&quot;; // show ascii-name of the chromaFormatIDC</span></span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(separateColourPlaneFlag,<span class="string">&quot;sepCPF&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(disableDeblockingFilterIDC,<span class="string">&quot;disDF&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2</span>(adaptiveTransformMode,<span class="string">&quot;adaTM&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS_if_nz</span>(fmoMode,<span class="string">&quot;fmoMode&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS</span>(bdirectMode);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS_if_nz</span>(outputAUD,<span class="string">&quot;outputAUD&quot;</span>);</span><br><span class="line"><span class="comment">//ADD_ENCODECONFIGH264_2_OSS(entropyCodingMode);</span></span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS</span>(idrPeriod);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS</span>(level);</span><br><span class="line"><span class="comment">//ADD_ENCODECONFIGH264_2_OSS(numTemporalLayers);</span></span><br><span class="line"></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.outputBufferingPeriodSEI = m_stEncoderInput.output_sei_BufferPeriod;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.outputPictureTimingSEI   = m_stEncoderInput.output_sei_PictureTime;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.hierarchicalPFrames      = !! m_stEncoderInput.hierarchicalP;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.hierarchicalBFrames      = !! m_stEncoderInput.hierarchicalB;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.disableSPSPPS            = !! m_stEncoderInput.outBandSPSPPS;</span><br><span class="line"><span class="comment">//        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.outputFramePackingSEI    = m_stEncoderInput.stereo3dMode!= NV_ENC_STEREO_PACKING_MODE_NONE ? 1 : 0;</span></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.outputFramePackingSEI    = m_stEncoderInput.stereo3dEnable ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.stereoMode               = (NV_ENC_STEREO_PACKING_MODE)m_stEncoderInput.stereo3dMode;</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.enableStereoMVC          = m_stEncoderInput.stereo3dEnable;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.separateColourPlaneFlag  = m_stEncoderInput.separateColourPlaneFlag;<span class="comment">// set to 1 to enable 4:4:4 mode</span></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.entropyCodingMode        = (m_stEncoderInput.profile &gt; NV_ENC_H264_PROFILE_BASELINE) ? m_stEncoderInput.vle_entropy_mode : NV_ENC_H264_ENTROPY_CODING_MODE_CAVLC;</span><br><span class="line">        <span class="keyword">if</span> (m_stEncoderInput.max_ref_frames&gt;<span class="number">0</span>) </span><br><span class="line">             m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.maxNumRefFrames     = m_stEncoderInput.max_ref_frames;</span><br><span class="line">        <span class="keyword">if</span> ( pvui != <span class="literal">NULL</span> )</span><br><span class="line">            m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.h264VUIParameters = *pvui;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(outputBufferingPeriodSEI,<span class="string">&quot;outBPSEI&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(outputPictureTimingSEI,<span class="string">&quot;outPTSEI&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(hierarchicalPFrames,<span class="string">&quot;hierP&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(hierarchicalBFrames,<span class="string">&quot;hierB&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(disableSPSPPS,<span class="string">&quot;disSPSPPS&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(outputFramePackingSEI,<span class="string">&quot;outFPSEI&quot;</span>);</span><br><span class="line"><span class="comment">//ADD_ENCODECONFIGH264_2_OSS2_if_nz(enableStereoMVC,&quot;enableStereo&quot;);</span></span><br><span class="line"><span class="comment">//if ( m_stEncoderInput.stereo3dEnable )</span></span><br><span class="line"><span class="comment">//ADD_ENCODECONFIGH264_2_OSS2(stereoMode,&quot;stereoMode&quot;);</span></span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2</span>(entropyCodingMode,<span class="string">&quot;entCM&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2</span>(maxNumRefFrames,<span class="string">&quot;maxRef&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (m_stEncoderInput.enableLTR) &#123;</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2</span>(ltrNumFrames, <span class="string">&quot;ltrnf&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(ltrTrustMode, <span class="string">&quot;ltrtm&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.sliceMode = m_stEncoderInput.sliceMode;</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.sliceModeData = m_stEncoderInput.sliceModeData;</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2</span>(sliceMode, <span class="string">&quot;SM&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2</span>(sliceModeData, <span class="string">&quot;SMData&quot;</span>);</span><br><span class="line"></span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.enableLTR    = m_stEncoderInput.enableLTR;</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.ltrNumFrames = m_stEncoderInput.ltrNumFrames;</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.ltrTrustMode = m_stEncoderInput.ltrTrustMode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NVENC API 3</span></span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.enableVFR = m_stEncoderInput.enableVFR ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(enableVFR,<span class="string">&quot;enaVFR&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// NVENC API 4</span></span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.qpPrimeYZeroTransformBypassFlag = m_stEncoderInput.qpPrimeYZeroTransformBypassFlag;</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(qpPrimeYZeroTransformBypassFlag,<span class="string">&quot;qpPrimeYZero&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ..........</span><br></pre></td></tr></table></figure><h4 id="4-2-7-2-初始化硬件编码器会话"><a href="#4-2-7-2-初始化硬件编码器会话" class="headerlink" title="4.2.7.2 初始化硬件编码器会话"></a>4.2.7.2 初始化硬件编码器会话</h4><p>当我们完成上面的参数设置后，就可以将前面设置的NV_ENC_INITIALIZE_PARAMS作为输入参数，调用nvEncInitializeEncoder，来完成编码器的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// Initialize the Encoder</span></span><br><span class="line">   nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncInitializeEncoder</span>(m_hEncoder, &amp;m_stInitEncParams);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nvStatus == NV_ENC_SUCCESS)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (m_stEncoderInput.outBandSPSPPS &gt; <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">           <span class="built_in">SET_VER</span>(m_spspps, NV_ENC_SEQUENCE_PARAM_PAYLOAD);</span><br><span class="line">           m_spspps.spsppsBuffer = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">char</span> [<span class="number">1024</span>];</span><br><span class="line">           m_spspps.inBufferSize = <span class="number">1024</span>;</span><br><span class="line">           m_spspps.outSPSPPSPayloadSize = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">int</span>[<span class="number">1</span>];</span><br><span class="line">           nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncGetSequenceParams</span>(m_hEncoder, &amp;m_spspps);</span><br><span class="line">           <span class="built_in">assert</span>(nvStatus == NV_ENC_SUCCESS);</span><br><span class="line">           <span class="keyword">if</span> (nvStatus == NV_ENC_SUCCESS)</span><br><span class="line">           &#123;</span><br><span class="line">               (*m_fwrite_callback)(m_spspps.spsppsBuffer, <span class="number">1</span>, *m_spspps.outSPSPPSPayloadSize, m_fOutput, m_privateData);</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt; outSPSPPS PayloadSize = %d, Payload=&quot;</span>, *m_spspps.outSPSPPSPayloadSize);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(*m_spspps.outSPSPPSPayloadSize) ; i++) </span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, ((<span class="type">unsigned</span> <span class="type">char</span> *)m_spspps.spsppsBuffer)[i]);</span><br><span class="line"></span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-分配输入-x2F-输出缓冲区"><a href="#4-3-分配输入-x2F-输出缓冲区" class="headerlink" title="4.3 分配输入&#x2F;输出缓冲区"></a>4.3 分配输入&#x2F;输出缓冲区</h2><p>当我们完成初始化编码会话后，此时应该分配缓冲区来保存输入&#x2F;输出数据。</p><p>而我们由于我们是在Linux端，通过OpenGL来给NvEnc数据，因此我们此时就那不通过直接调用NvEncCreateInputBuffer应用程序接口来分配输入缓冲区了．<br>具体解释，在官方文档中也有重点提到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Creating Resources Required to Hold Input/output Data</span><br><span class="line">Once the encode session is initialized, the client should allocate buffers to hold the input/output data.</span><br><span class="line"></span><br><span class="line">The client may choose to allocate input buffers through NVIDIA Video Encoder Interface by calling NvEncCreateInputBuffer API. In this case, the client is responsible for destroying the allocated input buffers before closing the encode session. It is also the client’s responsibility to fill the input buffer with valid input data according to the chosen input buffer format.</span><br><span class="line"></span><br><span class="line">The client should allocate buffers to hold the output encoded bit stream using the NvEncCreateBitstreamBuffer API. It is the client’s responsibility to destroy these buffers before closing the encode session.</span><br><span class="line"></span><br><span class="line">Alternatively, in scenarios where the client cannot or does not want to allocate input buffers through the NVIDIA Video Encoder Interface, it can use any externally allocated DirectX resource as an input buffer. However, the client must perform some simple processing to map these resources to resource handles that are recognized by the NVIDIA Video Encoder Interface before use. The translation procedure is explained in Section Input buffers allocated externally.</span><br><span class="line"></span><br><span class="line">If the client has used a CUDA device to initialize the encoder session and wishes to use input buffers NOT allocated through the NVIDIA Video Encoder Interface, the client is required to use buffers allocated using the cuMemAlloc family of APIs. NVIDIA Video Encoder Interface supports CUdeviceptr and CUarray input formats.</span><br><span class="line"></span><br><span class="line">If the client has used the OpenGL device type to initialize the encoder session and wishes to use input buffers NOT allocated through the NVIDIA Video Encoder Interface, the client is required to provide the textures allocated earlier.</span><br><span class="line"></span><br><span class="line">The client may generate textures using glGenTextures(), bind it to either the NV_ENC_INPUT_RESOURCE_OPENGL_TEX::GL_TEXTURE_RECTANGLE or NV_ENC_INPUT_RESOURCE_OPENGL_TEX::GL_TEXTURE_2D target, allocate storage for it using glTexImage2D() and copy data to it.</span><br><span class="line"></span><br><span class="line">Note that the OpenGL interface for NVENCODE API is only supported on Linux.</span><br><span class="line"></span><br><span class="line">If the client has used a DirectX 12 device to initialize encoder session, then client must allocate input and output buffers using ID3D12Device::CreateCommittedResource() API. The client must perform some simple processing to map these input and output resources to resource handles that are recognized by the NVIDIA Video Encoder Interface before use. The translation procedure is explained in Section Input output buffer allocation for DirectX 12.</span><br><span class="line"></span><br><span class="line">Note: The client should allocate at least (1 + NB) input and output buffers, where NB is the number of B frames between successive P frames.</span><br></pre></td></tr></table></figure><h3 id="4-3-1-外部分配的输入缓冲区"><a href="#4-3-1-外部分配的输入缓冲区" class="headerlink" title="4.3.1 外部分配的输入缓冲区"></a>4.3.1 外部分配的输入缓冲区</h3><p>要将外部分配的缓冲区传递给编码器，需要执行以下步骤：</p><ul><li>填充具有外部分配缓冲区的属性的NV_ENC_REGISTER_RESOURCE。</li><li>调用NvEncRegisterResource，将上述填充好的NV_ENC_REGISTER_RESOURCE属性注册。</li><li>NvEncRegisterResource返回一个已注册的资源句柄NV_ENC_REGISTER_RESOURCE::registeredResource。</li><li>使用上述的句柄调用NvEncMapInputResource。</li><li>NV_ENC_MAP_INPUT_RESOURCE::mappedResource映射的句柄将会生效。</li><li>用户应当使用这个映射的句柄(NV_ENC_MAP_INPUT_RESOURCE::mappedResource) 作为输入缓冲句柄参数(NV_ENC_PIC_PARAMS)。</li><li>用户使用完资源后NvEncUnmapInputResource必须被调用。</li><li>在销毁注册的资源之前，用户还必须调用NvEncUnregisterResource，传入NvEncRegisterResource返回的句柄。映射的资源句柄 (NV_ENC_MAP_INPUT_RESOURCE::mappedResource) 不应在 NVIDIA 视频编码器接口处于映射状态时用于任何其他目的。这种用法不受支持，可能会导致未定义的行为。</li></ul><p>我们需要思考一个问题，外部分配的输入缓冲区要多大？这就需要看一下NvEnc支持什么格式的数据进行编码了，通过文档我们可以看出编码支持YUV和RGB格式直接编码，那么我们就可以直接将OpenGL渲染和特效处理后的RGBA数据直接进行编码啦！！！（如果你想知道NV12的数据如何编码可以参考例程，后面我写的这些代码里面的NV_ENC_BUFFER_FORMAT_NV12_TYPE走的就是NV12的编码，但是是只有一条纹理(直接把NV12存到一条上，你也可以用两条，具体参考例程吧)）</p><h3 id="4-3-1-1-NV-ENC-REGISTER-RESOURCE的填充和注册"><a href="#4-3-1-1-NV-ENC-REGISTER-RESOURCE的填充和注册" class="headerlink" title="4.3.1.1 NV_ENC_REGISTER_RESOURCE的填充和注册"></a>4.3.1.1 NV_ENC_REGISTER_RESOURCE的填充和注册</h3><p>我们可以先看下NVENC_export&#x2F;Samples&#x2F;nvEncode2&#x2F;src文件夹中的CNvEncoderH264.cpp文件中对应的这段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配 IO 缓冲区 -</span></span><br><span class="line">        <span class="comment">// 注意，这里的表面必须分配给源视频的*编码高度*和*编码宽度*，</span></span><br><span class="line">        <span class="comment">// 而不是显示高度和宽度。如果我们使用显示高度和宽度，那么色度部分</span></span><br><span class="line">        <span class="comment">// 解码帧的偏移很可能不正确（导致颜色未对齐。）</span></span><br><span class="line">        <span class="comment">// 例子：</span></span><br><span class="line">        <span class="comment">// 源视频编码宽度 x 高度 = 1920 x 1088（编码尺寸 VC1/MPEG2/MPEG4/H264）</span></span><br><span class="line">        <span class="comment">// 源视频显示尺寸 = 1920 x 1080</span></span><br><span class="line">        <span class="comment">// ...AllocateIOBuffers( 1920, 1088, ...);</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"><span class="comment">// 在隔行编码模式下，编码器将输入作为一个整体帧（即一对场）接收，</span></span><br><span class="line"><span class="comment">// 所以仍然使用全高。</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dwPicHeight = m_uMaxHeight;</span><br><span class="line"><span class="type">int</span> numMBs = ((m_dwFrameWidth + <span class="number">15</span>)/<span class="number">16</span>) * ((dwPicHeight + <span class="number">15</span>)/<span class="number">16</span>);</span><br><span class="line"><span class="type">int</span> NumIOBuffers = m_stEncoderInput.numBFrames + <span class="number">4</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AllocateIOBuffers</span>(m_uMaxWidth, dwPicHeight, NumIOBuffers);</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>在AllocateIOBuffers函数中，我们可以看到由于NVENC_export在设计之初是只为使用在Win端的，因此它整个类型判断只有NV_ENC_CUDA和NV_ENC_DX9，缺少了Linux端的代码，因此我们需要多新增一个NV_ENC_OPENGL枚举变量，并添加改类型的代码，如下所示，可以看出在NV_ENC_OPENGL类型的if语句中，我们首先使用 glGenTextures() 生成纹理，并将其绑定到NV_ENC_INPUT_RESOURCE_OPENGL_TEX::GL_TEXTURE_2D 目标，接着使用 glTexImage2D() 为其分配存储空间．</p><p>PS:这边顺便也加了一段NV_ENC_DX11的代码，如果你用到NV_ENC_DX12,NV_ENC_DX10那就参考着这个改就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">CNvEncoder::AllocateIOBuffers</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> dwInputWidth, <span class="type">unsigned</span> <span class="type">int</span> dwInputHeight, <span class="type">unsigned</span> <span class="type">int</span> maxFrmCnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_dwMaxSurfCount = maxFrmCnt;</span><br><span class="line">    NVENCSTATUS status = NV_ENC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &gt; CNvEncoder::AllocateIOBuffers() = Size (%dx%d @ %d frames)\n&quot;</span>, dwInputWidth, dwInputHeight, maxFrmCnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; m_dwMaxSurfCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        m_stInputSurface[i].dwWidth  = dwInputWidth;</span><br><span class="line">        m_stInputSurface[i].dwHeight = dwInputHeight;</span><br><span class="line">        <span class="keyword">if</span> (m_stEncoderInput.useMappedResources)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_CUDA)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; &gt; CUDA+NVENC InterOp using %d buffers.\n&quot;</span>, m_dwMaxSurfCount);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Illustrate how to use a Cuda buffer not allocated using NvEncCreateInputBuffer as input to the encoder.</span></span><br><span class="line">                <span class="built_in">cuCtxPushCurrent</span>(m_cuContext);</span><br><span class="line">                CUcontext   cuContextCurr;</span><br><span class="line">                CUdeviceptr devPtrDevice;</span><br><span class="line">                CUresult    result = CUDA_SUCCESS;                          </span><br><span class="line"></span><br><span class="line"><span class="comment">// For each buffer, allocate a host-memory space and a device-memory space.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// (1) Allocate Cuda buffer. We will use this to hold the input YUV data.</span></span><br><span class="line"><span class="type">unsigned</span> row_count;</span><br><span class="line"><span class="keyword">if</span> ( m_stEncoderInput.chromaFormatIDC == cudaVideoChromaFormat_420 ) &#123;</span><br><span class="line">m_stInputSurface[i].bufferFmt = NV_ENC_BUFFER_FORMAT_NV12;</span><br><span class="line">row_count = dwInputHeight*<span class="number">3</span>/<span class="number">2</span>; <span class="comment">// enough rows for NV12 frame</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// YUV 4:4:4</span></span><br><span class="line">m_stInputSurface[i].bufferFmt = NV_ENC_BUFFER_FORMAT_YUV444;</span><br><span class="line">row_count = dwInputHeight*<span class="number">3</span>; <span class="comment">// enough rows for YUV444 frame</span></span><br><span class="line">&#125;</span><br><span class="line">                result = <span class="built_in">cuMemAllocPitch</span>(&amp;devPtrDevice, (<span class="type">size_t</span> *)&amp;m_stInputSurface[i].dwCuPitch, dwInputWidth, row_count, <span class="number">16</span>);</span><br><span class="line">                m_stInputSurface[i].pExtAlloc      = (<span class="type">void</span>*)devPtrDevice;</span><br><span class="line"><span class="built_in">cuMemsetD8</span>( devPtrDevice, <span class="number">128</span>, m_stInputSurface[i].dwCuPitch*row_count);<span class="comment">// clear the memory</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// (2) Allocate Cuda buffer in host memory. We will use this to load data onto the Cuda buffer we want to use as input.</span></span><br><span class="line">                result = <span class="built_in">cuMemAllocHost</span>((<span class="type">void</span>**)&amp;m_stInputSurface[i].pExtAllocHost, m_stInputSurface[i].dwCuPitch*row_count);</span><br><span class="line"></span><br><span class="line">                m_stInputSurface[i].type           = NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR;</span><br><span class="line"><span class="built_in">memset</span>( (<span class="type">void</span> *)m_stInputSurface[i].pExtAllocHost, <span class="number">128</span>, m_stInputSurface[i].dwCuPitch*row_count);<span class="comment">// clear the memory</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">cuCtxPopCurrent</span>(&amp;cuContextCurr);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(NV_WINDOWS)</span></span><br><span class="line">            <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_DX9)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; &gt; DirectX+NVENC InterOp using %d buffers.\n&quot;</span>, m_dwMaxSurfCount);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Illustrate how to use an externally allocated IDirect3DSurface9* as input to the encoder.</span></span><br><span class="line">                IDirect3DSurface9 *pSurf = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> dwFormat = <span class="built_in">MAKE_FOURCC</span>(<span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>);;</span><br><span class="line">                HRESULT hr = S_OK;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">IsNV12Format</span>(m_dwInputFormat))</span><br><span class="line">                &#123;</span><br><span class="line">                    dwFormat = <span class="built_in">MAKE_FOURCC</span>(<span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">IsYV12Format</span>(m_dwInputFormat))</span><br><span class="line">                &#123;</span><br><span class="line">                    dwFormat = <span class="built_in">MAKE_FOURCC</span>(<span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                hr = m_pD3D9Device-&gt;<span class="built_in">CreateOffscreenPlainSurface</span>(dwInputWidth, dwInputHeight, (D3DFORMAT)dwFormat, D3DPOOL_DEFAULT, (IDirect3DSurface9 **)&amp;m_stInputSurface[i].pExtAlloc, <span class="literal">NULL</span>);</span><br><span class="line">                m_stInputSurface[i].bufferFmt      = NV_ENC_BUFFER_FORMAT_NV12;</span><br><span class="line">                m_stInputSurface[i].type           = NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_DX11)</span><br><span class="line">&#123;</span><br><span class="line">ID3D11Texture2D *pInputTextures = <span class="literal">NULL</span>;</span><br><span class="line">D3D11_TEXTURE2D_DESC desc;</span><br><span class="line"><span class="built_in">ZeroMemory</span>(&amp;desc, <span class="built_in">sizeof</span>(D3D11_TEXTURE2D_DESC));</span><br><span class="line">desc.Width = m_stEncoderInput.width;</span><br><span class="line">desc.Height = m_stEncoderInput.height;</span><br><span class="line">desc.MipLevels = <span class="number">1</span>;</span><br><span class="line">desc.ArraySize = <span class="number">1</span>;</span><br><span class="line">desc.Format = <span class="built_in">DXGI_FORMAT</span>(<span class="number">103</span>);</span><br><span class="line">desc.SainputFramesmpleDesc.Count = <span class="number">1</span>;</span><br><span class="line">desc.Usage = D3D11_USAGE_DEFAULT;</span><br><span class="line">desc.BindFlags = D3D11_BIND_RENDER_TARGET;</span><br><span class="line">desc.CPUAccessFlags = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (m_pD3D11Device-&gt;<span class="built_in">CreateTexture2D</span>(&amp;desc, <span class="literal">NULL</span>, &amp;pInputTextures) != S_OK)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">m_stInputSurface[i].pExtAlloc = (<span class="type">void</span> *)pInputTextures;</span><br><span class="line">m_stInputSurface[i].type = NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX;</span><br><span class="line">m_stInputSurface[i].bufferFmt = NV_ENC_BUFFER_FORMAT_NV12_PL;</span><br><span class="line">m_stInputSurface[i].dwCuPitch = m_stEncoderInput.width;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_OPENGL)<span class="comment">//NVENCODE API 的 OpenGL 接口仅在 Linux 上受支持</span></span><br><span class="line">&#123;</span><br><span class="line">NV_ENC_INPUT_RESOURCE_OPENGL_TEX *pResource = <span class="keyword">new</span> NV_ENC_INPUT_RESOURCE_OPENGL_TEX;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> tex;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;tex);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, tex);</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NV_ENC_BUFFER_FORMAT_NV12_TYPE</span></span><br><span class="line">                <span class="comment">//因此存放的是NV12，所以分配空间m_stEncoderInput.width*m_stEncoderInput.height* 3 / 2就够了</span></span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_R8, m_stEncoderInput[<span class="number">0</span>].width, m_stEncoderInput[<span class="number">0</span>].height* <span class="number">3</span> / <span class="number">2</span>, <span class="number">0</span>, GL_RED, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, m_stEncoderInput[<span class="number">0</span>].width, m_stEncoderInput[<span class="number">0</span>].height, <span class="number">0</span>, GL_RED, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glIsTexture</span>(tex)== <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">WSLogEx</span>(<span class="string">L&quot;Failed to create opengltextures \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pResource-&gt;texture = tex;</span><br><span class="line">            pResource-&gt;target = GL_TEXTURE_2D;</span><br><span class="line"></span><br><span class="line">m_stInputSurface[i].pExtAlloc = pResource;</span><br><span class="line">m_stInputSurface[i].type = NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NV_ENC_BUFFER_FORMAT_NV12_TYPE</span></span><br><span class="line">m_stInputSurface[i].bufferFmt = NV_ENC_BUFFER_FORMAT_NV12_PL;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">m_stInputSurface[i].bufferFmt      = NV_ENC_BUFFER_FORMAT_ARGB;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">m_stInputSurface[i].dwCuPitch = m_stEncoderInput.width;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="comment">// Register the allocated buffer with NvEncodeAPI</span></span><br><span class="line">            NV_ENC_REGISTER_RESOURCE stRegisterRes;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;stRegisterRes, <span class="number">0</span>, <span class="built_in">sizeof</span>(NV_ENC_REGISTER_RESOURCE));</span><br><span class="line">            <span class="built_in">SET_VER</span>(stRegisterRes, NV_ENC_REGISTER_RESOURCE);</span><br><span class="line">            stRegisterRes.resourceType = m_stInputSurface[i].type;</span><br><span class="line">stRegisterRes.bufferFormat = m_stInputSurface[i].bufferFmt;</span><br><span class="line">            <span class="comment">// Pass the resource handle to be registered and mapped during registration.</span></span><br><span class="line">            <span class="comment">// Do not pass this handle while mapping</span></span><br><span class="line">            stRegisterRes.resourceToRegister       = m_stInputSurface[i].pExtAlloc;</span><br><span class="line">            stRegisterRes.width                    = m_stInputSurface[i].dwWidth;</span><br><span class="line">            stRegisterRes.height                   = m_stInputSurface[i].dwHeight;</span><br><span class="line">            stRegisterRes.pitch                    = m_stInputSurface[i].dwCuPitch;</span><br><span class="line">            </span><br><span class="line">            status = m_pEncodeAPI-&gt;<span class="built_in">nvEncRegisterResource</span>(m_hEncoder, &amp;stRegisterRes);</span><br><span class="line">            <span class="built_in">checkNVENCErrors</span>(status);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Use this registered handle to retrieve an encoder-understandable mapped resource handle, through NvEncMapInputResource.</span></span><br><span class="line">            <span class="comment">// The mapped handle can be directly used with NvEncEncodePicture.</span></span><br><span class="line">            m_stInputSurface[i].hRegisteredHandle = stRegisterRes.registeredResource;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">// Premiere Plugin: allocate non-mapped resources</span></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &gt; System Memory with %d buffers.\n&quot;</span>, m_dwMaxSurfCount);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Allocate input surface</span></span><br><span class="line">            NV_ENC_CREATE_INPUT_BUFFER stAllocInputSurface;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;stAllocInputSurface, <span class="number">0</span>, <span class="built_in">sizeof</span>(stAllocInputSurface));</span><br><span class="line">            <span class="built_in">SET_VER</span>(stAllocInputSurface, NV_ENC_CREATE_INPUT_BUFFER);</span><br><span class="line">            stAllocInputSurface.width              = (m_dwFrameWidth  + <span class="number">31</span>)&amp;~<span class="number">31</span>;<span class="comment">//dwFrameWidth;</span></span><br><span class="line">            stAllocInputSurface.height             = (m_dwFrameHeight + <span class="number">31</span>)&amp;~<span class="number">31</span>; <span class="comment">//dwFrameHeight;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line">            stAllocInputSurface.memoryHeap         = NV_ENC_MEMORY_HEAP_SYSMEM_CACHED;</span><br><span class="line">            stAllocInputSurface.bufferFmt          = NV_ENC_BUFFER_FORMAT_NV12;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            stAllocInputSurface.memoryHeap         = NV_ENC_MEMORY_HEAP_SYSMEM_UNCACHED;</span><br><span class="line">            stAllocInputSurface.bufferFmt          = m_dwInputFormat;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_stEncoderInput.chromaFormatIDC == cudaVideoChromaFormat_420)</span><br><span class="line">stAllocInputSurface.bufferFmt = NV_ENC_BUFFER_FORMAT_NV12;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">stAllocInputSurface.bufferFmt = NV_ENC_BUFFER_FORMAT_YUV444;</span><br><span class="line"></span><br><span class="line">            status = m_pEncodeAPI-&gt;<span class="built_in">nvEncCreateInputBuffer</span>(m_hEncoder, &amp;stAllocInputSurface);</span><br><span class="line">            <span class="built_in">checkNVENCErrors</span>(status);</span><br><span class="line"></span><br><span class="line">            m_stInputSurface[i].hInputSurface      = stAllocInputSurface.inputBuffer;</span><br><span class="line">            m_stInputSurface[i].bufferFmt          = stAllocInputSurface.bufferFmt;</span><br><span class="line">            m_stInputSurface[i].dwWidth            = (m_dwFrameWidth  + <span class="number">31</span>)&amp;~<span class="number">31</span>;</span><br><span class="line">            m_stInputSurface[i].dwHeight           = (m_dwFrameHeight + <span class="number">31</span>)&amp;~<span class="number">31</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_stInputSurfQueue.<span class="built_in">Add</span>(&amp;m_stInputSurface[i]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时，我们已经完成NV_ENC_REGISTER_RESOURCE的填充和注册，接下来就是通过NvEncRegisterResource返回的资源句柄NV_ENC_REGISTER_RESOURCE::registeredResource来进行句柄的映射操作，从而将OpenGL分配的外部输入缓冲区映射到NV_ENC中</p><h3 id="4-3-1-2-将OpenGL分配的外部输入缓冲区映射到NV-ENC中"><a href="#4-3-1-2-将OpenGL分配的外部输入缓冲区映射到NV-ENC中" class="headerlink" title="4.3.1.2 将OpenGL分配的外部输入缓冲区映射到NV_ENC中"></a>4.3.1.2 将OpenGL分配的外部输入缓冲区映射到NV_ENC中</h3><p>继续参考NVENC_export&#x2F;Samples&#x2F;nvEncode2&#x2F;src文件夹中的CNvEncoderH264.cpp文件中EncodeCudaMemFrame，可以看出也缺少了Linux端的代码，我们将他补完整．<br>PS:这边顺便也加了一段NV_ENC_DX11的代码，如果你用到NV_ENC_DX12,NV_ENC_DX10那就参考着这个改就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">CNvEncoderH264::EncodeCudaMemFrame</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">EncodeFrameConfig *pEncodeFrame, CUdeviceptr oDecodedFrame[<span class="number">3</span>], <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> oFrame_pitch, <span class="type">bool</span> bFlush )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NVENCSTATUS nvStatus = NV_ENC_SUCCESS;</span><br><span class="line">    HRESULT hr = S_OK;</span><br><span class="line">    NV_ENC_MAP_INPUT_RESOURCE mapRes = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bFlush)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">FlushEncoder</span>();</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pEncodeFrame)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> E_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EncodeInputSurfaceInfo  *pInput;</span><br><span class="line">    EncodeOutputBuffer      *pOutputBitstream;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_stInputSurfQueue.<span class="built_in">Remove</span>(pInput, INFINITE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_stOutputSurfQueue.<span class="built_in">Remove</span>(pOutputBitstream, INFINITE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lockedPitch = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// encode width and height</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwWidth =  m_uMaxWidth; <span class="comment">//m_stEncoderInput.width;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwHeight = m_uMaxHeight;<span class="comment">//m_stEncoderInput.height;</span></span><br><span class="line">    <span class="comment">// Align 32 as driver does the same</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwSurfWidth  = (dwWidth + <span class="number">0x1f</span>) &amp; ~<span class="number">0x1f</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwSurfHeight = (dwHeight + <span class="number">0x1f</span>) &amp; ~<span class="number">0x1f</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pLuma    = pEncodeFrame-&gt;yuv[<span class="number">0</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pChromaU = pEncodeFrame-&gt;yuv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pChromaV = pEncodeFrame-&gt;yuv[<span class="number">2</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pInputSurface = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pInputSurfaceCh = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">const</span>    <span class="type">bool</span> need_2d_memcpy = (oFrame_pitch % pInput-&gt;dwCuPitch) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CUDA or DX9 interop with NVENC</span></span><br><span class="line">    <span class="keyword">if</span> (m_stEncoderInput.useMappedResources)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Here we copy from Host to Device Memory (CUDA)</span></span><br><span class="line">        <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_CUDA)</span><br><span class="line">        &#123;</span><br><span class="line">            CUresult result;</span><br><span class="line">            <span class="built_in">cuCtxPushCurrent</span>(m_cuContext); <span class="comment">// Necessary to bind the </span></span><br><span class="line">            CUcontext cuContextCurr;</span><br><span class="line"><span class="comment">// YUV444     : we don&#x27;t actually support this correctly.  Copy only the luma (Y) plane</span></span><br><span class="line"><span class="comment">// NV12  (420): the #bytes to </span></span><br><span class="line"><span class="keyword">if</span> ( need_2d_memcpy ) &#123;</span><br><span class="line"><span class="comment">// The source-framebuffer and destination-framebuffer have different pitches.</span></span><br><span class="line"><span class="comment">// (This seems to only happen when decoding HEVC-video using the DXVA/hybrid decoder.)</span></span><br><span class="line"></span><br><span class="line">CUDA_MEMCPY2D cuda_memcpy2d;</span><br><span class="line"><span class="built_in">memset</span>( (<span class="type">void</span> *)&amp;cuda_memcpy2d, <span class="number">0</span>, <span class="built_in">sizeof</span>(cuda_memcpy2d) );<span class="comment">// clear cuda_memcpy2d</span></span><br><span class="line"></span><br><span class="line">cuda_memcpy2d.dstDevice   = (CUdeviceptr) pInput-&gt;pExtAlloc;</span><br><span class="line">cuda_memcpy2d.dstMemoryType = CU_MEMORYTYPE_DEVICE;</span><br><span class="line">cuda_memcpy2d.dstPitch    = pInput-&gt;dwCuPitch;</span><br><span class="line">cuda_memcpy2d.dstXInBytes = <span class="number">0</span>; <span class="comment">// pInput-&gt;dwWidth;</span></span><br><span class="line">cuda_memcpy2d.dstY = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ( m_stEncoderInput.chromaFormatIDC == cudaVideoChromaFormat_444 )</span><br><span class="line">cuda_memcpy2d.Height = pInput-&gt;dwHeight;           <span class="comment">// luma(Y) plane only</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cuda_memcpy2d.Height = (pInput-&gt;dwHeight * <span class="number">3</span>) &gt;&gt; <span class="number">1</span>;<span class="comment">// Y + UV plane</span></span><br><span class="line"><span class="comment">//cuda_memcpy2d.srcArray </span></span><br><span class="line">cuda_memcpy2d.srcDevice = oDecodedFrame[<span class="number">0</span>];</span><br><span class="line">cuda_memcpy2d.srcHost = <span class="literal">NULL</span>;</span><br><span class="line">cuda_memcpy2d.srcMemoryType = CU_MEMORYTYPE_DEVICE;</span><br><span class="line">cuda_memcpy2d.srcPitch = oFrame_pitch;</span><br><span class="line">cuda_memcpy2d.srcXInBytes = <span class="number">0</span>; <span class="comment">// pInput-&gt;dwWidth;</span></span><br><span class="line">cuda_memcpy2d.srcY = <span class="number">0</span>;</span><br><span class="line">cuda_memcpy2d.WidthInBytes = oFrame_pitch;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nCNvEncoderH264::EncodeCudaMemFrame(): cuMemcpy2D(src_pitch=%0u -&gt; dst_pitch=%0u)\n&quot;</span>,</span><br><span class="line">oFrame_pitch, cuda_memcpy2d.dstPitch</span><br><span class="line">);</span><br><span class="line">result = <span class="built_in">cuMemcpy2D</span>(&amp;cuda_memcpy2d);</span><br><span class="line"><span class="comment">//result = cuMemcpy2DUnaligned(&amp;cuda_memcpy2d);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// source framebuffer and dest framebuffer have matching pitch,</span></span><br><span class="line"><span class="comment">// we can use a simpler 1D-memcpy</span></span><br><span class="line"><span class="keyword">if</span> (m_stEncoderInput.chromaFormatIDC == cudaVideoChromaFormat_444)</span><br><span class="line">result = <span class="built_in">cuMemcpyDtoD</span>((CUdeviceptr)pInput-&gt;pExtAlloc, oDecodedFrame[<span class="number">0</span>], pInput-&gt;dwCuPitch*pInput-&gt;dwHeight * <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">result = <span class="built_in">cuMemcpyDtoD</span>((CUdeviceptr)pInput-&gt;pExtAlloc, oDecodedFrame[<span class="number">0</span>], (pInput-&gt;dwCuPitch*pInput-&gt;dwHeight*<span class="number">3</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="built_in">checkCudaErrors</span>(result);</span><br><span class="line">            <span class="built_in">cuCtxPopCurrent</span>(&amp;cuContextCurr);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> Grab a pointer GPU Device Memory (DX9) and then copy the result</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_DX9)</span><br><span class="line">       &#123;</span><br><span class="line">           IDirect3DSurface9 *pSurf = (IDirect3DSurface9 *)pInput-&gt;pExtAlloc;</span><br><span class="line">           pSurf-&gt;<span class="built_in">UnlockRect</span>();</span><br><span class="line">       &#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_DX11)</span><br><span class="line">&#123;</span><br><span class="line">ID3D11Texture2D *pInputTextures = (ID3D11Texture2D *)pInput-&gt;pExtAlloc;</span><br><span class="line">ID3D11DeviceContext *pImmediateContext = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (m_pD3D11Device)</span><br><span class="line">&#123;</span><br><span class="line">m_pD3D11Device-&gt;<span class="built_in">GetImmediateContext</span>(&amp;pImmediateContext);</span><br><span class="line"><span class="keyword">if</span> (NV_INPUT_ENC_FRAME_DX11 ==  pEncodeFrame-&gt;inputEncodeFrameDeviceType )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//使用 GPU 将源资源的全部内容复制到目标资源。</span></span><br><span class="line">ID3D11Texture2D *pSrcTextures = (ID3D11Texture2D*)pLuma;</span><br><span class="line">pImmediateContext-&gt;<span class="built_in">CopyResource</span>(pInputTextures,pSrcTextures);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (NV_INPUT_ENC_FRAME_CPU == pEncodeFrame-&gt;inputEncodeFrameDeviceType)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//upload</span></span><br><span class="line">HRESULT hr = S_OK;</span><br><span class="line"></span><br><span class="line">D3D11_TEXTURE2D_DESC dstDesc;</span><br><span class="line">D3D11_BOX d3d11box;</span><br><span class="line"></span><br><span class="line">pInputTextures-&gt;<span class="built_in">GetDesc</span>(&amp;dstDesc);</span><br><span class="line">d3d11box.front = <span class="number">0</span>; d3d11box.back = <span class="number">1</span>;</span><br><span class="line">d3d11box.left = <span class="number">0</span>; d3d11box.top = <span class="number">0</span>;</span><br><span class="line">d3d11box.right = dstDesc.Width;</span><br><span class="line">d3d11box.bottom = dstDesc.Height;</span><br><span class="line"><span class="keyword">if</span> (dstDesc.Format == (DXGI_FORMAT)<span class="number">103</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//CPU 将数据从内存复制到在不可映射内存中创建的子资源</span></span><br><span class="line">pImmediateContext-&gt;<span class="built_in">UpdateSubresource</span>(pInputTextures, <span class="number">0</span>, &amp;d3d11box, pInputSurface, dstDesc.Width, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pImmediateContext)</span><br><span class="line">                pImmediateContext-&gt;<span class="built_in">Release</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_OPENGL)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//GPU的copy</span></span><br><span class="line"><span class="keyword">if</span> (NV_INPUT_ENC_FRAME_OpenGL ==  pEncodeFrame-&gt;inputEncodeFrameDeviceType)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">NV_ENC_INPUT_RESOURCE_OPENGL_TEX *pResource = (NV_ENC_INPUT_RESOURCE_OPENGL_TEX *)pInput-&gt;pExtAlloc;</span><br><span class="line"><span class="keyword">if</span>((pResource-&gt;target != GL_TEXTURE_2D) || (<span class="built_in">glIsTexture</span>(pResource-&gt;texture) == <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GLuint fboBuffer = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;fboBuffer);<span class="comment">//声明一个帧缓冲区</span></span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, fboBuffer);<span class="comment">//绑定</span></span><br><span class="line"><span class="comment">//将纹理附加到帧缓冲区上</span></span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_READ_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class="line">GL_TEXTURE_2D,  *((GLuint*)pLuma), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT1,</span><br><span class="line">GL_TEXTURE_2D, pResource-&gt;texture, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">glReadBuffer</span>(GL_COLOR_ATTACHMENT0);</span><br><span class="line"><span class="built_in">glDrawBuffer</span>(GL_COLOR_ATTACHMENT1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//glBlitFramebuffer 一般用于帧缓冲区（颜色缓冲区）间高性能数据拷贝</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NV_ENC_BUFFER_FORMAT_NV12_TYPE</span></span><br><span class="line"><span class="built_in">glBlitFramebuffer</span>(<span class="number">0</span>, <span class="number">0</span>, pInput-&gt;dwWidth, pInput-&gt;dwHeight * <span class="number">3</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, pInput-&gt;dwWidth, pInput-&gt;dwHeight * <span class="number">3</span> / <span class="number">2</span>,</span><br><span class="line">GL_COLOR_BUFFER_BIT, GL_NEAREST);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="built_in">glBlitFramebuffer</span>(<span class="number">0</span>, <span class="number">0</span>, pInput-&gt;dwWidth, pInput-&gt;dwHeight, <span class="number">0</span>, <span class="number">0</span>, pInput-&gt;dwWidth, pInput-&gt;dwHeight,</span><br><span class="line">GL_COLOR_BUFFER_BIT, GL_NEAREST);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (NV_INPUT_ENC_FRAME_CPU == pEncodeFrame-&gt;inputEncodeFrameDeviceType)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//WIN32</span></span></span><br><span class="line">        <span class="built_in">SET_VER</span>(mapRes, NV_ENC_MAP_INPUT_RESOURCE);</span><br><span class="line">        mapRes.registeredResource  = pInput-&gt;hRegisteredHandle;</span><br><span class="line">        nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncMapInputResource</span>(m_hEncoder, &amp;mapRes);</span><br><span class="line">        pInput-&gt;hInputSurface = mapRes.mappedResource;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时，我们已经调用了NvEncMapInputResource接口，如果返回成功的话，说明NV_ENC_MAP_INPUT_RESOURCE::mappedResource映射的句柄此时已经生效了</p><h3 id="4-3-2-分配输出的比特流缓冲区"><a href="#4-3-2-分配输出的比特流缓冲区" class="headerlink" title="4.3.2 分配输出的比特流缓冲区"></a>4.3.2 分配输出的比特流缓冲区</h3><p>分配输出的比特流缓冲区需要调用NvEncCreateBitstreamBuffer来进行分配。此时我们回到下NVENC_export&#x2F;Samples&#x2F;nvEncode2&#x2F;src文件夹中的CNvEncoder.cpp文件中的AllocateIOBuffers函数．<br>可以看出分配输出的比特流缓冲区的具体操作分为以下几个步骤：</p><ul><li>填充NV_ENC_CREATE_BITSTREAM_BUFFER结构体</li><li>调用nvEncCreateBitstreamBuffer接口，分配输出比特流缓冲区</li><li>设置视频编码接口的操作模式</li></ul><p>但是这个代码是有问题的，问题在于之前Guest在编写NVENC_export时候，只关注于Win端，因此没有注意到在Linux端是没办法使用异步操作模式的，也就是不能调用nvEncRegisterAsyncEvent接口，文档解释如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Modes of Operation</span><br><span class="line">The NVIDIA Video Encoder Interface supports the following two modes of operation.</span><br><span class="line"></span><br><span class="line">Asynchronous Mode</span><br><span class="line">This mode of operation is used for asynchronous output buffer processing. For this mode, the client allocates an event object and associates the event with an allocated output buffer. This event object is passed to the NVIDIA Encoder Interface as part of the NvEncEncodePicture API. The client can wait on the event in a separate thread. When the event is signaled, the client calls the NVIDIA Video Encoder Interface to copy output bitstream produced by the encoder. Note that the encoder supports asynchronous mode of operation only for Windows 7 and above, with driver running in WDDM mode. In Linux and Windows with TCC mode (TCC mode is available on Tesla boards1), ONLY synchronous mode is supported (refer to Section Synchronous Mode)</span><br><span class="line"></span><br><span class="line">The client should set the flag NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync to 1 to indicate that it wants to operate in asynchronous mode. After creating the event objects (one object for each output bitstream buffer allocated), the client needs to register them with the NVIDIA Video Encoder Interface using the NvEncRegisterAsyncEvent. The client is required to pass a bitstream buffer handle and the corresponding event handle as input to NvEncEncodePicture. The NVIDIA Video Encoder Interface will signal this event when the hardware encoder finishes encoding the current input data. The client can then call NvEncLockBitstream in non-blocking mode NV_ENC_LOCK_BITSTREAM::doNotWait flag set to 1 to fetch the output data.</span><br><span class="line"></span><br><span class="line">The client should call NvEncUnregisterAsyncEvent to unregister the Event handles before destroying the event objects. Whenever possible, NVIDIA recommends using the asynchronous mode of operation instead of synchronous mode.</span><br><span class="line"></span><br><span class="line">A step-by-step control flow for asynchronous mode is as follows:</span><br><span class="line"></span><br><span class="line">When working in asynchronous mode, the output sample must consist of an event + output buffer and clients must work in multi-threaded manner (D3D9 device should be created with MULTITHREADED flag).</span><br><span class="line">The output buffers are allocated using NvEncCreateBitstreamBuffer API. The NVIDIA Video Encoder Interface will return an opaque pointer to the output memory in NV_ENC_CREATE_BITSTREAM_BUFFER::bitstreambuffer. This opaque output pointer should be used in NvEncEncodePicture and NvEncLockBitsteam/ NvEncUnlockBitsteam calls. For accessing the output memory using CPU, client must call NvEncLockBitsteam API. The number of IO buffers should be at least 4 + number of B frames.</span><br><span class="line">The events are windows event handles allocated using Windows’ CreateEvent API and registered using the function NvEncRegisterAsyncEvent before encoding. The registering of events is required only once per encoding session. Clients must unregister the events using NvEncUnregisterAsyncEvent before destroying the event handles. The number of event handles must be same as number of output buffers as each output buffer is associated with an event.</span><br><span class="line">Client must create a secondary thread in which it can wait on the completion event and copy the bitstream data from the output sample. Client will have two threads: one is the main application thread which submits encoding work to NVIDIA Encoder while secondary thread waits on the completion events and copies the compressed bitstream data from the output buffer.</span><br><span class="line">Client must send the output buffer and event in NV_ENC_PIC_PARAMS::outputBitstream and NV_ENC_PIC_PARAMS:: completionEvent fields respectively as part of NvEncEncodePicture API call.</span><br><span class="line">Client should then wait on the event on the secondary thread in the same order in which it has called NvEncEncodePicture calls irrespective of input buffer re-ordering (encode order! = display order). When enablePTD = 1, NVIDIA Encoder takes care of the reordering in case of B frames in a way that is transparent to the encoder clients. For AV1, NVIDIA encoder also transparently performs frame bitstream packing, meaning it always concatenates into a single output buffer the bitstream corresponding to leading no-show frames with the bitstream of the first show frame that follows. Each output buffer therefore always contains a single frame to display along with all the preceding non-display frames in encode order since the previous frame to display.</span><br><span class="line">When the event gets signalled client must send down the output buffer of sample event it was waiting on in NV_ENC_LOCK_BITSTREAM::outputBitstream field as part of NvEncLockBitstream call.</span><br><span class="line">The NVIDIA Encoder Interface returns a CPU pointer and bitstream size in bytes as part of the NV_ENC_LOCK_BITSTREAM.</span><br><span class="line">After copying the bitstream data, client must call NvEncUnlockBitstream for the locked output bitstream buffer.</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The client will receive the event&#x27;s signal and output buffer in the same order in which they were queued.</span><br><span class="line">The NV_ENC_LOCK_BITSTREAM::pictureType notifies the output picture type to the clients.</span><br><span class="line">Both, the input and output sample (output buffer and the output completion event) are free to be reused once the NVIDIA Video Encoder Interface has signalled the event and the client has copied the data from the output buffer.</span><br><span class="line"></span><br><span class="line">Synchronous Mode</span><br><span class="line">This mode of operation is used for synchronous output buffer processing. In this mode the client makes a blocking call to the NVIDIA Video Encoder Interface to retrieve the output bitstream data from the encoder. The client sets the flag NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync to 0 for operation in synchronous mode. The client then must call NvEncEncodePicture without setting a completion event handle. The client must call NvEncLockBitstream with flag NV_ENC_LOCK_BITSTREAM::doNotWait set to 0, so that the lock call blocks until the hardware encoder finishes writing the output bitstream. The client can then operate on the generated bitstream data and call NvEncUnlockBitstream. This is the only mode supported on Linux.</span><br></pre></td></tr></table></figure><p>翻译一下大概意思：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">异步模式:</span><br><span class="line">这种操作模式用于异步输出缓冲区处理。对于这种模式，必须分配一个事件对象，并将事件与分配的输出缓冲区相关联。此事件对象作为 NVIDIA 编码器接口的一部分传递给NvEncEncodePicture应用程序接口。用户可以在单独的线程中等待事件。当事件发出信号时，用户调用 NVIDIA 视频编码器接口来复制编码器产生的输出比特流。请注意，编码器仅支持 Windows 7 及更高版本的异步操作模式，在 WDDM 模式下运行的驱动程序。</span><br><span class="line">用户应该设置标志NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync为1，表示它要在异步模式下运行。</span><br><span class="line">在创建事件对象（为每个输出比特流缓冲区分配一个对象）后，用户需要调用 NvEncRegisterAsyncEvent。</span><br><span class="line">用户需要将比特流缓冲区句柄和相应的事件句柄作为输入传递给NvEncEncodePicture。</span><br><span class="line">当硬件编码器完成对当前输入数据的编码时，NVIDIA 视频编码器接口将发出此事件信号。然后用户可以在非阻塞模式（NV_ENC_LOCK_BITSTREAM::doNotWait 标志设置为 1 ）下调用NvEncLockBitstream 以获取输出数据。</span><br><span class="line">在销毁事件对象之前，客户应该调用NvEncUnregisterAsyncEvent取消注册的事件句柄。只要有可能，NVIDIA 建议使用异步操作模式而不是同步模式。</span><br><span class="line">异步模式的分步控制流程如下：</span><br><span class="line"></span><br><span class="line">在异步模式下工作时，输出样本必须由事件 + 输出缓冲区组成，并且用户必须以多线程方式工作（D3D9 设备应使用 MULTITHREADED 标志创建）。</span><br><span class="line">输出缓冲区使用 NvEncCreateBitstreamBuffer来分配。它将返回一个指向输出内存的不透明指针 NV_ENC_CREATE_BITSTREAM_BUFFER::bitstreambuffer。这个不透明的输出指针应该用于NvEncEncodePicture 和 NvEncLockBitsteam/ NvEncUnlockBitsteam的调用中。要使用 CPU 访问输出存储器，用户必须调用NvEncLockBitsteam。IO 缓冲区的数量应至少为 4 + B 帧的数量。</span><br><span class="line">如果这些事件是使用CreateEvent分配的 Windows 事件句柄，则在编码前需要使用NvEncRegisterAsyncEvent进行注册。每个编码会话只需要注册一次事件。用户必须在销毁事件句柄之前，使用NvEncUnregisterAsyncEvent取消注册事件。事件句柄的数量必须与输出缓冲区的数量相同，因为每个输出缓冲区都与一个事件相关联。</span><br><span class="line">用户必须创建一个辅助线程，它可以在其中等待完成事件并从输出样本中复制比特流数据。用户将有两个线程：一个是主应用程序线程，它向 NVIDIA 编码器提交编码工作，而辅助线程等待完成事件并从输出缓冲区复制压缩的比特流数据。</span><br><span class="line">用户必须将输出缓冲区和事件发送到 NV_ENC_PIC_PARAMS::outputBitstream 和 NV_ENC_PIC_PARAMS::completionEvent字段，依次调用NvEncEncodePicture API。</span><br><span class="line">然后用户应该按照它调用的相同顺序在辅助线程上等待事件，NvEncEncodePicture调用与输入缓冲区重新排序无关（编码顺序 != 显示顺序）。NVIDIA Encoder 负责处理 B 帧的重新排序，并且应该对编码器用户透明。</span><br><span class="line">当事件得到信号时，用户必须向下发送它正在等待的样本事件的输出缓冲区，即调用NvEncLockBitstream的参数NV_ENC_LOCK_BITSTREAM::outputBitstream。</span><br><span class="line">NVIDIA 编码器接口返回作为NV_ENC_LOCK_BITSTREAM一部分的，以字节为单位的CPU指针和比特流大小。</span><br><span class="line">复制比特流数据后，对于锁定的输出比特流缓冲区，用户必须调用 NvEncUnlockBitstream。</span><br><span class="line">提示：</span><br><span class="line">用户将按照它们排队的相同顺序接收事件的信号和输出缓冲区。</span><br><span class="line">NV_ENC_LOCK_BITSTREAM::pictureType 将输出图片类型通知给用户。</span><br><span class="line">一旦 NVIDIA 视频编码器接口发出事件信号并且用户已从输出缓冲区复制数据，输入和输出样本（输出缓冲区和输出完成事件）都可以自由重用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">同步模式：</span><br><span class="line">这种操作模式用于同步输出缓冲处理。在这种模式下，用户对 NVIDIA 视频编码器接口进行阻塞调用，以从编码器检索输出比特流数据。</span><br><span class="line">同步模式下，用户设置标志NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync为 0。然后用户必须调用NvEncEncodePicture无需设置完成事件句柄。用户调用NvEncLockBitstream，NV_ENC_LOCK_BITSTREAM::doNotWait需设置为 0，以便阻塞和锁定调用，直到硬件编码器完成输出比特流的写入。然后用户可以对生成的比特流数据进行操作，然后调用NvEncUnlockBitstream。这是 Linux 上唯一支持的模式。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因此我们将AllocateIOBuffers函数修改成以下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//Allocate output surface</span></span><br><span class="line">        m_stBitstreamBuffer[i].dwSize = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">        NV_ENC_CREATE_BITSTREAM_BUFFER stAllocBitstream;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;stAllocBitstream, <span class="number">0</span>, <span class="built_in">sizeof</span>(stAllocBitstream));</span><br><span class="line">        <span class="built_in">SET_VER</span>(stAllocBitstream, NV_ENC_CREATE_BITSTREAM_BUFFER);</span><br><span class="line">        stAllocBitstream.size                      =  m_stBitstreamBuffer[i].dwSize;</span><br><span class="line">        stAllocBitstream.memoryHeap                = NV_ENC_MEMORY_HEAP_SYSMEM_CACHED;</span><br><span class="line"></span><br><span class="line">        status = m_pEncodeAPI-&gt;<span class="built_in">nvEncCreateBitstreamBuffer</span>(m_hEncoder, &amp;stAllocBitstream);</span><br><span class="line">        <span class="built_in">checkNVENCErrors</span>(status);</span><br><span class="line"></span><br><span class="line">        m_stBitstreamBuffer[i].hBitstreamBuffer    = stAllocBitstream.bitstreamBuffer;</span><br><span class="line">        m_stBitstreamBuffer[i].pBitstreamBufferPtr = stAllocBitstream.bitstreamBufferPtr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO : need to fix the ucode to set the bitstream position</span></span><br><span class="line">        <span class="keyword">if</span> (m_stEncoderInput.outBandSPSPPS == <span class="number">0</span>)</span><br><span class="line">            m_stBitstreamBuffer[i].pBitstreamBufferPtr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line"> NV_ENC_EVENT_PARAMS nvEventParams = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">SET_VER</span>(nvEventParams, NV_ENC_EVENT_PARAMS);</span><br><span class="line">        m_stBitstreamBuffer[i].hOutputEvent        = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">        nvEventParams.completionEvent              = m_stBitstreamBuffer[i].hOutputEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register the resource for interop with NVENC</span></span><br><span class="line">        nvEventParams.completionEvent              = m_stBitstreamBuffer[i].hOutputEvent;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        m_stBitstreamBuffer[i].hOutputEvent = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line">        m_pEncodeAPI-&gt;<span class="built_in">nvEncRegisterAsyncEvent</span>(m_hEncoder, &amp;nvEventParams);<span class="comment">//Linux端不支持异步模式，只能用同步模式</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        m_stOutputSurfQueue.<span class="built_in">Add</span>(&amp;m_stBitstreamBuffer[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_stEOSOutputBfr.bEOSFlag = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line"> NV_ENC_EVENT_PARAMS nvEventParams = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">SET_VER</span>(nvEventParams, NV_ENC_EVENT_PARAMS);</span><br><span class="line">    m_stEOSOutputBfr.hOutputEvent = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">    nvEventParams.completionEvent = m_stEOSOutputBfr.hOutputEvent;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    m_stEOSOutputBfr.hOutputEvent = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line">    m_pEncodeAPI-&gt;<span class="built_in">nvEncRegisterAsyncEvent</span>(m_hEncoder, &amp;nvEventParams);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32 </span></span><br><span class="line">    <span class="comment">// intialize output thread</span></span><br><span class="line">    <span class="keyword">if</span> (hr == S_OK &amp;&amp; !m_pEncoderThread)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pEncoderThread = <span class="keyword">new</span> <span class="built_in">CNvEncoderThread</span>(<span class="built_in">reinterpret_cast</span>&lt;CNvEncoder*&gt;(<span class="keyword">this</span>), MAX_OUTPUT_QUEUE);</span><br><span class="line">        <span class="keyword">if</span> (!m_pEncoderThread)</span><br><span class="line">        &#123;</span><br><span class="line">            hr = E_FAIL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_pEncoderThread-&gt;<span class="built_in">ThreadStart</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>    </span></span><br><span class="line"><span class="comment">///////</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// transfer the encoder-settings to m_sei_user_payload</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">m_sei_user_payload_str = oss.<span class="built_in">str</span>();</span><br><span class="line"><span class="comment">//printf( &quot;m_sei_user_payload(%0u) = &#x27;%s&#x27;\n&quot;, m_sei_user_payload_str.length(), m_sei_user_payload_str.c_str() );</span></span><br><span class="line"></span><br><span class="line">m_sei_user_payload.payloadType = <span class="number">5</span>;<span class="comment">// Annex D : Type 5 = &#x27;user data unregistered&#x27;</span></span><br><span class="line">m_sei_user_payload.payloadSize = m_sei_user_payload_str.<span class="built_in">length</span>();<span class="comment">// fill in later</span></span><br><span class="line"><span class="keyword">if</span> ( m_sei_user_payload.payload != <span class="literal">NULL</span> )</span><br><span class="line"><span class="keyword">delete</span> [] m_sei_user_payload.payload;</span><br><span class="line"></span><br><span class="line">m_sei_user_payload.payload = <span class="keyword">new</span> <span class="type">uint8_t</span>[ m_sei_user_payload.payloadSize ];</span><br><span class="line"><span class="built_in">memcpy</span>( (<span class="type">char</span> *)m_sei_user_payload.payload, m_sei_user_payload_str.<span class="built_in">c_str</span>(), m_sei_user_payload.payloadSize );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hr == S_OK)</span><br><span class="line">        m_bEncoderInitialized = <span class="literal">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">HRESULT <span class="title">CNvEncoderH264::EncodeCudaMemFrame</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">EncodeFrameConfig *pEncodeFrame, CUdeviceptr oDecodedFrame[<span class="number">3</span>], <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> oFrame_pitch, <span class="type">bool</span> bFlush )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NVENCSTATUS nvStatus = NV_ENC_SUCCESS;</span><br><span class="line">    HRESULT hr = S_OK;</span><br><span class="line">    NV_ENC_MAP_INPUT_RESOURCE mapRes = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bFlush)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">FlushEncoder</span>();</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pEncodeFrame)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> E_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EncodeInputSurfaceInfo  *pInput;</span><br><span class="line">    EncodeOutputBuffer      *pOutputBitstream;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_stInputSurfQueue.<span class="built_in">Remove</span>(pInput, INFINITE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_stOutputSurfQueue.<span class="built_in">Remove</span>(pOutputBitstream, INFINITE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lockedPitch = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// encode width and height</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwWidth =  m_uMaxWidth; <span class="comment">//m_stEncoderInput.width;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwHeight = m_uMaxHeight;<span class="comment">//m_stEncoderInput.height;</span></span><br><span class="line">    <span class="comment">// Align 32 as driver does the same</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwSurfWidth  = (dwWidth + <span class="number">0x1f</span>) &amp; ~<span class="number">0x1f</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwSurfHeight = (dwHeight + <span class="number">0x1f</span>) &amp; ~<span class="number">0x1f</span>;</span><br><span class="line">    <span class="comment">//unsigned char *pLuma    = pEncodeFrame-&gt;yuv[0];</span></span><br><span class="line">    <span class="comment">//unsigned char *pChromaU = pEncodeFrame-&gt;yuv[1];</span></span><br><span class="line">    <span class="comment">//unsigned char *pChromaV = pEncodeFrame-&gt;yuv[2];</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pInputSurface = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pInputSurfaceCh = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">const</span>    <span class="type">bool</span> need_2d_memcpy = (oFrame_pitch % pInput-&gt;dwCuPitch) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CUDA or DX9 interop with NVENC</span></span><br><span class="line">    <span class="keyword">if</span> (m_stEncoderInput.useMappedResources)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Here we copy from Host to Device Memory (CUDA)</span></span><br><span class="line">        <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_CUDA)</span><br><span class="line">        &#123;</span><br><span class="line">            CUresult result;</span><br><span class="line">            <span class="built_in">cuCtxPushCurrent</span>(m_cuContext); <span class="comment">// Necessary to bind the </span></span><br><span class="line">            CUcontext cuContextCurr;</span><br><span class="line"><span class="comment">// YUV444     : we don&#x27;t actually support this correctly.  Copy only the luma (Y) plane</span></span><br><span class="line"><span class="comment">// NV12  (420): the #bytes to </span></span><br><span class="line"><span class="keyword">if</span> ( need_2d_memcpy ) &#123;</span><br><span class="line"><span class="comment">// The source-framebuffer and destination-framebuffer have different pitches.</span></span><br><span class="line"><span class="comment">// (This seems to only happen when decoding HEVC-video using the DXVA/hybrid decoder.)</span></span><br><span class="line"></span><br><span class="line">CUDA_MEMCPY2D cuda_memcpy2d;</span><br><span class="line"><span class="built_in">memset</span>( (<span class="type">void</span> *)&amp;cuda_memcpy2d, <span class="number">0</span>, <span class="built_in">sizeof</span>(cuda_memcpy2d) );<span class="comment">// clear cuda_memcpy2d</span></span><br><span class="line"></span><br><span class="line">cuda_memcpy2d.dstDevice   = (CUdeviceptr) pInput-&gt;pExtAlloc;</span><br><span class="line">cuda_memcpy2d.dstMemoryType = CU_MEMORYTYPE_DEVICE;</span><br><span class="line">cuda_memcpy2d.dstPitch    = pInput-&gt;dwCuPitch;</span><br><span class="line">cuda_memcpy2d.dstXInBytes = <span class="number">0</span>; <span class="comment">// pInput-&gt;dwWidth;</span></span><br><span class="line">cuda_memcpy2d.dstY = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ( m_stEncoderInput.chromaFormatIDC == cudaVideoChromaFormat_444 )</span><br><span class="line">cuda_memcpy2d.Height = pInput-&gt;dwHeight;           <span class="comment">// luma(Y) plane only</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cuda_memcpy2d.Height = (pInput-&gt;dwHeight * <span class="number">3</span>) &gt;&gt; <span class="number">1</span>;<span class="comment">// Y + UV plane</span></span><br><span class="line"><span class="comment">//cuda_memcpy2d.srcArray </span></span><br><span class="line">cuda_memcpy2d.srcDevice = oDecodedFrame[<span class="number">0</span>];</span><br><span class="line">cuda_memcpy2d.srcHost = <span class="literal">NULL</span>;</span><br><span class="line">cuda_memcpy2d.srcMemoryType = CU_MEMORYTYPE_DEVICE;</span><br><span class="line">cuda_memcpy2d.srcPitch = oFrame_pitch;</span><br><span class="line">cuda_memcpy2d.srcXInBytes = <span class="number">0</span>; <span class="comment">// pInput-&gt;dwWidth;</span></span><br><span class="line">cuda_memcpy2d.srcY = <span class="number">0</span>;</span><br><span class="line">cuda_memcpy2d.WidthInBytes = oFrame_pitch;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nCNvEncoderH264::EncodeCudaMemFrame(): cuMemcpy2D(src_pitch=%0u -&gt; dst_pitch=%0u)\n&quot;</span>,</span><br><span class="line">oFrame_pitch, cuda_memcpy2d.dstPitch</span><br><span class="line">);</span><br><span class="line">result = <span class="built_in">cuMemcpy2D</span>(&amp;cuda_memcpy2d);</span><br><span class="line"><span class="comment">//result = cuMemcpy2DUnaligned(&amp;cuda_memcpy2d);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// source framebuffer and dest framebuffer have matching pitch,</span></span><br><span class="line"><span class="comment">// we can use a simpler 1D-memcpy</span></span><br><span class="line"><span class="keyword">if</span> (m_stEncoderInput.chromaFormatIDC == cudaVideoChromaFormat_444)</span><br><span class="line">result = <span class="built_in">cuMemcpyDtoD</span>((CUdeviceptr)pInput-&gt;pExtAlloc, oDecodedFrame[<span class="number">0</span>], pInput-&gt;dwCuPitch*pInput-&gt;dwHeight * <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">result = <span class="built_in">cuMemcpyDtoD</span>((CUdeviceptr)pInput-&gt;pExtAlloc, oDecodedFrame[<span class="number">0</span>], (pInput-&gt;dwCuPitch*pInput-&gt;dwHeight*<span class="number">3</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="built_in">checkCudaErrors</span>(result);</span><br><span class="line">            <span class="built_in">cuCtxPopCurrent</span>(&amp;cuContextCurr);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//#if defined(NV_WINDOWS)</span></span><br><span class="line"><span class="comment">//        // <span class="doctag">TODO:</span> Grab a pointer GPU Device Memory (DX9) and then copy the result</span></span><br><span class="line"><span class="comment">//        if (m_stEncoderInput.interfaceType == NV_ENC_DX9)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            IDirect3DSurface9 *pSurf = (IDirect3DSurface9 *)pInput-&gt;pExtAlloc;</span></span><br><span class="line"><span class="comment">//            pSurf-&gt;UnlockRect();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//#endif</span></span><br><span class="line">        <span class="built_in">SET_VER</span>(mapRes, NV_ENC_MAP_INPUT_RESOURCE);</span><br><span class="line">        mapRes.registeredResource  = pInput-&gt;hRegisteredHandle;</span><br><span class="line">        nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncMapInputResource</span>(m_hEncoder, &amp;mapRes);</span><br><span class="line">        pInput-&gt;hInputSurface = mapRes.mappedResource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// here we just pass the frame in system memory to NVENC</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CNvEncoderH264::EncodeCudaMemFrame ERROR !useMappedResources\n&quot;</span>);</span><br><span class="line">        <span class="built_in">UnlockInputBuffer</span>(pInput-&gt;hInputSurface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;m_stEncodePicParams, <span class="number">0</span>, <span class="built_in">sizeof</span>(m_stEncodePicParams));</span><br><span class="line">    <span class="built_in">SET_VER</span>(m_stEncodePicParams, NV_ENC_PIC_PARAMS);</span><br><span class="line">    m_stEncodePicParams.inputBuffer = pInput-&gt;hInputSurface;</span><br><span class="line">    m_stEncodePicParams.bufferFmt = pInput-&gt;bufferFmt;</span><br><span class="line">    m_stEncodePicParams.inputWidth = pInput-&gt;dwWidth;</span><br><span class="line">    m_stEncodePicParams.inputHeight = pInput-&gt;dwHeight;</span><br><span class="line">    m_stEncodePicParams.outputBitstream = pOutputBitstream-&gt;hBitstreamBuffer;</span><br><span class="line">    m_stEncodePicParams.completionEvent = m_bAsyncModeEncoding == <span class="literal">true</span> ? pOutputBitstream-&gt;hOutputEvent : <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( m_stEncoderInput.FieldEncoding == NV_ENC_PARAMS_FRAME_FIELD_MODE_FRAME ) &#123;</span><br><span class="line">        <span class="comment">// progressive-video encoding mode</span></span><br><span class="line">        m_stEncodePicParams.pictureStruct = NV_ENC_PIC_STRUCT_FRAME;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// interlaced-video encoding mode</span></span><br><span class="line">        <span class="comment">// In interlaced-mode, NVENC requires interlaced-input, even if the frames are progressive</span></span><br><span class="line">        <span class="comment">// pEncodeFrame-&gt;fieldPicflag ?</span></span><br><span class="line">        m_stEncodePicParams.pictureStruct = pEncodeFrame-&gt;topField ? </span><br><span class="line">            NV_ENC_PIC_STRUCT_FIELD_TOP_BOTTOM : NV_ENC_PIC_STRUCT_FIELD_BOTTOM_TOP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    m_stEncodePicParams.codecPicParams.h264PicParams.h264ExtPicParams.mvcPicParams.viewID = pEncodeFrame-&gt;viewId;    </span></span><br><span class="line">    m_stEncodePicParams.encodePicFlags = <span class="number">0</span>;</span><br><span class="line">    m_stEncodePicParams.inputTimeStamp = <span class="number">0</span>;</span><br><span class="line">    m_stEncodePicParams.inputDuration = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For H264-only: embed encoder-settings (text-string) into the encoded videostream</span></span><br><span class="line"><span class="keyword">if</span> (m_sei_user_payload_str.<span class="built_in">length</span>()) &#123; <span class="comment">// m_sei_user_payload.payloadSize ) &#123;</span></span><br><span class="line">m_stEncodePicParams.codecPicParams.h264PicParams.seiPayloadArrayCnt = <span class="number">1</span>;</span><br><span class="line">m_stEncodePicParams.codecPicParams.h264PicParams.seiPayloadArray = &amp;m_sei_user_payload;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete the payload.  This way, our user-sei is only embedded into the *first* frame</span></span><br><span class="line"><span class="comment">// of the output-bitstream, and nothing subsequent.  While we really should mebed</span></span><br><span class="line"><span class="comment">// it in every frame, that would bloat the output filesize, and MediaInfo only</span></span><br><span class="line"><span class="comment">// needs the user-sei in the first-frame to display the info. </span></span><br><span class="line">m_sei_user_payload_str.<span class="built_in">clear</span>();</span><br><span class="line">&#125; <span class="comment">// sei</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!m_stInitEncParams.enablePTD)</span><br><span class="line">&#123;</span><br><span class="line">m_stEncodePicParams.codecPicParams.h264PicParams.refPicFlag = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//m_stEncodePicParams.codecPicParams.h264PicParams.frameNumSyntax = m_dwFrameNumInGOP;</span></span><br><span class="line">m_stEncodePicParams.codecPicParams.h264PicParams.displayPOCSyntax = <span class="number">2</span> * m_dwFrameNumInGOP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!m_stInitEncParams.enablePTD)</span><br><span class="line">m_stEncodePicParams.pictureType = ((m_dwFrameNumInGOP % m_stEncoderInput.gopLength) == <span class="number">0</span>) ? NV_ENC_PIC_TYPE_IDR : NV_ENC_PIC_TYPE_P;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handling Dynamic Resolution Changing    </span></span><br><span class="line">    <span class="keyword">if</span> (pEncodeFrame-&gt;dynResChangeFlag)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ERROR, dynResChangeFlag != 0: is not supported&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handling Dynamic Bitrate Change</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pEncodeFrame-&gt;dynBitrateChangeFlag == DYN_DOWNSCALE)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ERROR, dynBitrateChangeFlag == DYN_UPSCALE: is not supported&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pEncodeFrame-&gt;dynBitrateChangeFlag == DYN_UPSCALE)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ERROR, dynBitrateChangeFlag == DYN_UPSCALE: is not supported&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((m_bAsyncModeEncoding == <span class="literal">false</span>) &amp;&amp; </span><br><span class="line">        (m_stInitEncParams.enablePTD == <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        EncoderThreadData stThreadData;</span><br><span class="line">        stThreadData.pOutputBfr = pOutputBitstream;</span><br><span class="line">        stThreadData.pInputBfr = pInput;</span><br><span class="line">        stThreadData.pOutputBfr-&gt;bDynResChangeFlag = pEncodeFrame-&gt;dynResChangeFlag == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        pOutputBitstream-&gt;bWaitOnEvent = <span class="literal">false</span>;</span><br><span class="line">        m_pEncodeFrameQueue.<span class="built_in">Add</span>(stThreadData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncEncodePicture</span>(m_hEncoder, &amp;m_stEncodePicParams);</span><br><span class="line">    </span><br><span class="line">    m_dwFrameNumInGOP++;</span><br><span class="line">    <span class="keyword">if</span> ((m_bAsyncModeEncoding == <span class="literal">false</span>) &amp;&amp; </span><br><span class="line">        (m_stInitEncParams.enablePTD == <span class="number">1</span>))</span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="keyword">if</span> (nvStatus == NV_ENC_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            EncoderThreadData stThreadData;</span><br><span class="line">            <span class="keyword">while</span> (m_pEncodeFrameQueue.<span class="built_in">Remove</span>(stThreadData, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">                m_pEncoderThread-&gt;<span class="built_in">QueueSample</span>(stThreadData);<span class="comment">//只在Win下支持异步，所以Win下才能用m_pEncoderThread</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">CopyBitstreamData</span>(stThreadData);<span class="comment">//Linux下只能同步，不需要线程</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span> (nvStatus != NV_ENC_ERR_NEED_MORE_INPUT) &#123;</span><br><span class="line"><span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="built_in">assert</span>(nvStatus == NV_ENC_ERR_NEED_MORE_INPUT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nvStatus == NV_ENC_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            EncoderThreadData stThreadData;</span><br><span class="line">            stThreadData.pOutputBfr = pOutputBitstream;</span><br><span class="line">            stThreadData.pInputBfr = pInput;</span><br><span class="line">            pOutputBitstream-&gt;bWaitOnEvent = <span class="literal">true</span>;</span><br><span class="line">            stThreadData.pOutputBfr-&gt;bDynResChangeFlag = pEncodeFrame-&gt;dynResChangeFlag == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32            </span></span><br><span class="line">            <span class="comment">// Queue o/p Sample</span></span><br><span class="line">            <span class="keyword">if</span> (!m_pEncoderThread-&gt;<span class="built_in">QueueSample</span>(stThreadData))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>            </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line">            <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Nvida的Video_Codec_SDK中参考例程的讲解（二）：搭建AppDecGL的调试环境</title>
      <link href="/2023/01/12/Nvida%E7%9A%84Video_Codec_SDK%E4%B8%AD%E5%8F%82%E8%80%83%E4%BE%8B%E7%A8%8B%E7%9A%84%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%90%AD%E5%BB%BAAppDecGL%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/"/>
      <url>/2023/01/12/Nvida%E7%9A%84Video_Codec_SDK%E4%B8%AD%E5%8F%82%E8%80%83%E4%BE%8B%E7%A8%8B%E7%9A%84%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%90%AD%E5%BB%BAAppDecGL%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>首先我们cd到Samples文件夹中,打算开命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code .</span><br></pre></td></tr></table></figure><p>等待vscode打开后，接着在AppDecGL.cpp文件的110行上打一个断点．</p><h1 id="配置launch-json调试脚本"><a href="#配置launch-json调试脚本" class="headerlink" title="配置launch.json调试脚本"></a>配置launch.json调试脚本</h1><p>接着在VS Code中同时按下Ctrl + Shift + P打开输入”launch.json”。</p><p>如果没有这个选项的话，那就同时按下Ctrl + Shift + D，选择创建一个”launch.json”，点击Web app(Egd)</p><p>接着在launch.json文件中输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) AppDecGL Launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span>   <span class="comment">//正在使用的调试器,使用Visual Studio Windows时必须为cppvsdbg,使用GDB或LLDB时必须为cppdbg.</span></span><br><span class="line">          <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span>  <span class="comment">//表示此配置是用于启动程序还是附加到已运行的实例上</span></span><br><span class="line">          <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/ws/Desktop/Nvida/Video_Codec_SDK_11.1.5/Samples/build_linux/AppDecGL&quot;</span><span class="punctuation">,</span>   <span class="comment">//要执行的可执行文件的完整路径</span></span><br><span class="line">          <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span>            <span class="comment">//设置调试器启动的应用程序的工作目录</span></span><br><span class="line">          <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span>   <span class="comment">//要连接的调试器</span></span><br><span class="line">          <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此时，我们如果直接点击右上角的三角形符号，选择Debug C&#x2F;C++ File，接着在弹出框中选择打开(gdb) AppDecGL Launch的话，会直接运行程序，而我们在cpp文件中打的断点是无法命中的，因为我们之前用cmake编译生成出来的可执行文件是不包含Debug调试信息的．</p><p>为了方便我们调试信息，同时也方便后面对程序进行修改和单独编译，此时我们用两种方法</p><h2 id="方法一：改变Cmake的CMAKE-BUILD-TYPE为Debug"><a href="#方法一：改变Cmake的CMAKE-BUILD-TYPE为Debug" class="headerlink" title="方法一：改变Cmake的CMAKE_BUILD_TYPE为Debug"></a>方法一：改变Cmake的CMAKE_BUILD_TYPE为Debug</h2><p>先把build_linux文件夹清空，<br>接着在命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake .. -DCMAKE_BUILD_TYPE=Debug</span><br><span class="line">make -j 20 #我的电脑是２０核CPU，如果不知道CPU核数的话，可以直接输入make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>此时编译出来的可执行文件就包含着调试信息，我们就可以直接通过launch,json脚本来调试程序了<br><img src="/./picture/Video_Codec_SDK%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2/1.png"></p><h2 id="方法二：需要通过AppDecGL文件夹中的CMakeList-txt文件来配置编译的json脚本"><a href="#方法二：需要通过AppDecGL文件夹中的CMakeList-txt文件来配置编译的json脚本" class="headerlink" title="方法二：需要通过AppDecGL文件夹中的CMakeList.txt文件来配置编译的json脚本"></a>方法二：需要通过AppDecGL文件夹中的CMakeList.txt文件来配置编译的json脚本</h2><p>具体可参考这篇<a href="https://blog.csdn.net/wanzew/article/details/83097457">文章</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++ build active file&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/g++&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-L /usr/local/cuda-11.8/targets/x86_64-linux/lib&quot;</span><span class="punctuation">,</span><span class="string">&quot;-I /usr/local/cuda-11.8/targets/x86_64-linux/include&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Task generated by Debugger.&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/usr/local/cuda-11.8/targets/x86_64-linux/include&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/../Interface&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/NvCodec&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/AppTranscode&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/Utils&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/External&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c11&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gnu++14&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux-gcc-x64&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>注：请安装如下2个VS Code插件：C&#x2F;C++、C&#x2F;C++ Runner</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Nvida的Video_Codec_SDK中参考例程的讲解（一）：编译Sample样例</title>
      <link href="/2023/01/10/Nvida%E7%9A%84Video_Codec_SDK%E4%B8%AD%E5%8F%82%E8%80%83%E4%BE%8B%E7%A8%8B%E7%9A%84%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BC%96%E8%AF%91Sample%E6%A0%B7%E4%BE%8B/"/>
      <url>/2023/01/10/Nvida%E7%9A%84Video_Codec_SDK%E4%B8%AD%E5%8F%82%E8%80%83%E4%BE%8B%E7%A8%8B%E7%9A%84%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BC%96%E8%AF%91Sample%E6%A0%B7%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>现在我们通过Nvida提供的Video_Codec_SDK中的Sample来学习硬件解码编码相关知识</p><h1 id="1-前期准备："><a href="#1-前期准备：" class="headerlink" title="1 前期准备："></a>1 前期准备：</h1><p>先阅读完Nvida的这个<a href="https://docs.nvidia.com/video-technologies/video-codec-sdk/ffmpeg-with-nvidia-gpu/index.html">文档</a></p><p>接着下载FFmpeg以及与Nvidia编解码器API接口所需的FFmpeg版本的标头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone -b release/xx  https://git.ffmpeg.org/ffmpeg.git</span><br><span class="line">git clone -b sdk/xx https://github.com/FFmpeg/nv-codec-headers.git</span><br></pre></td></tr></table></figure><p><a href="https://www.nvidia.com/Download/index.aspx?lang=en-us">下载对应的Nvida驱动程序</a></p><p><a href="https://wujianqiangcode.github.io/Linux%E4%B8%8BNvidia%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4">安装Nvidia驱动教程</a></p><p><a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux&target_arch=x86_64&Distribution=Ubuntu&target_version=20.04">下载CUDA Toolkit</a></p><p><a href="https://developer.nvidia.com/nvidia-video-codec-sdk/download">下载Nvida的Video_Codec_SDK</a></p><p>接着下载CUDA演示样例验证是否成功安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/NVIDIA/cuda-samples.git</span><br></pre></td></tr></table></figure><p>注：如果make后提示找不到glut的话，输入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install libgl1-mesa-dev</span><br><span class="line">sudo apt-get install libglu1-mesa-dev</span><br><span class="line">sudo apt-get install libglut-dev</span><br></pre></td></tr></table></figure><p>出现：E: 无法定位软件包 libglut-dev，执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install freeglut3-dev</span><br></pre></td></tr></table></figure><p>如果成功显示该画面就说明安装成功：<br><img src="/./picture/Video_Codec_SDK%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1/CUDA%E6%BC%94%E7%A4%BA%E6%A0%B7%E4%BE%8B%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5.png"></p><p>接着可以用cmake工具构建一下Video_Codec_SDK里面的Samples，如果能成功构建，那么就代表CUDA Toolkit安装成功了。<br><img src="/./picture/Video_Codec_SDK%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1/%E9%AA%8C%E8%AF%81CUDA%20Toolkit%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png"></p><h1 id="Ubuntu下编译Sample文件夹中的例程"><a href="#Ubuntu下编译Sample文件夹中的例程" class="headerlink" title="Ubuntu下编译Sample文件夹中的例程"></a>Ubuntu下编译Sample文件夹中的例程</h1><h2 id="设置FFmpeg库路径"><a href="#设置FFmpeg库路径" class="headerlink" title="设置FFmpeg库路径"></a>设置FFmpeg库路径</h2><p>首先进入Sample文件夹中，打开CMakeList.txt文件，可以看出文档中有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(NV_FFMPEG_HDRS $&#123;PC_AVCODEC_INCLUDE_DIRS&#125;)</span><br></pre></td></tr></table></figure><p>因此，如果你已经安装完成ffmpeg的话，我们就可以直接指定一下FFmpeg所在的目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PKG_CONFIG_PATH=/usr/local/ffmpeg/lib/pkgconfig</span><br></pre></td></tr></table></figure><h2 id="安装vulkan"><a href="#安装vulkan" class="headerlink" title="安装vulkan"></a>安装vulkan</h2><p>命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa</span><br><span class="line">sudo apt upgrade</span><br><span class="line"> </span><br><span class="line">sudo apt-get install vulkan-tools vulkan-utils libvulkan1 libvulkan-dev  #如果装不下来就一直装，会慢慢装成功的</span><br><span class="line"> </span><br><span class="line">sudo add-apt-repository -r ppa:graphics-drivers/ppa   #最后移除这个新加的repository</span><br></pre></td></tr></table></figure><h2 id="安装GL相关的库"><a href="#安装GL相关的库" class="headerlink" title="安装GL相关的库"></a>安装GL相关的库</h2><p>命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libgl1-mesa-dev libglu1-mesa-dev freeglut3-dev</span><br><span class="line"> </span><br><span class="line">sudo apt-cache search glew  #先用这行查看libglew的可用版本，下面的libglew2.0改成你的可用版本</span><br><span class="line">sudo apt-get install libglew2.0 libglew-dev</span><br></pre></td></tr></table></figure><h2 id="Sample的编译与验证"><a href="#Sample的编译与验证" class="headerlink" title="Sample的编译与验证"></a>Sample的编译与验证</h2><p>随后进入AppDecGL文件夹，打开AppDecGL.cpp，跳到110行，将main()的szInFilePath的值为你的某一个视频文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> szInFilePath[<span class="number">256</span>] = <span class="string">&quot;/home/ws/Videos/1.mp4&quot;</span>;</span><br></pre></td></tr></table></figure><p>接着回到Sample文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd ./Video_Codec_SDK_10.0.26/Samples</span><br><span class="line">mkdir build</span><br><span class="line">cd build/</span><br><span class="line">cmake ..</span><br><span class="line">make -j 20 #我的电脑是２０核CPU，如果不知道CPU核数的话，可以直接输入make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>接着运行例程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./AppDecGL</span><br></pre></td></tr></table></figure><p>此时将会显示视频画面窗口，同时命令行窗口也会显示以下信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GPU in use: NVIDIA GeForce RTX 3060 Ti</span><br><span class="line">Decode with NvDecoder.</span><br><span class="line">[INFO ][15:46:13] Media format: QuickTime / MOV (mov,mp4,m4a,3gp,3g2,mj2)</span><br><span class="line">Session Initialization Time: 33 ms </span><br><span class="line">[INFO ][15:46:13] Video Input Information</span><br><span class="line">Codec        : AVC/H.264</span><br><span class="line">Frame rate   : 30/1 = 30 fps</span><br><span class="line">Sequence     : Progressive</span><br><span class="line">Coded size   : [3840, 2160]</span><br><span class="line">Display area : [0, 0, 3840, 2160]</span><br><span class="line">Chroma       : YUV 420</span><br><span class="line">Bit depth    : 8</span><br><span class="line">Video Decoding Params:</span><br><span class="line">Num Surfaces : 4</span><br><span class="line">Crop         : [0, 0, 0, 0]</span><br><span class="line">Resize       : 3840x2160</span><br><span class="line">Deinterlace  : Weave</span><br><span class="line"></span><br><span class="line">Total frame decoded: 6635</span><br><span class="line">XIO:  fatal IO error 17 (File exists) on X server &quot;:1&quot;</span><br><span class="line">      after 77 requests (77 known processed) with 0 events remaining.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>后续章节我们将通过讲解Nvida的Video_Codec_SDK中的Sample来学习硬件解码编码的相关知识点</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下的Nvidia驱动的安装步骤</title>
      <link href="/2023/01/05/Linux%E4%B8%8BNvidia%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/"/>
      <url>/2023/01/05/Linux%E4%B8%8BNvidia%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>安装对应的必备软件和依赖</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update  </span><br><span class="line">sudo apt-get install g++</span><br><span class="line">sudo apt-get install gcc</span><br><span class="line">sudo apt-get install make</span><br></pre></td></tr></table></figure><h1 id="查看GPU型号"><a href="#查看GPU型号" class="headerlink" title="查看GPU型号"></a>查看GPU型号</h1><p>接着查看一下GPU型号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci | grep -i vga</span><br></pre></td></tr></table></figure><p>返回结果如下：</p><p><font color = yellow>ws@wujianqiang-ubuntu-18</font>:~$ lspci | grep -i vga</p><p>65:00.0 <font color = red>VGA</font> compatible controller: NVIDIA Corporation Device 2489 (rev a1)</p><p><font color = yellow>ws@wujianqiang-ubuntu-18</font>:~$ </p><p>通过序列号在<a href="https://devicehunt.com/view/type/pci/vendor/10DE/device/2489">该网站</a>上查看显卡型号</p><h1 id="官网下载驱动"><a href="#官网下载驱动" class="headerlink" title="官网下载驱动"></a>官网下载驱动</h1><p>接着我们去<a href="https://www.nvidia.com/Download/index.aspx?lang=en-us">Nvida官网</a>下载对应驱动</p><h1 id="卸载原有的驱动"><a href="#卸载原有的驱动" class="headerlink" title="卸载原有的驱动"></a>卸载原有的驱动</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove --purge nvidia*</span><br></pre></td></tr></table></figure><h1 id="禁用nouveau"><a href="#禁用nouveau" class="headerlink" title="禁用nouveau"></a>禁用nouveau</h1><p>nouveau是通用驱动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/modprobe.d/blacklist.conf </span><br></pre></td></tr></table></figure><p>接着在打开的文集尾部加上这两句话</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset=0</span><br></pre></td></tr></table></figure><p>然后输入该命令进行更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-initramfs –u</span><br></pre></td></tr></table></figure><p>最后重启电脑后输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep nouveau</span><br></pre></td></tr></table></figure><p>如果没有显示任何输出，则证明屏蔽成功</p><h1 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h1><p>输入以下命令，停止当前显示服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo telinit 3</span><br></pre></td></tr></table></figure><p>等待界面黑屏后，按下Ctrl+Alt+F1，等待弹出login，然后输入对应帐号密码（帐号是root，密码就是您登录ubuntu的密码）<br><font color =red>注：在该界面下进行输入时，键盘右侧的数字键盘处于无法使用的状态</font></p><p>登录成功后，接着输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -a</span><br><span class="line">sudo /home/ws/...... #进入到你下载的驱动的对应位置</span><br><span class="line">sudo chmod 777 NVIDIA-Linux-x86_64-515.76.run #给该驱动文集授权</span><br></pre></td></tr></table></figure><p>接着，如果是台式机的话输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./NVIDIA-Linux-x86_64-515.76.run </span><br></pre></td></tr></table></figure><p>如果是笔记本的话输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./NVIDIA-Linux-x86_64-515.76.run （–no-opengl-files）</span><br></pre></td></tr></table></figure><p><font color =red>注：笔记本一定要加上–no-opengl-files，否则会出现循环登录现象，也就是loop login</font></p><h1 id="安装过程中的选项"><a href="#安装过程中的选项" class="headerlink" title="安装过程中的选项"></a>安装过程中的选项</h1><p>1.The distribution-provided pre-install script failed! Are you sure you want to continue?<br>选择continue installation</p><p>2.Would you like to register the kernel module souces with DKMS? This will allow DKMS to automatically build a new module, if you install a different kernel later?<br>选择 No </p><p>3.问题没记住，选项是：install without signing</p><p>4.问题大概是：Nvidia’s 32-bit compatibility libraries? 选择 No 继续。</p><p>5.Would you like to run the nvidia-xconfigutility to automatically update your x configuration so that the NVIDIA x driver will be used when you restart x? Any pre-existing x confile will be backed up.<br>选择 Yes </p><p>安装成功后重启电脑，接着命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>出现以下界面则表示安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Tue Oct 25 14:19:45 2022       </span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 515.76       Driver Version: 515.76       CUDA Version: 11.7     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                               |                      |               MIG M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  NVIDIA GeForce ...  Off  | 00000000:65:00.0  On |                  N/A |</span><br><span class="line">|  0%   43C    P8    11W / 200W |    600MiB /  8192MiB |      0%      Default |</span><br><span class="line">|                               |                      |                  N/A |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">                                                                               </span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                                  |</span><br><span class="line">|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |</span><br><span class="line">|        ID   ID                                                   Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">|    0   N/A  N/A      1258      G   /usr/lib/xorg/Xorg                 24MiB |</span><br><span class="line">|    0   N/A  N/A      1308      G   /usr/bin/gnome-shell               82MiB |</span><br><span class="line">|    0   N/A  N/A      1579      G   /usr/lib/xorg/Xorg                317MiB |</span><br><span class="line">|    0   N/A  N/A      1712      G   /usr/bin/gnome-shell               68MiB |</span><br><span class="line">|    0   N/A  N/A      2061      G   ...AAAAAAAAA= --shared-files       20MiB |</span><br><span class="line">|    0   N/A  N/A      4948      G   ...RendererForSitePerProcess       72MiB |</span><br><span class="line">|    0   N/A  N/A      6319      G   ...264068829843617026,131072       10MiB |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何通过FFmpeg抽取视频数据</title>
      <link href="/2022/11/25/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87FFmpeg%E6%8A%BD%E5%8F%96%E8%A7%86%E9%A2%91%E6%95%B0%E6%8D%AE/"/>
      <url>/2022/11/25/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87FFmpeg%E6%8A%BD%E5%8F%96%E8%A7%86%E9%A2%91%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>FFmpeg抽取视频数据的具体步骤其实和上一篇文章讲的FFmpeg抽取音频数据的步骤差不多。程序中唯二两个需要修改的地方是：</p><ul><li>av_find_best_stream函数中的输入参数AVMEDIA_TYPE_AUDIO需要修改成AVMEDIA_TYPE_VIDEO</li><li>视频的pkt.dts不能直接与pkt.pts直接相等（因为视频中可能存在B帧），需要跟pkt.pts一样通过av_rescale_q_rnd函数进行转换</li></ul><p>抽取视频主要有以下几个步骤：</p><ul><li>参数的初始化</li><li>打开多媒体文件</li><li>从多媒体文件中找到视频流</li><li>打开目的文件到上下文</li><li>为目的文件创建一个新的视频流</li><li>设置输出视频参数</li><li>写多媒体文件头到目的文件</li><li>从多媒体文件中读出视频数据到目的文件中</li><li>写多媒体文件尾到文件中</li><li>将申请的资源释放掉</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/avutil.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.处理一些参数</span></span><br><span class="line">    <span class="type">char</span>* src;</span><br><span class="line">    <span class="type">char</span>* dst;</span><br><span class="line"></span><br><span class="line">    AVFormatContext *pFmtCtx = <span class="literal">NULL</span>;</span><br><span class="line">    AVFormatContext *oFmtCtx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    AVOutputFormat *outFmt = <span class="literal">NULL</span>;</span><br><span class="line">    AVStream *outStream = <span class="literal">NULL</span>;</span><br><span class="line">    AVStream *inStream = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    AVPacket pkt;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_log_set_level</span>(AV_LOG_DEBUG);</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;<span class="number">3</span>)&#123;<span class="comment">//argv[0]:extra_video;argv[1]:源数据；argv[2]:目的数据；</span></span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">&quot;arguments must be more than 3&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    src = argv[<span class="number">1</span>];</span><br><span class="line">    dst = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.打开多媒体文件</span></span><br><span class="line">    ret = <span class="built_in">avformat_open_input</span>(&amp;pFmtCtx,src,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;%s\n&quot;</span>,<span class="built_in">av_err2str</span>(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.从多媒体文件中找到视频流</span></span><br><span class="line">    idx = <span class="built_in">av_find_best_stream</span>(pFmtCtx, AVMEDIA_TYPE_VIDEO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(idx &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">av_log</span>(pFmtCtx, AV_LOG_ERROR, <span class="string">&quot;Does not include video&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> _ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.打开目的文件到上下文</span></span><br><span class="line">    oFmtCtx = <span class="built_in">avformat_alloc_context</span>();</span><br><span class="line">    <span class="keyword">if</span>(!oFmtCtx)&#123;</span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;NO Memory!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> _ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    outFmt = <span class="built_in">av_guess_format</span>(<span class="literal">NULL</span>, dst, <span class="literal">NULL</span>);</span><br><span class="line">    oFmtCtx-&gt;oformat =outFmt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.为目的文件创建一个新的视频流</span></span><br><span class="line">    outStream = <span class="built_in">avformat_new_stream</span>(oFmtCtx, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.设置输出视频参数</span></span><br><span class="line">    inStream = pFmtCtx-&gt;streams[idx];</span><br><span class="line">    <span class="built_in">avcodec_parameters_copy</span>(outStream-&gt;codecpar, inStream-&gt;codecpar);</span><br><span class="line">    outStream-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;<span class="comment">//设置为0的话，会自动适配合适的编解码器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    ret = <span class="built_in">avio_open2</span>(&amp;oFmtCtx-&gt;pb, dst, AVIO_FLAG_WRITE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">av_log</span>(oFmtCtx, AV_LOG_ERROR, <span class="string">&quot;%s&quot;</span>, <span class="built_in">av_err2str</span>(ret));</span><br><span class="line">        <span class="keyword">goto</span> _ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.写多媒体文件头到目的文件</span></span><br><span class="line">    ret = <span class="built_in">avformat_write_header</span>(oFmtCtx, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">av_log</span>(oFmtCtx, AV_LOG_ERROR, <span class="string">&quot;%s&quot;</span>, <span class="built_in">av_err2str</span>(ret));</span><br><span class="line">        <span class="keyword">goto</span> _ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//8.从多媒体文件中读出视频数据到目的文件中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">av_read_frame</span>(pFmtCtx, &amp;pkt)  &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pkt.stream_index == idx)&#123;<span class="comment">//判断是否是要读取的音频帧</span></span><br><span class="line">            pkt.pts = <span class="built_in">av_rescale_q_rnd</span>(pkt.pts, inStream-&gt;time_base, outStream-&gt;time_base, (AV_ROUND_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">            pkt.dts = <span class="built_in">av_rescale_q_rnd</span>(pkt.dts, inStream-&gt;time_base, outStream-&gt;time_base, (AV_ROUND_INF | AV_ROUND_PASS_MINMAX));<span class="comment">//视频的dts和pts可能是不同的</span></span><br><span class="line">            pkt.duration = <span class="built_in">av_rescale_q</span>(pkt.duration, inStream-&gt;time_base, outStream-&gt;time_base);</span><br><span class="line">            pkt.stream_index = <span class="number">0</span>;</span><br><span class="line">            pkt.pos = <span class="number">-1</span>;<span class="comment">//设置为-1时，则会自动计算</span></span><br><span class="line">            <span class="built_in">av_interleaved_write_frame</span>(oFmtCtx, &amp;pkt);</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(&amp;pkt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//9.写多媒体文件尾到文件中</span></span><br><span class="line">    <span class="built_in">av_write_trailer</span>(oFmtCtx);</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//10.将申请的资源释放掉</span></span><br><span class="line">_ERROR:</span><br><span class="line">    <span class="keyword">if</span>(pFmtCtx)&#123;</span><br><span class="line">        <span class="built_in">avformat_close_input</span>(&amp;pFmtCtx);</span><br><span class="line">        pFmtCtx = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(oFmtCtx-&gt;pb)&#123;</span><br><span class="line">        <span class="built_in">avio_close</span>(oFmtCtx-&gt;pb);<span class="comment">//关闭目标文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(oFmtCtx)&#123;</span><br><span class="line">        <span class="built_in">avformat_free_context</span>(oFmtCtx);</span><br><span class="line">        oFmtCtx = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello ffmpeg&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将代码文件保存成extra_audio.c文件，并在当前路径下建立一个build.sh文件，打开该文件后，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">clang -g -o extra_video extra_video.c `pkg-config --libs --cflags libavutil libavformat libavcodec`</span><br></pre></td></tr></table></figure><p>保存退出后，在当前路径下打开命令行窗口，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build.sh</span><br></pre></td></tr></table></figure><p>如果没有报错信息出现，那么就证明我们完成了该文件的编译工作，接着就能在当前路径上看到我们生成的extra_audio可执行程序文件和extra_audio.dSYM这个具备调试信息的目标文件。</p><p>接着我们找个具备音频信息的文件来进行演示，我们可以先用ffplay播放一下这个文件，以下是我这边通过ffplay播放该文件时，命令行窗口输出的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input #0, mov,mp4,m4a,3gp,3g2,mj2, from &#x27;1.mp4&#x27;:</span><br><span class="line">  Metadata:</span><br><span class="line">    major_brand     : isom</span><br><span class="line">    minor_version   : 512</span><br><span class="line">    compatible_brands: isomiso2avc1mp41</span><br><span class="line">    comment         : vid:v0200fg10000cbuq3hjc77ua8dieuid0</span><br><span class="line">    encoder         : Lavf58.45.100</span><br><span class="line">  Duration: 00:00:35.32, start: 0.000000, bitrate: 2348 kb/s</span><br><span class="line">    Stream #0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(tv, bt709), 720x1280 [SAR 1:1 DAR 9:16], 2217 kb/s, 29.83 fps, 30 tbr, 15360 tbn, 60 tbc (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      handler_name    : VideoHandler</span><br><span class="line">    Stream #0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 128 kb/s (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      handler_name    : SoundHandler</span><br><span class="line">   7.79 A-V: -0.024 fd=   6 aq=   23KB vq=  247KB sq=    0B f=0/0   </span><br></pre></td></tr></table></figure><p>可以看到该文件一共有两路流。<br>一路上视频流（h264）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream #0:0(und): Video: h264 (High)</span><br></pre></td></tr></table></figure><p>一路是音频流(aac)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream #0:1(und): Audio: aac (LC)</span><br></pre></td></tr></table></figure><p>此时我们在命令行窗口输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code .</span><br></pre></td></tr></table></figure><p>打开vscode后，在lauch.json文件中输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(lldb) 启动&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;/Users/wujianqiang/Desktop/1.mp4&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;1.h264&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我们要抽取的1.mp4放在&#x2F;Users&#x2F;wujianqiang&#x2F;Desktop路径下，而抽取后生成的文件起名为1.h264</p><p>设置好后，我们启动程序，此时就可以进行代码的调试了。</p><p>此时，我们将最终生成的1.h264文件，通过ffplay进行播放时，命令行输出的窗口信息为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input #0, h264, from &#x27;/Users/wujianqiang/Desktop/LearningFFmpegNotes/ectra_video/1.h264&#x27;:</span><br><span class="line">  Duration: N/A, bitrate: N/A</span><br><span class="line">    Stream #0:0: Video: h264 (High), yuv420p(tv, bt709, progressive), 720x1280 [SAR 1:1 DAR 9:16], 30 fps, 30 tbr, 1200k tbn, 60 tbc</span><br><span class="line">    nan M-V:    nan fd=   0 aq=    0KB vq=  229KB sq=    0B f=0/0 </span><br></pre></td></tr></table></figure><p>此时我们与原视频信息进行对比后可以发现，由于1.h264是不带视频信息的视频压缩数据，因此不具备原始视频的相关信息，至于为什么1.h264文件的帧率是30帧，那是因为ffmpeg默认的h264输出的视频帧率是30帧，如果将</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何通过FFmpeg抽取音频数据</title>
      <link href="/2022/11/25/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87FFmpeg%E6%8A%BD%E5%8F%96%E9%9F%B3%E9%A2%91%E6%95%B0%E6%8D%AE/"/>
      <url>/2022/11/25/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87FFmpeg%E6%8A%BD%E5%8F%96%E9%9F%B3%E9%A2%91%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>抽取音频主要有以下几个步骤：</p><ul><li>参数的初始化</li><li>打开多媒体文件</li><li>从多媒体文件中找到音频流</li><li>打开目的文件到上下文</li><li>为目的文件创建一个新的音频流</li><li>设置输出音频参数</li><li>写多媒体文件头到目的文件</li><li>从多媒体文件中读出音频数据到目的文件中</li><li>写多媒体文件尾到文件中</li><li>将申请的资源释放掉</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/avutil.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.处理一些参数</span></span><br><span class="line">    <span class="type">char</span>* src;</span><br><span class="line">    <span class="type">char</span>* dst;</span><br><span class="line"></span><br><span class="line">    AVFormatContext *pFmtCtx = <span class="literal">NULL</span>;</span><br><span class="line">    AVFormatContext *oFmtCtx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    AVOutputFormat *outFmt = <span class="literal">NULL</span>;</span><br><span class="line">    AVStream *outStream = <span class="literal">NULL</span>;</span><br><span class="line">    AVStream *inStream = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    AVPacket pkt;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_log_set_level</span>(AV_LOG_DEBUG);</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;<span class="number">3</span>)&#123;<span class="comment">//argv[0]:extra_audio;argv[1]:源数据；argv[2]:目的数据；</span></span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">&quot;arguments must be more than 3&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    src = argv[<span class="number">1</span>];</span><br><span class="line">    dst = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.打开多媒体文件</span></span><br><span class="line">    ret = <span class="built_in">avformat_open_input</span>(&amp;pFmtCtx,src,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;%s\n&quot;</span>,<span class="built_in">av_err2str</span>(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.从多媒体文件中找到音频流</span></span><br><span class="line">    idx = <span class="built_in">av_find_best_stream</span>(pFmtCtx, AVMEDIA_TYPE_AUDIO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(idx &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">av_log</span>(pFmtCtx, AV_LOG_ERROR, <span class="string">&quot;Does not include audio&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> _ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.打开目的文件到上下文</span></span><br><span class="line">    oFmtCtx = <span class="built_in">avformat_alloc_context</span>();</span><br><span class="line">    <span class="keyword">if</span>(!oFmtCtx)&#123;</span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;NO Memory!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> _ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    outFmt = <span class="built_in">av_guess_format</span>(<span class="literal">NULL</span>, dst, <span class="literal">NULL</span>);</span><br><span class="line">    oFmtCtx-&gt;oformat =outFmt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.为目的文件创建一个新的音频流</span></span><br><span class="line">    outStream = <span class="built_in">avformat_new_stream</span>(oFmtCtx, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.设置输出音频参数</span></span><br><span class="line">    inStream = pFmtCtx-&gt;streams[idx];</span><br><span class="line">    <span class="built_in">avcodec_parameters_copy</span>(outStream-&gt;codecpar, inStream-&gt;codecpar);</span><br><span class="line">    outStream-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;<span class="comment">//设置为0的话，会自动适配合适的编解码器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    ret = <span class="built_in">avio_open2</span>(&amp;oFmtCtx-&gt;pb, dst, AVIO_FLAG_WRITE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">av_log</span>(oFmtCtx, AV_LOG_ERROR, <span class="string">&quot;%s&quot;</span>, <span class="built_in">av_err2str</span>(ret));</span><br><span class="line">        <span class="keyword">goto</span> _ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.写多媒体文件头到目的文件</span></span><br><span class="line">    ret = <span class="built_in">avformat_write_header</span>(oFmtCtx, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">av_log</span>(oFmtCtx, AV_LOG_ERROR, <span class="string">&quot;%s&quot;</span>, <span class="built_in">av_err2str</span>(ret));</span><br><span class="line">        <span class="keyword">goto</span> _ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//8.从多媒体文件中读出音频数据到目的文件中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">av_read_frame</span>(pFmtCtx, &amp;pkt)  &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pkt.stream_index == idx)&#123;<span class="comment">//判断是否是要读取的音频帧</span></span><br><span class="line">            pkt.pts = <span class="built_in">av_rescale_q_rnd</span>(pkt.pts, inStream-&gt;time_base, outStream-&gt;time_base, (AV_ROUND_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">            pkt.dts = pkt.pts;<span class="comment">//音频的dts和pts是相同的</span></span><br><span class="line">            pkt.duration = <span class="built_in">av_rescale_q</span>(pkt.duration, inStream-&gt;time_base, outStream-&gt;time_base);</span><br><span class="line">            pkt.stream_index = <span class="number">0</span>;</span><br><span class="line">            pkt.pos = <span class="number">-1</span>;<span class="comment">//设置为-1时，则会自动计算</span></span><br><span class="line">            <span class="built_in">av_interleaved_write_frame</span>(oFmtCtx, &amp;pkt);</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(&amp;pkt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//9.写多媒体文件尾到文件中</span></span><br><span class="line">    <span class="built_in">av_write_trailer</span>(oFmtCtx);</span><br><span class="line">    <span class="comment">//10.将申请的资源释放掉</span></span><br><span class="line"></span><br><span class="line">_ERROR:</span><br><span class="line">    <span class="keyword">if</span>(pFmtCtx)&#123;</span><br><span class="line">        <span class="built_in">avformat_close_input</span>(&amp;pFmtCtx);</span><br><span class="line">        pFmtCtx = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(oFmtCtx-&gt;pb)&#123;</span><br><span class="line">        <span class="built_in">avio_close</span>(oFmtCtx-&gt;pb);<span class="comment">//关闭目标文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(oFmtCtx)&#123;</span><br><span class="line">        <span class="built_in">avformat_free_context</span>(oFmtCtx);</span><br><span class="line">        oFmtCtx = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello ffmpeg&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将代码文件保存成extra_audio.c文件，并在当前路径下建立一个build.sh文件，打开该文件后，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">clang -g -o extra_audio extra_audio.c `pkg-config --libs --cflags libavutil libavformat libavcodec`</span><br></pre></td></tr></table></figure><p>保存退出后，在当前路径下打开命令行窗口，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build.sh</span><br></pre></td></tr></table></figure><p>如果没有报错信息出现，那么就证明我们完成了该文件的编译工作，接着就能在当前路径上看到我们生成的extra_audio可执行程序文件和extra_audio.dSYM这个具备调试信息的目标文件。</p><p>接着我们找个具备音频信息的文件来进行演示，我们可以先用ffplay播放一下这个文件，以下是我这边通过ffplay播放该文件时，命令行窗口输出的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input #0, mov,mp4,m4a,3gp,3g2,mj2, from &#x27;1.mp4&#x27;:</span><br><span class="line">  Metadata:</span><br><span class="line">    major_brand     : isom</span><br><span class="line">    minor_version   : 512</span><br><span class="line">    compatible_brands: isomiso2avc1mp41</span><br><span class="line">    comment         : vid:v0200fg10000cbuq3hjc77ua8dieuid0</span><br><span class="line">    encoder         : Lavf58.45.100</span><br><span class="line">  Duration: 00:00:35.32, start: 0.000000, bitrate: 2348 kb/s</span><br><span class="line">    Stream #0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(tv, bt709), 720x1280 [SAR 1:1 DAR 9:16], 2217 kb/s, 29.83 fps, 30 tbr, 15360 tbn, 60 tbc (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      handler_name    : VideoHandler</span><br><span class="line">    Stream #0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 128 kb/s (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      handler_name    : SoundHandler</span><br><span class="line">   7.79 A-V: -0.024 fd=   6 aq=   23KB vq=  247KB sq=    0B f=0/0   </span><br></pre></td></tr></table></figure><p>可以看到该文件一共有两路流。<br>一路上视频流（h264）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream #0:0(und): Video: h264 (High)</span><br></pre></td></tr></table></figure><p>一路是音频流(aac)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream #0:1(und): Audio: aac (LC)</span><br></pre></td></tr></table></figure><p>此时我们在命令行窗口输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code .</span><br></pre></td></tr></table></figure><p>打开vscode后，在lauch.json文件中输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(lldb) 启动&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;/Users/wujianqiang/Desktop/1.mp4&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;1.aac&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我们要抽取的1.mp4放在&#x2F;Users&#x2F;wujianqiang&#x2F;Desktop路径下，而抽取后生成的文件起名为1.aac</p><p>设置好后，我们启动程序，此时就可以进行代码的调试了。<br><img src="/./picture/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87FFmpeg%E6%8A%BD%E5%8F%96%E9%9F%B3%E9%A2%91%E6%95%B0%E6%8D%AE/1.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多媒体基本概念</title>
      <link href="/2022/11/12/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/11/12/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="多媒体基本概念"><a href="#多媒体基本概念" class="headerlink" title="多媒体基本概念"></a>多媒体基本概念</h1><ul><li>多媒体文件其实上一个容器</li><li>在容器里有很多流（Stream&#x2F;Track）</li><li>每种流（轨道）是不同的编码器编码的</li><li>从流（轨道）中读出的数据称为包</li><li>在一个包中包含着一个或多个帧（这些帧数据都是被编码器压缩处理过的数据）</li></ul><p>注：流和轨道是同一个意思，在容器里的多个流（轨道）之间是平行关系，也就是说，无论是不同种类的流之间（视频、音频还是字幕流之间），还是视频流和视频流（音频流和音频流、字幕流和字幕流）之间，每个流和轨道之间都是平行关系，数据互相独立不交互</p><h1 id="FFmpeg几个重要的结构体"><a href="#FFmpeg几个重要的结构体" class="headerlink" title="FFmpeg几个重要的结构体"></a>FFmpeg几个重要的结构体</h1><ul><li>AVFormatContext<br>格式上下文，它说链接多个API之间的桥梁</li><li>AVStream<br>可以通过AVStream读取文件的流</li><li>AVPacket<br>可以通过AVStream中得到一个个AVPacket包（里面存放的就是压缩后的帧数据），之后就能通过解码器还原每个包中的帧原始数据</li></ul><h1 id="FFmpeg操作流数据的基本步骤"><a href="#FFmpeg操作流数据的基本步骤" class="headerlink" title="FFmpeg操作流数据的基本步骤"></a>FFmpeg操作流数据的基本步骤</h1><ul><li>解复用（打开容器的操作就是解复用）</li><li>获取流</li><li>读取数据包</li><li>解码数据包，获得原始数据</li><li>对原始数据进行操作（图片旋转，倍速播放，音频降噪等）</li><li>释放资源</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何使用VSCode调试自己写的ffmpeg代码</title>
      <link href="/2022/11/12/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8VSCode%E8%B0%83%E8%AF%95%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84ffmpeg%E4%BB%A3%E7%A0%81/"/>
      <url>/2022/11/12/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8VSCode%E8%B0%83%E8%AF%95%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84ffmpeg%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>打开命令行，进入到所要编译运行到.c文件下，接着在命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code .</span><br></pre></td></tr></table></figure><p>等待VSCode到打开</p><p>打开VSCode后，如果该.c文件中的#inlcude头文件无法寻找到，那么将鼠标放在该include该语句上，此时会提示检测到 #include 错误。请更新 includePath。已为此翻译单元。</p><p>此时点击编辑includePath设置。进入后在IntelliSense 配置<br>使用此编辑器编辑在基础 c_cpp_properties.json 文件中定义的 IntelliSense 设置。在此编辑器中所做的更改仅适用于所选的配置。要一次编辑多个配置，请转到 c_cpp_properties.json。<br>中点击c_cpp_properties.json。在”includePath”: 上添加头文件到相关路径</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Mac&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/usr/local/ffmpeg/include&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;macFrameworkPath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/clang&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;macos-clang-x64&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>接着点击vscode左上角终端里面的配置任务，打开tasks.json文件，输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/clang&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fcolor-diagnostics&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-fansi-escape-codes&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;`pkg-config --libs --cflags libavutil`&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>继续点击运行，如果出现以下报错:<br><img src="/./picture/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8VSCode%E8%B0%83%E8%AF%95%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84ffmpeg%E4%BB%A3%E7%A0%81/2.png"></p><p>则通过命令后进入当前文件夹，输入输入以下命令（这里用Log.c这个测试文件进行测试）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wujianqiang@wujianqiangdeMacBook-Pro ~ % cd /Users/wujianqiang/Desktop/LearningFFmpegNotes/av_log</span><br><span class="line">wujianqiang@wujianqiangdeMacBook-Pro av_log % vim build.sh</span><br></pre></td></tr></table></figure><p>接着在build.sh中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">clang -g -o Log Log.c `pkg-config --libs --cflags libavutil`</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>保存退出后，给该文件进行授权后，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wujianqiang@wujianqiangdeMacBook-Pro av_log % ls</span><br><span class="line">Log.cbuild.shloglog.dSYM</span><br><span class="line">wujianqiang@wujianqiangdeMacBook-Pro av_log % ./build.sh</span><br><span class="line">zsh: permission denied: ./build.sh</span><br><span class="line">wujianqiang@wujianqiangdeMacBook-Pro av_log % chmod +x build.sh </span><br><span class="line">wujianqiang@wujianqiangdeMacBook-Pro av_log % chmod 777 build.sh </span><br><span class="line">wujianqiang@wujianqiangdeMacBook-Pro av_log % ./build.sh </span><br><span class="line">wujianqiang@wujianqiangdeMacBook-Pro av_log % </span><br></pre></td></tr></table></figure><p>接着回到VSCode，点击右侧的三角运行标志，接着点击显示所有自动调试设置，添加配置,输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(lldb) 启动&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/./picture/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8VSCode%E8%B0%83%E8%AF%95%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84ffmpeg%E4%BB%A3%E7%A0%81/1.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac下编译可调式的Debug版本FFmpeg全过程</title>
      <link href="/2022/11/10/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%8F%AF%E8%B0%83%E8%AF%95%E7%9A%84Debug%E7%89%88%E6%9C%ACFFmpeg%EF%BC%8C%E5%B9%B6%E9%80%9A%E8%BF%87GDB%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/"/>
      <url>/2022/11/10/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%8F%AF%E8%B0%83%E8%AF%95%E7%9A%84Debug%E7%89%88%E6%9C%ACFFmpeg%EF%BC%8C%E5%B9%B6%E9%80%9A%E8%BF%87GDB%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>今天说一个比较好用的学习ffmpeg的方法。我们经常通过ffmpeg的命令来进行文件格式转换或者是查看文件的媒体信息。</p><p>如果这个时候，我们想知道ffmpeg在执行我们输入命令后的具体程序运行流程，那么，我们就需要编译一个可调式版本的ffmpeg。事实上，通过调试我们输入的ffmpeg命令，在一定程度上有利于我们加深对ffmpeg的理解与学习。</p><p>接下来，本文将通过以下几个步骤来演示如何调试ffmpeg</p><ul><li>ffmpeg的下载与编译</li><li>如何通过gdb调试ffmpeg</li><li>如何在vscode调试ffmpeg</li></ul><h1 id="FFmpeg的下载与编译"><a href="#FFmpeg的下载与编译" class="headerlink" title="FFmpeg的下载与编译"></a>FFmpeg的下载与编译</h1><p>输入以下参数进行下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b release/xx  https://git.ffmpeg.org/ffmpeg.git</span><br></pre></td></tr></table></figure><p>这边可以根据选择选择自己需要的ffmpeg版本</p><p>clone后的ffmpeg文件夹结构如下：</p><ul><li>libavcodec：用于各种类型声音&#x2F;图像编解码；</li><li>libavdevice：用于音视频数据采集和渲染等功能的设备相关;</li><li>libavfilter：包含多媒体处理常用的滤镜功能;</li><li>libavformat：包含多种多媒体容器格式的封装、解封装工具;</li><li>libavutil：包含一些公共的工具函数；</li><li>libpostproc：用于后期效果处理；</li><li>libswresample：用于音频重采样和格式转换等功能;</li><li>libswscale：用于视频场景比例缩放、色彩映射转换；</li></ul><p>接着进入ffmpeg文件夹，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/home/ws/Desktop/FFmpeg/4.2/FFmpeg4.2_debug/ --enable-shared --disable-optimizations --enable-debug --disable-x86asm --extra-cflags=-g --disable-stripping</span><br></pre></td></tr></table></figure><p>其中：</p><h2 id="prefix"><a href="#prefix" class="headerlink" title="prefix:"></a>prefix:</h2><p>生成的bin lib include share存放的位置</p><h2 id="shared"><a href="#shared" class="headerlink" title="shared:"></a>shared:</h2><p>ffmpeg生成的库一共有三个版本：static(静态库版本)、shared(动态库版本)、Dev(开发者版本)</p><ul><li>static: 里面只有3个应用程序：ffmpeg.exe，ffplay.exe，ffprobe.exe，每个exe的体积都很大，相关的Dll已经被编译到exe里面去了。作为工具而言此版本就可以满足我们的需求；</li><li>shared:里面除了3个应用程序：ffmpeg.exe，ffplay.exe，ffprobe.exe之外，还有一些Dll(或dylib或so)，比如说avcodec-54.dll之类的。shared里面的可执行程序体积很小，他们在运行的时候，到相应的Dll中调用功能。程序运行过程必须依赖于提供的dll文件；</li><li>dev:是用于开发的，里面包含了库文件xxx.lib以及头文件xxx.h，这个版本不包含exe文件。dev版本中include文件夹内文件用途</li></ul><h2 id="optimizations"><a href="#optimizations" class="headerlink" title="optimizations:"></a>optimizations:</h2><p>编译器优化，这个需要禁止</p><h2 id="debug"><a href="#debug" class="headerlink" title="debug:"></a>debug:</h2><p>是否生成可调试的ffmpeg</p><h2 id="x86asm"><a href="#x86asm" class="headerlink" title="x86asm:"></a>x86asm:</h2><p>独立x86程序集</p><h2 id="–extra-cflag"><a href="#–extra-cflag" class="headerlink" title="–extra-cflag:"></a>–extra-cflag:</h2><p>第三方库不在默认的include路径，则需要指定–extra-cflags&#x3D;-I&#x2F;xxxx&#x2F;include<br>extra-cflags的额外用法：比如–extra-cflags&#x3D;-Dxxx，-D的意思是宏，指的就是在编译的时候预定义了xxx这样的宏</p><h2 id="stripping"><a href="#stripping" class="headerlink" title="stripping:"></a>stripping:</h2><p>–disable-stripping：禁用剥离可执行文件和共享库</p><p>其他ffmpeg的相关配置参数具体含义，<a href="https://www.cnblogs.com/x_wukong/p/12746031.html">详见</a></p><p>等待configure检验完成后，接着输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure><p>如果想让编译的速度快一点可以查看一下电脑配置，通过make的-j命令（加速程序编译），比如我的电脑可以开到20</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make -j 20</span><br></pre></td></tr></table></figure><p>等待make运行结束后，再输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>此时，我们完成了FFmpeg的编译</p><h1 id="如何通过gdb调试ffmpeg"><a href="#如何通过gdb调试ffmpeg" class="headerlink" title="如何通过gdb调试ffmpeg"></a>如何通过gdb调试ffmpeg</h1><p>当我们完成FFmpeg后，我们可以在当前文件夹看到ffmpeg_g这个文件(带_g的就表示是可以调试的)<br>我们可以查看一下这个文件信息，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ffmpeg_g -version</span><br></pre></td></tr></table></figure><p>接着，运行gdb首，并指定ffmpeg_g作为调试程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./ffmpeg_g</span><br></pre></td></tr></table></figure><p>此时，我们可以验证一下是否可以调试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set args -version #设置运行参数linux 上使用 vscode debug ffmpeg ?</span><br><span class="line">b main #将断电打在main函数的入口处</span><br><span class="line">layout src #显示源码布局</span><br><span class="line">run #运行程序</span><br></pre></td></tr></table></figure><p>接着输入n后回车即可进行单步调试<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%8F%AF%E8%B0%83%E8%AF%95%E7%9A%84Debug%E7%89%88%E6%9C%ACFFmpeg%EF%BC%8C%E5%B9%B6%E9%80%9A%E8%BF%87GDB%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/1.png"></p><p>在此，我们继续演示一下如何进行调试。输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb ./ffmpeg_g</span><br><span class="line">set args -i &#x27;/home/ws/Videos/1.mp4&#x27;  #获取mp4信息</span><br><span class="line">b main #将断电打在main函数的入口处</span><br><span class="line">layout src #显示源码布局</span><br><span class="line">run #运行程序</span><br></pre></td></tr></table></figure><p>gdb常用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n #单步调试</span><br><span class="line">s #单步单步跟踪到函数内部</span><br><span class="line">continue #直接运行到下一个断点处</span><br><span class="line">u 行数 #运行到指定位置</span><br><span class="line">b #添加断点，可根据行数、函数名、条件进行断点设置</span><br><span class="line">info breakpoints #查看已设置断点</span><br><span class="line">p #打印基本类型变量，数组，字符数组</span><br><span class="line">l #打印源码</span><br></pre></td></tr></table></figure><p>具体可参考这篇<a href="https://zhuanlan.zhihu.com/p/74897601">文章</a></p><h1 id="如何在vscode调试ffmpeg"><a href="#如何在vscode调试ffmpeg" class="headerlink" title="如何在vscode调试ffmpeg"></a>如何在vscode调试ffmpeg</h1><p>首先cd到FFmpeg文件夹，然后在命令行输入以下命令打开vscode：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code . </span><br></pre></td></tr></table></figure><p>接着在VS Code中同时按下Ctrl + Shift + P打开输入”launch.json”。<br>如果没有这个选项的话，那就同时按下Ctrl + Shift + D，选择创建一个”launch.json”，点击Web app(Egd)<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%8F%AF%E8%B0%83%E8%AF%95%E7%9A%84Debug%E7%89%88%E6%9C%ACFFmpeg%EF%BC%8C%E5%B9%B6%E9%80%9A%E8%BF%87GDB%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/2.png"></p><p>把下面这段话替换进行</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gcc - 生成和调试活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;/../ffmpeg_g&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;-version&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// &quot;preLaunchTask&quot;: &quot;C/C++: gcc 生成活动文件&quot;,</span></span><br><span class="line">        <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gdb&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) Launch&quot;</span><span class="punctuation">,</span> <span class="comment">// 配置名称，将会在启动配置的下拉菜单中显示</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span> <span class="comment">// 配置类型，对于C/C++可认为此处只能是cppdbg，由cpptools提供；不et args -version #设置运行参数linux 上使用 vscode debug ffmpeg ?</span></span><br><span class="line">b main #将断电打在main函数的入口处</span><br><span class="line">layout src #显示源码布局</span><br><span class="line">run #运行程序同编程语言不同</span><br><span class="line">        <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span> <span class="comment">// 可以为launch（启动）或attach（附加）</span></span><br><span class="line">        <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span> <span class="comment">// 将要进行调试的程序的路径</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span>    <span class="comment">// 指定输出文件名，不加该参数则默认输出a.exe，Linux下默认a.out</span></span><br><span class="line">            <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span>    <span class="comment">// 生成和调试有关的信息</span></span><br><span class="line">            <span class="string">&quot;-m64&quot;</span><span class="punctuation">,</span>  <span class="comment">// 不知为何有时会生成16位程序而无法运行，此条可强制生成64位的</span></span><br><span class="line">            <span class="string">&quot;-Wall&quot;</span><span class="punctuation">,</span> <span class="comment">// 开启额外警告</span></span><br><span class="line">            <span class="string">&quot;-static-libgcc&quot;</span><span class="punctuation">,</span>     <span class="comment">// 静态链接libgcc，一般都会加上</span></span><br><span class="line">            <span class="string">&quot;-fexec-charset=GBK&quot;</span><span class="punctuation">,</span> <span class="comment">// 生成的程序使用GBK编码，不加这条会导致Win下输出中文乱码；繁体系统改成BIG5</span></span><br><span class="line">            <span class="string">&quot;-D__USE_MINGW_ANSI_STDIO&quot;</span><span class="punctuation">,</span> <span class="comment">// 用MinGW写C时留着，否则不需要，用于支持printf的%zd和%Lf等</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 编译的命令，其实相当于VSC帮你在终端中输了这些东西</span></span><br><span class="line">        <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="comment">// 设为true时程序将暂停在程序入口处，相当于在main上打断点</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span> <span class="comment">// 调试程序时的工作目录，此为工作区文件夹；改成$&#123;fileDirname&#125;可变为文件所在目录</span></span><br><span class="line">        <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 环境变量ffmpeg_g器的内容，具体作用自行Google</span></span><br><span class="line">                <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Compile&quot;</span> <span class="comment">// 调试前执行的任务，一般为编译程序。与tasks.json的label相对应</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>保存退出后，我们打开想要调试的文件，以本次要调试的ffmpeg_g为例，打开fftools文件夹中的ffmpeg.c文件，并在4852行加上断点（鼠标挪到行号的左边会出现一个淡淡的小红点，点下之后会显示红点，代表你在本行打了一个断点）</p><p><font color =red>注：请安装如下2个VS Code插件：Cffmpeg_g&#x2F;C++、C&#x2F;C++ Runner</font></p><p>接下来可以点击上方的工具栏来执行相关调试操作，也可以使用快捷键来进行操作：<br>F5：继续执行<br>F10：单步跳过<br>F11：单步调试<br>Shift + F11：单步跳出<br>Shift + F5：停止调试</p><p>之后我们可以通过”args”: [“-version”],这个参数来调试ffmpeg</p><p>左边的DEBUG工具栏可以让你轻松地查看本地变量和寄存器，可以添加相关的变量监视，也可以查看函数的调用堆栈等信息。</p><p>再举个查看文件信息的例子，修改launch.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gcc - 生成和调试活动文件&quot;</span><span class="punctuation">,</span>ffmpeg_g</span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;/../ffmpeg_g&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;-i&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;&#x27;/home/ws/Videos/1.mp4&#x27;&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// &quot;preLaunchTask&quot;: &quot;C/C++: gcc 生成活动文件&quot;,</span></span><br><span class="line">      <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gdb&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%8F%AF%E8%B0%83%E8%AF%95%E7%9A%84Debug%E7%89%88%E6%9C%ACFFmpeg%EF%BC%8C%E5%B9%B6%E9%80%9A%E8%BF%87GDB%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/3.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg文件IO操作</title>
      <link href="/2022/10/04/FFmpeg%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/10/04/FFmpeg%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>简单介绍一下如何使用FFmpeg进行文件IO操作，从操作文件和操作目录两个层面讲起，首先是文件的相关操作。</p><h2 id="文件的删除与重命名"><a href="#文件的删除与重命名" class="headerlink" title="文件的删除与重命名"></a>文件的删除与重命名</h2><ul><li>avpriv_io_delete()</li><li>avpriv_io_move()</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子1：删除文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//delete url</span></span><br><span class="line">    <span class="type">int</span> ret = avpriv_io_delete(<span class="string">&quot;./a.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Failed to delete a.txt\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">&quot;Success to delete a.txt \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子2：文件重命名</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = avpriv_io_move(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;2.txt&quot;</span>);<span class="comment">//avpriv_io_move(src, dst)；</span></span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Failed to rename \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">&quot;Success to rename \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>命令行窗口输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -g -o ffmpeg_del ffmpeg_file.c `pkg-config --cflags  --libs libavutil libavformat `</span><br></pre></td></tr></table></figure><p>如果出现该报错：<br><img src="/./picture/FFmpeg%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/1.png"></p><p>说明你现在安装的FFmpeg是最新版本的，没有这个函数，年可以选择切换成4.x版本的FFmpeg重新进行编译</p><p>这里我们切换到4.2版本演示一下，因为之前是通过git clone的方式下载代码的，因此可以直接用git命令切换到4.2版本的release分支上重新进行编译，你也可以重新git clone <a href="https://github.com/FFmpeg/FFmpeg.git">https://github.com/FFmpeg/FFmpeg.git</a><br>代码下来切换分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout release/4.2</span><br></pre></td></tr></table></figure><p>git branch查看切换完成后输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --cc=/usr/bin/clang --prefix=/usr/local/ffmpeg --enable-gpl --enable-nonfree --enable-libfdk-aac --enable-libx264 --enable-libmp3lame --enable-libx265  --enable-filter=delogo --enable-debug --disable-optimizations --enable-libspeex --enable-videotoolbox --enable-shared --enable-pthreads --enable-version3 --enable-hardcoded-tables --host-cflags= --host-ldflags=</span><br></pre></td></tr></table></figure><p>如果出现报错，请根据<a href="https://wujianqiangcode.github.io/2022/10/02/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/">这篇文章</a>进行修改。</p><p>接着输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><p>此时回到之前的位置，继续输入命令即可完成编译<br><img src="/./picture/FFmpeg%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/2.png"></p><h2 id="操作目录到重要函数"><a href="#操作目录到重要函数" class="headerlink" title="操作目录到重要函数"></a>操作目录到重要函数</h2><ul><li>avio_open_dir()</li><li>avio_read_dir()</li><li>avio_close_dir()</li></ul><h3 id="操作目录到重要结构体"><a href="#操作目录到重要结构体" class="headerlink" title="操作目录到重要结构体"></a>操作目录到重要结构体</h3><ul><li>AVIODirContext：操作目录到上下文，存储例如打开的是哪个目录之类的信息，串联作用，作为输入参数来传递给后续要进行的操作函数。实际上我们在调用avio_open_dir()函数后，程序就会自动给我们生成一个AVIODirContext，里面存储了一些目录的基本信息，因此在后续我们调用avio_read_dir()或者是avio_close_dir()时候，它将作为参数进行传递，这样avio_read_dir()或者是avio_close_dir()就知道我们实际上要操作的是哪个目录。</li><li>AVIODirEntry：目录项。用于存放该目录下每个文件的文件名，文件大小等信息</li></ul><p>接下来通过这几个函数，我们来简单的实现一下ls这个命令的具体功能。</p><p>PS：在终端输入ls后，即可显示该目录下所有文件的文件名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    AVIODirContext *ctx = <span class="literal">NULL</span>;</span><br><span class="line">    AVIODirEntry *entry = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    av_log_set_level(AV_LOG_INFO);</span><br><span class="line">    <span class="type">int</span> ret = avio_open_dir(&amp;ctx, <span class="string">&quot;./&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Cant open dir %s\n &quot;</span>,av_err2str(ret));</span><br><span class="line">        <span class="keyword">goto</span> __fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ret = avio_read_dir(ctx, &amp;entry);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Cant read dir %s\n &quot;</span>,av_err2str(ret));</span><br><span class="line">            <span class="keyword">goto</span> __fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!entry)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">&quot;%12&quot;</span>PRId64<span class="string">&quot; %s \n&quot;</span>, entry-&gt;size, entry-&gt;name);</span><br><span class="line">        avio_free_directory_entry(&amp;entry);<span class="comment">//释放</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">__fail:</span><br><span class="line">    avio_close_dir(&amp;ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入编译命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -g -o list ffmpeg_list.c `pkg-config --cflags  --libs libavutil libavformat `</span><br></pre></td></tr></table></figure><p><img src="/./picture/FFmpeg%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/3.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg日志系统</title>
      <link href="/2022/10/04/FFmpeg%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/10/04/FFmpeg%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="步骤一：引入相关头文件"><a href="#步骤一：引入相关头文件" class="headerlink" title="步骤一：引入相关头文件"></a>步骤一：引入相关头文件</h2><p>从libavutil这个包含工具函数的文件夹中引入log.h头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/log.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="步骤二：设置日志级别"><a href="#步骤二：设置日志级别" class="headerlink" title="步骤二：设置日志级别"></a>步骤二：设置日志级别</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">av_log_set_level</span>(AV_LOG_DEBUG)</span><br></pre></td></tr></table></figure><p><strong>常用的日志级别：</strong></p><ul><li>AV_LOG_ERROR</li><li>AV_LOG_WARNING</li><li>AV_LOG_INFO</li><li>AV_LOG_DEBUG</li></ul><p>从上到下看，这四个优先级别：从高到低。<br>也就是说如果设置为最低级别的AV_LOG_DEBUG，那么所有的日志信息都会打印出来；而如果设置为最高级别的AV_LOG_ERROR，那么只有AV_LOG_ERROR的日志信息才会打印出来。</p><h2 id="步骤三：打印日志信息"><a href="#步骤三：打印日志信息" class="headerlink" title="步骤三：打印日志信息"></a>步骤三：打印日志信息</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">&quot;...%s\n&quot;</span>, op)</span><br></pre></td></tr></table></figure><p>av_log(…)函数中的第1个参数指定该log所属的结构体,例如AVFormatContext、AVCodecContext等等，一般都设置成NULL；第2个参数表示该日志的级别；第3个参数是需要打印的字符串信息，里面可以添加%s，%d等占位符，第4，5，…参数代表第3个参数中字符串内占位符要显示的内容。</p><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    av_log_set_level(AV_LOG_DEBUG);<span class="comment">//设置日志级别</span></span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">&quot;Hello word!\n&quot;</span>);<span class="comment">//设置输出内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存成.cw文件退出后，打开命令行窗口，</p><p>Mac下输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clang -g -o log log.c -I/usr/local/ffmpeg/include -L/usr/local/ffmpeg/lib -lavutil</span><br><span class="line">或者是输入：</span><br><span class="line">clang -g -o log log.c `pkg-config --cflags --libs libavutil`</span><br></pre></td></tr></table></figure><p>Linux下输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -o</span><br></pre></td></tr></table></figure><p>PS：</p><p>-g 参数：输出有调试信息的</p><p>-o 参数：-o参数后面接的是输出执行文件的名称</p><p>-I 参数：指定引入的FFmpeg头文件的路径</p><p>-L 参数：指定所依赖的FFmpeg库的路径</p><p>-l 参数：指定所依赖的FFmpeg库的名称</p><p>–cflag参数：表示获取所需要引入的头文件目录地址</p><p> –libs参数：表示获取所依赖的库路径以及指定所要添加的库的名字（后面接库的名字）</p><p>回车编译后，执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./log</span><br></pre></td></tr></table></figure><p>就能看到结果了。</p><p><img src="/./picture/FFmpeg%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/1.png"></p><p>如果将代码中的日志级别改成AV_LOG_INFO的话，那就无法输出AV_LOG_DEBUG级别的信息了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    av_log_set_level(AV_LOG_INFO);<span class="comment">//改成AV_LOG_INFO级别</span></span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">&quot;AV_LOG_DEBUG级别日志信息\n&quot;</span>);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">&quot;AV_LOG_INFO级别日志信息&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./FFmpeg%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/2.png"></p><p>而比AV_LOG_INFO级别更高的日志是可以正常打印的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    av_log_set_level(AV_LOG_INFO);<span class="comment">//改成AV_LOG_INFO级别</span></span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">&quot;AV_LOG_DEBUG级别日志信息\n&quot;</span>);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">&quot;AV_LOG_INFO级别日志信息&quot;</span>);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;AV_LOG_ERROR级别日志信息&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./picture/FFmpeg%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/3.png"></p><p>PS：</p><p>如果采用pkg-config报以下错误的话：<br><img src="/./picture/FFmpeg%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/4.png"></p><p>说明没有配置环境，首先在命令行窗口输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim ~/.bash_profile </span><br></pre></td></tr></table></figure><p>打开后添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;/usr/local/ffmpeg/bin:$PATH&quot;</span><br><span class="line"></span><br><span class="line">export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/ffmpeg/lib/pkgconfig</span><br><span class="line">export LD_LIBRARY_PATH=$LIB_LIBRARY_PATH:/usr/local/ffmpeg/lib</span><br></pre></td></tr></table></figure><p>然后按下esc退出编辑后，按下:wq保存退出</p><p>接着输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>此时环境配置生效，再次运行命令，即可正常编译<br><img src="/./picture/FFmpeg%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/5.png"></p><p>PS:<br>MAC设置环境变量时, 配置的 bash_profile 没有生效，需要手动执行下面命令才生效。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>原因：zsh和bash有别， zsh模式不执行上述脚本，bash模式才执行。mac自带zsh，新款的默认使用后zsh。</p><p>解决方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd //Users/wujianqiang</span><br><span class="line"></span><br><span class="line">sudo su</span><br><span class="line"></span><br><span class="line">bash</span><br><span class="line"></span><br><span class="line">vim   ~/.bashrc </span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;/usr/local/ffmpeg/bin:$PATH&quot;</span><br><span class="line">export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/ffmpeg/lib/pkgconfig</span><br><span class="line">export LD_LIBRARY_PATH=$LIB_LIBRARY_PATH:/usr/local/ffmpeg/lib</span><br></pre></td></tr></table></figure><p>借助输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br><span class="line">zsh</span><br><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;/usr/local/ffmpeg/bin:$PATH&quot;</span><br><span class="line">export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/ffmpeg/lib/pkgconfig</span><br><span class="line">export LD_LIBRARY_PATH=$LIB_LIBRARY_PATH:/usr/local/ffmpeg/lib</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>最后:wq退出即可。</p><p>PS:为了让.bash_profile生效，一般在zhsrc加上一句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg学习笔记</title>
      <link href="/2022/10/03/FFmpeg%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/10/03/FFmpeg%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>之前学习FFmpeg一直是跳着学，用到什么学习什么，没有一个系统性的学习过程。因此趁着最近这段时间刚好有空，想从头到尾仔仔细细的学习一遍，同时整理一下相关的学习笔记，帮助别其他伙伴们快速入门FFmpeg，同时也方便自己后续进行回顾学习。</p><p>本篇博客的目的是让零基础的读者可以通过阅读该博客，从而彻底的熟练使用FFmpeg，以及音视频的相关知识。因此我将通过之前学习雷霄骅前辈的博客，李超大佬的课程，以及实际项目工作中运用到知识和遇到的问题进行精华总结。帮助其他伙伴们从零开始彻底掌握FFmpeg。</p><h1 id="本课程分为四个部分："><a href="#本课程分为四个部分：" class="headerlink" title="本课程分为四个部分："></a>本课程分为四个部分：</h1><h2 id="第一部分：音视频基础知识"><a href="#第一部分：音视频基础知识" class="headerlink" title="第一部分：音视频基础知识"></a>第一部分：音视频基础知识</h2><h3 id="帧率、码率、比特率等参数含义"><a href="#帧率、码率、比特率等参数含义" class="headerlink" title="- 帧率、码率、比特率等参数含义"></a>- 帧率、码率、比特率等参数含义</h3><h3 id="I帧、B帧、P帧的区别"><a href="#I帧、B帧、P帧的区别" class="headerlink" title="- I帧、B帧、P帧的区别"></a>- I帧、B帧、P帧的区别</h3><h3 id="YUV和RGB是什么"><a href="#YUV和RGB是什么" class="headerlink" title="- YUV和RGB是什么"></a>- YUV和RGB是什么</h3><h3 id="H264是什么"><a href="#H264是什么" class="headerlink" title="- H264是什么"></a>- H264是什么</h3><h2 id="第二部分：-如何在各个平台上编译FFmpeg"><a href="#第二部分：-如何在各个平台上编译FFmpeg" class="headerlink" title="第二部分： 如何在各个平台上编译FFmpeg"></a>第二部分： 如何在各个平台上编译FFmpeg</h2><h3 id="Windows系统编译FFmpeg"><a href="#Windows系统编译FFmpeg" class="headerlink" title="- Windows系统编译FFmpeg"></a>- Windows系统编译FFmpeg</h3><h3 id="MacOS系统编译FFmpeg"><a href="#MacOS系统编译FFmpeg" class="headerlink" title="- MacOS系统编译FFmpeg"></a>- <a href="https://wujianqiangcode.github.io/2022/10/02/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/">MacOS系统编译FFmpeg</a></h3><h3 id="Linux系统编译FFmpeg"><a href="#Linux系统编译FFmpeg" class="headerlink" title="- Linux系统编译FFmpeg"></a>- Linux系统编译FFmpeg</h3><h3 id="编译IOS系统可用的FFmpeg"><a href="#编译IOS系统可用的FFmpeg" class="headerlink" title="- 编译IOS系统可用的FFmpeg"></a>- 编译IOS系统可用的FFmpeg</h3><h3 id="编译Android系统可用的FFmpeg"><a href="#编译Android系统可用的FFmpeg" class="headerlink" title="- 编译Android系统可用的FFmpeg"></a>- 编译Android系统可用的FFmpeg</h3><h2 id="第三部分：FFmpeg常用的命令有哪些"><a href="#第三部分：FFmpeg常用的命令有哪些" class="headerlink" title="第三部分：FFmpeg常用的命令有哪些"></a>第三部分：FFmpeg常用的命令有哪些</h2><h2 id="第四部分：如何调用FFmpeg的函数实现功能"><a href="#第四部分：如何调用FFmpeg的函数实现功能" class="headerlink" title="第四部分：如何调用FFmpeg的函数实现功能"></a>第四部分：如何调用FFmpeg的函数实现功能</h2><h3 id="FFmpeg源代码结构"><a href="#FFmpeg源代码结构" class="headerlink" title="- FFmpeg源代码结构"></a>- <a href="https://wujianqiangcode.github.io/2022/10/03/FFmpeg%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/">FFmpeg源代码结构</a></h3><h3 id="FFmpeg日志系统"><a href="#FFmpeg日志系统" class="headerlink" title="- FFmpeg日志系统"></a>- <a href="https://wujianqiangcode.github.io/2022/10/04/FFmpeg%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/">FFmpeg日志系统</a></h3><h3 id="FFmpeg的文件IO操作"><a href="#FFmpeg的文件IO操作" class="headerlink" title="- FFmpeg的文件IO操作"></a>- <a href="https://wujianqiangcode.github.io/2022/10/04/FFmpeg%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/">FFmpeg的文件IO操作</a></h3><h2 id="第五部分：深入理解主流的音视频协议"><a href="#第五部分：深入理解主流的音视频协议" class="headerlink" title="第五部分：深入理解主流的音视频协议"></a>第五部分：深入理解主流的音视频协议</h2><h2 id="第六部分：深度剖析FFmpeg源代码"><a href="#第六部分：深度剖析FFmpeg源代码" class="headerlink" title="第六部分：深度剖析FFmpeg源代码"></a>第六部分：深度剖析FFmpeg源代码</h2><h2 id="第七部分：第三方开源库和主流渲染引擎框架的学习"><a href="#第七部分：第三方开源库和主流渲染引擎框架的学习" class="headerlink" title="第七部分：第三方开源库和主流渲染引擎框架的学习"></a>第七部分：第三方开源库和主流渲染引擎框架的学习</h2><h3 id="第三方开源库"><a href="#第三方开源库" class="headerlink" title="第三方开源库"></a>第三方开源库</h3><h4 id="WebRTC-学习笔记"><a href="#WebRTC-学习笔记" class="headerlink" title="- WebRTC 学习笔记"></a>- WebRTC 学习笔记</h4><h4 id="libyuv"><a href="#libyuv" class="headerlink" title="- libyuv"></a>- libyuv</h4><h4 id="Mplayer"><a href="#Mplayer" class="headerlink" title="- Mplayer"></a>- Mplayer</h4><h4 id="x264"><a href="#x264" class="headerlink" title="- x264"></a>- x264</h4><h4 id="OpenCV-学习笔记"><a href="#OpenCV-学习笔记" class="headerlink" title="- OpenCV 学习笔记"></a>- OpenCV 学习笔记</h4><h3 id="主流渲染引擎框架"><a href="#主流渲染引擎框架" class="headerlink" title="主流渲染引擎框架"></a>主流渲染引擎框架</h3><h4 id="OpenGL-学习笔记"><a href="#OpenGL-学习笔记" class="headerlink" title="- OpenGL 学习笔记"></a>- OpenGL 学习笔记</h4><h4 id="Metal-学习笔记"><a href="#Metal-学习笔记" class="headerlink" title="- Metal 学习笔记"></a>- Metal 学习笔记</h4><h4 id="DirectX-3D-学习笔记"><a href="#DirectX-3D-学习笔记" class="headerlink" title="- DirectX 3D 学习笔记"></a>- DirectX 3D 学习笔记</h4><h4 id="OpenCL"><a href="#OpenCL" class="headerlink" title="- OpenCL"></a>- OpenCL</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg源代码结构</title>
      <link href="/2022/10/03/FFmpeg%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/"/>
      <url>/2022/10/03/FFmpeg%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="FFmpeg源代码目录："><a href="#FFmpeg源代码目录：" class="headerlink" title="FFmpeg源代码目录："></a>FFmpeg源代码目录：</h1><p><img src="/./picture/FFmpeg%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/1.png"></p><table>  <tr>    <th>libavcodec</th>    <th>包含一系列编解码器等实现（如：h264、h265、AAC、Opus等）  </tr>  <tr>    <td>libavformat</td>    <td>包含音视频协议、容器格式以及IO访问的相关函数实现</td>  </tr>  <tr>    <td>libavutil</td>    <td>包含hash器，解码器和各种工具函数</td>  </tr>  <tr>    <td>libavfilter</td>    <td>提供了各种音视频过滤器（如：多路流合并、变速等特效）</td>  </tr>  <tr>    <td>libavdevice</td>    <td>包含对所有音视频设备等操作，提供访问捕获设备和回放设备等接口</td>  </tr>  <tr>    <td>libswresample</td>    <td>实现了混音和重采样</td>  </tr>  <tr>    <td>libswscale</td>    <td>实现了色彩转换和图像的缩放功能</td>  </tr></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac下编译FFmpeg全过程</title>
      <link href="/2022/10/02/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/10/02/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="下载源代码"><a href="#下载源代码" class="headerlink" title="下载源代码"></a>下载源代码</h2><p>首先用在命令行窗口用Git命令下载FFmpeg源代码</p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://git.ffmpeg.org/ffmpeg.git</span><br></pre></td></tr></table></figure><p>进行源代码的下载</p><h2 id="编译FFmpeg"><a href="#编译FFmpeg" class="headerlink" title="编译FFmpeg"></a>编译FFmpeg</h2><p>下载完后，进入ffmpeg文件夹切换到对应分支，这边切换到4.2版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout release/4.2</span><br></pre></td></tr></table></figure><p>首先输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --cc=/usr/bin/clang --prefix=/usr/local/ffmpeg --enable-gpl --enable-nonfree --enable-libfdk-aac --enable-libx264 --enable-libmp3lame --enable-libx265  --enable-filter=delogo --enable-debug --disable-optimizations --enable-libspeex --enable-videotoolbox --enable-shared --enable-pthreads --enable-version3 --enable-hardcoded-tables --host-cflags= --host-ldflags=</span><br></pre></td></tr></table></figure><span id="more"></span><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/1.png"></p><h3 id="检测编译环境"><a href="#检测编译环境" class="headerlink" title="检测编译环境"></a>检测编译环境</h3><h4 id="安装yasm"><a href="#安装yasm" class="headerlink" title="安装yasm"></a>安装yasm</h4><p>如果出现该报错提示，说明还需要下载一下yasm</p><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/2.png"></p><p><a href="http://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gz">yasm的下载链接</a></p><p>解压完yasm后，切换路径：</p><p>cd yasm-1.3.0<br> 接着进行执行配置，输入：</p><p> .&#x2F;configure<br>然后进行编译，输入：</p><p>make<br>最后进行安装，输入：</p><p>make install（提示：Permission denied，就执行sudo make install）</p><p>安装成功yasm后，我们继续cd进入到ffmpeg的文件夹下，进行.&#x2F;configure操作</p><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/3.png"></p><h4 id="安装libmp3lame"><a href="#安装libmp3lame" class="headerlink" title="安装libmp3lame"></a>安装libmp3lame</h4><p>如果出现以下报错，说明我们还得安装一下libmp3lame</p><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/5.png"></p><p><a href="https://sourceforge.net/projects/lame/files/lame/3.99/">libmp3lame的下载地址</a></p><p>解压完lame-3.100后，切换路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd lame-3.100</span><br></pre></td></tr></table></figure><p> 接着进行执行配置，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><p>然后进行编译，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/6.png"></p><p>如果出现以上报错，进入include文件夹，找到libmp3lame.sym文件</p><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/7.png"></p><p>删除lame_init_old所在行</p><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/8.png"></p><p>然后继续make</p><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/9.png"></p><p> 最后进行安装，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install（提示：Permission denied，就执行sudo make install）</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/10.png"></p><p>继续cd到ffmpeg文件夹中，进行.&#x2F;configure操作</p><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/11.png"></p><h4 id="安装x264、x265-等"><a href="#安装x264、x265-等" class="headerlink" title="安装x264、x265 等"></a>安装x264、x265 等</h4><p>大概率x264、x265这些也没有安装，直接一口气输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install fdk-aac&amp;&amp;brew install x264&amp;&amp;brew install x265&amp;&amp;brew install speex&amp;&amp;brew install pkg-config&amp;&amp;brew  install sdl2</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/12.png"><br>等待跑完后 再执行<br>之前ffmpeg到configure操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --cc=/usr/bin/clang --prefix=/usr/local/ffmpeg --enable-gpl --enable-nonfree --enable-libfdk-aac --enable-libx264 --enable-libmp3lame --enable-libx265  --enable-filter=delogo --enable-debug --disable-optimizations --enable-libspeex --enable-videotoolbox --enable-shared --enable-pthreads --enable-version3 --enable-hardcoded-tables --host-cflags= --host-ldflags=</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/13.png"></p><p>此时输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><p>必须加上sudo，否则会出现改报错<br><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/15.png"><br>开始进行编译<br><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/14.png"><br><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/16.png"></p><p>等待编译完成后，我们输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/ffmpeg/</span><br></pre></td></tr></table></figure><p>进入后就能看到我们编译完成的文件了。<br><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/17.png"></p><h2 id="添加ffmpeg环境变量"><a href="#添加ffmpeg环境变量" class="headerlink" title="添加ffmpeg环境变量"></a>添加ffmpeg环境变量</h2><p>接下来为了方便，我们修改一下环境变量，命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br></pre></td></tr></table></figure><p>回车后输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH: /usr/local/ffmpeg/bin</span><br></pre></td></tr></table></figure><p>然后输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure><p>接着输入，让环境变量生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>然后查看环境变量的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure><p>此时如果生效后在任意位置打开命令行窗口输入ffmpeg，将显示如下内容，证明已成功安装完成。<br><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/18.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>利用Hexo搭建个人博客全过程</title>
      <link href="/2022/10/01/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/10/01/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p><a href="https://nodejs.org/en/">安装地址</a></p><p>点击16.17.1.LTS</p><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1.png"><br>下载完成后，一直点击下一步进行安装即可</p><p><font color = gree>PS:这个安装包内除了Node.js以外，还包含npm包管理器，这个是等会搭建hexo博客所必须用到的东西。</font></p><h2 id="通过npm安装cnpm"><a href="#通过npm安装cnpm" class="headerlink" title="通过npm安装cnpm"></a>通过npm安装cnpm</h2><p>接着打开终端,切换到root用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure><p>输入密码<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/2.png"></p><span id="more"></span><p>此时我们可以查看一下刚刚安装的版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/3.png"></p><p>此时证明刚刚有成功安装node.js</p><p>接着利用npm来安装cmpn，通过镜像圆来解决访问国外网站较慢的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/4.png"><br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/5.png"></p><p>接着用cmpn来安装hexo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/6.png"></p><h2 id="通过hexo搭建博客"><a href="#通过hexo搭建博客" class="headerlink" title="通过hexo搭建博客"></a>通过hexo搭建博客</h2><p>输入pwd查看当前位置</p><p>接着新建一个空白文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir blog</span><br></pre></td></tr></table></figure><p><font color =gree>PS：后续如果在搭建博客的过程中出现问题的话，可以把该文件夹删掉，再重来接下来的所有步骤</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd blog/</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/7.png"></p><p>接下来可以真正使用hexo来生成我们的博客，先初始化一个博客，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo init</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/8.png"><br>等待安装初始化完成后，启动我们的博客，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/9.png"></p><p>用浏览器打开<a href="http://localhost:4000/">http://localhost:4000/</a><br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/10.png"></p><p>接着键盘输入control+c断开连接</p><p>此时，我们可以创建一篇文章，按照顺序输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;第一篇文章&quot;</span><br><span class="line">cd source/_posts/</span><br><span class="line">ls</span><br><span class="line">vim 第一篇文章.md</span><br></pre></td></tr></table></figure><p>进入vim后可以随便输入点内容,然后保存退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure><p>接着按照顺序输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>继续用浏览器打开<a href="http://localhost:4000/%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%88%9A%E5%88%9A%E5%86%99%E7%9A%84%E5%86%85%E5%AE%B9%E4%BA%86">http://localhost:4000/，就可以看到刚刚写的内容了</a></p><h2 id="将博客部署到Github上"><a href="#将博客部署到Github上" class="headerlink" title="将博客部署到Github上"></a>将博客部署到Github上</h2><p>接下来，我们先在浏览器上登陆Github，并新建一个仓库</p><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/11.png"></p><p>然后输入Repository name<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/12.png"></p><p>Description里面可以简单写一下<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/13.png"></p><p>最后点击Creat repository<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/14.png"></p><p>接着安装git部署插件，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/15.png"></p><p>然后用vim打开config.yml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim _config.yml</span><br></pre></td></tr></table></figure><p>到文件最底部，找到# Deployment配置<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/16.png"></p><p>在type:后面写上：<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/18.png"><br>并输入:wq保存退出</p><p>PS:repo的地址在这：<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/17.png"></p><p>此时将它部署到GitHub上，，先配置git信息，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;wujianqiangCode&quot;</span><br><span class="line">git config --global user.email &quot;ijianqiangwu@outlook.com&quot;</span><br></pre></td></tr></table></figure><p>接着输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>如果出现该报错：<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/19.png"><br>github在2021年8月14日七夕这天搞事情，如果这天你提交了github代码报错如下：<br>remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.<br>那么就得换成token登陆了，坑爹！</p><p>登录自己的github账号，个人设置那里<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20.png"></p><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/21.png"></p><p>找到Developer seetings，点击进入配置<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/22.png"></p><p>最后点击Generate生成令牌<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/23.png"></p><p>记得把你的token保存下来，因为你再次刷新网页的时候，你已经没有办法看到它了！！！</p><p>之后就可以用自己生成的token登录，把上面生成的token粘贴到输入密码的位置，然后成功hexo d了。</p><p>此时输入<a href="https://wujianqiangcode.github.io/%E5%B0%B1%E8%83%BD%E7%9C%8B%E5%88%B0%E5%8D%9A%E5%AE%A2%E4%BA%86">https://wujianqiangcode.github.io/就能看到博客了</a></p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>接着是更换主题，浏览器输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github.com/litten/hexo-theme-yilia</span><br></pre></td></tr></table></figure><p>这边推荐可以换成🀄这个作者的主题,将他的主题仓库克隆到我们的themes&#x2F;yilia文件夹中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure><p>clone完后输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim _config.yml </span><br></pre></td></tr></table></figure><p>找到theme<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/24.png"><br>换成yilia后保存退出<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/25.png"></p><p>接着为了能够插入图片，找到post_asset_folder：<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/27.png"></p><p>改成：<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/28.png"></p><p>保存退出后，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-marked</span><br></pre></td></tr></table></figure><p>接着输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>此时登陆博客，多刷新几次后就能看到结果<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/26.png"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
