<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WebAudioAPI音频重采样</title>
      <link href="/2024/02/02/WebAudioAPI%E9%9F%B3%E9%A2%91%E9%87%8D%E9%87%87%E6%A0%B7/"/>
      <url>/2024/02/02/WebAudioAPI%E9%9F%B3%E9%A2%91%E9%87%8D%E9%87%87%E6%A0%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>目前的WebCodecs API仅支持对音频文件的解码和编码，并不支持音频重采样操作；如果想要实现对音频的重采样操作的话，可以用Web Audio API中的OfflineAudioContext.</p><p>关于OfflineAudioContext的相关内容，具体可参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/OfflineAudioContext">官方文档</a>；</p><h1 id="OfflineAudioContext的介绍"><a href="#OfflineAudioContext的介绍" class="headerlink" title="OfflineAudioContext的介绍"></a>OfflineAudioContext的介绍</h1><p>接下来我们整一段运行在JS主线程的测试代码，用于测试重采样的效率：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> audio_Resample_frame_plane_data = [];</span><br><span class="line"><span class="keyword">const</span> offlineContext = <span class="keyword">new</span> <span class="title class_">OfflineAudioContext</span>(<span class="number">2</span>, math.<span class="title function_">ceil</span>(<span class="number">1024</span>*<span class="number">48000</span>/<span class="number">44100</span>), <span class="number">48000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//According to the decoded frame information, copy the PCM data on each plane</span></span><br><span class="line"><span class="keyword">var</span> audio_frame_plane_data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">1024</span>);</span><br><span class="line">  audio_frame_plane_data[i] = <span class="keyword">new</span> <span class="title class_">Float32Array</span>(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nTestWebCodecAudioDecoderFrameBeginTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Counter to track the number of times rendering has completed</span></span><br><span class="line"><span class="keyword">var</span> renderCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill random numbers into audio data</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; audio_frame_plane_size[i]; j++) &#123;</span><br><span class="line">        audio_frame_plane_data[i][j] = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2</span> - <span class="number">1</span>; <span class="comment">//Random number range is -1 to 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create AudioBuffer object</span></span><br><span class="line"><span class="keyword">const</span> audioBuffer = offlineContext.<span class="title function_">createBuffer</span>(<span class="number">2</span>, <span class="number">1024</span>, <span class="number">44100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Copy the decoded PCM data to the array of each channel</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> channel = <span class="number">0</span>; channel &lt; audioBuffer.<span class="property">numberOfChannels</span>; channel++) &#123;</span><br><span class="line">    <span class="keyword">const</span> channelData = audioBuffer.<span class="title function_">getChannelData</span>(channel);</span><br><span class="line">    channelData.<span class="title function_">set</span>(audio_frame_plane_data[channel]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> count = <span class="number">0</span>; count &lt; <span class="number">1</span>; count++) &#123;</span><br><span class="line"></span><br><span class="line">  nTestWebCodecAudioDecoderFrameBeginTime = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>().<span class="title function_">toFixed</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start rendering</span></span><br><span class="line">  <span class="keyword">const</span> source = offlineContext.<span class="title function_">createBufferSource</span>();</span><br><span class="line">  source.<span class="property">buffer</span> = audioBuffer;</span><br><span class="line">  source.<span class="title function_">connect</span>(offlineContext.<span class="property">destination</span>);</span><br><span class="line">  source.<span class="title function_">start</span>();</span><br><span class="line">  source.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Listen to the rendering completion event</span></span><br><span class="line">  offlineContext.<span class="title function_">startRendering</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">renderedBuffer</span>) &#123;</span><br><span class="line">        <span class="comment">// Store the resampled data in the array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> channel = <span class="number">0</span>; channel &lt; renderedBuffer.<span class="property">numberOfChannels</span>; channel++) &#123;</span><br><span class="line">          <span class="keyword">const</span> channelData = renderedBuffer.<span class="title function_">getChannelData</span>(channel);</span><br><span class="line">          audio_Resample_frame_plane_data.<span class="title function_">push</span>(channelData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//increment counter</span></span><br><span class="line">        renderCount++;</span><br><span class="line">        <span class="comment">// If all rendering has been completed, perform subsequent operations</span></span><br><span class="line">        <span class="keyword">if</span> (renderCount === <span class="number">100</span>) &#123;</span><br><span class="line">          <span class="keyword">var</span> nTestWebCodecAudioDecoderFrameEndTime = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>().<span class="title function_">toFixed</span>(<span class="number">8</span>);</span><br><span class="line">          <span class="keyword">var</span> timeDiff = (nTestWebCodecAudioDecoderFrameEndTime - nTestWebCodecAudioDecoderFrameBeginTime).<span class="title function_">toFixed</span>(<span class="number">8</span>);</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;将一百帧44100 2声道的PCM数据重采样成48000 2声道的PCM数据音频数据花费的时间为:&quot;</span> + timeDiff + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出这段代码是测试重采样一百帧音频数据所花费的时间。由于官方文档关于OfflineAudioContext的细节较少，在网上能查询到的相关博客也相对稀少，因此接下来我们将先通过这段代码，来只要介绍OfflineAudioContext的相关接口的输入参数设置。</p><p>首先是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> offlineContext = <span class="keyword">new</span> <span class="title class_">OfflineAudioContext</span>(<span class="number">2</span>, math.<span class="title function_">ceil</span>(<span class="number">1024</span>*<span class="number">48000</span>/<span class="number">44100</span>), <span class="number">48000</span>);</span><br></pre></td></tr></table></figure><p>这一行代码用于创建一个OfflineAudioContext对象，其中有三个输入参数，第一个输入参数为：输出的PCM数据的声道数（也就是采样后的声道数），第三个输入参数为：输出的PCM数据的采样率（也就是采样后的采样率，即：需要重新采样的采样率）。这里需要注意的是对于输出的PCM数据的采样率是有一定的限制的，必须在8000Hz到96000Hz的范围内，而输出的PCM数据的声道数在官方文档中并没有强调参数的设置范围，不过常用的也基本上是1，2，6，8这几个声道参数。<br>至于第二个输入参数，则需要重点讲一下，根据官方文档，我们可以知道第二个参数是length，指定为音频上下文创建的缓冲区大小（以样本帧为单位），其中一个样本帧是一个单元，可以包含音频数据中每个通道的单个音频数据样本。例如，频率为48000Hz的5秒缓冲区将具有采样帧sampleRate的长度 。5 * 48000 &#x3D; 240000；<br>但是官方文档中并没有说明这个length指的是输入的PCM的数据的length，还是说重采样后输出的PCM的数据的length。一开始我也以为是输入的PCM的数据的length，结果调试的时候发现重采样后的数据长度不对劲，尽然跟源的PCM长度一模一样。因此对于这个输入参数的设置要十分的注意，由于测试代码是将44100 2声道的PCM数据重采样成48000 2声道，而WebCodecs音频解码一个block出来的音频帧没声道的采样个数是1024个，因此做了math.ceil(1024*48000&#x2F;44100)的处理，从而得到输出后的采样个数，并将其指定为音频采样后的缓冲区大小。</p><p>接下来是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> audioBuffer = offlineContext.<span class="title function_">createBuffer</span>(<span class="number">2</span>, <span class="number">1024</span>, <span class="number">44100</span>);</span><br></pre></td></tr></table></figure><p>这一行代码用于创建一个缓冲区，用于存放待采样的PCM数据，这边待采样的PCM数据的声道数为2，采样率为44100，每个声道的采样个数为1024个。</p><h1 id="JS的主线程和JS的Wrok线程的数据交互方案设计"><a href="#JS的主线程和JS的Wrok线程的数据交互方案设计" class="headerlink" title="JS的主线程和JS的Wrok线程的数据交互方案设计"></a>JS的主线程和JS的Wrok线程的数据交互方案设计</h1><p>是不是以为这就实现我们需要的重采样功能了？too young too simple，有没有发现为什么我上面在介绍OfflineAudioContext的这段测试代码的时候，要强调这是一段运行在JS主线程的测试代码，因此OfflineAudioContext直能在JS的主线程中才能创建！！！究极蛋疼的一点是，我们的WebCodec的音频解码是运行在JS的Work线程中的，这才是最靠北的地方，我们需要找到一个方案，将JS的Work线程中解码后的音频数据送到JS的主线程中进行重采样操作，等操作完后还需要将重采样后的PCM数据送到JS的Work线程进行位深处理（做位深处理的原因是音频解码后的数据和重采样的输入输出数据全是f32类型的，而我们给解码器的源压缩数据一般都是s16的，如果你想保证C++层输出的音频帧跟源的位深信息保持一致的话，就得做位深转换，当然如果你打通了全链路f32的话那就没必要做位深转换咯），最后再把处理后的音频帧数据从JS的Work线程传递到C++层。<br>因此综上所述：这是一个涉及到JS的主线程，JS的Wrok线程和C++层的复杂数据交互操作，非常的麻烦。而通过之前对WebCodec音频解码插件的开发笔记，我们可以知道C++和JS之间的数据交互采用的是<a href="https://emscripten.org/">emscripten</a>技术。那JS的主线程和JS的Wrok线程之间的数据交互要用什么来实现呢？答案是<a href="https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel">MessageChannel</a>+<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage">postMessage</a>.</p><h1 id="MessageChannel介绍"><a href="#MessageChannel介绍" class="headerlink" title="MessageChannel介绍"></a>MessageChannel介绍</h1><p>官方文档对MessageChannel的介绍就简简单单的一行：The MessageChannel interface of the Channel Messaging API allows us to create a new message channel and send data through it via its two MessagePort properties.<br>具体来说：MessageChannel是一个消息传递的通道，MessageChannel有两个参数port1和port2，当我们用port1发送数据的时候，port2就能接听和接收到数据，同理port2发送消息的时候，port1也能接听和接收到数据。而MessageChannel可以用于JS不同线程之间的消息传递，因此通过MessageChannel就能实现JS不同线程之间的数据交互操作。</p><p>因此我们现在可以设计一套重采样方案：JS的Work线程完成解码操作后，首先通过MessageChannel将解码后的数据从JS的Work线程传递到JS主线程，然后通过emscripten告诉C++层，C++层接收到消息后，通过调用emscripten_sync_run_in_main_runtime_thread接口，强制将重采样的JS函数在JS的主线程中运行，等待重采样结束后，再用MessageChannel将重采样后的数据从JS的主线程传递到JS的Work线程做位深处理，在JS的Work线程做完位深处理后，再通过emscripten将数据传递到C++层。</p><p>这个方案看起来虽然复杂（实际上交互也很复杂），但是是不是挺完美？too young too simple.这个方案还有一个问题就是，我们的MessageChannel要在JS的主线程还是JS的Work线程中创建呢？创建后，假如当前线程使用port1的话，那我们要咋将port2告诉另一个线程呢？难不成我们要需要通过C++层来传递port2的值吗？</p><p>首先第一个问题MessageChannel要在JS的主线程还是JS的Work线程中创建呢？<br>其实在哪个线程创建都行，前提是如何将port2告诉另一个线程，如果我们在JS的Work线程中创建MessageChannel，那么port1就在Work线程中保持，而port2就需要我们传递给JS的主线程进行保存咯，主要的方案有两个：</p><ul><li>JS的Work线程通过emscripten将post2传到C++层，C++层调用emscripten_sync_run_in_main_runtime_thread接口，将post2作为某个JS函数的输入参数传递到JS主线程。</li><li>通过postMessage将post2直接传递给JS的主线程</li></ul><p>其中步骤二的参考例程为：<br>在JS的主线程中可以创建一个Web Worker，并监听其message事件。在Web Worker中，可以使用postMessage()方法将数据发送给主线程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在主线程中创建Web Worker</span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;worker.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听Web Worker的message事件</span></span><br><span class="line">worker.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received message from worker:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向Web Worker发送数据</span></span><br><span class="line">worker.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello from main thread!&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在Web Worker中，可以监听主线程的message事件，并使用postMessage()方法将数据发送给主线程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Web Worker中监听message事件</span></span><br><span class="line">self.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received message from main thread:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向主线程发送数据</span></span><br><span class="line">  self.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello from worker!&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这边我将MessageChannel的创建放在JS的主线程中创建（为什么这么干我们后面会讲到），然后通过PThread.pthreads[webcodec_audio_decoder_thread_id];的方式获得JS的Work线程，最后将post1传递给JS的Work线程，而port2存放在JS主线程中的WebCodec_JS_Main_Thread_Audio_Resample_Channel_Port。相关代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call this function in the JS main thread to create a MessageChannel</span></span><br><span class="line"><span class="attr">JS_WebCodecAudioDecoderConfigChannelSendMessage</span>: <span class="keyword">function</span> (<span class="params">audio_decoder_obj_adrr, webcodec_audio_decoder_thread_id</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">WebCodecAudioDecoderMsgChannel</span>) &#123;</span><br><span class="line">        <span class="title class_">WebCodecAudioDecoderMsgChannel</span> = <span class="keyword">new</span> <span class="title class_">MessageChannel</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> targetWorker = <span class="title class_">PThread</span>.<span class="property">pthreads</span>[webcodec_audio_decoder_thread_id];</span><br><span class="line">        targetWorker.<span class="title function_">postMessage</span>(&#123; <span class="attr">msg_type</span>: <span class="string">&quot;GetChannelPort&quot;</span>, <span class="attr">webcodec_audio_decoder_obj_adrr</span>: audio_decoder_obj_adrr &#125;, </span><br><span class="line">            [<span class="title class_">WebCodecAudioDecoderMsgChannel</span>.<span class="property">port1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="title class_">WebCodec</span>_JS_Main_Thread_Audio_Resample_Channel_Port = <span class="title class_">WebCodecAudioDecoderMsgChannel</span>.<span class="property">port2</span>;</span><br><span class="line">        <span class="comment">// The listening object of the JS main thread: JS_AudioDecoderWaitChannelMessage is used to obtain the data of the audio decoding frame</span></span><br><span class="line">        <span class="title class_">WebCodec</span>_JS_Main_Thread_Audio_Resample_Channel_Port.<span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, JS_AudioDecoderWaitChannelMessage);</span><br><span class="line">        <span class="title class_">WebCodec</span>_JS_Main_Thread_Audio_Resample_Channel_Port.<span class="title function_">start</span>();</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;JS_WebCodecAudioDecoderConfigChannelSendMessage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add JS_AudioResampleWaitChannelMessage as a listening object in the Work thread of WebCodecAudioDecoder.</span></span><br><span class="line"><span class="attr">JS_AudioResampleAddEventListener</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    self.<span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, JS_AudioResampleWaitChannelMessage);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;JS_AudioResampleAddEventListener&quot;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------------------------- Data transfer direction: main thread &lt;-- Work thread----------------------------------- //</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">WebCodecAudioDecoderMsgChannel</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">WebCodec</span>_JS_Work_Thread_Audio_Decoder_Channel_Port = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">WebCodec</span>_JS_Main_Thread_Audio_Resample_Channel_Port = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    The listening object JS_AudioResampleMessage of port2 of MessageChannel (used in the main </span></span><br><span class="line"><span class="comment">    thread of JS to obtain audio decoded data).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">JS_AudioDecoderWaitChannelMessage</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">data</span>.<span class="property">type</span> == <span class="string">&#x27;audioDecoderFrameData&#x27;</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------- Data transfer direction: main thread --&gt; Work thread ----------------------------------- //</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    The listening object JS_AudioResampleMessage of port1 of MessageChannel (used in the Work thread </span></span><br><span class="line"><span class="comment">    of JS to obtain audio resampled data).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">JS_AudioResampleMessage</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">data</span>.<span class="property">type</span> == <span class="string">&#x27;PushResampledAudioDecoderData&#x27;</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    The Work thread monitoring object of JS audio decoding is to assign the port1 of the MessageChannel </span></span><br><span class="line"><span class="comment">    created by the main thread to the WebCodec_JS_Work_Thread_Audio_Decoder_Channel_Port of the Wrok thread.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">JS_AudioResampleWaitChannelMessage</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">data</span>.<span class="property">msg_type</span> == <span class="string">&#x27;GetChannelPort&#x27;</span>) &#123;</span><br><span class="line">        <span class="title class_">WebCodec</span>_JS_Work_Thread_Audio_Decoder_Channel_Port = e.<span class="property">ports</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// Add the listening object of the JS audio decoding Work thread to monitor the resampling message of the JS main thread.</span></span><br><span class="line">        <span class="title class_">WebCodec</span>_JS_Work_Thread_Audio_Decoder_Channel_Port.<span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, JS_AudioResampleMessage);</span><br><span class="line">        <span class="title class_">WebCodec</span>_JS_Work_Thread_Audio_Decoder_Channel_Port.<span class="title function_">start</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[JS] JS_AudioResampleWaitChannelMessage &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JS_AudioResampleAddEventListener</span>();</span><br><span class="line"><span class="built_in">emscripten_sync_run_in_main_runtime_thread</span>(EM_FUNC_SIG_III, JS_WebCodecAudioDecoderConfigChannelSendMessage, (<span class="type">int</span>)<span class="keyword">this</span>, <span class="built_in">pthread_self</span>());</span><br></pre></td></tr></table></figure><p>接下来，我们详细的讲述一下上面的这几段代码：<br>根据程序代码的执行步骤：</p><h2 id="步骤一：调用JS-AudioResampleAddEventListener"><a href="#步骤一：调用JS-AudioResampleAddEventListener" class="headerlink" title="步骤一：调用JS_AudioResampleAddEventListener();"></a>步骤一：调用JS_AudioResampleAddEventListener();</h2><p>当我们需要进行重采样操作的时候，首先C++层调用JS_AudioResampleAddEventListener函数，此时JS的Work线程注册了监听对象JS_AudioResampleWaitChannelMessage，后面只要JS的Work线程在监听到消息的话，会自动触发执行JS_AudioResampleWaitChannelMessage函数，而JS_AudioResampleWaitChannelMessage函数的作用是就是获取我们后续在JS主线程中创建的MessageChannel的post1.</p><p>PS:</p><ul><li>注意self.addEventListener(“message”, JS_AudioResampleWaitChannelMessage);这里的self是JS的Work线程（因为我们在C++层调用JS_AudioResampleAddEventListener的时候是直接调用，并没有通过emscripten指定调用其他的线程，因此是运行在JS的Work线程也就是解码所在的线程），而addEventListener()方法用于向指定的元素添加事件监听器。当指定的事件类型在元素上触发时，事件监听器会被调用。在JavaScript中，可以使用addEventListener()方法来监听Web Worker的message事件。message事件在Web Worker接收到来自主线程的消息时触发。</li></ul><h2 id="步骤二：调用emscripten-sync-run-in-main-runtime-thread-EM-FUNC-SIG-III-JS-WebCodecAudioDecoderConfigChannelSendMessage-int-this-pthread-self"><a href="#步骤二：调用emscripten-sync-run-in-main-runtime-thread-EM-FUNC-SIG-III-JS-WebCodecAudioDecoderConfigChannelSendMessage-int-this-pthread-self" class="headerlink" title="步骤二：调用emscripten_sync_run_in_main_runtime_thread(EM_FUNC_SIG_III, JS_WebCodecAudioDecoderConfigChannelSendMessage, (int)this, pthread_self());"></a>步骤二：调用emscripten_sync_run_in_main_runtime_thread(EM_FUNC_SIG_III, JS_WebCodecAudioDecoderConfigChannelSendMessage, (int)this, pthread_self());</h2><p>接下来，我们在C++层通过emscripten的emscripten_sync_run_in_main_runtime_thread接口强制将JS_WebCodecAudioDecoderConfigChannelSendMessage运行在主线程中，此时在这个JS函数中将会做三件事情：</p><ul><li>new一个MessageChannel</li><li>将MessageChannel的post1通过let targetWorker &#x3D; PThread.pthreads[webcodec_audio_decoder_thread_id];targetWorker.postMessage({ msg_type: “GetChannelPort”, webcodec_audio_decoder_obj_adrr: audio_decoder_obj_adrr }, [WebCodecAudioDecoderMsgChannel.port1]);的方式传递给JS的Work线程</li><li>将MessageChannel的post2存放在WebCodec_JS_Main_Thread_Audio_Resample_Channel_Port中，并添加和启动post2的监听，并将JS_AudioDecoderWaitChannelMessage作为监听的响应函数</li></ul><p>此时在做第二件事情的时候，会触发我们步骤一在Work线程注册的JS_AudioResampleWaitChannelMessage函数，此时JS_AudioResampleWaitChannelMessage函数通过if语句判断是否是e.data.msg_type &#x3D;&#x3D; ‘GetChannelPort’，从而得到post1，并存放到WebCodec_JS_Work_Thread_Audio_Decoder_Channel_Port中，同时对WebCodec_JS_Work_Thread_Audio_Decoder_Channel_Port（也就是MessageChannel的post1添加和启动监听对象JS_AudioResampleMessage，用于接收后面JS主线程重采样结束后传递过来的PCM数据和相关重采样输出数据）</p><p>在做第三件事情的时候，添加和启动JS_AudioDecoderWaitChannelMessage为WebCodec_JS_Main_Thread_Audio_Resample_Channel_Port（也就是MessageChannel的post2）的监听对象，JS_AudioDecoderWaitChannelMessage的作用监听JS的Work线程传递过来的PCM解码数据和相关重采样的输入参数。</p><p>此时，当JS的Work线程完成当前Block的解码后，即可通过WebCodec_JS_Work_Thread_Audio_Decoder_Channel_Port传递解码后的数据到JS的主线程做重采样处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call postMessage in the Work thread of the current audio decoding to send a message to the main thread.</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  <span class="attr">audio_frame_plane_number</span>: <span class="variable language_">this</span>.<span class="property">codec_channel_number</span>,</span><br><span class="line">  <span class="attr">audio_sample_counts_per_each_plane</span>: audio_sample_counts_per_each_plane,</span><br><span class="line">  <span class="attr">audio_data_per_each_plane</span>: audio_data_per_each_plane</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> message = &#123; <span class="attr">type</span>: <span class="string">&#x27;audioDecoderFrameData&#x27;</span>, </span><br><span class="line">  <span class="attr">audio_decoder_frame_plane_info</span>: data</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">WebCodec</span>_JS_Work_Thread_Audio_Decoder_Channel_Port.<span class="title function_">postMessage</span>(message);</span><br></pre></td></tr></table></figure><p>同样JS的主线程重采样完成后也可通过WebCodec_JS_Main_Thread_Audio_Resample_Channel_Port传递重采样的数据到JS的Work线程做位深处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the resampled data from the JS main thread to the Work thread</span></span><br><span class="line"><span class="title class_">WebCodec</span>_JS_Main_Thread_Audio_Resample_Channel_Port.<span class="title function_">postMessage</span>(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;PushResampledAudioDecoderData&#x27;</span>,</span><br><span class="line">        <span class="attr">webcodec_audio_decoder_obj_adrr</span>: webcodec_audio_decoder_obj_adrr,</span><br><span class="line">        <span class="attr">audio_resample_plane_data</span>: audio_resample_plane_data,</span><br><span class="line">        <span class="attr">audio_resample_plane_number_of_frames</span>: renderedBuffer.<span class="property">length</span>,</span><br><span class="line">        <span class="attr">audio_resample_channels_number</span>: renderedBuffer.<span class="property">numberOfChannels</span>,</span><br><span class="line">        <span class="attr">audio_resample_sample_rate</span>: renderedBuffer.<span class="property">sampleRate</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>因此，整个重采样的流程就是：</p><ul><li>C++层调用JS_AudioResampleAddEventListener();和emscripten_sync_run_in_main_runtime_thread(EM_FUNC_SIG_III, JS_WebCodecAudioDecoderConfigChannelSendMessage, (int)this, pthread_self());完成MessageChannel的创建和相关监听对象的注册工作</li><li>当JS的Work线程完成音频帧的解码时，调用WebCodec_JS_Work_Thread_Audio_Decoder_Channel_Port.postMessage(message);将解码后的数据传递给JS的主线程，接着通过emscripte通知C++层需要开始进行重采样处理，此时C++层调用emscripten_sync_run_in_main_runtime_thread(EM_FUNC_SIG_VIIIII,JS_ResampleAudioDecoderFrame,(int)this,m_stWSAudioInfo.channels,m_stWSAudioInfo.sample_rate,m_nChannelsNumberOfAudioDecoderFrameResample,m_nSampleRateOfAudioDecoderFrameResample);将重采样JS函数JS_ResampleAudioDecoderFrame强制指定在JS的主线程中运行，等待重采样结束后通过WebCodec_JS_Main_Thread_Audio_Resample_Channel_Port.postMessage将重采样后的数据发送到JS的Work线程中做进一步的位深处理，最后JS的Wrok线程再通过emscripten将做完位深处理后的数据传递到C++层。</li></ul><p>这边可能有人会疑惑，既然原本的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage">window.postMessage()</a>技术就能进行JS的主线程和其他线程的交互工作，为什么还要多此一举的通过window.postMessage()将MessageChannel的post1传递给JS的Work线程，然后后续的重采样的交互操作再通过MessageChannel的post1和post2来实现？这个主要的原因是由于我们现在开发的是音频解码和重采样，如果都通过window.postMessage()来进行消息监听和传递的话，鬼知道会不会跟其他的功能模块冲突了，比如要是有模块的e.data.msg_type 都是 ‘GetChannelPort’的话，那不就消息冲突了，这样排查起来不得爆炸，因为我们最好别搞什么通过window.postMessage()直接从JS子线程向JS的主线程传递消息的骚操作，不然到时候炸了排查到吐血，因为这也是为什么我一开始说的我们后面会讲到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这边我将MessageChannel的创建放在JS的主线程中创建，然后通过PThread.pthreads[webcodec_audio_decoder_thread_id];的方式获得JS的Work线程，最后将post1传递给JS的Work线程，而port2存放在JS主线程中的WebCodec_JS_Main_Thread_Audio_Resample_Channel_Port。</span><br></pre></td></tr></table></figure><p>这样做的好处是：我们此时post1的传递是通过JS的主线程的window.postMessage()向JS的WebCodecsAudioDecoder线程传递，而不是反过来的操作，因此就避免了后续可能出现的消息冲突的爆炸问题！！！</p><h1 id="重采样的具体代码实现以及相关注意事项"><a href="#重采样的具体代码实现以及相关注意事项" class="headerlink" title="重采样的具体代码实现以及相关注意事项"></a>重采样的具体代码实现以及相关注意事项</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">JS_ResampleAudioDecoderFrame</span>: <span class="keyword">function</span> (<span class="params">webcodec_audio_decoder_obj_adrr,src_channels_number,src_sample_rate,dst_channels_number,dst_sample_rate</span>)&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">      <span class="comment">// Determine whether the browser supports OfflineAudioContext</span></span><br><span class="line">      <span class="keyword">const</span> <span class="title class_">OfflineAudioContext</span> = <span class="variable language_">window</span>.<span class="property">OfflineAudioContext</span> || <span class="variable language_">window</span>.<span class="property">webkitOfflineAudioContext</span>;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title class_">OfflineAudioContext</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;OfflineAudioContext is not supported in this browser&#x27;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;OfflineAudioContext is not supported in this browser&#x27;</span>));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Create OfflineAudioContext object，</span></span><br><span class="line">          <span class="comment">//Since OfflineAudioContext will be closed every time it completes rendering, it has to be recreated every time and cannot be reused! ! !</span></span><br><span class="line">          <span class="title class_">WebCodec</span>_JS_Main_Thread_Audio_Resample_Offline_Context = <span class="keyword">new</span> <span class="title class_">OfflineAudioContext</span>(dst_channels_number,(audio_sample_counts_per_each_plane[<span class="number">0</span>] /src_sample_rate)*dst_sample_rate, dst_sample_rate);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Create an AudioBuffer object to store the decoded audio PCM data</span></span><br><span class="line">          <span class="keyword">const</span> audioBuffer = <span class="title class_">WebCodec</span>_JS_Main_Thread_Audio_Resample_Offline_Context.<span class="title function_">createBuffer</span>(src_channels_number, audio_sample_counts_per_each_plane[<span class="number">0</span>], src_sample_rate);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Copy the decoded PCM data to the array of each channel</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> channel = <span class="number">0</span>; channel &lt; audioBuffer.<span class="property">numberOfChannels</span>; channel++) &#123;</span><br><span class="line">              <span class="keyword">const</span> channelData = audioBuffer.<span class="title function_">getChannelData</span>(channel);</span><br><span class="line">              channelData.<span class="title function_">set</span>(audio_data_per_each_plane[channel]);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Start rendering</span></span><br><span class="line">          <span class="keyword">const</span> source = <span class="title class_">WebCodec</span>_JS_Main_Thread_Audio_Resample_Offline_Context.<span class="title function_">createBufferSource</span>();</span><br><span class="line">          source.<span class="property">buffer</span> = audioBuffer;</span><br><span class="line"></span><br><span class="line">          source.<span class="title function_">connect</span>(<span class="title class_">WebCodec</span>_JS_Main_Thread_Audio_Resample_Offline_Context.<span class="property">destination</span>);</span><br><span class="line">          source.<span class="title function_">start</span>();</span><br><span class="line">          source.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Asynchronous callback</span></span><br><span class="line">          <span class="title class_">WebCodec</span>_JS_Main_Thread_Audio_Resample_Offline_Context.<span class="title function_">startRendering</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">renderedBuffer</span>) &#123;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// Store the resampled data in the array</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">let</span> channel = <span class="number">0</span>; channel &lt; renderedBuffer.<span class="property">numberOfChannels</span>; channel++) &#123;</span><br><span class="line">                  <span class="keyword">const</span> channelData = renderedBuffer.<span class="title function_">getChannelData</span>(channel);</span><br><span class="line">                  audio_resample_plane_data[channel] = <span class="keyword">new</span> <span class="title class_">Float32Array</span>(channelData);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// Return the resampled data from the JS main thread to the Work thread</span></span><br><span class="line">              <span class="title class_">WebCodec</span>_JS_Main_Thread_Audio_Resample_Channel_Port.<span class="title function_">postMessage</span>(</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="attr">type</span>: <span class="string">&#x27;PushResampledAudioDecoderData&#x27;</span>,</span><br><span class="line">                      <span class="attr">webcodec_audio_decoder_obj_adrr</span>: webcodec_audio_decoder_obj_adrr,</span><br><span class="line">                      <span class="attr">audio_resample_plane_data</span>: audio_resample_plane_data,</span><br><span class="line">                      <span class="attr">audio_resample_plane_number_of_frames</span>: renderedBuffer.<span class="property">length</span>,</span><br><span class="line">                      <span class="attr">audio_resample_channels_number</span>: renderedBuffer.<span class="property">numberOfChannels</span>,</span><br><span class="line">                      <span class="attr">audio_resample_sample_rate</span>: renderedBuffer.<span class="property">sampleRate</span></span><br><span class="line">                  &#125;</span><br><span class="line">              );</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">          <span class="title function_">reject</span>(error);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>到此基本上重采样的功能已经实现了，你是不是也这样以为呢?too young too simple!!!</p><p>这边还有一个大坑，不注意的话就掉进去了，我们在最开始讲重采样测试代码的时候说了：由于测试代码是将44100 2声道的PCM数据重采样成48000 2声道，而WebCodecs音频解码一个block出来的音频帧没声道的采样个数是1024个，因此做了math.ceil(1024*48000&#x2F;44100)的处理，从而得到输出后的采样个数，并将其指定为音频采样后的缓冲区大小。</p><p>此时，我们想想这样搞是不是有点小问题？按照测试代码，源是44100的采样率，每帧源数据的每个声道的采样个数是1024,而目的帧的采样率是48000，那么目的帧每个声道的采样个数X的计算公式是：1024&#x2F;X &#x3D; 44100&#x2F;48000,也就是x &#x3D; 1114.55782,不能被整除，如果我们直接将每次解码后的数据直接送去重采样的话，那么拿到的重采样后的数据长度是不对劲的，如果你像测试代码一样利用math.ceil做了向上取整的话或者是向下取整的话，都不能保证最终生成的整个重采样后的PCM数据是48000的采样率，声音听起来也会有细微的噪点！！！</p><p>因此这边你需要干的时候是送去重采样的数据是能被整除的数据，这就意味着你必须在JS层创建一个缓冲区，用于存放解码后的音频数据，直到满足一定的大小要求后再将数据送到JS主线程做重采样处理，并且重采样处理后的数据你还得做拆包处理，并且重新计算pts和duration！！！<br>而这边重采样的条件是什么呢？最简单粗暴的方式是假如源是44100的采样率的话，我们我送过去采样的每个声道的采样个数就是44100，也就是每次我都送1s的源PCM数据过去重采样，那么肯定能被整除了，但是一个block解码出来每个声道的采样个数才1024个大小，如果你源是44100的话，那开辟的缓冲区就得存放44帧的解码数据，这样有个问题就是当应用层每次进行seek操作的时候，你都得把这么大的一个缓冲区全给清空了，并且seek后第一个取帧的话，又得等你填满这个缓冲区后并且完成重采样和位深处理后应用层才能拿到seek后的那帧数据，这个效率爆炸低！<br>那么我们有什么方式来提高效率吗？答案就是保证每次送去重采样的数据量既可以被整除又尽可能的小，那么我们就回到了一开始OfflineAudioContext的第三个输入参数的上了，通过官方文档可知OfflineAudioContext支持的重采样范围为8000Hz到96000Hz，因此我们要找到而无论是8000Hz、96000Hz，还是我们常见的44100Hz、48000Hz均能被整除的一个数，及公约数</p><p>这边可供我们的最好的选择是25，25这个数字刚好能被常用的采样率整除，而将一秒的PCM数据拆分成25个包又容易计算pts和duration值，每个包的duration刚好是1&#x2F;25,小数点后可以除净，因此我们可以采用这个方式设置缓冲区的大小，即缓冲区的大小为：源采样率&#x2F;25,当缓冲区填满后立马开始重采样操作！！！这样就能最高效率的实现WEbCodecs的音频解码+音频重采样+位深处理的方案设计！！！</p><p>但是还有一个问题不知道大家有没有想到？万一这个文件的pts不是严格递增的呢？我们如果简单粗暴的采用,duration&#x3D;1s&#x2F;25;pts&#x3D;num＊duration的方式,可能就会出现音视频没有对齐的现象咯；因此我们在进行重采用的处理之前，还需要对解码后的音频帧进行处理，以确保音视频文件的对齐．如何处理呢？简单来说就是需要保证在重采样的数据必须是连续的。因此需要对解码后的音频帧的pts和durationß做一定的判断，来确保重采样的输入缓冲区内数据为连续pcm数据</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>音视频编解码引擎之多路流转换模块的架构设计</title>
      <link href="/2024/02/02/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E5%BC%95%E6%93%8E%E4%B9%8B%E5%A4%9A%E8%B7%AF%E6%B5%81%E8%BD%AC%E6%8D%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/02/02/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E5%BC%95%E6%93%8E%E4%B9%8B%E5%A4%9A%E8%B7%AF%E6%B5%81%E8%BD%AC%E6%8D%A2%E6%A8%A1%E5%9D%97%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>何谓多路流转换，实际上就是多路视频&#x2F;音频&#x2F;字幕&#x2F;图片流的编码和写入文件容器的过程（文件容器根据自身特性，决定是否抛弃无法存储的信息流）．</p><h1 id="架构设计思想"><a href="#架构设计思想" class="headerlink" title="架构设计思想"></a>架构设计思想</h1><p>对于每条流，我们都有对应的编码参数，因此对于多路流的转换接口，我们设置如下：</p><p>通过一个vector来存放应用层每次AddStreamEncodeParam的流和对应的编码参数信息</p><p>定义两个类CConverterCallBackThread和CConverterProcessThread，一个用于获取转化的回调信息，一个用于转换，这两个类都作为MultiStreamConverter的类成员变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MediaStreamInformationOfMultiStreamConverter</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>    program_id_;</span><br><span class="line">    AVIS_STREAM_TYPE    type_;</span><br><span class="line">    <span class="comment">// ... //</span></span><br><span class="line">EncodeParam      encode_param_;</span><br><span class="line">    IMediaStream*       stream_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;MediaStreamInformationOfMultiStreamConverter&gt; MediaStreamInformationOfMultiStreamConverterVecotr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CConverterCallBackThread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CConverterCallBackThread</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CConverterCallBackThread</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">RESULT <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">RESULT <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">RESULT <span class="title">ExitThread</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">RESULT <span class="title">SetProgressInforation</span><span class="params">(...)</span></span>;<span class="comment">//用于CConverterProcessThread调用，从而通知CallBackThread在svc进行转换消息的处理</span></span><br><span class="line">    <span class="function">RESULT <span class="title">SetCallBack</span><span class="params">(MULTI_STREAM_CALL_BACK pCallBack, <span class="type">void</span> *pUserObj)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">svc</span><span class="params">(...)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MultiStreamEncodeInformation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ... //</span></span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;CThreadEncoderMuxer&gt;    thread_encoder_muxer;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>*                          extra_data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>        extra_data_size;</span><br><span class="line"><span class="comment">// ... //</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CThreadEncoderMuxer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CThreadEncoderMuxer</span>();</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">CThreadEncoderMuxer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RESULT <span class="title">Init</span><span class="params">(IMediaStream* pIMediaStream)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">RESULT <span class="title">SetEncodeParam</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function">RESULT <span class="title">EncodeFrame</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function">RESULT <span class="title">GetExtraData</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">RESULT <span class="title">SetMuxer</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">svc</span><span class="params">(...)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... //</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ... //</span></span><br><span class="line"></span><br><span class="line">            pThisObj-&gt;<span class="built_in">EncodeFrame</span>(...);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ... //</span></span><br><span class="line"></span><br><span class="line">            pThisObj-&gt;<span class="built_in">WriteEncodeFrame</span>(...);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ... //</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CConverterProcessThread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CConverterProcessThread</span>();</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">CConverterProcessThread</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">RESULT <span class="title">SetOutputFileContainerFourCC</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* FourCC)</span></span>;</span><br><span class="line">    <span class="function">RESULT <span class="title">SetOutputFilePath</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span>* path)</span></span>;</span><br><span class="line">    <span class="function">RESULT <span class="title">SetOutputFileName</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span>* name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">RESULT <span class="title">SetInputMediaStreamVecotr</span><span class="params">(MediaStreamInformationOfMultiStreamConverter MediaStreamVetor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Start</span><span class="params">(<span class="type">double</span> begin_time, <span class="type">double</span> length, MULTI_STREAM_CALL_BACK FnCallBack,<span class="type">void</span>* user_obj,CConverterCallBackThread* pCallBackThread)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Pause</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Resume</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stop</span><span class="params">(WPARAM wParam = <span class="number">0</span>, LPARAM lParam = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Abort</span><span class="params">(WPARAM wParam = <span class="number">0</span>, LPARAM lParam = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">RESULT <span class="title">SetConverterSleep</span><span class="params">(<span class="type">int</span> interval,<span class="type">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsFinishConverter</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="function">RESULT <span class="title">CreateMediaFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... //</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_pMediaStreamInformationOfMultiStreamConverter.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">//在这里定义一个MultiStreamEncodeInformation结构体变量，填装对应流的信息，每个流都整一个thread_encoder_muxer，这个线程用于调用编码器和复用器进行编码和复用，相当于每个流在自己对应的线程里面自己编码和复用操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">svc</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiStreamConverter</span> : <span class="keyword">public</span> IMTUnknown&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MultiStreamConverter</span>();</span><br><span class="line">    ~<span class="built_in">MultiStreamConverter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">RESULT <span class="title">SetOutputFileContainerFourCC</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* FourCC)</span></span>;<span class="comment">//mp4 mov mkv ...</span></span><br><span class="line">    <span class="function">RESULT <span class="title">SetOutputFilePath</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span>* path)</span></span>;</span><br><span class="line">    <span class="function">RESULT <span class="title">SetOutputFileName</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span>* name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">RESULT <span class="title">AddStreamEncodeParam</span><span class="params">(AVSI_STREAM_TYPE type,IMediaStream* pInputMediaStream,EncodeParam&amp; param,<span class="type">bool</span> use_gpu = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">RESULT <span class="title">SetAllStreamClipTime</span><span class="params">(<span class="type">double</span> begin_time,<span class="type">double</span> length)</span></span>;<span class="comment">//从每条流的什么时间点开始转换，转换多长的时长</span></span><br><span class="line"></span><br><span class="line">    <span class="function">RESULT <span class="title">SetCallBack</span><span class="params">(MULTI_STREAM_CALL_BACK FnCallBack,<span class="type">void</span>* user_obj)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        m_FnCallBack = FnCallBack;</span><br><span class="line">        m_pUserObj   = user_obj;</span><br><span class="line">        <span class="keyword">return</span> m_pCallBackThread-&gt;<span class="built_in">SetCallBack</span>(FnCallBack,user_obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">RESULT <span class="title">Start</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        m_pCallBackThread-&gt;<span class="built_in">Start</span>();</span><br><span class="line">m_pConvThread-&gt;<span class="built_in">Start</span>(...,m_pCallBackThread);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">RESULT <span class="title">Pause</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    <span class="function">RESULT <span class="title">Resume</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    <span class="function">RESULT <span class="title">Stop</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    <span class="function">MULTI_STREAM_CONVERTER_STATE <span class="title">GetCurrentConverterStatus</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int i = 0; ; ++i)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        if (!(i % interval))&#123;</span></span><br><span class="line"><span class="comment">            if (m_nSleepMillSecond &gt; 0)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                Sleep(length);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">RESULT <span class="title">SetConverterSleep</span><span class="params">(<span class="type">int</span> interval,<span class="type">int</span> length)</span></span>;<span class="comment">//用于控制CPU占用率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CConverterCallBackThread*m_pCallBackThread;</span><br><span class="line">MULTI_STREAM_CALLBACKm_fnCallback;</span><br><span class="line"><span class="type">void</span> *m_pUserObj;</span><br><span class="line">CConverterProcessThread*m_pConverterProcessThread;</span><br><span class="line"></span><br><span class="line">    MULTI_STREAM_CALL_BACK      m_FnCallBack;</span><br><span class="line">    <span class="type">void</span>*                       m_m_pUserObj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>音视频解复用插件系统的架构设计之解复用插件管理器的设计</title>
      <link href="/2024/01/16/%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E5%A4%8D%E7%94%A8%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%A7%A3%E5%A4%8D%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/01/16/%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E5%A4%8D%E7%94%A8%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%A7%A3%E5%A4%8D%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>解复用插件管理器顾名思义就是用于管理解复用器插件的一套系统。一般来说整个音视频编解码引擎基本上只需要将ffmpeg的解复用功能封装成一个解复用插件即可，基本上能满足市面上绝大多数文件的解复用需求，但是为什么要做成类似解码器一样的插件化设计的原因是：后续如果有专业的格式或者是相对特殊的文件或者某个fourcc更优秀的开源解复用方案的话就可以封装成一个个解复用插件，这样将ffmpeg作为兜底的解复用插件，其他特定fourcc的文件用对应的解复用插件进行处理，提升音视频编解码引擎的整体兼容性．</p><h1 id="解复用插件管理器的架构设计"><a href="#解复用插件管理器的架构设计" class="headerlink" title="解复用插件管理器的架构设计"></a>解复用插件管理器的架构设计</h1><p>解复用器插件的命名规范为：</p><ul><li>dmpFFmpeg(demuxer plugin FFmpeg)</li><li>dmpMplayer(demuxer plugin Mplayer)</li></ul><h2 id="解码插件管理器的导出接口介绍"><a href="#解码插件管理器的导出接口介绍" class="headerlink" title="解码插件管理器的导出接口介绍"></a>解码插件管理器的导出接口介绍</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">InitDemuxerPluginManager</span><br><span class="line">UninitDemuxerPluginManager</span><br><span class="line"></span><br><span class="line">GetDemuxerPluginCount（扩展接口）</span><br><span class="line">GetCurrentDemuxerPluginItem（扩展接口）</span><br><span class="line">ForcefullySetSpecifyDemuxerPluginName（扩展接口）</span><br><span class="line"></span><br><span class="line">CreateOperationOfCurrentDemuxerPlugin</span><br><span class="line">DestroyOperationOfCurrentDemuxerPlugin</span><br><span class="line"></span><br><span class="line">SetEnableMultiThreadOperationOfCurrentDemuxer</span><br><span class="line"></span><br><span class="line">GetMaxBlockSizeOperationOfCurrentDemuxerPlugin</span><br><span class="line">GetBlockOperationOfCurrentDemuxerPlugin</span><br><span class="line"></span><br><span class="line">SeekOperationOfCurrentDemuxerPlugin</span><br><span class="line"></span><br><span class="line">GetExtraDataOperationOfCurrentDemuxerPlugin</span><br><span class="line">GetStreamCodecParamOperationOfCurrentDemuxerPlugin</span><br><span class="line"></span><br><span class="line">ReleaseFileMediaInfomation</span><br><span class="line">ReleaseBlock</span><br><span class="line">CopyBlock</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是：解复用是将音视频文件中的多个流（如音频流、视频流、字幕流等）分离出来的过程。因此最好少启动多线程解复用，这样在多线程可以同时处理不同的流，加快解复用的速度，特别是对于大型的音视频文件或高比特率的流媒体数据，可以显著减少解复用的时间，提高解复用的效率和性能。即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GetBlockOperationOfCurrentDemuxerPlugin</span><br><span class="line">SeekOperationOfCurrentDemuxerPlugin</span><br></pre></td></tr></table></figure><p>通过SetEnableMultiThreadOperationOfCurrentDemuxer设置开启多线程解复用后，上述两个函数的具体执行将在多线程下进行．其他的函数则正常执行即可．</p><h2 id="多线程解复用的大致细节"><a href="#多线程解复用的大致细节" class="headerlink" title="多线程解复用的大致细节"></a>多线程解复用的大致细节</h2><p>对于多线程方案的选择，直接用C++11的thread实现即可，C++11的这套thread已经非常成熟了，没必要再去用libpthread那套玩意．大致的流程就是创建一个线程，该线程执行svc函数，svc函数里面整个死循环(for (;;)),然后对GetBlockOperationOfCurrentDemuxerPlugin和SeekOperationOfCurrentDemuxerPlugin主要更改对应的变量，然后进入while循环，等待对应的变量被改变，线程中一直死循环的svc接收到这些变量的改变后执行对应的操作，然后修改完对应的变量值，GetBlockOperationOfCurrentDemuxerPlugin和SeekOperationOfCurrentDemuxerPlugin在while循环中发现值被改变后就将对应的数据return出去．<br>简单来说，GetBlockOperationOfCurrentDemuxerPlugin和SeekOperationOfCurrentDemuxerPlugin只用于发送和接收指令，具体的实现在线程的svc中执行．</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>音视频解复用插件系统的架构设计之解复用插件的设计</title>
      <link href="/2024/01/14/%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E5%A4%8D%E7%94%A8%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%A7%A3%E5%A4%8D%E7%94%A8%E6%8F%92%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/01/14/%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E5%A4%8D%E7%94%A8%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%A7%A3%E5%A4%8D%E7%94%A8%E6%8F%92%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一般来说，我们都是直接采用ffmpeg进行解复用处理，当然如果有其他的专业格式文件的话，也可以做成对应的解复用插件进行处理．<br>本篇博客主要讲述一下，如何设计一套解复用插件的管理架构，来实现不同类型（视频、音频、图片、文本）压缩数据的解码。<br>首先一个解码插件系统，分为调度层的插件管理器以及各个具体的解码器插件：</p><ul><li>DemuxerPluginManager</li><li>FFmpegDemuxerPlugin</li><li>MplayerDemuxerPlugin<br>….</li></ul><h1 id="插件对外接口"><a href="#插件对外接口" class="headerlink" title="插件对外接口"></a>插件对外接口</h1><p>由于插件需要通过上层的一个管理器进行统一调度和交互，因此作为一个解复用器插件，需要导出下面些接口函数，来跟上层进行交互操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stAVStreamCodecParameters</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>   codec_FourCC;<span class="comment">//FindCodecFourCC(pCodec-&gt;codec_id);</span></span><br><span class="line"><span class="type">int</span>bits_per_coded_sample;<span class="comment">//pCodec-&gt;bits_per_coded_sample;</span></span><br><span class="line"><span class="type">int</span>block_align;<span class="comment">//pCodec-&gt;block_align;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>codec_tag;<span class="comment">//pCodec-&gt;codec_tag;</span></span><br><span class="line"><span class="type">int</span>     width;<span class="comment">//pCodec-&gt;width;</span></span><br><span class="line"><span class="type">int</span>     height;<span class="comment">//pCodec-&gt;height;</span></span><br><span class="line"><span class="type">int</span>profile;<span class="comment">//pCodec-&gt;profile;</span></span><br><span class="line"><span class="type">int</span>level;<span class="comment">//pCodec-&gt;level;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* __stdcall <span class="title">Create</span><span class="params">(<span class="type">const</span> stMediaInfomation *pMediaInfomation)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">Destroy</span><span class="params">(<span class="type">void</span>* pDemuxerHandle)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> __stdcall <span class="title">GetMaxBlockSize</span><span class="params">(<span class="type">void</span>* pDemuxerHandle)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> __stdcall <span class="title">GetBlock</span><span class="params">(<span class="type">void</span>* pDemuxerHandle, <span class="type">void</span>** ppBlock, <span class="type">unsigned</span> <span class="type">int</span> stream_id)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">DestroyBlock</span><span class="params">(<span class="type">void</span>* pDemuxerHandle, <span class="type">void</span> *pBlock)</span></span>;</span><br><span class="line"><span class="function">__int64 __stdcall <span class="title">Seek</span><span class="params">(<span class="type">void</span>* pDemuxerHandle, __int64 pos, <span class="type">unsigned</span> <span class="type">int</span> stream_id)</span></span>; </span><br><span class="line"><span class="function"><span class="type">void</span>* __stdcall <span class="title">GetExtraData</span><span class="params">(<span class="type">void</span>* pDemuxerHandle, <span class="type">unsigned</span> <span class="type">int</span> stream_id)</span></span>;</span><br><span class="line"><span class="function">stAVStreamCodecParameters* __stdcall <span class="title">GetStreamCodecParam</span><span class="params">(<span class="type">void</span>* pDemuxerHandle, <span class="type">unsigned</span> <span class="type">int</span> stream_id)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>* (__stdcall* CREATE_API_DEMUXER_PLUGIN)(<span class="type">const</span> stMediaInfomation* pMediaInfomation);</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(__stdcall* DESTROY_API_DEMUXER_PLUGIN)</span><span class="params">(<span class="type">void</span>* pDemuxerHandle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="title">int</span> <span class="params">(__stdcall* GET_MAX_BLOCK_SIZE_API_DEMUXER_PLUGIN)</span><span class="params">(<span class="type">void</span>* pDemuxerHandle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(__stdcall* GET_BLOCK_API_DEMUXER_PLUGIN)</span><span class="params">(<span class="type">void</span>* pDemuxerHandle, <span class="type">void</span>** ppBlock, <span class="type">unsigned</span> <span class="type">int</span> stream_id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(__stdcall* DESTROY_BLOCK_API_DEMUXER_PLUGIN)</span><span class="params">(<span class="type">void</span>* pDemuxerHandle, <span class="type">void</span> *pBlock)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> __int64 (__stdcall* SEEK_API_DEMUXER_PLUGIN)(<span class="type">void</span>* pDemuxerHandle, __int64 pos, <span class="type">unsigned</span> <span class="type">int</span> stream_id); </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>* (__stdcall* GET_EXTRA_DATA_API_DEMUXER_PLUGIN)(<span class="type">void</span>* pDemuxerHandle, <span class="type">unsigned</span> <span class="type">int</span> stream_id);</span><br><span class="line"><span class="keyword">typedef</span> stAVStreamCodecParameters* (__stdcall* GET_STREAM_CODEC_PARAM_API_DEMUXER_PLUGIN)(<span class="type">void</span>* pDemuxerHandle, <span class="type">unsigned</span> <span class="type">int</span> stream_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">emDemuxerPluginPriority</span>&#123;</span><br><span class="line">    HIGHEST,</span><br><span class="line">    HIGH,</span><br><span class="line">    LOW,</span><br><span class="line">    LOWEST,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stDemuxerPluginItem</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">wchar_t</span>                description_info_[<span class="number">64</span>];<span class="comment">//描述信息</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>FourCC_;<span class="comment">//用于识别当前解复用器支持解码哪些FourCC</span></span><br><span class="line">emDemuxerPluginPriority     priority_;<span class="comment">//用于判断当前解复用器的优先级，上层根据该参数的大小来决定优先选择哪个解复用器进行解复用</span></span><br><span class="line"></span><br><span class="line">CREATE_API_DEMUXER_PLUGIN Create_;</span><br><span class="line">DESTROY_API_DEMUXER_PLUGINDestroy_;</span><br><span class="line">GET_MAX_BLOCK_SIZE_API_DEMUXER_PLUGINGetMaxBlockSize_;</span><br><span class="line">GET_BLOCK_API_DEMUXER_PLUGINGetBlock_;</span><br><span class="line">DESTROY_BLOCK_API_DEMUXER_PLUGINDestoryBlock;</span><br><span class="line">SEEK_API_DEMUXER_PLUGINSeek_;</span><br><span class="line">GET_EXTRA_DATA_API_DEMUXER_PLUGINGetExtraData_;</span><br><span class="line">GET_STREAM_CODEC_PARAM_API_DEMUXER_PLUGINGetStreamCodecParam_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> stDemuxerPluginItem* (__stdcall* GET_DEMUXER_PLUGIN_INFO_ARRAY_API)();</span><br></pre></td></tr></table></figure><h2 id="接口的具体实现："><a href="#接口的具体实现：" class="headerlink" title="接口的具体实现："></a>接口的具体实现：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> MT_FFMPEG_DEMUXER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* __stdcall <span class="title">Create</span><span class="params">(<span class="type">const</span> stMediaInfomation *pMediaInfomation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FFmpegDemuxer* pFFmpegDemuxer = <span class="keyword">new</span> <span class="built_in">FFmpegDemuxer</span>(pMediaInfomation);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pFFmpegDemuxer-&gt;<span class="built_in">Open</span>() == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> pFFmpegDemuxer;</span><br><span class="line">pFFmpegDemuxer = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(pFFmpegDemuxer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">Destroy</span><span class="params">(<span class="type">void</span>* pDemuxerHandle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FFmpegDemuxer* pFFmpegDemuxer = <span class="built_in">static_cast</span>&lt;FFmpegDemuxer*&gt;(pDemuxerHandle);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pFFmpegDemuxer)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">pFFmpegDemuxer-&gt;<span class="built_in">Close</span>();</span><br><span class="line"><span class="keyword">delete</span> pFFmpegDemuxer;</span><br><span class="line">pFFmpegDemuxer = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> __stdcall <span class="title">GetMaxBlockSize</span><span class="params">(<span class="type">void</span>* pDemuxerHandle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FFmpegDemuxer* pFFmpegDemuxer = <span class="built_in">static_cast</span>&lt;FFmpegDemuxer*&gt;(pDemuxerHandle);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pFFmpegDemuxer)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pFFmpegDemuxer-&gt;<span class="built_in">GetMaxBlockSize</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> __stdcall <span class="title">GetBlock</span><span class="params">(<span class="type">void</span>* pDemuxerHandle, <span class="type">void</span>** ppBlock, <span class="type">unsigned</span> <span class="type">int</span> stream_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FFmpegDemuxer* pFFmpegDemuxer = <span class="built_in">static_cast</span>&lt;FFmpegDemuxer*&gt;(pDemuxerHandle);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pFFmpegDemuxer)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pFFmpegDemuxer-&gt;<span class="built_in">GetBlock</span>(ppBlock, stream_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">DestroyBlock</span><span class="params">(<span class="type">void</span>* pDemuxerHandle, <span class="type">void</span> *pBlock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FFmpegDemuxer* pFFmpegDemuxer = <span class="built_in">static_cast</span>&lt;FFmpegDemuxer*&gt;(pDemuxerHandle);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pFFmpegDemuxer)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pFFmpegDemuxer-&gt;<span class="built_in">DestroyBlock</span>(pBlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__int64 __stdcall <span class="title">Seek</span><span class="params">(<span class="type">void</span>* pDemuxerHandle, __int64 pos, <span class="type">unsigned</span> <span class="type">int</span> stream_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FFmpegDemuxer* pFFmpegDemuxer = <span class="built_in">static_cast</span>&lt;FFmpegDemuxer*&gt;(pDemuxerHandle);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pFFmpegDemuxer)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pFFmpegDemuxer-&gt;<span class="built_in">Seek</span>(pos,stream_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* __stdcall <span class="title">GetExtraData</span><span class="params">(<span class="type">void</span>* pDemuxerHandle, <span class="type">unsigned</span> <span class="type">int</span> stream_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FFmpegDemuxer* pFFmpegDemuxer = <span class="built_in">static_cast</span>&lt;FFmpegDemuxer*&gt;(pDemuxerHandle);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pFFmpegDemuxer)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pFFmpegDemuxer-&gt;<span class="built_in">GetExtraData</span>(stream_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">stAVStreamCodecParameters* __stdcall <span class="title">GetStreamCodecParam</span><span class="params">(<span class="type">void</span>* pDemuxerHandle, <span class="type">unsigned</span> <span class="type">int</span> stream_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FFmpegDemuxer* pFFmpegDemuxer = <span class="built_in">static_cast</span>&lt;FFmpegDemuxer*&gt;(pDemuxerHandle);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pFFmpegDemuxer)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> pFFmpegDemuxer-&gt;<span class="built_in">GetStreamCodecParam</span>(stream_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stDemuxerPluginItem g_FFmpegDemuxerInfoList[] = </span><br><span class="line">&#123;</span><br><span class="line">&#123; <span class="string">L&quot;AVI File Demuxer&quot;</span>, <span class="string">&#x27; IVA&#x27;</span>, emDemuxerPluginPriority::HIGH, Create, Destroy, GetMaxBlockSize, GetBlock, DestroyBlock, Seek, GetExtraData, GetStreamCodecParam &#125;,</span><br><span class="line">......</span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">0</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>  <span class="function"><span class="type">const</span> stDemuxerPluginItem* __stdcall <span class="title">GetDemuxerPluginInfomationArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> g_FFmpegDemuxerInfoList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>音视频解复用插件系统的架构设计之媒体信息的插件设计</title>
      <link href="/2024/01/10/%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E5%A4%8D%E7%94%A8%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%AA%92%E4%BD%93%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8F%92%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/01/10/%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E5%A4%8D%E7%94%A8%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%AA%92%E4%BD%93%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8F%92%E4%BB%B6%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>对于音视频文件的媒体信息提取，我们可以采用两套方案</p><ul><li>ffmpeg</li><li>MediaInfoLib</li></ul><p>根据实际场景可以得出结论：在部分特殊文件下，MediaInfoLib对媒体信息的获取相对FFmpeg而言更加准确，且在某些信息的获取下MediaInfoLib的获取效率更高，因此对于媒体信息的获取，我们最方便的方案就是直接采用MediaInfoLib这个开源第三方库来实现对应的功能．这边没必要像解码器和解复用器一样搞一堆的插件，因为MediaInfoLib识别异常的文件大概率ffmpeg也识别异常，全用MediaInfoLib就够用了</p><p>PS:<a href="https://mediaarea.net/en/MediaInfo/Download">MediaInfoLib下载地址</a></p><h1 id="需要获取的媒体信息"><a href="#需要获取的媒体信息" class="headerlink" title="需要获取的媒体信息"></a>需要获取的媒体信息</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stMediaInfomation</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>                    FourCC;</span><br><span class="line"><span class="type">wchar_t</span>                name[<span class="number">512</span>];</span><br><span class="line"><span class="type">wchar_t</span>                description[<span class="number">128</span>];</span><br><span class="line"><span class="type">double</span>                media_length;<span class="comment">//取各个节目流中，最长的那路</span></span><br><span class="line"><span class="type">int</span>                bit_rate;<span class="comment">//各路节目流码率之和</span></span><br><span class="line"><span class="type">int</span>                program_count;</span><br><span class="line">std::vector&lt;stProgramInfomation*&gt;    program_infomation;</span><br><span class="line"><span class="type">bool</span>                            is_constant_frame_rate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stProgramInfomation</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>                    id;</span><br><span class="line"><span class="type">double</span>                    media_length;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>        bit_rate;</span><br><span class="line"><span class="type">int</span>                    video_stream_count;</span><br><span class="line"><span class="type">int</span>                    audio_stream_count;</span><br><span class="line">std::vector&lt;stAVSIStreamInfomation*&gt;video_stream_infomation;</span><br><span class="line">std::vector&lt;stAVSIStreamInfomation*&gt;audio_stream_infomation;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>                    time_stamp_reference_stream_id;<span class="comment">//时间戳参考音频流ID</span></span><br><span class="line"><span class="type">int</span>                    subtitle_picture_stream_count;<span class="comment">//字幕流的数目</span></span><br><span class="line">std::vector&lt;stAVSIStreamInfomation*&gt;subtitle_picture_infomation;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>                    image_stream_count;<span class="comment">//字幕流的数目</span></span><br><span class="line">std::vector&lt;stAVSIStreamInfomation*&gt;image_infomation;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">emAVSIStreamType</span>&#123;</span><br><span class="line"></span><br><span class="line">NONE,</span><br><span class="line">    DVD_NAVIGATION_DATA,</span><br><span class="line">VIDEO_STREAM,</span><br><span class="line">    AUDIO_STREAM,</span><br><span class="line">    INTERNAL_SUBTITLE_PICTURE,</span><br><span class="line">    EXTERNAL_SUBTITLE_PICTURE,</span><br><span class="line">    IMAGE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">emStreamStatus</span>&#123;</span><br><span class="line">    NOT_SUPPORT_SEEK_OPERATION,</span><br><span class="line">    UNKNOWN_PLAY_DURATION,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视频信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stVideoStreamInfomation</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> width;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> height;</span><br><span class="line"><span class="type">double</span> frame_rate;</span><br><span class="line"><span class="type">int</span> total_frames;</span><br><span class="line"><span class="type">int</span> x_ratio;</span><br><span class="line"><span class="type">int</span> y_ratio;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bit_depth;</span><br><span class="line"><span class="type">double</span> frame_rate_max;</span><br><span class="line"><span class="type">bool</span> is_VBR;</span><br><span class="line">    emStreamStatus status; </span><br><span class="line">    ......<span class="comment">//colo range color space ...... </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stAudioStreamInfomation</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> sample_rate;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> channels;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bit_count_of_per_sample;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> byte_count_per_second;</span><br><span class="line"><span class="type">double</span> length;</span><br><span class="line">    emStreamStatus status;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stAVSIStreamInfomation</span></span><br><span class="line">&#123;</span><br><span class="line">emAVSIStreamTypetype;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>id;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>FourCC;</span><br><span class="line"><span class="type">wchar_t</span>    name[<span class="number">64</span>];</span><br><span class="line"><span class="type">wchar_t</span>    description[<span class="number">128</span>];</span><br><span class="line"><span class="type">double</span>    length;</span><br><span class="line"><span class="type">int</span>    bit_rate;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            stVideoStreamInfomation origin_video_stream_infomation;</span><br><span class="line">            stVideoStreamInfomation current_video_stream_infomation;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            stAudioStreamInfomation origin_audio_stream_infomation;</span><br><span class="line">            stAudioStreamInfomation current_audio_stream_infomation;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            stSubtitlePictureStreamInfomation origin_subtitle_picture_stream_infomation;</span><br><span class="line">            stSubtitlePictureStreamInfomation current_subtitle_picture_stream_infomation;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            stImageStreamInfomation origin_image_stream_infomation;</span><br><span class="line">            stImageStreamInfomation current_image_stream_infomation;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对外导出接口:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* __stdcall <span class="title">Create</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span> *pFileName)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">Destroy</span><span class="params">(<span class="type">void</span>* pMediaInfomationHandle)</span></span>;</span><br><span class="line"><span class="function">stAVSIStreamInfomation* __stdcall <span class="title">GetFileMediaInfomation</span><span class="params">(<span class="type">void</span>* pMediaInfomationHandle)</span></span>;</span><br></pre></td></tr></table></figure><p>最优解的方案就是：采用多个获取媒体信息的方案，然后对获取的结果进行比对得到正确的结果．比如同时对一个文件采用ffmpeg和mediainfolib获取媒体信息，后续搞个补丁层：获取某个信息的时候，将mediainfolib和ffmpeg的信息做比对，得出正确的信息，将这一行为封装成一个函数接口，上层对于具体的媒体信息数据的获取均通过这一个个函数来获取，这样就能做到，对于部分特殊文件，无需修改第三方库的源代码，方便后续第三方库的正常版本的迭代升级．</p><p>具体的插件架构设计参考解码插件和解复用的插件架构设计，这边不再赘述．</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>音视频解码插件系统的架构设计之解码插件管理器的设计</title>
      <link href="/2024/01/08/%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%A7%A3%E7%A0%81%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/01/08/%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%A7%A3%E7%A0%81%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>解码插件管理器顾名思义就是用于管理解码插件的一套系统。接下来我们将介绍一下整个音视频编解码引擎到底需要哪些解码器。</p><p>首先整个音视频编解码引擎的解码器类型分为以下四类：</p><ul><li>视频解码器</li><li>音频解码器</li><li>图片解码器</li><li>字幕解码器<br>我们统一将这些解码器插件生成的dll&#x2F;dylib&#x2F;so放在可执行文件夹下的DecoderPlugins文件夹中，并规范命名为：</li><li>视频类的XX解码器:vdpXX</li><li>音频类的XX解码器:adpXX</li><li>图片类的XX解码器:idpXX</li><li>字幕类的XX解码器:sdpXX<br>为什么要这样命名，我们后续会讲到．</li></ul><h1 id="解码器插件方案选择"><a href="#解码器插件方案选择" class="headerlink" title="解码器插件方案选择"></a>解码器插件方案选择</h1><p>接下来，我们将逐个讲述每种类型的解码器应该如何进行方案的选择和设计</p><h2 id="视频解码器插件方案选择"><a href="#视频解码器插件方案选择" class="headerlink" title="视频解码器插件方案选择"></a>视频解码器插件方案选择</h2><p>对于视频类型的解码器，一共分为三种：</p><ul><li>CPU解码，也叫做软件解码，一般采用ffmpeg</li><li>GPU解码，也叫做硬件解码，一般采用各大显卡厂商的解决方案</li><li>系统解码，指代的是系统厂商提供的解码方案，比如Win端的Media Foundation</li></ul><p>而由于现阶段各大显卡厂商的GPU编解码加速方案已达到成熟商用阶段，因此整个视频解码器插件方案仅需要CPU解码和各大显卡厂商的GPU解码即可满足要求，不需要再去搞系统解码那套繁杂的东西，而我们说的CPU解码方案一般采用ffmpeg即可满足要求，后续如果有开源的专业设备的解码需求或者兼容性更好的某个fourcc的开源方案，也可以封装成对应的插件，因此接下来，我们将着重讲述一下各系统平台下，GPU编解码的加速方案应该如何选择．</p><p>PS:对于视频编解码，主要有两个加速方案：</p><ul><li>硬件加速</li><li>非硬件加速</li></ul><p>所谓的硬件加速指的是通过显卡，FPGA等硬件设备来实现视频文件的解码和编码功能；非硬件加速指的是通过CPU进行视频编解码．<br>这两个方案具备的优缺点如下：<br>硬件加速：<br>优点：编解码速度快<br>缺点：画面质量一般<br>非硬件加速：<br>优点：画面质量好<br>缺点：编解码速度较低</p><p>注意：GPU解码不一定比CPU快，集成显卡上1080p及以下分辨率CPU下会更高效，需要针对显卡和CPU进行性能分析来选择最合适的处理方式</p><h3 id="各系统平台下，GPU加速方案的选择"><a href="#各系统平台下，GPU加速方案的选择" class="headerlink" title="各系统平台下，GPU加速方案的选择"></a>各系统平台下，GPU加速方案的选择</h3><p>首先，对于PC用户而言，主流的三大GPU厂商的INTEL&#x2F;NVIDIA&#x2F;AMD都有自己的硬件加速方案，对于Mac&#x2F;IOS用户而言，Apple也有提供对应的硬件加速方案，对于Android用户而言，同样有对应的硬件加速方案．</p><p>接下来，我们将从真正的商业应用产品开发的角度上，设计每个操作系统平台的硬件加速方案．</p><h4 id="PC端用户："><a href="#PC端用户：" class="headerlink" title="PC端用户："></a>PC端用户：</h4><h5 id="INTEL硬件加速方案"><a href="#INTEL硬件加速方案" class="headerlink" title="INTEL硬件加速方案"></a>INTEL硬件加速方案</h5><p>首先我们先分析INTEL厂商的硬件加速方案：<br>现如今，INTEL厂商提供了以下两套硬件加速方案：</p><ul><li>Media SDK(又称为QSV)</li><li>OneVPL</li></ul><p>Media SDK(又称为QSV)：提供一套用于视频编解码以及处理（VPP）的API：libmfx，支持Linux&#x2F;Windows.</p><p>在Media SDK的<a href="https://www.intel.com/content/www/us/en/developer/articles/tool/media-sdk.html">官网</a>，我们可以看到下面这段话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The Intel Media SDK project is no longer active.</span><br><span class="line"></span><br><span class="line">For continued support and access to new features, Intel Media SDK users are encouraged to read the transition guide on upgrading from Intel® Media SDK to Intel® oneAPI Video Processing Library (oneVPL), and to move to oneVPL as soon as possible.</span><br><span class="line"></span><br><span class="line">For more information, see the oneVPL website.</span><br></pre></td></tr></table></figure><p>从这段Discontinuation Notice，我们可以看出Media SDK(又称为QSV)是旧版本的硬件加速方案，而OneVPL是新的硬件加速方案，但是作为一个商业化学产品的底层架构而言，由于各大厂商的硬件加速方案均采用向前兼容模式，因此我们不得不将两套方案均封装成编解码器插件，以适配旧的I卡设备，同时单独采用一个版本的Media SDK的话，还是无法覆盖到全部I卡设备的用户群体，因此根据每套Media SDK版本的适配群体，我们需要同时提供两个版本的Media SDK编解码插件（2017和2019）,或者是提供一套2017版本的Media SDK编解码插件，再加上封装一套最新的OneVPL编解码器插件．</p><p>OneVPL（OneAPI Video Processing Library）是英特尔于2020年推出的视频处理库</p><p>由于之前跟微软相关团队了解过，Media SDK这套已经不再维护，因此为了保证解码的兼容性达到最优情况，我们设计的方案为：</p><ul><li>2017年之前包括2017年的I卡均采用2017版本的Media SDK解决方案</li><li>2018年和2019年的I卡均采用2019版本的Media SDK解决方案</li><li>2017年之后包括2020年的I卡均采用最新版本的OneVPL解决方案</li></ul><h5 id="NVIDIA硬件加速方案"><a href="#NVIDIA硬件加速方案" class="headerlink" title="NVIDIA硬件加速方案"></a>NVIDIA硬件加速方案</h5><p>作为GPU的AI霸主：NVIDA，Nvidia曾经一度提出VDPAU与Intel 提出的VA-API在Linux上竞争，但最近的趋势似乎是Nvidia走向了更为封闭的方式，最主要的倾向是，Nvidia似乎放缓了对VPDAU的支持，取而代之的是提供较为封闭的NVDEC与NVENC库</p><p>因此我们从商业化的角度上来看，选择<a href="https://developer.nvidia.com/video-codec-sdk">Video_Codec_SDK</a>作为我们的硬件加速方案(PS:Video_Codec_SDK这是一套能运行于Windows 和 Linux 上硬件加速视频编码和解码的方案).</p><p>PS:NvDec采用最新的SDK方案即可，但是NvEnc为了适配低端旧型号的N卡，我们也需要采用两套版本的Video_Codec_SDK，这边一般采用Video_Codec_SDK 11和Video_Codec_SDK 12(NvEnc的部分头文件里的结构体定义大改，如果用最新的NvEnc的话，会出现旧的显卡比如GT710显卡在创建编码会话时会返回无效版本号，这一点再后续的编码插件文章上会具体讲)</p><p>需要注意的是Video_Codec_SDK提供一套跟各版本DirectX&#x2F;OpenGL&#x2F;Valken互操作的接口(每个平台支持的互操作对象都不一样)，开发人员可以通过互操作方式将NvDec解码后的数据从CUDA中映射到Direct&#x2F;OpenGL&#x2F;Valken，或者将Direct&#x2F;OpenGL&#x2F;Valken数据通过互操作映射到CUDA后送给NvEnc编码器．<br>但是这种互操作的方式除非是必须进行Device转换，否则最好是做成CUDA全流程，并且最好是NV12管线的CDUA全流程(NvDec-&gt;Effect-&gt;NvEnc)，并且中间Effect链路(旋转&#x2F;缩放&#x2F;crop&#x2F;hdr2sdr等)最好是采用ptx预加载模式，而不是直接用cu脚本，这样才能将性能拉到极致．</p><h5 id="AMD硬件加速方案"><a href="#AMD硬件加速方案" class="headerlink" title="AMD硬件加速方案"></a>AMD硬件加速方案</h5><p>AMF SDK用于控制AMD媒体加速器，以进行视频编码和解码以及色彩空间转换，现在开源出来的<a href="https://github.com/GPUOpen-LibrariesAndSDKs/AMF">版本</a>，并未支持Linux，只能在Windows上进行编码，支持的Codec有AVC&#x2F;HEVC。需要指出的是AMF的全称是Advanced Media Framework，之前有时会被称之为VCE(Video Coding Engine)</p><p>另外，VCE实际上支持两种模式，一种模式是所谓的full fixed mode，这种模式之下，所有的编码相关执行使用的ASIC方式，而另一种模式则是hybrid mode，主要是通过GPU中的3D引擎的计算单元执行编码相关动作，而对应的接口则是AMD’s Accelerated Parallel Programming SDK 以及 OpenCL。</p><p>但是很可惜的是，AMF SDK的效果真的很一般(很多不太规范的文件解码出来的画面奇奇怪怪的)，在实际用户使用场景下，经常出现部分A卡解码绿屏或者乱码的问题，因此如果要采用这套AMF SDK的话，那就需要覆盖测试，仅开放部分显卡型号，其他型号的A卡全部禁止使用这套AMF SDK．</p><p>那么假如用户的电脑不具备I卡核显，并且只有一张A卡，且该A卡型号采用AMF SDK的话会出现解码绿屏&#x2F;花屏之类问题的话，那么我们难道就只能走CPU编解码了吗？<br>此时我们就需要使用其他的硬件加速方案．</p><h3 id="其他硬件加速方案"><a href="#其他硬件加速方案" class="headerlink" title="其他硬件加速方案"></a>其他硬件加速方案</h3><p>作为开发PC电脑系统的微软，在windows系统上也有自己的硬件加速方案，分为:</p><ul><li>DXVA</li><li>D3D11VA</li><li>D3D12VA</li></ul><p>DXVA一共有DXVA1.0和DXVA2.0两个版本，它们之间的区别是:在DXVA 1中，软件解码器必须通过视频呈现器访问API。如果不调用视频呈现器，就无法使用DXVA 1 API。DXVA 2 中已删除此限制。使用 DXVA 2，主机解码器 (或任何应用程序) 都可以通过 IDirectXVideoDecoderService 接口直接访问API.</p><p>一般从产品商业化的角度上，我们并不会采用DXVA作为AMF SDK补充的硬件加速方案，这是因为DXVA2.0经过实际测试过，性能方面不如D3D11VA，而D3D11VA作为现在主流系统的一个AMF SDK补充的硬件加速方案是较为适合的一种选择，而D3D12VA相比D3D11VA而言，主要的新增点在于增加了对AV1编码的支持.</p><p>因此，如果从极致性能选择上来说:应该采用D3D11VA＋D3D12VA作为AMF SDK补充的硬件加速方案，并且只在支持D3D12的高版本系统上且需要AV1编码的时候才调用D3D12VA解决方案．</p><h4 id="Mac-x2F-IOS端用户："><a href="#Mac-x2F-IOS端用户：" class="headerlink" title="Mac&#x2F;IOS端用户："></a>Mac&#x2F;IOS端用户：</h4><h5 id="Apple硬件加速方案"><a href="#Apple硬件加速方案" class="headerlink" title="Apple硬件加速方案"></a>Apple硬件加速方案</h5><p>在macOS上的硬件加速接口也是跟随着Apple经历了漫长的演化，从90年代初的QuickTime 1.0所使用的基于C的API开始，一直到iOS 8 以及 OS X 10.8，Apple 才最终发布完整的Video Toolbox framework（之前的硬件加速接口并未公布，而是Apple自己内部使用），期间也出现了现在已经废弃的Video Decode Acceleration (VDA)接口。Video Toolbox是一套C API，依赖了CoreMedia,CoreVideo,以及CoreFoundation框架，同时支持编码，解码，Pixel转换等功能．</p><p>因此在Mac端别无选择，直接采用<a href="https://developer.apple.com/documentation/videotoolbox">VideoToolbox</a>即可</p><h4 id="Linux端用户："><a href="#Linux端用户：" class="headerlink" title="Linux端用户："></a>Linux端用户：</h4><p>Linux上的硬件加速接口，经历了一个漫长的演化过程，现如今的现状是：<br><a href="https://http.download.nvidia.com/XFree86/vdpau/doxygen/html/index.html">VDPAU</a>与<a href="https://github.com/intel/libva">VAAPI</a>共存，而这两个API其后的力量，则分别是支持VDPAU的Nvidia和支持VA-API的Intel，另一个熟悉的厂商AMD，实际上同时提供过基于VDPAU和VA-API的支持，真是为难了他。另外，对照VDPAU与VA-API可知，VDPAU仅定义了解码部分的硬件加速，缺少了编码部分的加速（解码部分也缺乏VP8&#x2F;VP9的支持，且API的更新状态似乎也比较慢），此外，值得一提的是，最新的状态是，Nvidia似乎是想用NVDEC去取代提供VDPAU接口的方式去提供Linux上的硬件加速，或许不久的将来，VA-API会统一Linux上的Video硬件加速接口（这样，AMD也不必有去同时支持VDPAU与VAAPI而双线作战的窘境），这对Linux上的用户，无疑可能是一个福音。除去VDPAU和VAAPI，Linux的Video4Linux2 API的扩展部分定义了M2M接口，通过M2M的接口，可以把CODEC作为Video Filter去实现，现在某些SoC平台下，已经有了支持，这个方案多使用在嵌入式环境之中。</p><p>PS:VDPAU与NVDEC的区别:</p><ul><li>NVDEC作为一种私有API，只被nvidia driver支持。</li><li>VDPAU是一种开源API，最初是由Nvidia开发的用于支持Nvidia PureVideo SIP Block，后来发展为可以被多种GPU支持。</li></ul><h5 id="INTEL硬件加速方案-1"><a href="#INTEL硬件加速方案-1" class="headerlink" title="INTEL硬件加速方案"></a>INTEL硬件加速方案</h5><p>对于Intel Media SDK，除了可以编解码，还有可以进行视频的其他操作。2017年开始，Linux上才有开源的Intel Media SDK实现,之前Linux上的对应方案叫做Intel® Media Server Studio，现在已经不可用了。</p><p>Linux上的Intel Media SDK底层基于Libva。编译Intel Media SDK也是要安装VAAPI驱动等Intel媒体栈软件。</p><p>类比PC端用户，如果是该硬件加速方案是运行在服务器上的话，那么根据显卡型号选择一个对应版本的Media SDK或者OneVPL作为硬件加速方案即可．当然如果你相信自己实力，也可以直接用VA-API作为硬件加速方案，但是VA-API接口设计很底层，且复杂,没必要干这种吃力不讨好的事情.</p><p>PS:官方网站上说OneVPL支持Ubuntu 20.04以上的版本，因此对于CentOS以及Ubuntu 18.04的版本得跑下例程验证一下能不能用</p><h5 id="NVIDIA硬件加速方案-1"><a href="#NVIDIA硬件加速方案-1" class="headerlink" title="NVIDIA硬件加速方案"></a>NVIDIA硬件加速方案</h5><p>类比PC端用户，Linux端从产品商业化角度上来说，直接采用Video_Codec_SDK这套硬件加速方案即可，但是需要注意的是一般Linux端的编解码底层很多时候并不是直接封装成UI提供给用户使用的，而是在企业的服务器上进行运行，提供用户云化的一套转换方案，因此对于Video_Codec_SDK的选择还是需要根据当前服务器企业级显卡的型号来进行版本选择，例如：采用A10显卡的话，那么就需要查看一下当前驱动支持的Video_Codec_SDK版本，如果采用Video_Codec_SDK　12版本的话，NvEncOpenEncodeSessionEx等相关API就会返回无效版本信息，此时就必须采用Video_Codec_SDK　11版本才能正常进行转换</p><h5 id="AMD硬件加速方案-1"><a href="#AMD硬件加速方案-1" class="headerlink" title="AMD硬件加速方案"></a>AMD硬件加速方案</h5><p>AMF Linux支持尚未正式发布，只能上VA-API</p><h4 id="Android端用户："><a href="#Android端用户：" class="headerlink" title="Android端用户："></a>Android端用户：</h4><p>仅有Google在Android API 16之后推出的用于音视频编解码的一套偏底层的API:<a href="https://developer.android.com/reference/android/media/MediaCodec">MediaCodec</a>可以作为Android端硬件加速方案，一般结合OpenGL ES进行来实现全流程GPU转换</p><h4 id="Web端用户："><a href="#Web端用户：" class="headerlink" title="Web端用户："></a>Web端用户：</h4><p>为了性能最优考虑，直接上<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebCodecs_API">WebCodecs</a>，在web端进行编解码，而不是调底层的ffmpeg，原因是底层自己整的ffmpeg在Web端可没法开汇编优化，鬼知道用户的电脑啥型号，因此只能用Web端自己的这套WebCodecs.</p><h2 id="音频解码器插件方案选择"><a href="#音频解码器插件方案选择" class="headerlink" title="音频解码器插件方案选择"></a>音频解码器插件方案选择</h2><p>直接上ffmpeg就够用了，Web端如果想搭建f32全流程链路的话可以考虑上<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebCodecs_API">WebCodecs</a></p><h2 id="图片解码器插件方案选择"><a href="#图片解码器插件方案选择" class="headerlink" title="图片解码器插件方案选择"></a>图片解码器插件方案选择</h2><p>对于CPU的图片的解码和编码，站在产品商业化的角度上来讲，除了系统提供的SDK以外(win:<a href="https://learn.microsoft.com/zh-cn/windows/win32/wic/-wic-creating-decoder">wic</a>  mac:<br><a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/ImageIOGuide/imageio_basics/ikpg_basics.html">CGImageSource</a> web:<a href="https://developer.mozilla.org/en-US/docs/Web/API/ImageDecoder">webcodecs</a>)，我们一般采用FreeImage，理由是:FreeImage相较于libpng和stb_image对图片格式支持的类型更多．</p><p>而在桌面端系统上仅有两套图片编解码GPU加速方案:</p><ul><li>VideoToolBox(Mac x86&#x2F;ARM)</li><li>NvJPEG，OneVPL(Windows&#x2F;Linux)</li><li>OneVPL</li></ul><p>而在移动端系统上也仅有两套图片编解码GPU加速方案:</p><ul><li>VideoToolBox(IOS)</li><li>NDK ImageDecoder API(Android)</li></ul><p>其中VideoToolBox无论是桌面端还移动端，均仅支持HEIC解码</p><p>PS:高效率图像格式（High Efficiency Image Format ，HEIF）最早被苹果公司的iPhone所使用，HEIC在各方面均优于JPEG，通过使用更现代的压缩算法，它可以将相同数量的数据大小压缩到JPEG图像文件的50%左右。随着手机Camera的不断升级，照片的细节也日益增加。通过将照片存储为HEIF格式而不非JPEG，可以让文件大小减半，几乎可以在同一部手机上存储以前2倍的照片数量。如果一些云服务也支持HEIF文件，则上传到在线服务的速度也会更快，并且使用更少的存储空间。在iPhone上，这意味着您的照片应该会以以前两倍的速度上传到iCloud照片库。HEIC唯一缺点：兼容性目前使用HEIF或HEIC照片唯一的缺点就是兼容性问题。现在的软件只要能够查看图片，那它肯定就可以读取JPEG图像，但如果你拍摄了以HEIF或HEIC扩展名结尾的图片，并不是在所有地方和软件中都可以正确识别。</p><p>因此对于图片编解码GPU加速方案设计最优为：</p><ul><li>桌面端，如果是HEIC文件且为Apple的设备，走VideoToolBox，如果具备N卡，且为JPEG图片，走NvJPEG，否则走FreeImage.</li><li>移动端，如果是HEIC文件且为Apple的设备，走VideoToolBox，否则走FreeImage或者用ffmpeg的图片解码也基本够用．</li></ul><p>优化空间：</p><ul><li>Freeimage处理png采用的是libpng,速度比不上<a href="https://github.com/kanryu/lodepng-turbo">lodepng-turbo</a>,经过测试速度差不多差一倍；</li><li>Freeimage处理jpeg采用的是libjpeg，但在速度上，<a href="https://libjpeg-turbo.org/">libjpeg-turbo</a>一般是libjpeg的2-4倍；</li><li>NvJpeg是CUDA代码，可以通过A卡和I卡官方的转换方案(C++异构编程)转成对应显卡的GPU代码，来实现对应的图片解码编码；</li></ul><p>因此整个图片解码插件的调用优先级的判断条件为：</p><ul><li>判断当前系统以及图片格式是否支持GPU解码，支持的话就用GPU解码</li><li>判断当前系统是否具备系统解码方案，支持的话就用系统解码</li><li>判断当前图片文件格式是否为jpeg,是的话就采用libjpeg-turbo,判断当前图片文件格式是否为png,是的话就采用llodepng-turbo</li><li>使用freeimage</li><li>如果有部分格式ffmpeg解码更优秀的话就用ffmpeg</li></ul><h2 id="字幕解码器插件方案选择"><a href="#字幕解码器插件方案选择" class="headerlink" title="字幕解码器插件方案选择"></a>字幕解码器插件方案选择</h2><p>字幕分为两种类型：</p><ul><li>内嵌字幕</li><li>外挂字幕（srt ssa ass文件）<br>对于内嵌字幕直接用ffmpeg解码就行<br>对于外挂字幕，自己根据规范读取字幕文件，然后用Dtype等渲染成图片</li></ul><p>字幕渲染方案有：</p><ul><li>FreeType</li><li>Skia</li><li>Dtype</li></ul><p>一般是用Dtype</p><h1 id="解码插件管理器的架构设计"><a href="#解码插件管理器的架构设计" class="headerlink" title="解码插件管理器的架构设计"></a>解码插件管理器的架构设计</h1><p>根据简介中，解码插件的规范命名，我们可以根据待解码的Block的类型来判断用哪些类型的解码器；即：如果是视频的话判断插件名称前缀是否为vdp，如果是音频的话判断是否为adp，以此类推</p><p>同时对于视频类插件or图片类解码插件，我们要如何判断这个插件是cpu解码插件还是gpu解码插件呢？<br>答：我们可以创建一个数组，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* g_chVideoGpuDeocderPluginName[] = &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">    <span class="string">&quot;vdpMediaSDK.dll&quot;</span>,</span><br><span class="line">    <span class="string">&quot;vdpOneVPL.dll&quot;</span>,</span><br><span class="line">    <span class="string">&quot;vdpNvDec.dll&quot;</span>,</span><br><span class="line">    <span class="string">&quot;vdpAMF.dll&quot;</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line">    <span class="string">&quot;vdpMediaSDK.so&quot;</span>,</span><br><span class="line">    <span class="string">&quot;vdpOneVPL.so&quot;</span>,</span><br><span class="line">    <span class="string">&quot;vdpNvDec.so&quot;</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __APPLE__</span></span><br><span class="line">    <span class="string">&quot;vdpVideoToolBox.dylib&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span>　.......</span></span><br><span class="line">    .......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只要视频插件中，不在这个数组内的均认定为是cpu解码插件．</p><h2 id="解码插件管理器的导出接口介绍"><a href="#解码插件管理器的导出接口介绍" class="headerlink" title="解码插件管理器的导出接口介绍"></a>解码插件管理器的导出接口介绍</h2><p>对于DecoderPluginManager导出接口一般为以下几个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">InitDecoderPluginManager</span><br><span class="line">UnInitecoderPluginManager</span><br><span class="line"></span><br><span class="line">GetDecoderPluginCount（扩展接口）</span><br><span class="line">GetCurrentDecoderPluginItem（扩展接口）</span><br><span class="line">ForcefullySetSpecifyDecoderPluginName（扩展接口）</span><br><span class="line"></span><br><span class="line">InitOperationOfCurrentDecoderPlugin</span><br><span class="line">PutDataOperationOfCurrentDecoderPlugin</span><br><span class="line">GetNextFrameOperationOfCurrentDecoderPlugin</span><br><span class="line">ResetOperationOfCurrentDecoderPlugin</span><br><span class="line">CloseOperationOfCurrentDecoderPlugin</span><br><span class="line">GetCPUMemorySizeOperationOfCurrentDecoderPlugin</span><br><span class="line">GetGPUMemorySizeOperationOfCurrentDecoderPlugin</span><br></pre></td></tr></table></figure><h3 id="InitDecoderPluginManager"><a href="#InitDecoderPluginManager" class="headerlink" title="InitDecoderPluginManager"></a>InitDecoderPluginManager</h3><p>作用：插件初始化操作，读取可执行文件夹下的DecoderPlugins文件夹中的库名，根据库名称的前缀结合创建的数组（比如上面的g_chVideoGpuDeocderPluginName）,将这个插件进行归类并采用下面接口逐个进行加载，然后将相关句柄和获取的插件信息参数（支持哪些fourcc&#x2F;插件优先级）写入到定义的结构体中．</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">    HMODULE hModule = <span class="built_in">LoadLibraryW</span>(szPlugin);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    HMODULE hModule = <span class="built_in">dlopen</span>(<span class="built_in">W2A</span>(szPlugin), RTLD_LAZY);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这样后续我们就可以根据上层设置的输入参数来配合插件类型和优先级来选择对应的解码插件．</p><h3 id="UnInitecoderPluginManager"><a href="#UnInitecoderPluginManager" class="headerlink" title="UnInitecoderPluginManager"></a>UnInitecoderPluginManager</h3><p>将之前InitDecoderPluginManager操作后写入的结构体清理，释放对应的插件的加载</p><h3 id="GetDecoderPluginCount（扩展接口）和GetCurrentDecoderPluginItem（扩展接口）和ForcefullySetSpecifyDecoderPluginName（扩展接口）"><a href="#GetDecoderPluginCount（扩展接口）和GetCurrentDecoderPluginItem（扩展接口）和ForcefullySetSpecifyDecoderPluginName（扩展接口）" class="headerlink" title="GetDecoderPluginCount（扩展接口）和GetCurrentDecoderPluginItem（扩展接口）和ForcefullySetSpecifyDecoderPluginName（扩展接口）"></a>GetDecoderPluginCount（扩展接口）和GetCurrentDecoderPluginItem（扩展接口）和ForcefullySetSpecifyDecoderPluginName（扩展接口）</h3><p>后续根据具体情况看是否需要开放，主要作用是用于上层获取插件信息，同时强制指定某个解码器进行解码，这三个接口可以用于调试，即当成插件的调试接口．</p><h3 id="后续的这些接口：InitOperationOfCurrentDecoderPlugin-x2F-PutDataOperationOfCurrentDecoderPlugin-x2F-……"><a href="#后续的这些接口：InitOperationOfCurrentDecoderPlugin-x2F-PutDataOperationOfCurrentDecoderPlugin-x2F-……" class="headerlink" title="后续的这些接口：InitOperationOfCurrentDecoderPlugin&#x2F;PutDataOperationOfCurrentDecoderPlugin&#x2F;……"></a>后续的这些接口：InitOperationOfCurrentDecoderPlugin&#x2F;PutDataOperationOfCurrentDecoderPlugin&#x2F;……</h3><p>这些接口就是每个插件共有的接口信息了</p><p>PS:上述说的，除了创建一个数组来区分是否为gpu解码器以外，其实还有一个方法，那就是每个解码器插件均都导出一个函数，用于通知管理器这个插件是cpu解码还是gpu解码或者是系统的解码方案，这两个方法都可行，最好还是多导出一个函数，这样的话也省得后续添加插件的话还需要去改解码插件管理器的数组．</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>WebCodec音频解码插件开发笔记</title>
      <link href="/2024/01/07/WebCodecs%E9%9F%B3%E9%A2%91%E8%A7%A3%E7%A0%81%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/01/07/WebCodecs%E9%9F%B3%E9%A2%91%E8%A7%A3%E7%A0%81%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本章将讲述如何基于WebCodecs进行音频解码器插件的架构设计和开发工作。何为基于WebCodecs的音频解码器？实际上就是将音频pkt的解码交给JS层的WebCodecs进行处理,而C++层只进行对应的逻辑处理。从而借助Web端的WebCodecs实现音频解码的功能。</p><h1 id="C-端接口"><a href="#C-端接口" class="headerlink" title="C++端接口"></a>C++端接口</h1><p>根据上一篇博客《音视频解码插件系统的架构设计之解码插件的设计.md音视频解码插件系统的架构设计之解码插件的设计》，我们可以知道对于解码插件而言，需要将插件的具体代码逻辑封装在类CWebCodecsAudioDecoder中，并且所有解码插件类都必须对外提供的几个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pInfo, <span class="type">const</span> <span class="type">void</span>* pExtraData)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PutData</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pBlock)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">GetNextFrame</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">__int64 <span class="title">GetCPUMemorySizeOfCurrentDecoderPlugin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">__int64 <span class="title">GetGPUMemorySizeOfCurrentDecoderPlugin</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>接下来，我们将先通过上述的几个接口，来讲述如何进行WebCodecs的音频解码插件的具体开发。</p><h2 id="Init-…-函数的具体实现"><a href="#Init-…-函数的具体实现" class="headerlink" title="Init(…)函数的具体实现"></a>Init(…)函数的具体实现</h2><p>对于CWebCodecAudioDecoder类的Init函数的实现主要有以下几个步骤：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断输入参数是否正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    2.调用JS层JS_IsSupportWebAudioDecoder接口，判断当前WebCodec是否支持进行改插件类型的解码，如果支持就将该类的this设置到WS_WebCodecPutAudioDecoderToList中</span></span><br><span class="line"><span class="comment">    PS:JS层会先执行步骤4中this.CreateWebCodecAudioDecoder的isConfigSupported，如果支持的话JS层才会创建一个AudioDecoder,从而才会返回true:</span></span><br><span class="line"><span class="comment">    //Judge is support webcodec</span></span><br><span class="line"><span class="comment">    JS_IsSupportWebAudioDecoder: function () &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        if (typeof AudioDecoder == &quot;undefined&quot;) &#123;</span></span><br><span class="line"><span class="comment">            console.log(&quot;webcodecs is not supported.&quot;)</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return 1;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.将Init输入的相关参数信息赋值给对应的类成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.new一个长度为32，类型为char的的数组字段，用于传递给JS层中WebCodec中isConfigSupported接口输入参数config.codec（详见：https://developer.mozilla.org/en-US/docs/Web/API/AudioDecoder/isConfigSupported_static）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.将额外数据信息保存到成员你变量中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.根据额外数据选择对应的Codec</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.向SVC发送解码任务并等待JS层返回音频解码器创建是否成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//8.创建音频帧缓冲队列来存储解码后的音频帧</span></span><br></pre></td></tr></table></figure><p>WebCodecs音频解码支持以下几种Codec:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    AUDIO_CODEC_NONE = <span class="number">0</span>,</span><br><span class="line">    AUDIO_CODEC_AAC,</span><br><span class="line">    AUDIO_CODEC_MP3,</span><br><span class="line">    AUDIO_CODEC_PCM,</span><br><span class="line">    AUDIO_CODEC_FLAC, </span><br><span class="line">    AUDIO_CODEC_OPUS,  </span><br><span class="line">    AUDIO_CODEC_VORBIS, </span><br><span class="line">&#125; WS_AUDIO_CODEC_NAME;</span><br></pre></td></tr></table></figure><p>其中AAC需要根据额外信息进行特处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">CWebCodecsAudioDecoder::AudioSpecificConfigFromExtraPktData</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_eAudioCodecName = AUDIO_CODEC_NONE;</span><br><span class="line">        <span class="built_in">memset</span>(m_sCodecOfAudioWebCodecConfig, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((m_dwFourCC == <span class="string">&#x27; CAA&#x27;</span> )) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((m_pExtraData) &amp;&amp; (m_nExtraDataSize &gt; <span class="number">0</span>))&#123;<span class="comment">//ADIF</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">AudioAACSpecificConfigFromExtraPktData</span>() == <span class="literal">true</span>)&#123;</span><br><span class="line">                    m_eAudioCodecName = AUDIO_CODEC_AAC;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//If description is present, it is assumed to a AudioSpecificConfig as defined in [iso14496-3] section 1.6.2.1, Table 1.15, and the bitstream is assumed to be in aac.</span></span><br><span class="line">                    <span class="comment">//If the description is not present, the bitstream is assumed to be in adts format.</span></span><br><span class="line">                    <span class="comment">//The sampleRate and numberOfChannels members are ignored.</span></span><br><span class="line">                    m_bWebCodecAudioDecoderConfigDescriptionExistsFlag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">MTLogEx</span>(<span class="string">L&quot;Info:CWebCodecsAudioDecoder:AudioSpecificConfigFromExtraPktData m_eAudioCodecName = AUDIO_CODEC_AAC, m_sCodecOfAudioWebCodecConfig = %s \n&quot;</span>,m_sCodecOfAudioWebCodecConfig);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">MTLogEx</span>(<span class="string">L&quot;Error:CWebCodecsAudioDecoder:AudioSpecificConfigFromExtraPktData AudioAACSpecificConfigFromExtraPktData failed \n&quot;</span>);</span><br><span class="line">                    <span class="keyword">goto</span> WEB_AUDIO_DECODER_CONFIG_FAILED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//ADTS</span></span><br><span class="line">                m_bWebCodecAudioDecoderConfigDescriptionExistsFlag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//default to mp4a.40.02</span></span><br><span class="line">                <span class="built_in">sprintf</span>(m_sCodecOfAudioWebCodecConfig, <span class="string">&quot;%s.%02d&quot;</span>, audio_codec_type[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">                <span class="built_in">MTLogEx</span>(<span class="string">L&quot;Info:CWebCodecsAudioDecoder:AudioSpecificConfigFromExtraPktData m_eAudioCodecName = AUDIO_CODEC_AAC, m_sCodecOfAudioWebCodecConfig = %s \n&quot;</span>,m_sCodecOfAudioWebCodecConfig);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((m_dwFourCC == <span class="string">&#x27; AMCP&#x27;</span>) || (m_dwFourCC == <span class="string">&#x27;WALU&#x27;</span>) </span><br><span class="line">        || (m_dwFourCC == <span class="string">&#x27;8MCP&#x27;</span>) || (m_dwFourCC == <span class="string">&#x27; WAR&#x27;</span>) || (m_dwFourCC == <span class="string">&#x27; MCP&#x27;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//The description is expected to be omitted from the AudioDecoderConfig.</span></span><br><span class="line">            m_bWebCodecAudioDecoderConfigDescriptionExistsFlag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//PCM file extra data = nullptr</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">AudioPCMSpecificConfig</span>() == <span class="literal">true</span>)&#123;</span><br><span class="line">                m_eAudioCodecName = AUDIO_CODEC_PCM;</span><br><span class="line">                <span class="built_in">MTLogEx</span>(<span class="string">L&quot;Info:CWebCodecsAudioDecoder:AudioSpecificConfigFromExtraPktData m_eAudioCodecName = AUDIO_CODEC_PCM, m_sCodecOfAudioWebCodecConfig = %s \n&quot;</span>,m_sCodecOfAudioWebCodecConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">MTLogEx</span>(<span class="string">L&quot;Error:CWebCodecsAudioDecoder:AudioSpecificConfigFromExtraPktData AudioPCMSpecificConfig failed \n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> WEB_AUDIO_DECODER_CONFIG_FAILED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m_dwFourCC == <span class="string">&#x27; 3PM&#x27;</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">sprintf</span>(m_sCodecOfAudioWebCodecConfig, <span class="string">&quot;%s&quot;</span>, audio_codec_type[<span class="number">11</span>]);</span><br><span class="line">            m_eAudioCodecName = AUDIO_CODEC_MP3;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//description is not used for this codec.The sampleRate and numberOfChannels members are ignored.</span></span><br><span class="line">            m_bWebCodecAudioDecoderConfigDescriptionExistsFlag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//In MP3 files, extradata is often called ID3 tags. ID3 tags are a standardized format for </span></span><br><span class="line">            <span class="comment">//storing metadata (such as song title, artist, album, etc.) in audio files.</span></span><br><span class="line">            <span class="comment">//It should be noted that extradata (ID3 tag) is not part of the MP3 audio encoding itself, </span></span><br><span class="line">            <span class="comment">//it is just additional information used to store metadata. For decoding audio data, </span></span><br><span class="line">            <span class="comment">//we do not need to parse and use metadata information in extradata.</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">MTLogEx</span>(<span class="string">L&quot;Info:CWebCodecsAudioDecoder:AudioSpecificConfigFromExtraPktData m_eAudioCodecName = AUDIO_CODEC_MP3, m_sCodecOfAudioWebCodecConfig = %s \n&quot;</span>,m_sCodecOfAudioWebCodecConfig);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(....)&#123;</span><br><span class="line">            .....</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">MTLogEx</span>(<span class="string">L&quot;Error:CWebCodecsAudioDecoder:AudioSpecificConfigFromExtraPktData m_eAudioCodecName = AUDIO_CODEC_NONE, m_dwFourCC not support!!!&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> WEB_AUDIO_DECODER_CONFIG_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">WEB_AUDIO_DECODER_CONFIG_FAILED:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">MTLogEx</span>(<span class="string">L&quot;Error:CWebCodecsAudioDecoder:AudioSpecificConfigFromExtraPktData m_dwFourCC = %s failed \n&quot;</span>,m_dwFourCC);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// --------------------------------- The following interfaces are used for processing extra data ------------------------------------------ //</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">CWebCodecsAudioDecoder::AudioAACSpecificConfigFromExtraPktData</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">uint8_t</span>* extradata = m_pExtraData;</span><br><span class="line">        <span class="type">int</span> extradataSize =  m_nExtraDataSize;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            The extra data for MPEG-2 video starts with 00 00 01 B3, while the extra data for MPEG-4 video starts with 0000 01 or 00 00 00 01</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            For MPEG-2 AAC, you can check specific bits of the first byte of extradata. Bits 6 and 7 of the first byte of MPEG-2 AAC extradata represent the value of AudioObjectType. </span></span><br><span class="line"><span class="comment">            If the value of these two bits is 0, it means MPEG-2 AAC.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            For MPEG-4 AAC, you can check specific bits of the first byte of extradata. Bits 6 and 7 of the first byte of MPEG-4 AAC extradata represent the value of AudioObjectType. </span></span><br><span class="line"><span class="comment">            If the value of these two bits is not 0, it means MPEG-4 AAC.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> ((extradata[<span class="number">0</span>] &amp; <span class="number">0x30</span>) == <span class="number">0x00</span>) &#123;<span class="comment">//MPEG2_AAC</span></span><br><span class="line">           <span class="comment">//PS: The AudioObjectType value of MPEG-2 AAC is not stored directly in extradata, but is stored in a specific bit of the first byte.</span></span><br><span class="line">           <span class="built_in">sprintf</span>(m_sCodecOfAudioWebCodecConfig, <span class="string">&quot;%s&quot;</span>, audio_codec_type[<span class="number">1</span>]);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//MPEG4_AAC</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> audioObjectType = (extradata[<span class="number">0</span>] &gt;&gt; <span class="number">3</span>) &amp; <span class="number">0x1F</span>;</span><br><span class="line">            <span class="built_in">MTLogEx</span>(<span class="string">L&quot;Info:CWebCodecsAudioDecoder:AudioAACSpecificConfigFromExtraPktData audioObjectType = %d\n&quot;</span>,audioObjectType);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> channels = (extradata[<span class="number">1</span>] &gt;&gt; <span class="number">3</span>) &amp; <span class="number">0x0F</span>;</span><br><span class="line">            <span class="type">int</span> sbrPresent = ((extradata[<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x01</span>) == <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> psPresent = (extradata[<span class="number">1</span>] &amp; <span class="number">0x01</span>) == <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> sampleRate = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sampleRateIndex = ((extradata[<span class="number">0</span>] &amp; <span class="number">0x07</span>) &lt;&lt; <span class="number">1</span>) | ((extradata[<span class="number">1</span>] &gt;&gt; <span class="number">7</span>) &amp; <span class="number">0x01</span>);</span><br><span class="line">            <span class="keyword">if</span> (sampleRateIndex == <span class="number">0xf</span>) &#123;</span><br><span class="line">                sampleRate = (extradata[<span class="number">1</span>] &lt;&lt; <span class="number">12</span>) | (extradata[<span class="number">2</span>] &lt;&lt; <span class="number">4</span>) | ((extradata[<span class="number">3</span>] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xf</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (sampleRateIndex) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0x0</span>:</span><br><span class="line">                        sampleRate = <span class="number">96000</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0x1</span>:</span><br><span class="line">                        sampleRate= <span class="number">88200</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0x2</span>:</span><br><span class="line">                        sampleRate = <span class="number">64000</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0x3</span>:</span><br><span class="line">                        sampleRate = <span class="number">48000</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0x4</span>:</span><br><span class="line">                        sampleRate = <span class="number">44100</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0x5</span>:</span><br><span class="line">                        sampleRate = <span class="number">32000</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0x6</span>:</span><br><span class="line">                        sampleRate = <span class="number">24000</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0x7</span>:</span><br><span class="line">                        sampleRate = <span class="number">22050</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0x8</span>:</span><br><span class="line">                        sampleRate = <span class="number">16000</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0x9</span>:</span><br><span class="line">                        sampleRate = <span class="number">12000</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0xA</span>:</span><br><span class="line">                        sampleRate =<span class="number">11025</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0xB</span>:</span><br><span class="line">                        sampleRate = <span class="number">8000</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        sampleRate = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">MTLogEx</span>(<span class="string">L&quot;Info:CWebCodecsAudioDecoder:AudioAACSpecificConfigFromExtraPktData channels = %d, sampleRate = %d,sbrPresent = %d, psPresent = %d\n&quot;</span>,channels,sampleRate,sbrPresent,psPresent);</span><br><span class="line">            <span class="built_in">sprintf</span>(m_sCodecOfAudioWebCodecConfig, <span class="string">&quot;%s.%02d&quot;</span>, audio_codec_type[<span class="number">0</span>],audioObjectType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">CWebCodecsAudioDecoder::AudioPCMSpecificConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m_dwFourCC == <span class="string">&#x27;AMCP&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(m_sCodecOfAudioWebCodecConfig, <span class="string">&quot;%s&quot;</span>, audio_codec_type[<span class="number">11</span>]);<span class="comment">// A-law PCM</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(m_dwFourCC == <span class="string">&#x27;WALU&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(m_sCodecOfAudioWebCodecConfig, <span class="string">&quot;%s&quot;</span>, audio_codec_type[<span class="number">12</span>]);<span class="comment">// u-law PCM</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((m_dwFourCC == <span class="string">&#x27;8MCP&#x27;</span>) || (m_dwFourCC == <span class="string">&#x27; WAR&#x27;</span>))&#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(m_sCodecOfAudioWebCodecConfig, <span class="string">&quot;%s&quot;</span>, audio_codec_type[<span class="number">6</span>]);<span class="comment">// — using format u8</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(m_dwFourCC == <span class="string">&#x27; MCP&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">switch</span> (m_stWSAudioInfo.bitspersample)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">8</span>:&#123;</span><br><span class="line">                    <span class="built_in">MTLogEx</span>(<span class="string">L&quot;Error:CWebCodecsAudioDecoder:AudioAACSpecificConfigFromExtraPktData failed, bitspersample = 8, m_dwFourCC != &#x27;8MCP&#x27;, webcodec audio decoder not support fourcc S8 \n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">16</span>:&#123;</span><br><span class="line">                    <span class="built_in">sprintf</span>(m_sCodecOfAudioWebCodecConfig, <span class="string">&quot;%s&quot;</span>, audio_codec_type[<span class="number">7</span>]);<span class="comment">// — using format s16</span></span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">24</span>:&#123;</span><br><span class="line">                    <span class="built_in">sprintf</span>(m_sCodecOfAudioWebCodecConfig, <span class="string">&quot;%s&quot;</span>, audio_codec_type[<span class="number">8</span>]);<span class="comment">// — using three byte (24-bit) samples with interleaved channel arrangement.</span></span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">32</span>:&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="built_in">sprintf</span>(m_sCodecOfAudioWebCodecConfig, <span class="string">&quot;%s&quot;</span>, audio_codec_type[<span class="number">9</span>]);<span class="comment">// — using format s32</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="built_in">sprintf</span>(m_sCodecOfAudioWebCodecConfig, <span class="string">&quot;%s&quot;</span>, audio_codec_type[<span class="number">10</span>]);<span class="comment">// — using format f32</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;                </span><br><span class="line">                <span class="keyword">default</span>:&#123;</span><br><span class="line">                    <span class="built_in">MTLogEx</span>(<span class="string">L&quot;Error:CWebCodecsAudioDecoder:AudioPCMSpecificConfig failed, bitspersample = %d \n&quot;</span>,m_stWSAudioInfo.bitspersample);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">MTLogEx</span>(<span class="string">L&quot;Error:CWebCodecsAudioDecoder:AudioPCMSpecificConfig failed, m_dwFourCC = %s  \n&quot;</span>,m_dwFourCC);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>PS：对于aac的fourcc输入的pkt数据有两种类型：</p><ul><li>ADTS (不存在额外数据)</li><li>ADIF (存在额外数据)</li></ul><p>AAC音频格式：Advanced Audio Coding(高级音频解码)，是一种由MPEG-4标准定义的有损音频压缩格式，AAC属于有损压缩的格式，无损压缩格式有APE、FLAC，AAC的有损压缩优点在于体积小，而且声音几乎没有明显下降，所以目前AAC音频编码还是主流的音频压缩格式。<br>AAC编码分为两种方式，一种是AAC_ADIF，一种是AAC_ADTS。<br>ADIF：Audio Data Interchange Format 音频数据交换格式。这种格式的特征是可以确定的找到这个音频数据的开始，不需进行在音频数据流中间开始的解码，即它的解码必须在明确定义的开始处进行。故这种格式常用在磁盘文件中。<br>ADTS的全称是Audio Data Transport Stream。是AAC音频的传输流格式。AAC音频格式在MPEG-2（ISO-13318-7 2003）中有定义。AAC后来又被采用到MPEG-4标准中。这种格式的特征是它是一个有同步字的比特流，解码可以在这个流中任何位置开始。它的特征类似于mp3数据流格式。<br>所以两者的主要区别是，ADTS可以在任意帧解码，也就是说它每一帧都有头信息。ADIF只有一个统一的头信息，所以必须得到所有的数据后解码。</p><p>而JS层的Config只需要这些参数codec,sampleRate,numberOfChannels,description：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Configure config information</span></span><br><span class="line"><span class="keyword">let</span> config=&#123;&#125;;</span><br><span class="line">config.<span class="property">codec</span> = codec_str;</span><br><span class="line">config.<span class="property">sampleRate</span> = codec_sample_rate;</span><br><span class="line">config.<span class="property">numberOfChannels</span> = codec_channel_number;</span><br><span class="line">      <span class="keyword">if</span>(extra_data_size &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(extra_data_size);</span><br><span class="line">          <span class="keyword">let</span> pData = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(buffer);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; extra_data_size; i++) &#123;</span><br><span class="line">              pData[i] = <span class="title class_">Module</span>.<span class="property">HEAPU8</span>[extra_data_ptr + i];</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(buffer);</span><br><span class="line"></span><br><span class="line">          config.<span class="property">description</span> = pData;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">AudioDecoder</span>.<span class="title function_">isConfigSupported</span>(config).<span class="title function_">then</span>(<span class="function"><span class="params">decoderSupport</span>=&gt;</span>&#123;<span class="comment">//Configure config information</span></span><br><span class="line"><span class="keyword">let</span> config=&#123;&#125;;</span><br><span class="line">config.<span class="property">codec</span> = codec_str;</span><br><span class="line">config.<span class="property">sampleRate</span> = codec_sample_rate;</span><br><span class="line">config.<span class="property">numberOfChannels</span> = codec_channel_number;</span><br><span class="line">      <span class="keyword">if</span>(extra_data_size &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(extra_data_size);</span><br><span class="line">          <span class="keyword">let</span> pData = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(buffer);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; extra_data_size; i++) &#123;</span><br><span class="line">              pData[i] = <span class="title class_">Module</span>.<span class="property">HEAPU8</span>[extra_data_ptr + i];</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(buffer);</span><br><span class="line"></span><br><span class="line">          config.<span class="property">description</span> = pData;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">AudioDecoder</span>.<span class="title function_">isConfigSupported</span>(config).<span class="title function_">then</span>(<span class="function"><span class="params">decoderSupport</span>=&gt;</span>&#123;</span><br><span class="line">                      <span class="keyword">if</span> (!decoderSupport.<span class="property">supported</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;CreateWebCodecAudioDecoder::Error: AudioDecoder config is not supported.&quot;</span>);</span><br><span class="line"></span><br><span class="line">                          <span class="comment">//Notify the bottom layer that the audio decoder under this config parameter failed to be created.</span></span><br><span class="line">                          <span class="title class_">Module</span>.<span class="title function_">_Native_WebCodecAudioDecoderCreateStatus</span>(<span class="variable language_">this</span>.<span class="property">webcodec_audio_decoder_obj_adrr</span>, <span class="number">0</span>);</span><br><span class="line">                          </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">                      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(decoderSupport.<span class="property">config</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> init = &#123;</span><br><span class="line"><span class="title function_">output</span>(<span class="params">audio_frame</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> ws_auido_decoder = <span class="title class_">WebCodec</span>_Audio_Decoder_Obj_Table[webcodec_audio_decoder_obj_adrr];</span><br><span class="line"><span class="keyword">if</span> (ws_auido_decoder) &#123;</span><br><span class="line"><span class="keyword">if</span>((ws_auido_decoder.<span class="property">audio_decoder_destroy_flag</span> != <span class="number">0</span>) || (ws_auido_decoder.<span class="property">audio_decoder_reset_flag</span> != <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;audio frame from webcodec dropped because of flushing&quot;</span>);</span><br><span class="line">audio_frame.<span class="title function_">close</span>();</span><br><span class="line">&#125; </span><br><span class="line">                                  <span class="keyword">else</span> &#123;</span><br><span class="line">                                      <span class="comment">//Save the decoded audio frames into the list and wait for the subsequent format conversion processing of the audio decoded frames.</span></span><br><span class="line">ws_auido_decoder.<span class="title class_">AddAudioFrameToList</span>(audio_frame);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                                  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;audio frame from webcodec dropped because of webcodec destroyed&quot;</span>);</span><br><span class="line">audio_frame.<span class="title function_">close</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">error</span>(<span class="params">e</span>) &#123;<span class="comment">//Used to handle errors thrown by webcodec when decoding</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(e.<span class="property">name</span> + <span class="string">&quot;: &quot;</span> + e.<span class="property">message</span> );</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">audio_decoder</span> = <span class="keyword">new</span> <span class="title class_">AudioDecoder</span>(init);</span><br><span class="line">                          <span class="variable language_">this</span>.<span class="property">audio_decoder</span>.<span class="title function_">configure</span>(decoderSupport.<span class="property">config</span>);<span class="comment">//Configure audio codec</span></span><br><span class="line">                      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                          <span class="variable language_">console</span>.<span class="title function_">error</span>(e.<span class="property">name</span> + <span class="string">&quot;: &quot;</span> + e.<span class="property">message</span> + <span class="string">&quot;custom: audio decoder configure error&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Module</span>.<span class="title function_">_Native_WebCodecAudioDecoderCreateStatus</span>(<span class="variable language_">this</span>.<span class="property">webcodec_audio_decoder_obj_adrr</span>, <span class="number">0</span>); <span class="comment">// audio decoder configure error</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">//Register an event handler for a specific event type EventTarget</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">&#x27;addEventListener&#x27;</span> <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">audio_decoder</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebCodec audio decoder has addEventListener function, enabled&quot;</span>);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">audio_decoder</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;dequeue&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Async queue more decoding work</span></span><br><span class="line"><span class="comment">// call native to dispatch event to thread scheduled by mainloop</span></span><br><span class="line"><span class="title class_">Module</span>.<span class="title function_">_Native_WebCodecAudioDecoderProcessEvent</span>(<span class="variable language_">this</span>.<span class="property">webcodec_audio_decoder_obj_adrr</span>, <span class="number">1</span>, <span class="variable language_">this</span>.<span class="property">source_thread_id</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebCodec audio decoder has addEventListener function, disabled&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// all success!</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Js::WS_WebCodecAuidoDecoderClass::CreateWebCodecAudioDecoder decoder create success&quot;</span>);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">audio_decoder_config</span> = decoderSupport.<span class="property">config</span>;</span><br><span class="line"><span class="title class_">Module</span>.<span class="title function_">_Native_WebCodecAudioDecoderCreateStatus</span>(<span class="variable language_">this</span>.<span class="property">webcodec_audio_decoder_obj_adrr</span>, <span class="number">1</span>);<span class="comment">//Notify the underlying audio decoder is successfully created</span></span><br><span class="line"></span><br><span class="line">                  &#125; <span class="comment">// end decoder support logic</span></span><br><span class="line">                  , <span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">                      <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">name</span> + <span class="string">&quot;: &quot;</span> + e.<span class="property">message</span>);</span><br><span class="line"><span class="title class_">Module</span>.<span class="title function_">_Native_WebCodecAudioDecoderCreateStatus</span>(<span class="variable language_">this</span>.<span class="property">webcodec_audio_decoder_obj_adrr</span>, <span class="number">0</span>); <span class="comment">// check decoder support fail</span></span><br><span class="line">                  &#125;</span><br><span class="line">      );</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="PutData-…-函数的具体实现"><a href="#PutData-…-函数的具体实现" class="headerlink" title="PutData(…)函数的具体实现"></a>PutData(…)函数的具体实现</h2><p>对于CWebCodecAudioDecoder类的PutData函数的实现主要有以下几个步骤：</p><ul><li>1.对于包含关键帧且解码器已重置的关键帧，我们需要清除列表中的block数据。</li><li>2.判断当前WebCodecs是否初始化成功，如果不成功则直接return 0；PS可以设置一个GetWebCodecAudioDecoderCurrentStatus，用于判断当前是否是正常工作状态，还是Reset&#x2F;Init&#x2F;Abort等状态</li><li>3.判断输入的Block是否为空。如果为空，则表示所有Block数据均已PutData。此时m_bPutDataAllBlocks置1并返回0.，通知上层PutData结束。</li><li>4.将输入的pack数据存放到m_lstBlocks，同时将对应的pts信息存放到m_lstPts，并对m_lstPts数据进行排序</li></ul><h2 id="GetNextFrame-…-函数的具体实现"><a href="#GetNextFrame-…-函数的具体实现" class="headerlink" title="GetNextFrame(…)函数的具体实现"></a>GetNextFrame(…)函数的具体实现</h2><p>对于CWebCodecAudioDecoder类的GetNextFrame函数的实现主要有以下几个步骤：</p><p>整个取音频解码帧的策略：</p><ul><li>第一步：首先判断当前WebCodec音频解码插件的运行状态。 如果不是正常运行状态，则直接输出错误信息日志，然后返回nullptr。</li><li>步骤2：判断音频解码帧队列中是否有音频解码帧<br>  如果队列中有解码后的音频帧：则先回收m_pMediaFrame资源，然后使用m_pMediaFrame接收从解码帧队列中获取的音频解码帧； 然后将帧返回给上层<br>  如果队列中不存在解码后的音频帧：<br>  首先判断是否所有的Blok都已经发送到m_listSavePutDataBlocks中。 如果没有全部发送完毕，并且m_listSavePutDataBlocks中存储的待解码的Blok数量小于8，<br>  然后返回nullptr，并输出一条日志，要求发送更多的Blok（PS：音频解码器不需要做这一步，因为音频没有关键帧的概念）<br>  接下来，创建一个 do-while(1) 无限循环，并在循环体内添加三个中断条件：<br>      第一个中断条件：等待一定时间后，发现音频解码帧队列中有帧。<br>      第二个断点条件：判断是否满足以下所有条件：<br>          1.JS层通知Flush(m_bNativeWebCodecAudioDecoderNotifyFlush)。 PS：当前JS层audio_frame_list_size &#x3D; 0<br>          2.音频解码帧队列为空<br>          3、JS层存放解码后的音频帧的List大小为0。<br>          4. JS层没有任何音频解码，解码帧正在由ProcessAudioFrame处理。<br>      第三个断点条件：发现音频解码帧队列中有帧<br>      第四个中断条件：没有PutData来完成所有的Blok，但是PutData之前存储的List of Bloks已经为空。</li></ul><p>PS：设置m_evAudioDecoderFrameAvailable和条件一、三的目的是为了设置while等待，防止无休止的while循环，从而减少CPU消耗。</p><h2 id="Reset-函数的具体实现"><a href="#Reset-函数的具体实现" class="headerlink" title="Reset()函数的具体实现"></a>Reset()函数的具体实现</h2><p>对于CWebCodecAudioDecoder类的Reset函数的实现主要有以下几个步骤：</p><ul><li>1.将Reset标志设置为true</li><li>2.通知JS层的WebCodecs音频解码器我们准备重置了，此时Js层可以加一个判断，当收到这个消息的时候就不在对解码后的帧做任何的帧处理操作</li><li>3.等待JS层WebCodec完成所有解码帧的ProcessAudioFrame处理。此时JS层的ProcessAudioFrame函数满足if(this.resetFlag &#x3D;&#x3D; 1)，所以它只等待当前正在由 ProcessAudioFrame 处理的音频帧，其余仍在audio_frame_list中的音频解码帧不会被处理，直接返回。</li><li>4.通过设置task:Reset，调用JS_WebCodecAudioDecoderReset通知,JS层WebCodecs音频解码器执行Reset操作。</li><li>5.等待JS层WebCodecs音频解码器完成Reset操作。</li><li>6.相关类成员变量恢复初始化状态</li><li>7.释放Reset操作需要释放的资源</li></ul><p>接收task，并调用对应的JS接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CWebCodecsAudioDecoder::DoAudioDecoderWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="built_in">JSLayerWebCodecAudioDecoderTryGetFrame</span>();<span class="comment">//尝试从JS层取解码帧</span></span><br><span class="line">     <span class="built_in">JSLayerWebCodecAudioDecoderDecodeChunk</span>();<span class="comment">//向JS层送Blocks</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">GetAudioDecoderTaskCount</span>() &lt;= <span class="number">0</span>) &#123;<span class="comment">//判断是否接收到Task</span></span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//处理Task</span></span><br><span class="line">     <span class="keyword">do</span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="type">int</span> task = <span class="built_in">GetAudioDecoderTask</span>();</span><br><span class="line">         <span class="keyword">if</span>(task == WEBCODECS_AUDIO_DECODER_MSG_DEFAULT) </span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">switch</span> (task)</span><br><span class="line">         &#123;</span><br><span class="line">         <span class="keyword">case</span> WEBCODECS_AUDIO_DECODER_MSG_EXIT:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> WEBCODECS_AUDIO_DECODER_MSG_CREATE_DECODER:</span><br><span class="line">             <span class="built_in">JSLayerCreateWebCodecAudioDecoder</span>(); </span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> WEBCODECS_AUDIO_DECODER_MSG_MSG_DECODE_CHUNK:</span><br><span class="line">             <span class="built_in">JSLayerWebCodecAudioDecoderDecodeChunk</span>();</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> WEBCODECS_AUDIO_DECODER_MSG_MSG_FLUSH_DECODER:</span><br><span class="line">             <span class="built_in">JSLayerWebCodecAudioDecoderFlush</span>();</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> WEBCODECS_AUDIO_DECODER_MSG_SET_RESET_FLAG:</span><br><span class="line"><span class="built_in">JSLayerWebCodecAudioDecoderSetResetFlag</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> WEBCODECS_AUDIO_DECODER_MSG_RESET_DECODER:</span><br><span class="line">             <span class="built_in">JSLayerWebCodecAudioDecoderReset</span>();</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WEBCODECS_AUDIO_DECODER_MSG_SET_DESTROY_FLAG:</span><br><span class="line"><span class="built_in">JSLayerWebCodecAudioDecoderSetDestroyFlag</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> WEBCODECS_AUDIO_DECODER_MSG_DESTROY_DECODER:</span><br><span class="line">             <span class="built_in">JSLayerDestroyWebCodecAudioDecoder</span>();</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WS_WEB_CODEC_AUDIO_DECODER</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> msg_loop_audio_decoder_svc_init = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> std::mutexg_WebCodecAudioDecoderMux;</span><br><span class="line">    <span class="type">static</span> std::list&lt;CWebCodecsAudioDecoder*&gt; g_WebCodecAudioDecoderList;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span>* audio_codec_type[] = &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="string">&quot;mp4a.40&quot;</span>,          <span class="comment">// - For details, see MPEG-4 audio object types of [https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#avc1.ppccll]</span></span><br><span class="line">        <span class="string">&quot;mp4a.67&quot;</span>,          <span class="comment">// — MPEG-2 AAC LC</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;pcm-u8&quot;</span>,           <span class="comment">// — using format u8</span></span><br><span class="line">        <span class="string">&quot;pcm-s16&quot;</span>,          <span class="comment">// — using format s16</span></span><br><span class="line">        <span class="string">&quot;pcm-s24&quot;</span>,          <span class="comment">// — using three byte (24-bit) samples with interleaved channel arrangement.</span></span><br><span class="line">        <span class="string">&quot;pcm-s32&quot;</span>,          <span class="comment">// — using format s32</span></span><br><span class="line">        <span class="string">&quot;pcm-f32&quot;</span>,          <span class="comment">// — using format f32</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;alaw&quot;</span>,             <span class="comment">// — A-law PCM</span></span><br><span class="line">        <span class="string">&quot;ulaw&quot;</span>,             <span class="comment">// — u-law PCM</span></span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;mp3&quot;</span>,              <span class="comment">// — This codec has multiple equivalent codec strings:&quot;mp3&quot; &quot;mp4a.69&quot; &quot;mp4a.6B&quot; &quot;mp4a.69&quot; We use mp3 here</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;flac&quot;</span>,             <span class="comment">// — Not developed for use</span></span><br><span class="line">        <span class="string">&quot;opus&quot;</span>,             <span class="comment">// — Not developed for use</span></span><br><span class="line">        <span class="string">&quot;vorbis&quot;</span>            <span class="comment">// — Not developed for use</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">MsgLoop</span><span class="params">(<span class="type">void</span>* opaque)</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">bool</span> bInited = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_WebCodecAudioDecoderMux)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (g_WebCodecAudioDecoderList.<span class="built_in">size</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = g_WebCodecAudioDecoderList.<span class="built_in">begin</span>(); it != g_WebCodecAudioDecoderList.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            CWebCodecsAudioDecoder* pDecoder = (*it);</span><br><span class="line">            pDecoder-&gt;<span class="built_in">DoAudioDecoderWork</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span><span class="title">svc</span><span class="params">(<span class="type">void</span>* opaque)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">MTLogEx</span>(<span class="string">L&quot;Info:WS_WEB_CODEC_AUDIO_DECODER::svc audio deocoder msg loop svc start&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Set the main loop function and pass a parameter to the main loop function. </span></span><br><span class="line">        <span class="comment">//This function will be called continuously in the main loop until the program exits.</span></span><br><span class="line">        <span class="built_in">emscripten_set_main_loop_arg</span>(MsgLoop, opaque, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WS_WebCodecAudioDecoderCreateMsgSvc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_WebCodecAudioDecoderMux)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!msg_loop_audio_decoder_svc_init) &#123;</span><br><span class="line">            msg_loop_audio_decoder_svc_init = <span class="number">1</span>;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="function">std::thread <span class="title">cbThread</span><span class="params">(&amp;svc, &amp;g_WebCodecAudioDecoderList)</span></span>;</span><br><span class="line">                cbThread.<span class="built_in">detach</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">                <span class="built_in">MTLogEx</span>(<span class="string">L&quot;Error:WS_WEB_CODEC_AUDIO_DECODER::svc audio deocoder msg loop svc create failed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">WS_WebCodecPutAudioDecoderToList</span><span class="params">(CWebCodecsAudioDecoder* decoder)</span> </span>&#123;<span class="comment">//插件Init的时候调用WS_WebCodecPutAudioDecoderToList(this)</span></span><br><span class="line"> </span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_WebCodecAudioDecoderMux)</span></span>;</span><br><span class="line">        g_WebCodecAudioDecoderList.<span class="built_in">push_back</span>(decoder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">WS_WebCodecPopAudioDecoderFromList</span><span class="params">(CWebCodecsAudioDecoder* decoder)</span> </span>&#123;<span class="comment">//插件运行出现异常的状态的时候调用</span></span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_WebCodecAudioDecoderMux)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = g_WebCodecAudioDecoderList.<span class="built_in">begin</span>(); it != g_WebCodecAudioDecoderList.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it)-&gt;<span class="built_in">GetCurrentWebCodecAudioDecoderAddress</span>() == decoder-&gt;<span class="built_in">GetCurrentWebCodecAudioDecoderAddress</span>()) &#123;</span><br><span class="line">                it = g_WebCodecAudioDecoderList.<span class="built_in">erase</span>(it);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的对外的Init导出函数这边需要调用WS_WebCodecAudioDecoderCreateMsgSvc函数，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> HDECODEPLUGIN __stdcall <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pStreamInfo, <span class="type">const</span> <span class="type">void</span>* pExtraData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">WS_WebCodecAudioDecoderCreateMsgSvc</span>();</span><br><span class="line"></span><br><span class="line">CWebCodecsAudioDecoder* pDecoder = <span class="keyword">new</span> <span class="built_in">CWebCodecsAudioDecoder</span>();</span><br><span class="line"><span class="keyword">if</span> (!pDecoder) &#123;</span><br><span class="line"><span class="built_in">MTLogEx</span>(<span class="string">L&quot;HDECODEPLUGIN Init new CWebCodecsAudioDecoder() failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = pDecoder-&gt;<span class="built_in">Init</span>(pStreamInfo, pExtraData);</span><br><span class="line"><span class="keyword">if</span> (!ret) &#123;</span><br><span class="line"><span class="built_in">MTLogEx</span>(<span class="string">L&quot;HDECODEPLUGIN Init pDecoder-&gt;Init failed&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> pDecoder;</span><br><span class="line">        pDecoder = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;HDECODEPLUGIN&gt;(pDecoder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网上对于WebCodec的音频编解码的方案相关的资料基本只有官方的那个API文档，因此坑相对比较多，最为突出的一个坑就是：webCodecs音频解码后的数据全是f32，无论你源是S16还是什么，反正统一转出来的都是f32,因此如果你想想跟源保持一致的位深的话，就需要下面这段代码进行转换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//According to the decoded frame information, copy the PCM data on each plane</span></span><br><span class="line"><span class="keyword">var</span> audio_frame_plane_size = [];</span><br><span class="line"><span class="keyword">var</span> audio_frame_plane_data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; codec_channel_number; i++)&#123;</span><br><span class="line"></span><br><span class="line">    audio_frame_plane_size[i] = audio_frame.<span class="title function_">allocationSize</span>( &#123; <span class="attr">planeIndex</span>: i &#125;);</span><br><span class="line">    current_audio_decoder_frame_size += audio_frame_plane_size[i];</span><br><span class="line">    <span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(audio_frame_plane_size[i]);</span><br><span class="line">    </span><br><span class="line">    audio_frame_plane_data[i] = <span class="keyword">new</span> <span class="title class_">Float32Array</span>(buffer);</span><br><span class="line">    audio_frame.<span class="title function_">copyTo</span>(audio_frame_plane_data[i] , &#123; <span class="attr">planeIndex</span>: i &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(current_audio_decoder_frame_size &gt; audio_frame_data_buffer_size)&#123;</span><br><span class="line">    audio_frame_data_ptr = <span class="title class_">Module</span>.<span class="title function_">_Native_WebCodecAudioDecoderSetLargerAudioFrameDataBuffer</span>(audio_decoder_obj_adrr,audio_frame_ptr,current_audio_decoder_frame_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> frameBuffer = <span class="title class_">Module</span>.<span class="property">HEAPU8</span>.<span class="title function_">subarray</span>(audio_frame_data_ptr, </span><br><span class="line">    audio_frame_data_ptr + audio_frame_data_buffer_size);</span><br><span class="line"></span><br><span class="line">frameBuffer.<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(codec_bitspersample)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:&#123;<span class="comment">//Convert the decoded audio data to &quot;u8&quot; format</span></span><br><span class="line"></span><br><span class="line">        process_audio_decoder_frame_size = audio_frame.<span class="property">numberOfFrames</span>*(<span class="number">8</span>/<span class="number">8</span>)*codec_channel_number;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; audio_frame.<span class="property">numberOfFrames</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//process left channel sample data</span></span><br><span class="line">            <span class="keyword">const</span> left_channel_sample_data = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">1</span>, audio_frame_plane_data[<span class="number">0</span>][i])); <span class="comment">// Limit the data to between 0 and 1</span></span><br><span class="line">            <span class="keyword">const</span> process_int_left_sample_data = <span class="title class_">Math</span>.<span class="title function_">round</span>(left_channel_sample_data * <span class="number">255</span>); <span class="comment">// Scale the data to the 16-bit integer range (0 to 255)</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//process right channel sample data</span></span><br><span class="line">            <span class="keyword">const</span> right_channel_sample_data = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">1</span>, audio_frame_plane_data[<span class="number">1</span>][i])); <span class="comment">// Limit the data to between 0 and 1</span></span><br><span class="line">            <span class="keyword">const</span> process_int_right_sample_data = <span class="title class_">Math</span>.<span class="title function_">round</span>(right_channel_sample_data * <span class="number">255</span>); <span class="comment">// Scale the data to the 16-bit integer range (0 to 255)</span></span><br><span class="line">            </span><br><span class="line">            frameBuffer[<span class="number">2</span> * i] = process_int_left_sample_data &amp; <span class="number">0xFF</span>;</span><br><span class="line">            frameBuffer[<span class="number">2</span> * i + <span class="number">1</span>] = process_int_right_sample_data &amp; <span class="number">0xFF</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">16</span>:&#123;<span class="comment">//Convert the decoded audio data to &quot;s16&quot; format</span></span><br><span class="line"></span><br><span class="line">        process_audio_decoder_frame_size = audio_frame.<span class="property">numberOfFrames</span>*(<span class="number">16</span>/<span class="number">8</span>)*codec_channel_number;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; audio_frame.<span class="property">numberOfFrames</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//process left channel sample data</span></span><br><span class="line">            <span class="keyword">const</span> left_channel_sample_data = <span class="title class_">Math</span>.<span class="title function_">max</span>(-<span class="number">1</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">1</span>, audio_frame_plane_data[<span class="number">0</span>][i])); <span class="comment">// Limit the data to between -1 and 1</span></span><br><span class="line">            <span class="keyword">const</span> process_int_left_sample_data = <span class="title class_">Math</span>.<span class="title function_">round</span>(left_channel_sample_data * <span class="number">32767</span>); <span class="comment">// Scale the data to the 16-bit integer range (-32768 to 32767)</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//process right channel sample data</span></span><br><span class="line">            <span class="keyword">const</span> right_channel_sample_data = <span class="title class_">Math</span>.<span class="title function_">max</span>(-<span class="number">1</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">1</span>, audio_frame_plane_data[<span class="number">1</span>][i])); <span class="comment">// Limit the data to between -1 and 1</span></span><br><span class="line">            <span class="keyword">const</span> process_int_right_sample_data = <span class="title class_">Math</span>.<span class="title function_">round</span>(right_channel_sample_data * <span class="number">32767</span>); <span class="comment">// Scale the data to the 16-bit integer range (-32768 to 32767)</span></span><br><span class="line"></span><br><span class="line">            frameBuffer[<span class="number">4</span> * i] = process_int_left_sample_data &amp; <span class="number">0xFF</span>;</span><br><span class="line">            frameBuffer[<span class="number">4</span> * i + <span class="number">1</span>] = (process_int_left_sample_data &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">            </span><br><span class="line">            frameBuffer[<span class="number">4</span> * i + <span class="number">2</span>] = process_int_right_sample_data &amp; <span class="number">0xFF</span>;</span><br><span class="line">            frameBuffer[<span class="number">4</span> * i + <span class="number">3</span>] = (process_int_right_sample_data &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">24</span>:&#123;<span class="comment">//Convert the decoded audio data to &quot;s24&quot; format</span></span><br><span class="line"></span><br><span class="line">        process_audio_decoder_frame_size = audio_frame.<span class="property">numberOfFrames</span>*(<span class="number">24</span>/<span class="number">8</span>)*codec_channel_number;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; audio_frame.<span class="property">numberOfFrames</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//process left channel sample data</span></span><br><span class="line">            <span class="keyword">const</span> left_channel_sample_data = <span class="title class_">Math</span>.<span class="title function_">max</span>(-<span class="number">1</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">1</span>, audio_frame_plane_data[<span class="number">0</span>][i])); <span class="comment">// Limit the data to between -1 and 1</span></span><br><span class="line">            <span class="keyword">const</span> process_int_left_sample_data = <span class="title class_">Math</span>.<span class="title function_">round</span>(left_channel_sample_data * <span class="number">8388607</span>); <span class="comment">// Scale the data to the 16-bit integer range (-8388608 to 8388607)</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//process right channel sample data</span></span><br><span class="line">            <span class="keyword">const</span> right_channel_sample_data = <span class="title class_">Math</span>.<span class="title function_">max</span>(-<span class="number">1</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">1</span>, audio_frame_plane_data[<span class="number">1</span>][i])); <span class="comment">// Limit the data to between -1 and 1</span></span><br><span class="line">            <span class="keyword">const</span> process_int_right_sample_data = <span class="title class_">Math</span>.<span class="title function_">round</span>(right_channel_sample_data * <span class="number">8388607</span>); <span class="comment">// Scale the data to the 16-bit integer range (-8388608 to 8388607)</span></span><br><span class="line"></span><br><span class="line">            frameBuffer[<span class="number">6</span> * i] = process_int_left_sample_data &amp; <span class="number">0xFF</span>;</span><br><span class="line">            frameBuffer[<span class="number">6</span> * i + <span class="number">1</span>] = (process_int_left_sample_data &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">            frameBuffer[<span class="number">6</span> * i + <span class="number">2</span>] = (process_int_left_sample_data &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">            </span><br><span class="line">            frameBuffer[<span class="number">6</span> * i + <span class="number">3</span>] = process_int_right_sample_data &amp; <span class="number">0xFF</span>;</span><br><span class="line">            frameBuffer[<span class="number">6</span> * i + <span class="number">4</span>] = (process_int_right_sample_data &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">            frameBuffer[<span class="number">6</span> * i + <span class="number">5</span>] = (process_int_right_sample_data &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">32</span>:&#123;</span><br><span class="line">      </span><br><span class="line">        process_audio_decoder_frame_size = audio_frame.<span class="property">numberOfFrames</span>*(<span class="number">32</span>/<span class="number">8</span>)*codec_channel_number;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; audio_frame.<span class="property">numberOfFrames</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            frameBuffer[<span class="number">8</span> * i] = audio_frame_plane_data[<span class="number">0</span>][i] &amp; <span class="number">0xFF</span>;</span><br><span class="line">            frameBuffer[<span class="number">8</span> * i + <span class="number">1</span>] = (audio_frame_plane_data[<span class="number">0</span>][i] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">            frameBuffer[<span class="number">8</span> * i + <span class="number">2</span>] = (audio_frame_plane_data[<span class="number">0</span>][i] &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">            frameBuffer[<span class="number">8</span> * i + <span class="number">3</span>] = (audio_frame_plane_data[<span class="number">0</span>][i] &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">            </span><br><span class="line">            frameBuffer[<span class="number">8</span> * i + <span class="number">4</span>] = audio_frame_plane_data[<span class="number">1</span>][i] &amp; <span class="number">0xFF</span>;</span><br><span class="line">            frameBuffer[<span class="number">8</span> * i + <span class="number">5</span>] = (audio_frame_plane_data[<span class="number">1</span>][i] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">            frameBuffer[<span class="number">8</span> * i + <span class="number">6</span>] = (audio_frame_plane_data[<span class="number">1</span>][i] &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">            frameBuffer[<span class="number">8</span> * i + <span class="number">7</span>] = (audio_frame_plane_data[<span class="number">1</span>][i] &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> audio_frame_pts = audio_frame.<span class="property">timestamp</span>;</span><br><span class="line"><span class="keyword">let</span> audio_frame_duration = audio_frame.<span class="property">duration</span>;</span><br><span class="line">audio_frame.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure><p>当然最好还是把位深转换的这套操作放到C++层来进行会合适一点，这样处理速度也会相对较快.</p><p>PS：解码插件开发中用到的emscripten接口：</p><ul><li>emscripten_dispatch_to_thread</li><li>emscripten_set_main_loop_arg</li></ul><h2 id="emscripten-dispatch-to-thread"><a href="#emscripten-dispatch-to-thread" class="headerlink" title="emscripten_dispatch_to_thread:"></a>emscripten_dispatch_to_thread:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">emscripten_dispatch_to_thread</span><span class="params">(<span class="type">int</span> target_thread_index, <span class="type">void</span> (*job_func)(<span class="type">void</span>*), <span class="type">void</span>* job_arg, <span class="type">int</span> is_main_thread_blocking)</span></span>;</span><br><span class="line">参数说明：</span><br><span class="line">- target_thread_index：目标线程的索引，<span class="number">0</span> 表示主线程，<span class="number">1</span> 表示第一个工作线程，以此类推。</span><br><span class="line">- job_func：要在目标线程中执行的函数指针。</span><br><span class="line">- job_arg：传递给 job_func 函数的参数。</span><br><span class="line">- is_main_thread_blocking：指示是否阻塞主线程，<span class="number">0</span> 表示不阻塞，<span class="number">1</span> 表示阻塞。</span><br><span class="line"></span><br><span class="line">当调用 emscripten_dispatch_to_thread 函数时，它会将任务分派到指定的线程中执行。如果 is_main_thread_blocking 参数为 <span class="number">1</span>，则主线程将被阻塞，直到任务执行完成。</span><br><span class="line">这个函数在多线程的Emscripten应用程序中非常有用，可以将一些耗时的计算或需要在后台执行的任务分发到工作线程中，以避免阻塞主线程，提高应用程序的响应性能。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    The function of this static function is: as the input parameter of emscripten_dispatch_to_thread.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">StaticFunction_SchedulingBasedOnTask</span><span class="params">(<span class="type">int</span> webcodec_audio_decoder_obj_adrr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WS_WEB_CODEC_AUDIO_DECODER::CWebCodecsAudioDecoder* pDecoder = (WS_WEB_CODEC_AUDIO_DECODER::CWebCodecsAudioDecoder*)webcodec_audio_decoder_obj_adrr;</span><br><span class="line">    <span class="keyword">if</span> (pDecoder) &#123;</span><br><span class="line">        pDecoder-&gt;<span class="built_in">DoAudioDecoderWork</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    The function of this function: call emscripten_dispatch_to_thread provided by Emscripten, and schedule the StaticFunction_SchedulingBasedOnTask function (that is, </span></span><br><span class="line"><span class="comment">    the DoAudioDecoderWork that schedules Task) to the specified thread (the thread where the current decoder is located) for execution, </span></span><br><span class="line"><span class="comment">    so that each webcodec_audio_decoder_obj_adrr in the JS layer corresponds to a C++ one The audio decoder makes full use of the computing power </span></span><br><span class="line"><span class="comment">    of multi-core processors to improve the overall performance of the program.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">EMSCRIPTEN_KEEPALIVE <span class="type">int</span> <span class="title">Native_WebCodecAudioDecoderProcessEvent</span><span class="params">(<span class="type">int</span> webcodec_audio_decoder_obj_adrr, <span class="type">int</span> event_type, <span class="type">int</span> target_thread_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (event_type == WEBCODECS_AUDIO_DECODER_EVENT_DECODER_DEQUEUE) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Dispatch code to a specified thread for execution</span></span><br><span class="line">        ret = <span class="built_in">emscripten_dispatch_to_thread</span>(target_thread_id, EM_FUNC_SIG_VI, StaticFunction_SchedulingBasedOnTask, <span class="literal">nullptr</span>, webcodec_audio_decoder_obj_adrr);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">MTLogEx</span>(<span class="string">L&quot;Error:Emscripten emscripten_dispatch_to_thread StaticFunction_SchedulingBasedOnTask not executed via dispatch to thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="emscripten-set-main-loop-arg"><a href="#emscripten-set-main-loop-arg" class="headerlink" title="emscripten_set_main_loop_arg:"></a>emscripten_set_main_loop_arg:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">emscripten_set_main_loop_arg</span><span class="params">(em_callback_func func, <span class="type">void</span>* arg, <span class="type">int</span> fps, <span class="type">int</span> simulate_infinite_loop)</span></span>;</span><br><span class="line">参数说明：</span><br><span class="line">- func：主循环函数的指针，该函数将在每次循环迭代时被调用。</span><br><span class="line">- arg：传递给主循环函数的参数。</span><br><span class="line">- fps：循环的帧率，即每秒钟执行的循环次数。</span><br><span class="line">- simulate_infinite_loop：指示是否模拟无限循环，<span class="number">0</span> 表示不模拟，<span class="number">1</span> 表示模拟。</span><br><span class="line"></span><br><span class="line">当调用 emscripten_set_main_loop_arg 函数时，它会设置一个主循环，该循环将以指定的帧率运行，并在每次循环迭代时调用指定的主循环函数。可以通过 arg 参数传递额外的参数给主循环函数。</span><br><span class="line">这个函数在 Emscripten 应用程序中非常有用，可以用于控制应用程序的主循环，执行一些需要在每帧中更新的操作，例如游戏逻辑、渲染等。通过设置适当的帧率，可以控制应用程序的性能和流畅度。</span><br></pre></td></tr></table></figure><p>对于emscripten的学习，参考官方的文章即可：<a href="https://emscripten.org/docs/introducing_emscripten/about_emscripten.html">https://emscripten.org/docs/introducing_emscripten/about_emscripten.html</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>FFmpeg解码时长与WebCodec解码时长(不包含位深处理直接输出f32)基本一致，但是如果进行位深处理f32转s16的话，耗时增加好几倍。<br>因此结论为：如果不构建整条f32的解码，播放，特效处理，编码的链路的话，没必要使用WebCodecs进行音频解码，因为WebCodecs音频解码后输出的数据全部为f32，而如果根据源信息（一般为S16）进行调整的话，将导致解码耗时增加五六倍。<br>但是采用WebCodecs音频解码的作用主要是：<br>1.绕开专利问题<br>2.打通f32管线，并且采用Web Audio API的重采样方案，节省重采样耗时</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>音视频解码插件系统的架构设计之解码插件的设计</title>
      <link href="/2024/01/06/%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%A7%A3%E7%A0%81%E6%8F%92%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/01/06/%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%A7%A3%E7%A0%81%E6%8F%92%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本篇博客主要讲述一下，如何设计一套解码插件的管理架构，来实现不同类型（视频、音频、图片、文本）压缩数据的解码。<br>首先一个解码插件系统，分为调度层的插件管理器以及各个具体的解码器插件：</p><ul><li>DecoderPluginManager</li><li>WebCodecsAudioDecoderPlugin</li><li>WebCodecsVideoDecoderPlugin</li><li>WebCodecsImageDecoderPlugin</li><li>NvDecPlugin</li><li>OneVPLPlugin</li><li>AMFDecPlugin<br>….</li><li>FFmpegDecoderPlugin</li></ul><p>PS：DecoderMgr用于根据上层调用的输入参数信息结合当前设备的硬件情况，来选择适合的解码器插件进行数据解码</p><h1 id="插件对外接口"><a href="#插件对外接口" class="headerlink" title="插件对外接口"></a>插件对外接口</h1><p>由于插件需要通过上层的一个管理器进行统一调度和交互，因此作为一个解码器插件，无论是音频还是视频的解码器插件，都需要导出下面些接口函数，来跟上层进行交互操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pInfo, <span class="type">const</span> <span class="type">void</span>* pExtraData)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PutData</span><span class="params">(<span class="type">void</span>* pDecoderHandle,<span class="type">const</span> <span class="type">void</span>* pBlock)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">GetNextFrame</span><span class="params">(<span class="type">void</span>* pDecoderHandle)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">(<span class="type">void</span>* pDecoderHandle)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">(<span class="type">void</span>* pDecoderHandle)</span></span>;</span><br><span class="line"><span class="function">__int64 <span class="title">GetCPUMemorySize</span><span class="params">(<span class="type">void</span>* pDecoderHandle)</span></span>;</span><br><span class="line"><span class="function">__int64 <span class="title">GetGPUMemorySize</span><span class="params">(<span class="type">void</span>* pDecoderHandle)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Init-…-函数"><a href="#Init-…-函数" class="headerlink" title="Init(…)函数"></a>Init(…)函数</h2><p>该函数的作用：用于插件初始化的函数。<br>我们需要两个输入参数才能进行解码器插件的初始化操作：</p><ul><li>pInfo:基本的音频或者视频流的信息，例如(fourcc 音频的位深、声道数，采样率，视频的宽高等信息)</li><li>pExtraData:pkt的额外数据</li></ul><h2 id="PutData-…-函数"><a href="#PutData-…-函数" class="headerlink" title="PutData(…)函数"></a>PutData(…)函数</h2><p>该函数的作用：用于往解码器插件送入待解码的音频数据块</p><h2 id="GetNextFrame-…-函数函数"><a href="#GetNextFrame-…-函数函数" class="headerlink" title="GetNextFrame(…)函数函数"></a>GetNextFrame(…)函数函数</h2><p>该函数的作用：用于获取解码器下一个已解码的帧</p><h2 id="Reset-…-函数函数"><a href="#Reset-…-函数函数" class="headerlink" title="Reset(…)函数函数"></a>Reset(…)函数函数</h2><p>该函数的作用：用于重置解码器，此时解码器插件里之前送进来的block或正在解码的block，以及已经完成解码的帧均会被清除掉。该接口一般用于上层进行Seek操作或时触发。</p><h2 id="Close-…-函数"><a href="#Close-…-函数" class="headerlink" title="Close(…)函数"></a>Close(…)函数</h2><p>该函数的作用：用于关闭解码器插件</p><h2 id="GetCPUMemorySize-…-函数"><a href="#GetCPUMemorySize-…-函数" class="headerlink" title="GetCPUMemorySize(…)函数"></a>GetCPUMemorySize(…)函数</h2><p>该函数的作用：获取当前解码器插件的CPU内存占用大小</p><h2 id="GetGPUMemorySize-…-函数"><a href="#GetGPUMemorySize-…-函数" class="headerlink" title="GetGPUMemorySize(…)函数"></a>GetGPUMemorySize(…)函数</h2><p>该函数的作用：获取当前解码器插件的GPU显存占用大小</p><h1 id="对应的接口声明以及结构体定义如下："><a href="#对应的接口声明以及结构体定义如下：" class="headerlink" title="对应的接口声明以及结构体定义如下："></a>对应的接口声明以及结构体定义如下：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>* (__stdcall* INIT_API_DECODER_PLUGIN)(<span class="type">const</span> <span class="type">void</span>* pInfo, <span class="type">const</span> <span class="type">void</span>* pExtraData);</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(__stdcall* PUTDATA_API_DECODER_PLUGIN)</span><span class="params">(<span class="type">void</span>* pDecoderHandle, <span class="type">const</span> <span class="type">void</span>* pBlock)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>* (__stdcall* GETNEXTFRAME_API_DECODER_PLUGIN)(<span class="type">void</span>* pDecoderHandle);</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(__stdcall* RESET_API_DECODER_PLUGIN)</span><span class="params">(<span class="type">void</span>* pDecoderHandle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(__stdcall* CLOSE_API_DECODER_PLUGIN)</span><span class="params">(<span class="type">void</span>* pDecoderHandle)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> __int64 (__stdcall* GET_CPU_MEMORY_SIZE_API_DECODER_PLUGIN)(<span class="type">void</span>* pDecoderHandle);</span><br><span class="line"><span class="keyword">typedef</span> __int64 (__stdcall* GET_GPU_MEMORY_SIZE_API_DECODER_PLUGIN)(<span class="type">void</span>* pDecoderHandle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">emDecoderPluginPriority</span>&#123;</span><br><span class="line">    HIGHEST,</span><br><span class="line">    HIGH,</span><br><span class="line">    LOW,</span><br><span class="line">    LOWEST,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">emDecoderPluginType</span>&#123;</span><br><span class="line">NONE,</span><br><span class="line">    VIDEO,</span><br><span class="line">    AUDIO,</span><br><span class="line">    SUBTITLE,</span><br><span class="line">    IMAGE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stDecoderPluginItem</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">wchar_t</span>                description_info_[<span class="number">64</span>];<span class="comment">//描述信息</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>                FourCC_;<span class="comment">//用于识别当前解码器支持解码哪些FourCC</span></span><br><span class="line">emDecoderPluginType         type_;<span class="comment">//用于识别当前解码插件是哪种类型的插件(音频、视频。图片)</span></span><br><span class="line">emDecoderPluginPriority     priority_;<span class="comment">//用于判断当前解码器的优先级，上层根据该参数的大小来决定优先选择哪个解码器进行解码</span></span><br><span class="line"></span><br><span class="line">INIT_API_DECODER_PLUGINInit_;</span><br><span class="line">PUTDATA_API_DECODER_PLUGINPutData_;</span><br><span class="line">GETNEXTFRAME_API_DECODER_PLUGINGetNextFrame_;</span><br><span class="line">RESET_API_DECODER_PLUGINReset_;</span><br><span class="line">CLOSE_API_DECODER_PLUGINDemuxGetMaxBlockSizeClose_;</span><br><span class="line">GET_CPU_MEMORY_SIZE_API_DECODER_PLUGINGetCPUMemorySize_;</span><br><span class="line">GET_GPU_MEMORY_SIZE_API_DECODER_PLUGINGetGPUMemorySize_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> stDecoderPluginItem* (__stdcall* GET_DECODER_PLUGIN_INFO_ARRAY_API)();</span><br></pre></td></tr></table></figure><h2 id="接口的具体实现："><a href="#接口的具体实现：" class="headerlink" title="接口的具体实现："></a>接口的具体实现：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> MT_WEB_CODEC_AUDIO_DECODER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* __stdcall <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pInfo, <span class="type">const</span> <span class="type">void</span>* pExtraData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CXXXDecoder* pCXXXDecoder = <span class="keyword">new</span> <span class="built_in">CXXXDecoder</span>();</span><br><span class="line"><span class="keyword">if</span> (CXXXDecoder == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">MTLogEx</span>(<span class="string">L&quot;Error: vdpXXXDecoder Init failed(Because: new CXXXDecoder() failed,pCXXXDecoder = NULL) !!!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> bInitResult = pCXXXDecoder-&gt;<span class="built_in">Init</span>(pInfo, pExtraData);</span><br><span class="line"><span class="keyword">if</span> (bInitResult == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="built_in">MTLogEx</span>(<span class="string">L&quot;Info: vdpXXXDecoder Init Success !!!&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> pCXXXDecoder;</span><br><span class="line">        pCXXXDecoder = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(pCXXXDecoder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __stdcall <span class="title">PutData</span><span class="params">(<span class="type">void</span>* pDecoderHandle, <span class="type">const</span> <span class="type">void</span>* pBlock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CXXXDecoder* pDecoder = <span class="built_in">static_cast</span>&lt;CXXXDecoder*&gt;(pDecoderHandle);</span><br><span class="line"><span class="keyword">return</span> pDecoder-&gt;<span class="built_in">PutData</span>(pBlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> MEDIA_FRAME* __stdcall <span class="title">GetNextFrame</span><span class="params">(<span class="type">void</span>* pDecoderHandle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CXXXDecoder* pDecoder = <span class="built_in">static_cast</span>&lt;CXXXDecoder*&gt;(pDecoderHandle);</span><br><span class="line"><span class="keyword">return</span> pDecoder-&gt;<span class="built_in">GetNextFrame</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __stdcall <span class="title">Reset</span><span class="params">(<span class="type">void</span>* pDecoderHandle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CXXXDecoder* pDecoder = <span class="built_in">static_cast</span>&lt;CXXXDecoder*&gt;(pDecoderHandle);</span><br><span class="line">pDecoder-&gt;<span class="built_in">Reset</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __stdcall <span class="title">Close</span><span class="params">(<span class="type">void</span>* pDecoderHandle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CXXXDecoder* pDecoder = <span class="built_in">static_cast</span>&lt;CXXXDecoder*&gt;(pDecoderHandle);</span><br><span class="line"><span class="keyword">delete</span> pDecoder;</span><br><span class="line">    pDecoder = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> stDecoderPluginItem g_XXAudioDecoderInfoList[] = </span><br><span class="line">&#123;</span><br><span class="line">&#123; <span class="string">L&quot;AAC Decoder&quot;</span>, <span class="string">&#x27; CAA&#x27;</span>,emDecoderPluginType::AUDIO,emDecoderPluginPriority::HIGH,Init, PutData, GetNextFrame, Reset, Close, GetCPUMemorySize, GetGPUMemorySize&#125;,</span><br><span class="line">&#123; <span class="string">L&quot;AC3 Decoder&quot;</span>, <span class="string">&#x27; 3CA&#x27;</span>,emDecoderPluginType::AUDIO,emDecoderPluginPriority::LOW,Init, PutData, GetNextFrame, Reset, Close, GetCPUMemorySize, GetGPUMemorySize&#125;,</span><br><span class="line">    ...,</span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__attribute__((<span class="built_in">visiblity</span>(<span class="string">&quot;default&quot;</span>)))</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>  <span class="function"><span class="type">const</span> stDecoderPluginItem* __stdcall <span class="title">GetDecoderPluginInfomationArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> g_XXAudioDecoderInfoList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每个插件内部相对巧妙的采用了stDecoderPluginItem定义了一个静态的数组，并将该数组作为GetDecoderPluginInfomationArray()的返回值，而GetDecoderPluginInfomationArray()则进行了C接口的导出，这样做的话，解码插件管理器就可以调用每个插件的该导出函数，从而获取到每个插件的g_XXAudioDecoderInfoList数组，来得到当前插件支持的FourCC,插件解码格式类型，优先级以及对应的插件接口API。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>音视频编解码引擎之filter链路的架构设计</title>
      <link href="/2024/01/05/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E5%BC%95%E6%93%8E%E4%B9%8Bfilter%E9%93%BE%E8%B7%AF%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/01/05/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E5%BC%95%E6%93%8E%E4%B9%8Bfilter%E9%93%BE%E8%B7%AF%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>对于解码出来的视频帧&#x2F;音频帧我们一般都不会直接送到编码器中进行编码，往往会做一些缩放，旋转等等的特效处理，想象一下，视频解码器出来一帧画面，假如源携带了旋转信息的话，我们第一步就需要根据旋转信息进行正确的旋转处理，紧接着如果用户需要对这张画面做白平衡orAI算法处理的话，那我们还需要调用对应的算法对这一帧画面进行处理，处理完后用户如果希望修改导出的文件的分辨率，此时我们还需要做缩放处理．<br>因此我们将上述的这种针对视频帧&#x2F;音频帧流水线模式的链条处理模式称之为:filter链路．</p><h1 id="filter链路的架构设计思想"><a href="#filter链路的架构设计思想" class="headerlink" title="filter链路的架构设计思想"></a>filter链路的架构设计思想</h1><p>如何设计一套成熟实用的filter链路架构就需要考验大家对具体业务的认识度了．对于一套成熟的链路而言除了能从某个链路节点处拿到当前特效处理后的音视频帧以外，还需要提供Seek,Forward能力，从而通过Seek,Forward,GetSample来主动驱动解码端的帧数据推送，同时filter链路中每个节点也可能会修改该路流的媒体信息数据（比如你在做缩放，重采样处理的时候就需要修改对应的流信息），因此当我们将每个特效都飞封装成一个特效类时，这些类均需要具备某些公共的函数接口，我们将这些需要具备的公共接口封装成一个基类，然后每个特效类均继承该类,我们将这个基础的类命名为CMediaStreamBase:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IMediaStream</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetStreamInfomation</span><span class="params">(<span class="type">void</span>** ppStreamInfomation)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span>* <span class="title">GetSample</span><span class="params">(<span class="type">void</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Forward</span><span class="params">(<span class="type">void</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">Seek</span><span class="params">(<span class="type">double</span> time,<span class="type">bool</span> is_accurate)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同时还需要提供两个基类，用于设置输入流和获取输出流：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IMediaStreamInput</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">SetMediaStreamInput</span><span class="params">(IMediaStream *pMediaStream)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IMediaStreamOutput</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">GetMediaStreamOutput</span><span class="params">(IMediaStream **ppMediaStream)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下里，我们需要研究一下，当前的filter链路业务需求适合用什么样的设计模式来进行架构的设计．</p><p>由于filter链路具备以下特点：</p><ul><li>链路中特效算法的构建顺序需要应用层根据用户的选择以及素材的信息进行构建，底层无法事先知道链路的构建顺序<br>举个例子：假如用户在软件界面上选择了去抖动算法后点击播放，而源视频携带了旋转信息，此时应用层针对视频流就应该构建出一条视频流的filter链路：旋转－＞去抖动．</li></ul><p>而设计模式中的责任链具备以下的应用场景：</p><ul><li>当程序需要使用不同方式处理不同种类请求， 而且请求类型和顺序预先未知时， 可以使用责任链模式。</li><li>当必须按顺序执行多个处理者时，可以使用该模式。</li><li>如果所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。</li></ul><p>刚好满足我们对filter链路的设计思想，因此filter链路就是基于责任链模式来实现的．</p><h2 id="基于责任链模式的filter架构"><a href="#基于责任链模式的filter架构" class="headerlink" title="基于责任链模式的filter架构"></a>基于责任链模式的filter架构</h2><p>接下来我们将具体讲述如何设计一套满足应用场景的filter链路架构，做到底层容易扩展，应用层容易集成封装．我们以构建视频特效为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">emVideoEffectAlgorithmsName</span>&#123;</span><br><span class="line">    UnknownVideoAlgorithmsName,</span><br><span class="line">    Rotation,</span><br><span class="line">    Resize,</span><br><span class="line">    Crop,</span><br><span class="line">    NakedeyeVR,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PS:可以用Visua Studio -&gt;工具-&gt;创建GUID</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> IID_IMediaStreamInput = <span class="string">&quot;354E16ED-2345-1D22-AAE9-12DBA0C53E13&quot;</span>,  <span class="comment">// IID_IMediaStreamInput</span></span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用C++自己实现一个类似COM的IUnknown，用于后续filter中EffectNode的引用计数计算和QueryInterface的接口查询功能</span></span><br><span class="line"><span class="keyword">class</span> IMTUnknown &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">IMTUnknown</span>() : <span class="built_in">m_nRefCount</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">AddRef</span>()&#123;</span><br><span class="line">        m_nRefCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_nRefCount--;</span><br><span class="line">        <span class="keyword">if</span> (m_nRefCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>* <span class="title">QueryInterface</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* GUID)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_nRefCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CVideoRotationEffectNode</span>: <span class="keyword">public</span> IMTUnknown, </span><br><span class="line">                                <span class="keyword">public</span> IMediaStream, </span><br><span class="line">                                <span class="keyword">public</span> IMediaStreamInput, </span><br><span class="line">                                <span class="keyword">public</span> IMediaStreamOutput.</span><br><span class="line">                                <span class="keyword">public</span> IVideoRotationEffectNode&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CVideoRotationEffectNode</span>(LPUNKNOWN pUnk, HRESULT *phr);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CVideoRotationEffectNode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IVideoRotationEffectNode</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetRotationAngle</span><span class="params">(<span class="type">int</span> nRotationAngle)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetRotationAngle</span><span class="params">(<span class="type">int</span> *pRotationAngle)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IMediaStream</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetStreamInfomation</span><span class="params">(IStreamInfomation** ppStreamInfomation)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetSample</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetCurrentTime</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Forward</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Seek</span><span class="params">(<span class="type">double</span> time,<span class="type">bool</span> is_accurate)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IMediaStreamInput</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SetMediaStreamInput</span><span class="params">(IMediaStream *pMediaStream)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IMediaStreamOutput</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetMediaStreamOutput</span><span class="params">(IMediaStream **ppMediaStream)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IMTUnknown</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">QueryInterface</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* GUID)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(GUID,IID_IMediaStreamInput) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;IMediaStreamInput*&gt;(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(GUID,IID_IMediaStreamOutput) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;IMediaStreamOutput*&gt;(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(GUID,IID_IVideoRotationEffectNode) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;IVideoRotationEffectNode*&gt;(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CreateEffectFilterLink</span><span class="params">(IMediaStream* pMediaStream,stEffectParam* pEffectAlgorithmsParam,emVideoEffectAlgorithmsName name,...)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="built_in">va_start</span>(args, name);</span><br><span class="line"></span><br><span class="line">    emVideoEffectAlgorithmsName currentEffect = name;</span><br><span class="line">    <span class="keyword">while</span> (currentEffect != emVideoEffectAlgorithmsName::UnknownVideoAlgorithmsName) &#123;</span><br><span class="line">        <span class="comment">// 处理当前Effect</span></span><br><span class="line">        <span class="comment">// new 对应的effect对象</span></span><br><span class="line">        <span class="comment">// 设置对应effect的输入参数</span></span><br><span class="line">        <span class="comment">// 链接责任链模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取下一个Effect</span></span><br><span class="line">        currentEffect = <span class="built_in">va_arg</span>(args, emVideoEffectAlgorithmsName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_end</span>(args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">CreateEffectFilterLink</span>(pMediaStream,pEffectAlgorithmsParam, emVideoEffectAlgorithmsName::Rotation, emVideoEffectAlgorithmsName::NakedeyeVR,emVideoEffectAlgorithmsName::Resize); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同时，每个特效都有自己的输入参数的设置接口，比如上面举例的旋转特效SetRotationAngle接口，那么要如何设计一套SetCurrentEffectAlgorithmsNodeParam接口和GetCurrentEffectAlgorithmsNodeParam接口，用于设置和获取filter链路中某个特效的相关参数呢？<br>最直接的方式就是定义一个大的结构体，然后进行设置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">emEffectAlgorithmsType</span> &#123;</span><br><span class="line">    NONE,</span><br><span class="line">    VIDEO,</span><br><span class="line">    AUDIO,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">emVideoEffectAlgorithmsParamInforation</span>&#123;</span><br><span class="line"></span><br><span class="line">    emVideoEffectAlgorithmsName name_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span>&#123;<span class="comment">//CVideoRotationEffectNode</span></span><br><span class="line">            <span class="type">int</span> rotation_angle_;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span>&#123;<span class="comment">//CVideoResizeEffectNode</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> resize_height_;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> resize_width_;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ......小说</span><br><span class="line">    <span class="built_in">emVideoEffectAlgorithmsParamInforation</span>() : </span><br><span class="line">        <span class="built_in">name_</span>(emEffectAlgorithmsType::NONE),<span class="built_in">rotation_angle_</span>(<span class="number">0</span>), <span class="built_in">resize_height_</span>(<span class="number">0</span>), <span class="built_in">resize_width_</span>(<span class="number">0</span>) &#123;&#125; <span class="comment">// 构造函数初始化rotation_angle_和resize_height_、resize_width_的值为０</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stEffectAlgorithmsParam</span>&#123;</span><br><span class="line"></span><br><span class="line">    emEffectAlgorithmsType type_;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">emVideoEffectAlgorithmsParamInforation video_;</span><br><span class="line">emAudioEffectAlgorithmsParamInforation audio_;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样每次我都得修改这个结构体，有没有一种方式是不需要修改的，后续的新增接口or修改接口参数的话，直接是修改描述脚本？而程序是读取描述脚本，答案是可以的！！！</p><p>我们可以将每个EffectAlgorithmsNodeParam都提供一个共有的接口:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">emParamType</span> &#123;</span><br><span class="line">  NONE = <span class="number">0</span>,</span><br><span class="line">  BOOL = <span class="number">1</span>,</span><br><span class="line">  DOUBLE = <span class="number">2</span>,</span><br><span class="line">  FLOAT = <span class="number">3</span>,</span><br><span class="line">  LONGLONG = <span class="number">4</span>,</span><br><span class="line">  INT = <span class="number">5</span>,</span><br><span class="line">  STR_PTR = <span class="number">6</span>,</span><br><span class="line">  VOID_PTR = <span class="number">7</span></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stUnionClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    emParamType type_;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">bool</span> bValue_;</span><br><span class="line">        <span class="type">double</span> dValue_;</span><br><span class="line">        <span class="type">float</span> fValue_;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> llValue_;</span><br><span class="line">        <span class="type">int</span> nValue_;</span><br><span class="line">        <span class="type">char</span> szValue_[<span class="number">512</span>];</span><br><span class="line">        <span class="type">void</span>* pValue_;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::string str_;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stUnionClass</span>() : <span class="built_in">type_</span>(emParamType::NONE), <span class="built_in">llValue_</span>(<span class="number">0</span>), <span class="built_in">nValue_</span>(<span class="number">0</span>), <span class="built_in">pValue_</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(szValue_, <span class="number">0</span>, <span class="built_in">sizeof</span>(szValue_));</span><br><span class="line">        str_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">emResult</span> &#123;</span><br><span class="line">  SUCCESS = <span class="number">0</span>,</span><br><span class="line">  FAILED = <span class="number">1</span>,</span><br><span class="line">  ERROR_INVALID_NAME = <span class="number">2</span>,<span class="comment">//错误：无效名称</span></span><br><span class="line">  ERROR_INVALID_VALUE = <span class="number">3</span>,<span class="comment">//错误：无效值</span></span><br><span class="line">  ERROR_INVALID_DATA_TYPE = <span class="number">4</span>,<span class="comment">//错误：无效类型</span></span><br><span class="line">  ERROR_PATH_NOT_EXIST = <span class="number">5</span>,<span class="comment">//错误：路径不存在</span></span><br><span class="line">  ERR_NO_SUPPORT_PIXEL_FORMAT = <span class="number">6</span>,<span class="comment">//错误：不支持格式类型(有的算法可能只支持yv12数据，不支持其他格式数据，需要底层完成类型转换的相关接口，方面EffectAlgorithmsNode内部进行格式转换)</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">emResult <span class="title">SetParameter</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, stUnionClass value)</span></span>;</span><br><span class="line"><span class="function">emResult <span class="title">GetParameter</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, stUnionClass&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><p>参数名称name和相关描述信息可以写到某个xml或者是YAML或者JSON，这边个人推荐用YAML看着相对舒服多了，这样我们就不需要定义一个emVideoEffectAlgorithmsParamInforation结构体，而是变成了一层壳：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">emVideoFrameType</span> &#123;</span><br><span class="line">    CPU,</span><br><span class="line">    GPU_D3D,</span><br><span class="line">    GPU_OpenGL,</span><br><span class="line">    GPU_Metal,</span><br><span class="line">    GPU_CUDA,</span><br><span class="line">    GPU_OpenCL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">emVideoFrameFormat</span>&#123;</span><br><span class="line">    YV12,</span><br><span class="line">    NV12,</span><br><span class="line">    YV12Alpha,</span><br><span class="line">    ... ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMediaEffectAlgorithmsStream</span>: <span class="keyword">public</span> CUnknown, </span><br><span class="line">                                <span class="keyword">public</span> IMediaStream, </span><br><span class="line">                                <span class="keyword">public</span> IMediaStreamInput, </span><br><span class="line">                                <span class="keyword">public</span> IMediaStreamOutput.</span><br><span class="line">                                <span class="keyword">public</span> IMediaEffectAlgorithmsStream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CMediaEffectAlgorithmsStream</span>(LPUNKNOWN pUnk, HRESULT *phr,emEffectAlgorithmsType type,emVideoEffectAlgorithmsName video_effect_algorithms_name,emAudioEffectAlgorithmsName audio_effect_algorithms_name,):<span class="built_in">CUnknown</span>(pUnk, phr)</span><br><span class="line">        , <span class="built_in">m_emEffectAlgorithmsType</span>(type)</span><br><span class="line">        , <span class="built_in">m_pSrcMediaStream</span>(<span class="literal">nullptr</span>)</span><br><span class="line">        , <span class="built_in">m_pMediaStreamInfomation</span>(<span class="literal">nullptr</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(((video_effect_algorithms_name == UnknownVideoAlgorithmsName) &amp;&amp; (audio_effect_algorithms_name == UnknownAudioAlgorithmsName))</span><br><span class="line">            || ((video_effect_algorithms_name != UnknownVideoAlgorithmsName) &amp;&amp; (audio_effect_algorithms_name != UnknownAudioAlgorithmsName)))&#123;</span><br><span class="line">            <span class="built_in">MTLog</span>(<span class="string">L&quot;Error:....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(video_effect_algorithms_name != UnknownVideoAlgorithmsName)&#123;</span><br><span class="line">            <span class="built_in">MTLog</span>(<span class="string">L&quot;Infomation:....&quot;</span>);</span><br><span class="line">            m_emVideoEffectAlgorithmsName = video_effect_algorithms_name;</span><br><span class="line">            m_emAudioEffectAlgorithmsName = emAudioEffectAlgorithmsName::UnknownAudioAlgorithmsName;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从视频算法数组中找到对应的算法库的名称，然后dlopen加载</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">MTLog</span>(<span class="string">L&quot;Infomation:....&quot;</span>);</span><br><span class="line">            m_emVideoEffectAlgorithmsName = emVideoEffectAlgorithmsName::UnknownVideoAlgorithmsName;</span><br><span class="line">            m_emAudioEffectAlgorithmsName = audio_effect_algorithms_name;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从音频算法数组中找到对应的算法库的名称，然后dlopen加载</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Init</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CMediaEffectAlgorithmsStream</span>()&#123;</span><br><span class="line">        <span class="built_in">UninitEffecttAlgorithms</span>(m_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IMediaEffectAlgorithmsStream</span></span><br><span class="line">    <span class="function">emResult <span class="title">SetEffecttAlgorithmsParameter</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,stUnionClass value)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            函数内部实现举例：</span></span><br><span class="line"><span class="comment">                if (strcmp(name, &quot;RotationAngle&quot;) == 0) &#123;</span></span><br><span class="line"><span class="comment">                    if (value.type_ != emParamType::INT)&#123;</span></span><br><span class="line"><span class="comment">                        return emResult::ERROR_INVALID_DATA_TYPE;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    m_RotationAngle = value.nValue_;</span></span><br><span class="line"><span class="comment">                    return emResult::Success;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SetParameter</span>(name,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">emResult <span class="title">GetEffecttAlgorithmsParameter</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, stUnionClass&amp; value)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetParameter</span>(name,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IMediaStream</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetStreamInfomation</span><span class="params">(IStreamInfomation** ppStreamInfomation)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((m_pMediaStreamInfomation == <span class="literal">nullptr</span>)</span><br><span class="line">        || (ppStreamInfomation == <span class="literal">nullptr</span>)</span><br><span class="line">        || (*ppStreamInfomation == <span class="literal">nullptr</span>))&#123;</span><br><span class="line">            <span class="built_in">MTLog</span>(<span class="string">L&quot;Error:xxxx&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IMediaStreamInput</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SetMediaStreamInput</span><span class="params">(IMediaStream *pMediaStream)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//步骤一：加锁</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将之前的类成员变量的值和数据以及加载进来的算法库进行重置操作</span></span><br><span class="line">        <span class="built_in">Reset</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pMediaStream)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        m_pSrcMediaStream = pMediaStream;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个用于：存放当前节点的流媒体信息的结构体</span></span><br><span class="line">        <span class="keyword">if</span>(m_pMediaStreamInfomation != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_pMediaStreamInfomation-&gt;<span class="built_in">Release</span>();</span><br><span class="line">            m_pMediaStreamInfomation = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_pMediaStreamInfomation = <span class="keyword">new</span> MediaStreamInfomation;</span><br><span class="line">        <span class="built_in">memset</span>(m_pMediaStreamInfomation, <span class="number">0</span>, <span class="built_in">sizeof</span>(MediaStreamInfomation));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从输入流中获取上一个节点处理后的媒体信息流</span></span><br><span class="line">        <span class="keyword">if</span> (m_pSrcMediaStream-&gt;<span class="built_in">GetStreamInfomation</span>(&amp;m_pSrcStreamInfomation) != <span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将获取到的上一个节点处理后的媒体信息流的相关信息保存到当前的m_pMediaStreamInfomation指向的结构体中</span></span><br><span class="line">        m_pMediaStreamInfomation-&gt;XX = m_pSrcStreamInfomation-&gt;<span class="built_in">GetXX</span>();</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IMediaStreamOutput</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetMediaStreamOutput</span><span class="params">(IMediaStream **ppMediaStream)</span></span>&#123;</span><br><span class="line">        *ppMediaStream = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">stMediaFrame* <span class="title">GetSample</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!m_pSrcMediaStream || !m_pSrcStreamInfomation)&#123;</span><br><span class="line">            <span class="built_in">MTLog</span>(<span class="string">&quot;Error:xxx&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stMediaFrame *pInputMediaFrame = m_pSrcMediaStream-&gt;<span class="built_in">GetSample</span>();</span><br><span class="line">        <span class="keyword">if</span> (!pFrame) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (m_emEffectAlgorithmsType == emEffectAlgorithmsType::VIDEO)&#123;</span><br><span class="line">            <span class="comment">//创建一帧，用于存放算法输出的数据</span></span><br><span class="line">            m_pOutputMediaFrame = <span class="built_in">CreateVideoMediaFrame</span>(type,width,height,is_alpha,ia_black_image);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m_emEffectAlgorithmsType == emEffectAlgorithmsType::AUDIO)&#123;</span><br><span class="line">            m_pOutputMediaFrame = <span class="built_in">CreateAudioMediaFrame</span>(sample_rate,channels_number,bits_per_sample,nbufferSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">MTLog</span>(<span class="string">L&quot;Error:...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        emResult ret = <span class="built_in">Process</span>(pInputMediaFrame,m_pOutputMediaFrame);</span><br><span class="line">        <span class="keyword">if</span>(ret != emResult::SUCCESS)&#123;</span><br><span class="line">            <span class="built_in">MTLog</span>(<span class="string">L&quot;Error:...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改其他参数信息</span></span><br><span class="line">        m_pOutputMediaFrame-&gt;pts = pInputMediaFrame-&gt;pts;</span><br><span class="line">        m_pOutputMediaFrame-&gt;dts = pInputMediaFrame-&gt;dts;</span><br><span class="line">        m_pOutputMediaFrame-&gt;duration = pInputMediaFrame-&gt;duration;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_pOutputMediaFrame;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetCurrentTime</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (m_pSrcMediaStream)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_pSrcMediaStream-&gt;<span class="built_in">GetCurrentTime</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Forward</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_pSrcMediaStream)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_pSrcMediaStream-&gt;<span class="built_in">Forward</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Seek</span><span class="params">(<span class="type">double</span> time,<span class="type">bool</span> is_accurate)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (m_pSrcMediaStream)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_pSrcMediaStream-&gt;<span class="built_in">Seek</span>(time, is_accurate);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IUnknown</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">QueryInterface</span><span class="params">(InterfaceID iid)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (iid == InterfaceID::IMediaStreamInput) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;IMediaStreamInput*&gt;(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(iid == InterfaceID::IMediaStreamOutput) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;IMediaStreamOutput*&gt;(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    emEffectAlgorithmsType      m_emEffectAlgorithmsType;</span><br><span class="line">    emVideoEffectAlgorithmsName m_emVideoEffectAlgorithmsName;</span><br><span class="line">    emAudioEffectAlgorithmsName m_emAudioEffectAlgorithmsName;</span><br><span class="line"></span><br><span class="line">    IMediaStream*               m_pSrcMediaStream;</span><br><span class="line">    MediaStreamInfomation*      m_pMediaStreamInfomation;</span><br><span class="line">    std::mutex                  m_mutex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以每个算法实际上均导出以下几个函数即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">emResult <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Uninit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">emResult <span class="title">SetParameter</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,stUnionClass value)</span></span>;</span><br><span class="line"><span class="function">emResult <span class="title">GetParameter</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,stUnionClass&amp; value)</span></span>;</span><br><span class="line"><span class="function">emResult <span class="title">Process</span><span class="params">(<span class="type">const</span> stMediaFrame* pInputMediaFrame,stMediaFrame* pOutputMediaFrame)</span></span>;<span class="comment">//算法处理</span></span><br></pre></td></tr></table></figure><p>这边需要规范一下职责边界:<br>　　对于视频类的特效算法将会提供cpu和gpu两套解决方案，上层可以根据SetParameter接口来决定当前特效是采用CPU还是GPU，这样做的目的是：有时候可能会出现当前算法gpu模式下采用的模型的效果不好，或者是当前算法只开发出cpu的解决方案，gpu的方案还待开发等情况，因此需要有一个接口来让上层自主决定采用那种模式．同时CMediaEffectAlgorithmsStream层不关注当前帧是什么格式(yv12&#x2F;nv12&#x2F;rgba&#x2F;…)的帧，或者是什么类型的帧(d3d&#x2F;metal&#x2F;opengl&#x2F;cuda&#x2F;opencl),算法封装层会自动根据上层调用的Process，结合输入帧类型和格式，以及当前算法的支持情况来进行抉择(可能会在封装层调用格式or类型转换接口)；同时对于输出帧的格式和类型的抉择，我们在视频类的特效算法的SetParameter接口中提供bApplyGPUMode，emVideoFrameType和emVideoFrameFormat的设置(bApplyGPUMode:设置当前特效算法是否采用GPU模式进行处理,emVideoFrameType和emVideoFrameFormat:设置当前输出帧的格式和类型).</p><p>但还有个问题，我们根据实际的产品业务需求可知，对于算法的处理，分为三种方式：</p><ul><li>同步出帧模式(实时处理一对一:输入一帧数据，特效算法处理完立马输出一帧数据，例如：视频缩放和旋转算法）</li><li>异步出帧模式(实时处理多对一模:输入多帧数据，特效算法处理完才会输出一帧数据，例如：音频重采样算法）</li><li>预处理多线程模式(输入所有帧数据，得到一个xml&#x2F;yasm结果，后续播放的时候根据预处理的结果结合当前输入帧，得到输出帧)</li></ul><p>1.预处理算法怎么办？需要一个输入缓冲区的算法．比如重采样的算法怎么办？<br>2.引用计数怎么整<br>3.设计模式</p><h1 id="同步出帧模式和异步出帧模式的实现："><a href="#同步出帧模式和异步出帧模式的实现：" class="headerlink" title="同步出帧模式和异步出帧模式的实现："></a>同步出帧模式和异步出帧模式的实现：</h1><p>需要修改GetSample:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">stMediaFrame* <span class="title">GetSample</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_pSrcMediaStream || !m_pSrcStreamInfomation)&#123;</span><br><span class="line">        <span class="built_in">MTLog</span>(<span class="string">&quot;Error:xxx&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stMediaFrame *pInputMediaFrame = m_pSrcMediaStream-&gt;<span class="built_in">GetSample</span>();</span><br><span class="line">    <span class="keyword">if</span> (!pInputMediaFrame) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m_pOutputMediaFrame == <span class="literal">nullptr</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_emEffectAlgorithmsType == emEffectAlgorithmsType::VIDEO)&#123;</span><br><span class="line">            <span class="comment">//创建一帧，用于存放算法输出的数据</span></span><br><span class="line">            m_pOutputMediaFrame = <span class="built_in">CreateVideoMediaFrame</span>(type,width,height,is_alpha,ia_black_image);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m_emEffectAlgorithmsType == emEffectAlgorithmsType::AUDIO)&#123;</span><br><span class="line">            m_pOutputMediaFrame = <span class="built_in">CreateAudioMediaFrame</span>(sample_rate,channels_number,bits_per_sample,nbufferSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">MTLog</span>(<span class="string">L&quot;Error:...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stUnionClass stValue;</span><br><span class="line">    emResult result = <span class="built_in">GetEffecttAlgorithmsParameter</span>(<span class="string">&quot;is_多帧出一帧&quot;</span>, value);</span><br><span class="line">    <span class="keyword">if</span>((result != emResult::SUCCESS) ||(value.type_ != emParamType::BOOL))&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(value.bValue_ != <span class="literal">true</span>)&#123;<span class="comment">//同步出帧模式</span></span><br><span class="line"></span><br><span class="line">        result = <span class="built_in">Process</span>(pInputMediaFrame,m_pOutputMediaFrame);</span><br><span class="line">        <span class="keyword">if</span>(ret != emResult::SUCCESS)&#123;</span><br><span class="line">            <span class="built_in">MTLog</span>(<span class="string">L&quot;Error:...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//异步出帧模式</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            result = <span class="built_in">Process</span>(pInputMediaFrame,m_pOutputMediaFrame);</span><br><span class="line">            <span class="keyword">if</span>(ret != emResult::SUCCESS) ||(ret != emResult::MORE_INPUT_REQUIRED))&#123;</span><br><span class="line">                <span class="built_in">MTLog</span>(<span class="string">L&quot;Error:...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ret == emResult::SUCCESS)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Forward</span>() != <span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">MTLog</span>(<span class="string">L&quot;Info:...&quot;</span>);</span><br><span class="line">                result = <span class="built_in">Process</span>(<span class="literal">nullptr</span>,m_pOutputMediaFrame);</span><br><span class="line">                <span class="keyword">if</span>(ret != emResult::SUCCESS) || &#123;</span><br><span class="line">                    <span class="built_in">MTLog</span>(<span class="string">L&quot;Error:...&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">MTLog</span>(<span class="string">L&quot;Infomation:最后一帧&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            pInputMediaFrame = m_pSrcMediaStream-&gt;<span class="built_in">GetSample</span>();</span><br><span class="line">            <span class="keyword">if</span>(pInputMediaFrame == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="built_in">MTLog</span>(<span class="string">L&quot;Error:...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改其他参数信息</span></span><br><span class="line">    m_pOutputMediaFrame-&gt;pts = pInputMediaFrame-&gt;pts;</span><br><span class="line">    m_pOutputMediaFrame-&gt;dts = pInputMediaFrame-&gt;dts;</span><br><span class="line">    m_pOutputMediaFrame-&gt;duration = pInputMediaFrame-&gt;duration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_pOutputMediaFrame;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="预处理多线程模式的实现"><a href="#预处理多线程模式的实现" class="headerlink" title="预处理多线程模式的实现"></a>预处理多线程模式的实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(__stdcall *PREPROCESSING_ANALYSIS_CALL_BACK_FUN)</span><span class="params">(<span class="type">void</span>* pUserObj, ... ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StartPreprocessingAnalysis</span><span class="params">(PREPROCESSING_ANALYSIS_CALL_BACK_FUN CallBackFun,<span class="type">void</span>* pUserObj)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    stUnionClass stValue;</span><br><span class="line">    emResult result = <span class="built_in">GetEffecttAlgorithmsParameter</span>(<span class="string">&quot;isPreprocessing&quot;</span>, value);</span><br><span class="line">    <span class="keyword">if</span>((result != emResult::SUCCESS) ||(value.type_ != emParamType::BOOL))&#123;</span><br><span class="line">        <span class="keyword">return</span> emResult::FAILED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_bExitPreprocessingAnalysis = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_MagicXEPluginCls)</span><br><span class="line">&#123;</span><br><span class="line">m_pSrcMediaStream-&gt;<span class="built_in">AddRef</span>();</span><br><span class="line"><span class="function">std::thread <span class="title">aithread</span><span class="params">(&amp;AnalysisThread, <span class="keyword">this</span>, m_pSrcMediaStream, CallBackFun, pUserObj)</span></span>;</span><br><span class="line">aithread.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> emResult::FAILED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">AnalysisThread</span><span class="params">(<span class="type">void</span> * pobj, IMediaStream* pSrcMediaStream, PREPROCESSING_ANALYSIS_CALL_BACK_FUN CallBackFun, <span class="type">void</span>* pUserObj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CMediaEffectAlgorithmsStream* pThis = (CMediaEffectAlgorithmsStream*)pobj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pThis-&gt;m_bExitPreprocessingAnalysis)&#123;</span><br><span class="line">            <span class="comment">//... ...//</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pSrcMediaStream-&gt;<span class="built_in">Forward</span>() &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//... ...//</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">stMediaFrame *pInputMediaFrame = m_pSrcMediaStream-&gt;<span class="built_in">GetSample</span>();</span><br><span class="line">        <span class="keyword">if</span> (pInputMediaFrame == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">//... ...//</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m_pOutputMediaFrame == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (m_emEffectAlgorithmsType == emEffectAlgorithmsType::VIDEO)&#123;</span><br><span class="line">                <span class="comment">//创建一帧，用于存放算法输出的数据</span></span><br><span class="line">                m_pOutputMediaFrame = <span class="built_in">CreateVideoMediaFrame</span>(type,width,height,is_alpha,ia_black_image);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m_emEffectAlgorithmsType == emEffectAlgorithmsType::AUDIO)&#123;</span><br><span class="line">                m_pOutputMediaFrame = <span class="built_in">CreateAudioMediaFrame</span>(sample_rate,channels_number,bits_per_sample,nbufferSize);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">MTLog</span>(<span class="string">L&quot;Error:...&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//预处理操作</span></span><br><span class="line">        result = <span class="built_in">PreprocessingAnaly</span>(pInputMediaFrame);</span><br><span class="line">        <span class="keyword">if</span>(ret != emResult::SUCCESS)&#123;</span><br><span class="line">            <span class="built_in">MTLog</span>(<span class="string">L&quot;Error:...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用回调返回当前预处理进度百分比(当前输入帧pts/文件总时长)</span></span><br><span class="line">        <span class="built_in">CallBackFun</span>(pUserObj, .....);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用回调通知结束预处理</span></span><br><span class="line">    <span class="built_in">CallBackFun</span>(pUserObj, .....);</span><br><span class="line">    <span class="built_in">SetPreprocessingAnalysisThreadEnd</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SetPreprocessingAnalysisThreadEnd</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_ThreadMutex)</span></span>;</span><br><span class="line">m_conditionVariablePreprocessingAnalysisThreadEnd.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EndPreprocessingAnalysisThread</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_ThreadMutex)</span></span>;</span><br><span class="line">m_conditionVariablePreprocessingAnalysisThreadEnd.<span class="built_in">wait</span>(lock, [&amp;]() &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EndPreprocessingAnalysis</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_bExitPreprocessingAnalysis == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    m_bExitPreprocessingAnalysis = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">EndPreprocessingAnalysisThread</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每个算法实际上均导出再多加一个函数即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">emResult <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Uninit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">emResult <span class="title">SetParameter</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,stUnionClass value)</span></span>;</span><br><span class="line"><span class="function">emResult <span class="title">GetParameter</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,stUnionClass&amp; value)</span></span>;</span><br><span class="line"><span class="function">emResult <span class="title">PreprocessingAnaly</span><span class="params">(<span class="type">const</span> stMediaFrame* pInputMediaFrame)</span></span>;<span class="comment">//预处理分析</span></span><br><span class="line"><span class="function">emResult <span class="title">GetResultOfPreprocessingAnaly</span><span class="params">(<span class="type">const</span> stMediaFrame* pInputMediaFrame)</span></span>;<span class="comment">//预处理分析</span></span><br><span class="line"></span><br><span class="line"><span class="function">emResult <span class="title">Process</span><span class="params">(<span class="type">const</span> stMediaFrame* pInputMediaFrame,stMediaFrame* pOutputMediaFrame)</span></span>;<span class="comment">//算法处理</span></span><br></pre></td></tr></table></figure><p>同时对于预分析处理的算法，SetParameter和GetParameter函数还提供一系列的设置分析结果文件存放路径，修改和获取分析结果值的功能．</p><h1 id="架构的优化和完善"><a href="#架构的优化和完善" class="headerlink" title="架构的优化和完善"></a>架构的优化和完善</h1><p>但是在设计CreateEffectFilterLink接口的时候还有一个问题，如果用枚举变量代码每个算法，因为我们总会添加了删除某个算法，这样不小心的话容易造成版本冲突等问题，因此最优解是采用GUID的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">emResult</span> <span class="params">(__stdcall* INIT_API_EFFECT_ALGORITHM_PLUGIN)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>* (__stdcall* UNINIT_API_EFFECT_ALGORITHM_PLUGIN)();</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">emResult</span> <span class="params">(__stdcall* SET_PARAMETER_API_EFFECT_ALGORITHM_PLUGIN)</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,stUnionClass value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">emResult</span> <span class="params">(__stdcall* GET_PARAMETER_API_EFFECT_ALGORITHM_PLUGIN)</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,stUnionClass value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">emResult</span> <span class="params">(__stdcall* PROCESS_API_EFFECT_ALGORITHM_PLUGIN)</span><span class="params">(<span class="type">const</span> stMediaFrame* pInputMediaFrame,stMediaFrame* pOutputMediaFrame)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stEffectAlgorithmAPI</span>&#123;</span><br><span class="line">    </span><br><span class="line">    INIT_API_EFFECT_ALGORITHM_PLUGIN            Init_;</span><br><span class="line">    UNINIT_API_EFFECT_ALGORITHM_PLUGIN          Uninit_;</span><br><span class="line">    SET_PARAMETER_API_EFFECT_ALGORITHM_PLUGIN   SetParameter_;</span><br><span class="line">    GET_PARAMETER_API_EFFECT_ALGORITHM_PLUGIN   GetParameter_;</span><br><span class="line">    PROCESS_API_EFFECT_ALGORITHM_PLUGIN         Process_;</span><br><span class="line"></span><br><span class="line">    emEffectAlgorithmsType                      effect_algorithms_type_;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        emVideoEffectAlgorithmsName             video_effect_algorithms_name_;</span><br><span class="line">        emAudioEffectAlgorithmsName             audio_effect_algorithms_name_;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    stEffectAlgorithmAPI : <span class="built_in">Init_</span>(<span class="literal">NULL</span>)</span><br><span class="line">        , <span class="built_in">Uninit_</span>(<span class="literal">NULL</span>)</span><br><span class="line">        , <span class="built_in">SetParameter_</span>(<span class="literal">NULL</span>)</span><br><span class="line">        , <span class="built_in">GetParameter_</span>(<span class="literal">NULL</span>)</span><br><span class="line">        , <span class="built_in">Process_</span>(<span class="literal">NULL</span>)</span><br><span class="line">        , <span class="built_in">effect_algorithms_type_</span>(NONE)</span><br><span class="line">        , <span class="built_in">video_effect_algorithms_name_</span>(UnknownVideoAlgorithmsName)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_RESULT(ret) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (ret != emResult::SUCCESS) &#123; \</span></span><br><span class="line"><span class="meta">            MTLog(<span class="string">&quot;Error: %s, line %d, function %s\n&quot;</span>, #ret, __LINE__, __func__); \</span></span><br><span class="line"><span class="meta">            return; \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMediaEffectAlgorithmsStream</span>: <span class="keyword">public</span> IMediaStream, </span><br><span class="line">                                <span class="keyword">public</span> IMediaStreamInput, </span><br><span class="line">                                <span class="keyword">public</span> IMediaStreamOutput.</span><br><span class="line">                                <span class="keyword">public</span> IMediaEffectAlgorithmsStream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CMediaEffectAlgorithmsStream</span>(<span class="type">const</span> <span class="type">char</span>* effect_algorithm_guid):<span class="built_in">m_pSrcMediaStream</span>(<span class="literal">nullptr</span>)</span><br><span class="line">        , <span class="built_in">m_pMediaStreamInfomation</span>(<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过GUID值，查找对应的数组，得到对应的插件名称</span></span><br><span class="line">        string strEffectAlgorithmDynamicLibraryName = FindEffectAlgorithmInfo[effect_algorithm_guid];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打开动态库</span></span><br><span class="line">        <span class="type">void</span>* handle = <span class="built_in">dlopen</span>(strEffectAlgorithmDynamicLibraryName, RTLD_LAZY);</span><br><span class="line">        <span class="keyword">if</span> (handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 动态库打开失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取动态库中的函数指针</span></span><br><span class="line">        m_stEffectAlgorithmAPI.Init_ = (InitFunc)<span class="built_in">dlsym</span>(handle, <span class="string">&quot;Init&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (m_stEffectAlgorithmAPI.Init_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取函数指针失败</span></span><br><span class="line">            <span class="built_in">dlclose</span>(handle);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">        stUnionClass value</span><br><span class="line">        ret = m_stEffectAlgorithmAPI.<span class="built_in">GetParameter_</span>(<span class="string">&quot;type&quot;</span>,value);</span><br><span class="line">        <span class="built_in">CHECK_RESULT</span>(ret);</span><br><span class="line">        <span class="keyword">if</span>(value.str_ == <span class="string">&quot;video&quot;</span>)&#123;</span><br><span class="line">            m_stEffectAlgorithmAPI.effect_algorithms_type_ = emEffectAlgorithmsType::VIDEO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(value.str_ == <span class="string">&quot;audio&quot;</span>)&#123;</span><br><span class="line">            m_stEffectAlgorithmAPI.effect_algorithms_type_ = emEffectAlgorithmsType::AUDIO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">MTLog</span>(<span class="string">L&quot;Error:....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        emResult ret = m_stEffectAlgorithmAPI.<span class="built_in">Init_</span>();</span><br><span class="line">        <span class="built_in">CHECK_RESULT</span>(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CMediaEffectAlgorithmsStream</span>()&#123;</span><br><span class="line"></span><br><span class="line">        emResult ret = m_stEffectAlgorithmAPI.<span class="built_in">Uninit_</span>();</span><br><span class="line">        <span class="built_in">CHECK_RESULT</span>(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IMediaEffectAlgorithmsStream</span></span><br><span class="line">    <span class="function">emResult <span class="title">SetEffecttAlgorithmsParameter</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,stUnionClass value)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            函数内部实现举例：</span></span><br><span class="line"><span class="comment">                if (strcmp(name, &quot;RotationAngle&quot;) == 0) &#123;</span></span><br><span class="line"><span class="comment">                    if (value.type_ != emParamType::INT)&#123;</span></span><br><span class="line"><span class="comment">                        return emResult::ERROR_INVALID_DATA_TYPE;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    m_RotationAngle = value.nValue_;</span></span><br><span class="line"><span class="comment">                    return emResult::Success;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SetParameter</span>(name,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">emResult <span class="title">GetEffecttAlgorithmsParameter</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, stUnionClass&amp; value)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetParameter</span>(name,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IMediaStream</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetStreamInfomation</span><span class="params">(IStreamInfomation** ppStreamInfomation)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((m_pMediaStreamInfomation == <span class="literal">nullptr</span>)</span><br><span class="line">        || (ppStreamInfomation == <span class="literal">nullptr</span>)</span><br><span class="line">        || (*ppStreamInfomation == <span class="literal">nullptr</span>))&#123;</span><br><span class="line">            <span class="built_in">MTLog</span>(<span class="string">L&quot;Error:xxxx&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IMediaStreamInput</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SetMediaStreamInput</span><span class="params">(IMediaStream *pMediaStream)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//步骤一：加锁</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将之前的类成员变量的值和数据以及加载进来的算法库进行重置操作</span></span><br><span class="line">        <span class="built_in">Reset</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pMediaStream)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        m_pSrcMediaStream = pMediaStream;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个用于：存放当前节点的流媒体信息的结构体</span></span><br><span class="line">        <span class="keyword">if</span>(m_pMediaStreamInfomation != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_pMediaStreamInfomation-&gt;<span class="built_in">Release</span>();</span><br><span class="line">            m_pMediaStreamInfomation = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_pMediaStreamInfomation = <span class="keyword">new</span> MediaStreamInfomation;</span><br><span class="line">        <span class="built_in">memset</span>(m_pMediaStreamInfomation, <span class="number">0</span>, <span class="built_in">sizeof</span>(MediaStreamInfomation));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从输入流中获取上一个节点处理后的媒体信息流</span></span><br><span class="line">        <span class="keyword">if</span> (m_pSrcMediaStream-&gt;<span class="built_in">GetStreamInfomation</span>(&amp;m_pSrcStreamInfomation) != <span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将获取到的上一个节点处理后的媒体信息流的相关信息保存到当前的m_pMediaStreamInfomation指向的结构体中</span></span><br><span class="line">        m_pMediaStreamInfomation-&gt;XX = m_pSrcStreamInfomation-&gt;<span class="built_in">GetXX</span>();</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IMediaStreamOutput</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetMediaStreamOutput</span><span class="params">(IMediaStream **ppMediaStream)</span></span>&#123;</span><br><span class="line">        *ppMediaStream = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">stMediaFrame* <span class="title">GetSample</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!m_pSrcMediaStream || !m_pSrcStreamInfomation)&#123;</span><br><span class="line">            <span class="built_in">MTLog</span>(<span class="string">&quot;Error:xxx&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stMediaFrame *pInputMediaFrame = m_pSrcMediaStream-&gt;<span class="built_in">GetSample</span>();</span><br><span class="line">        <span class="keyword">if</span> (!pFrame) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (m_emEffectAlgorithmsType == emEffectAlgorithmsType::VIDEO)&#123;</span><br><span class="line">            <span class="comment">//创建一帧，用于存放算法输出的数据</span></span><br><span class="line">            m_pOutputMediaFrame = <span class="built_in">CreateVideoMediaFrame</span>(type,width,height,is_alpha,ia_black_image);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m_emEffectAlgorithmsType == emEffectAlgorithmsType::AUDIO)&#123;</span><br><span class="line">            m_pOutputMediaFrame = <span class="built_in">CreateAudioMediaFrame</span>(sample_rate,channels_number,bits_per_sample,nbufferSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">MTLog</span>(<span class="string">L&quot;Error:...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        emResult ret = <span class="built_in">Process</span>(pInputMediaFrame,m_pOutputMediaFrame);</span><br><span class="line">        <span class="keyword">if</span>(ret != emResult::SUCCESS)&#123;</span><br><span class="line">            <span class="built_in">MTLog</span>(<span class="string">L&quot;Error:...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改其他参数信息</span></span><br><span class="line">        m_pOutputMediaFrame-&gt;pts = pInputMediaFrame-&gt;pts;</span><br><span class="line">        m_pOutputMediaFrame-&gt;dts = pInputMediaFrame-&gt;dts;</span><br><span class="line">        m_pOutputMediaFrame-&gt;duration = pInputMediaFrame-&gt;duration;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_pOutputMediaFrame;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetCurrentTime</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (m_pSrcMediaStream)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_pSrcMediaStream-&gt;<span class="built_in">GetCurrentTime</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Forward</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_pSrcMediaStream)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_pSrcMediaStream-&gt;<span class="built_in">Forward</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Seek</span><span class="params">(<span class="type">double</span> time,<span class="type">bool</span> is_accurate)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (m_pSrcMediaStream)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_pSrcMediaStream-&gt;<span class="built_in">Seek</span>(time, is_accurate);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// //IMTUnknown</span></span><br><span class="line">    <span class="comment">// void* QueryInterface(const char* GUID) override &#123;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     if (strcmp(GUID,IID_IMediaStreamInput) == 0) &#123;</span></span><br><span class="line">    <span class="comment">//         return static_cast&lt;IMediaStreamInput*&gt;(this);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     else if(strcmp(GUID,IID_IMediaStreamOutput) == 0) &#123;</span></span><br><span class="line">    <span class="comment">//         return static_cast&lt;IMediaStreamOutput*&gt;(this);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     else if(strcmp(GUID,IID_IMediaEffectAlgorithmsStream) == 0) &#123;</span></span><br><span class="line">    <span class="comment">//         return static_cast&lt;IMediaEffectAlgorithmsStream*&gt;(this);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return nullptr;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    stEffectAlgorithmAPI        m_stEffectAlgorithmAPI;</span><br><span class="line"></span><br><span class="line">    IMediaStream*               m_pSrcMediaStream;</span><br><span class="line">    MediaStreamInfomation*      m_pMediaStreamInfomation;</span><br><span class="line">    std::mutex                  m_mutex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我把上面的注释掉了，原因是我们在中可以直接创建CMediaEffectAlgorithmsStream．而不是采用IMediaEffectAlgorithmsStream去实例化对象，这样就无须采用繁琐的QueryInterface机制来获取对应的IMediaStreamInput和IMediaStreamOutput的接口了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置输入流</span></span><br><span class="line">IMediaStreamInput* pIMediaStreamInput = pCMediaEffectAlgorithmsStream-&gt;<span class="built_in">QueryInterface</span>(IID_IMediaStreamInput);</span><br><span class="line">pIMediaStreamInput-&gt;<span class="built_in">SetMediaStreamInput</span>(pInputMediaStream);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置对应effect的输入参数</span></span><br><span class="line">pCMediaEffectAlgorithmsStream-&gt;<span class="built_in">SetEffecttAlgorithmsParameter</span>(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取输出流</span></span><br><span class="line">IMediaStreamOutput* pIMediaStreamOutput = pCMediaEffectAlgorithmsStream-&gt;<span class="built_in">QueryInterface</span>(IID_IMediaStreamOutput);</span><br><span class="line">pIMediaStreamOutput-&gt;<span class="built_in">GetMediaStreamOutput</span>(&amp;pOutputMediaStream);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而是直接：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CreateEffectFilterLink</span><span class="params">(IMediaStream* pMediaStream, stEffectParam* pEffectAlgorithmsParam, <span class="type">const</span> <span class="type">char</span>* chEffectFilterGuid, ...)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    va_list args;<span class="comment">//保存可变参数列表</span></span><br><span class="line">    <span class="built_in">va_start</span>(args, chEffectFilterGuid);<span class="comment">//指向可变参数列表的起始位置</span></span><br><span class="line"></span><br><span class="line">    IMediaStream *pInputMediaStream = pMediaStream;</span><br><span class="line">    IMediaStream *pOutputMediaStream = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* chCurrentEffectFilterLNodeGuid = <span class="built_in">va_arg</span>(args, <span class="type">const</span> <span class="type">char</span>*);<span class="comment">//使用va_arg宏获取参数的值，并将ap指针移动到下一个参数的位置   </span></span><br><span class="line">        <span class="keyword">if</span> (chCurrentEffectFilterLNodeGuid == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据当前的GUID值new对应的effect对象</span></span><br><span class="line">        CMediaEffectAlgorithmsStream* pCMediaEffectAlgorithmsStream = <span class="keyword">new</span> <span class="built_in">CMediaEffectAlgorithmsStream</span>(chCurrentEffectFilterLNodeGuid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置输入流</span></span><br><span class="line">        pCMediaEffectAlgorithmsStream&gt;<span class="built_in">SetMediaStreamInput</span>(pInputMediaStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置对应effect的输入参数</span></span><br><span class="line">        pCMediaEffectAlgorithmsStream-&gt;<span class="built_in">SetEffecttAlgorithmsParameter</span>(...);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取输出流</span></span><br><span class="line">        pCMediaEffectAlgorithmsStream-&gt;<span class="built_in">GetMediaStreamOutput</span>(&amp;pOutputMediaStream);</span><br><span class="line">        <span class="keyword">if</span>(pOutputMediaStream == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">MTLog</span>(<span class="string">&quot;Error:XXX&quot;</span>);</span><br><span class="line">            <span class="built_in">va_end</span>(args);<span class="comment">//清理va_list变量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pInputMediaStream = pOutputMediaStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_end</span>(args);<span class="comment">//清理va_list变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实通过上面的SetMediaStreamInput和GetMediaStreamOutput操作，其实本质上就是设计模式中的责任链模式的变种<br>PS：责任链：</p><ul><li><a href="https://www.cnblogs.com/TheGCC/p/14172799.html">https://www.cnblogs.com/TheGCC/p/14172799.html</a></li><li><a href="https://refactoringguru.cn/design-patterns/chain-of-responsibility">https://refactoringguru.cn/design-patterns/chain-of-responsibility</a></li></ul><h2 id="提供给应用层的接口"><a href="#提供给应用层的接口" class="headerlink" title="提供给应用层的接口"></a>提供给应用层的接口</h2><p>提供给应用层的接口:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CreateEffectFilterLink</span><br><span class="line">DestroyEffectFilterLink</span><br><span class="line">GetEffectFilterLinkInfo</span><br><span class="line">GetCurrentEffectAlgorithmsNodeParam</span><br><span class="line">SetCurrentEffectAlgorithmsNodeParam</span><br></pre></td></tr></table></figure><p>除了这些接口以外，实际上我们还可以提供一下链路上节点的增加和删除操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AddEffectFilterNode</span><br><span class="line">DeleteEffectFilterNode</span><br></pre></td></tr></table></figure><p>PS:叠加(视频流&#x2F;图片&#x2F;字幕)和混音这两个算法不在这里处理，后续会另外设计一套解决方案来继承</p><h1 id="整体架构的具体实现："><a href="#整体架构的具体实现：" class="headerlink" title="整体架构的具体实现："></a>整体架构的具体实现：</h1><h2 id="提供给应用层的接口的具体实现"><a href="#提供给应用层的接口的具体实现" class="headerlink" title="提供给应用层的接口的具体实现"></a>提供给应用层的接口的具体实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> EXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> EXPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出的 C 函数</span></span><br><span class="line"><span class="function">EXPORT emResult <span class="title">CreateEffectFilterLink</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="function">EXPORT <span class="type">void</span> <span class="title">DestroyEffectFilterLink</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">EXPORT emResult <span class="title">AddEffectFilterNode</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="function">EXPORT emResult <span class="title">DeleteEffectFilterNode</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">EXPORT emResult <span class="title">GetEffectFilterLinkInfo</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="function">EXPORT emResult <span class="title">GetCurrentEffectAlgorithmsNodeParam</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="function">EXPORT emResult <span class="title">SetCurrentEffectAlgorithmsNodeParam</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">endif</span></span></span></span><br></pre></td></tr></table></figure><h3 id="CreateEffectFilterLink"><a href="#CreateEffectFilterLink" class="headerlink" title="CreateEffectFilterLink:"></a>CreateEffectFilterLink:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stEffectParam</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CreateEffectFilterLink</span><span class="params">(IMediaStream* pMediaStream,<span class="type">const</span> stEffectParam* pEffectAlgorithmsParam, <span class="type">const</span> <span class="type">char</span>* chEffectFilterGuid, ...)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    va_list args;<span class="comment">//保存可变参数列表</span></span><br><span class="line">    <span class="built_in">va_start</span>(args, chEffectFilterGuid);<span class="comment">//指向可变参数列表的起始位置</span></span><br><span class="line"></span><br><span class="line">    IMediaStream *pInputMediaStream = pMediaStream;</span><br><span class="line">    IMediaStream *pOutputMediaStream = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* chCurrentEffectFilterLNodeGuid = <span class="built_in">va_arg</span>(args, <span class="type">const</span> <span class="type">char</span>*);<span class="comment">//使用va_arg宏获取参数的值，并将ap指针移动到下一个参数的位置   </span></span><br><span class="line">        <span class="keyword">if</span> (chCurrentEffectFilterLNodeGuid == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据当前的GUID值new对应的effect对象</span></span><br><span class="line">        CMediaEffectAlgorithmsStream* pCMediaEffectAlgorithmsStream = <span class="keyword">new</span> <span class="built_in">CMediaEffectAlgorithmsStream</span>(chCurrentEffectFilterLNodeGuid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置输入流</span></span><br><span class="line">        pCMediaEffectAlgorithmsStream&gt;<span class="built_in">SetMediaStreamInput</span>(pInputMediaStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置对应effect的输入参数</span></span><br><span class="line">        pCMediaEffectAlgorithmsStream-&gt;<span class="built_in">SetEffecttAlgorithmsParameter</span>(...);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取输出流</span></span><br><span class="line">        pCMediaEffectAlgorithmsStream-&gt;<span class="built_in">GetMediaStreamOutput</span>(&amp;pOutputMediaStream);</span><br><span class="line">        <span class="keyword">if</span>(pOutputMediaStream == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">MTLog</span>(<span class="string">&quot;Error:XXX&quot;</span>);</span><br><span class="line">            <span class="built_in">va_end</span>(args);<span class="comment">//清理va_list变量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pInputMediaStream = pOutputMediaStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_end</span>(args);<span class="comment">//清理va_list变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IMediaStream的架构设计</p><p>责任链模式＋策略模式＋类工厂</p><p>AI:享元模式＋代理模式＋原型模式</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>WebCodec视频解码插件开发笔记</title>
      <link href="/2023/12/16/WebCodecs%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/12/16/WebCodecs%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本章将讲述如何基于WebCodecs进行视频解码器插件的架构设计和开发工作。何为基于WebCodecs的音频解码器？实际上就是将音频pkt的解码交给JS层的WebCodecs进行处理,而C++层只进行对应的逻辑处理。从而借助Web端的WebCodecs实现视频解码的功能。</p><p>其实基于WebCodecs视频解码的插件开发和音频解码的插件开发本质上是一样的，Init接口中的区别主要是对额外数据的处理，根据WebCodecs的文档，我们可知，WebCodecs支持H264&#x2F;HEVC&#x2F;VP8&#x2F;VVP9&#x2F;AV1这几个Codec的解码。其他接口的调用逻辑基本是一样的。</p><p>还有就是WebCodecs解码出来的视频帧可以通过Web端的OpenGL来支持输出OpenGL纹理的解码视频帧，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nTextureID &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  let gl = GL.currentContext.GLctx;</span><br><span class="line">  let texObj = GL.textures[nTextureID];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (texObj) &#123;</span><br><span class="line">      gl.<span class="built_in">bindTexture</span>(gl.TEXTURE_2D, texObj);</span><br><span class="line">      gl.<span class="built_in">texParameteri</span>(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);</span><br><span class="line">      gl.<span class="built_in">texParameteri</span>(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);</span><br><span class="line">      gl.<span class="built_in">texParameteri</span>(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);</span><br><span class="line">      gl.<span class="built_in">texParameteri</span>(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);</span><br><span class="line">      gl.<span class="built_in">texImage2D</span>(gl.TEXTURE_2D, <span class="number">0</span>, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, e.data.video_frame);</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>PS:texture_id通过C++层来管理(创建和删除)即：<br>创建</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GLuint texture;</span><br><span class="line">GLsizei n = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">glGenTextures</span>(n, &amp;texture);</span><br></pre></td></tr></table></figure><p>删除：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GLsizei n = <span class="number">1</span>;</span><br><span class="line">GLuint texture = texture_id;</span><br><span class="line"><span class="keyword">if</span> (texture &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">glDeleteTextures</span>(n, &amp;texture);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这边还需要引入一个知识点：<br>Web Worker 线程是在主线程之外运行的 JavaScript 线程，可以用于执行一些耗时的计算、渲染等操作，以避免阻塞主线程。以下是一些 Web Worker 线程相关的操作：<br>创建 Web Worker 线程：可以使用 new Worker() 方法创建一个 Web Worker 线程。该方法接受一个参数，即要执行的 JavaScript 文件的 URL。例如，以下代码创建一个名为 myWorker 的 Web Worker 线程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myWorker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;worker.js&#x27;</span>);</span><br></pre></td></tr></table></figure><p>监听 message 事件：在 Web Worker 线程中，可以通过监听 message 事件来接收来自主线程或其他线程的消息。例如，以下代码在 Web Worker 线程中监听 message 事件，并在接收到消息时将消息内容打印到控制台：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received message:&#x27;</span>, e.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>发送消息：可以使用 postMessage() 方法向主线程或其他线程发送消息。该方法接受一个参数，即要发送的消息对象，可以是任何 JavaScript 对象。例如，以下代码向名为 myWorker 的 Web Worker 线程发送一个包含字符串 “Hello, worker!” 的消息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myWorker.<span class="title function_">postMessage</span>(<span class="string">&quot;Hello, worker!&quot;</span>);myWorker.<span class="title function_">postMessage</span>(<span class="string">&quot;Hello, worker!&quot;</span>);</span><br></pre></td></tr></table></figure><p>关闭 Web Worker 线程：可以使用 close() 方法关闭 Web Worker 线程。例如，以下代码关闭名为 myWorker 的 Web Worker 线程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myWorker.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure><p>需要注意的是，Web Worker 线程中不能直接访问 DOM 元素，也不能直接与主线程之外的其他线程通信。如果需要与其他线程通信，可以使用 MessageChannel API 或 SharedWorker API。<br>Web Worker 线程可以提高 Web 应用程序的性能和响应速度，但也需要注意避免过度使用，以避免增加系统负担和内存占用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">JS_WesWaitChannelMessage</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">data</span>.<span class="property">msg_type</span> == <span class="string">&#x27;GetChannelPort&#x27;</span>) &#123;</span><br><span class="line">        <span class="title class_">Wes</span>_Render_Channel_Port = e.<span class="property">ports</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="title class_">Wes</span>_Render_Channel_Port.<span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, JS_WebCodecVideoDecoderMessage);<span class="comment">//解码</span></span><br><span class="line">        <span class="title class_">Wes</span>_Render_Channel_Port.<span class="title function_">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">JS_WebDecoderWaitChannelMessage</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">data</span>.<span class="property">msg_type</span> == <span class="string">&#x27;GetChannelPort&#x27;</span>) &#123;</span><br><span class="line">        <span class="title class_">WebCodec</span>_Decoder_Channel_Port = e.<span class="property">ports</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="title class_">WebCodec</span>_Decoder_Channel_Port.<span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, JS_WesRenderMessage);<span class="comment">//渲染</span></span><br><span class="line">        <span class="title class_">WebCodec</span>_Decoder_Channel_Port.<span class="title function_">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">JS_WebCodecVideoDecoderMessage</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">data</span>.<span class="property">msg_type</span> == <span class="string">&#x27;WebCodecVideoDecoderGpuFrame&#x27;</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.<span class="property">data</span>.<span class="property">msg_type</span> == <span class="string">&#x27;WebCodecVideoDecoderRenderDeleteTextureID&#x27;</span>) &#123;</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.<span class="property">data</span>.<span class="property">msg_type</span> == <span class="string">&#x27;WebCodecVideoDecoderDestroy&#x27;</span>) &#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.<span class="property">data</span>.<span class="property">msg_type</span> == <span class="string">&#x27;WebCodecVideoDecoderCreate&#x27;</span>) &#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// end msg process</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">JS_WebCodecVideoDecoderSendMessage</span>(<span class="params">decoder_obj_adrr, target_thread_id, thread_id, frame</span>) &#123;</span><br><span class="line">        <span class="variable constant_">XX</span>.<span class="title function_">postMessage</span>(&#123; <span class="attr">targetThread</span>: target_thread_id, <span class="attr">sourceThread</span>: thread_id, <span class="attr">msg_type</span>: <span class="string">&quot;WebCodecVideoDecoderGpuFrame&quot;</span>, <span class="attr">webcodec_decoder_obj_adrr</span>: decoder_obj_adrr, <span class="attr">video_frame</span>: frame &#125;, [frame]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">JS_WesRenderMessage</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">data</span>.<span class="property">msg_type</span> == <span class="string">&#x27;WebCodecVideoDecoderRenderDeleteTextureID&#x27;</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其他的同理：JS_WebCodecVideoDecoderSendDestroyMessage、JS_WebCodecVideoDecoderSendCreateMessage、JS_WebCodecVideoDecoderDeleteTextureSendMessage</span><br></pre></td></tr></table></figure><p>PS:还有一点需要注意的是视频的CopyTo接口是异步的，而音频的是同步的，即视频的解码帧CopyTo：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> video_frame_promise = <span class="title class_">VideoFrame</span>.<span class="title function_">copyTo</span>(buffer, &#123; <span class="attr">rect</span>: copy_rect &#125;);</span><br><span class="line">video_frame_promise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">newResult</span>) &#123;</span><br><span class="line">    .......</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;CopyTo成功&#x27;</span>);</span><br><span class="line">    <span class="title class_">VideoFrame</span>.<span class="title function_">close</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    .......</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;CopyTo失败&#x27;</span>);</span><br><span class="line">    <span class="title class_">VideoFrame</span>.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>libyuv学习笔记之YUV之间转换的接口封装</title>
      <link href="/2023/11/23/libyuv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BYUV%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B0%81%E8%A3%85/"/>
      <url>/2023/11/23/libyuv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BYUV%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>根据之前的文章：&lt;&lt;YUV和RGBA格式介绍&gt;&gt;，我们可以知道相关的YUV格式主要有以下几种：<br><img src="/./libyuv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BYUV%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B0%81%E8%A3%85/YUV%E6%A0%BC%E5%BC%8F.png"></p><p>FFmpeg支持的可以处理多种不同的颜色空间。以下是一些常见的编码器和它们支持的颜色空间：</p><ul><li>YUV420P</li><li>YUV422P</li><li>YUV444P</li><li>YUV420P10LE</li><li>YUV422P10LE</li><li>YUV444P10LE</li><li>YUV420P1P12LE</li><li>YUV422P12LE</li><li>YUV444P12LE</li></ul><p>PS:可以使用ffmpeg -h encoder&#x3D;encoder_name命令来查看特定编码器的详细信息，包括支持的颜色空间．</p><p>由于直接用ffmpeg的libswscale(SwsContext API)来转换格式的话，效率低到爆炸，粗略测试过libyvu和libswscale的color space的性能差距接近十倍，libyuv虽然快，但对于color space的支持并不多，不过也满足上述的要求．</p><p>对于编解码底层而言，如果能做到ffdec和nvdec,mediaSDK等硬件加速方案解码出来的color space格式的全部管线（即：所有filter支持这些color space）那就是极好的，但是这点其实不太现实（投入产出比太低了），因此最优解是对解码和编码端输入和输出的color space进行限定，使得常用的旋转缩放crop这三个filter仅支持有限的color space即可</p><p>因此，需要先提供一个其他color转YV12的接口（通过libyuv的ConvertToI420）<br>PS:libyuv可以对I420进行旋转缩放crop操作，因此对于其他color space，如果不支持直接进行旋转缩放crop操作的话，可以先调用这个接口将其统一转成yv12或I420</p><p>YV12 ： 亮度（行×列） ＋ V（行×列&#x2F;4) + U（行×列&#x2F;4）<br>I420 ： 亮度（行×列） ＋ U（行×列&#x2F;4) + V（行×列&#x2F;4）</p><p>libyuv的接口定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Convert camera sample to I420 with cropping, rotation and vertical flip.</span></span><br><span class="line"><span class="comment">// &quot;src_size&quot; is needed to parse MJPG.</span></span><br><span class="line"><span class="comment">// &quot;dst_stride_y&quot; number of bytes in a row of the dst_y plane.</span></span><br><span class="line"><span class="comment">//   Normally this would be the same as dst_width, with recommended alignment</span></span><br><span class="line"><span class="comment">//   to 16 bytes for better efficiency.</span></span><br><span class="line"><span class="comment">//   If rotation of 90 or 270 is used, stride is affected. The caller should</span></span><br><span class="line"><span class="comment">//   allocate the I420 buffer according to rotation.</span></span><br><span class="line"><span class="comment">// &quot;dst_stride_u&quot; number of bytes in a row of the dst_u plane.</span></span><br><span class="line"><span class="comment">//   Normally this would be the same as (dst_width + 1) / 2, with</span></span><br><span class="line"><span class="comment">//   recommended alignment to 16 bytes for better efficiency.</span></span><br><span class="line"><span class="comment">//   If rotation of 90 or 270 is used, stride is affected.</span></span><br><span class="line"><span class="comment">// &quot;crop_x&quot; and &quot;crop_y&quot; are starting position for cropping.</span></span><br><span class="line"><span class="comment">//   To center, crop_x = (src_width - dst_width) / 2</span></span><br><span class="line"><span class="comment">//              crop_y = (src_height - dst_height) / 2</span></span><br><span class="line"><span class="comment">// &quot;src_width&quot; / &quot;src_height&quot; is size of src_frame in pixels.</span></span><br><span class="line"><span class="comment">//   &quot;src_height&quot; can be negative indicating a vertically flipped image source.</span></span><br><span class="line"><span class="comment">// &quot;crop_width&quot; / &quot;crop_height&quot; is the size to crop the src to.</span></span><br><span class="line"><span class="comment">//    Must be less than or equal to src_width/src_height</span></span><br><span class="line"><span class="comment">//    Cropping parameters are pre-rotation.</span></span><br><span class="line"><span class="comment">// &quot;rotation&quot; can be 0, 90, 180 or 270.</span></span><br><span class="line"><span class="comment">// &quot;fourcc&quot; is a fourcc. ie &#x27;I420&#x27;, &#x27;YUY2&#x27;</span></span><br><span class="line"><span class="comment">// Returns 0 for successful; -1 for invalid parameter. Non-zero for failure.</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ConvertToI420</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* sample,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">size_t</span> sample_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">uint8_t</span>* dst_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> dst_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">uint8_t</span>* dst_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> dst_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">uint8_t</span>* dst_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> dst_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> crop_x,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> crop_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> src_width,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> src_height,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> crop_width,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> crop_height,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">enum</span> RotationMode rotation,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">uint32_t</span> fourcc)</span></span>;</span><br></pre></td></tr></table></figure><p>其他YUV格式转I420的接口封装：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">libyuv_API <span class="type">int</span> __stdcall <span class="title">YUVToI420</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* src_data, <span class="type">int</span> src_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">unsigned</span> <span class="type">char</span>* dst_y_data, <span class="type">int</span> dst_y_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">unsigned</span> <span class="type">char</span>* dst_u_data, <span class="type">int</span> dst_u_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">unsigned</span> <span class="type">char</span>* dst_v_data, <span class="type">int</span> dst_v_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int</span> image_width, <span class="type">int</span> image_height, <span class="keyword">enum</span> libyuv::FourCC src_fourcc)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result =  libyuv::<span class="built_in">ConvertToI420</span>(src_data, src_stride,</span><br><span class="line">      dst_y_data, dst_y_stride, dst_u_data, dst_u_stride, dst_v_data, dst_v_stride,</span><br><span class="line">      <span class="number">0</span>, <span class="number">0</span>, image_width, image_height,image_width, image_height, libyuv::kRotate0, src_fourcc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(result != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//log err</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">           </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>libyuv的接口定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Convert I420 to specified format.</span></span><br><span class="line"><span class="comment">// &quot;dst_sample_stride&quot; is bytes in a row for the destination. Pass 0 if the</span></span><br><span class="line"><span class="comment">//    buffer has contiguous rows. Can be negative. A multiple of 16 is optimal.</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ConvertFromI420</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* y,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">int</span> y_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> <span class="type">uint8_t</span>* u,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">int</span> u_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> <span class="type">uint8_t</span>* v,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">int</span> v_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">uint8_t</span>* dst_sample,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">int</span> dst_sample_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">uint32_t</span> fourcc)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>YV12或I420转其他YUV格式的封装：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">libyuv_API <span class="type">int</span> __stdcall <span class="title">I420ToYUV</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* src_y_data, <span class="type">int</span> src_y_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">unsigned</span> <span class="type">char</span>* src_u_data, <span class="type">int</span> src_u_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">unsigned</span> <span class="type">char</span>* src_v_data, <span class="type">int</span> src_v_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">unsigned</span> <span class="type">char</span>* dst_data, <span class="type">int</span> dst_data_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int</span> image_width, <span class="type">int</span> image_height, <span class="keyword">enum</span> libyuv::FourCC dst_fourcc)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = libyuv::<span class="built_in">ConvertFromI420</span>(src_y_data, src_y_stride, src_u_data, src_u_stride, src_v_data, src_v_stride,</span><br><span class="line">      dst_data, dst_data_stride,</span><br><span class="line">      image_width, image_height, dst_fourcc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(result != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//log err</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样对于YUV之间的转换，采用上述的两个封装接口后，基本够用了，具体支持情况参考输入参数libyuv::FourCC即可</p><p>我们在此基础上再封装出一个总的API接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">libyuv_API <span class="type">int</span> __stdcall <span class="title">ConvertYUV</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* src_y_data, <span class="type">int</span> src_y_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">unsigned</span> <span class="type">char</span>* src_u_data, <span class="type">int</span> src_u_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">unsigned</span> <span class="type">char</span>* src_v_data, <span class="type">int</span> src_v_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">enum</span> libyuv::FourCC src_fourcc</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">unsigned</span> <span class="type">char</span>* dst_y_data, <span class="type">int</span> dst_y_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">unsigned</span> <span class="type">char</span>* dst_u_data, <span class="type">int</span> dst_u_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">unsigned</span> <span class="type">char</span>* dst_v_data, <span class="type">int</span> dst_v_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">enum</span> libyuv::FourCC dst_fourcc,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int</span> image_width, <span class="type">int</span> image_height)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((src_fourcc == libyuv::FourCC::FOURCC_I420) &amp;&amp; (dst_fourcc != libyuv::FourCC::FOURCC_I420))&#123;</span><br><span class="line"></span><br><span class="line">      result = <span class="built_in">I420ToYUV</span>(src_y_data, src_y_stride, src_u_data, src_u_stride, src_v_data, src_v_stride,</span><br><span class="line">                          dst_y_data, dst_y_stride,</span><br><span class="line">                          image_width, image_height, dst_fourcc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((src_fourcc != libyuv::FourCC::FOURCC_I420) &amp;&amp; (dst_fourcc == libyuv::FourCC::FOURCC_I420))&#123;</span><br><span class="line"></span><br><span class="line">      result = <span class="built_in">YUVToI420</span>(src_y_data, src_y_stride,</span><br><span class="line">                          dst_y_data, dst_y_stride, dst_u_data, dst_u_stride, dst_v_data, dst_v_stride,</span><br><span class="line">                          image_width, image_height,src_fourcc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((src_fourcc == libyuv::FourCC::FOURCC_I420) &amp;&amp; (dst_fourcc == libyuv::FourCC::FOURCC_I420))&#123;</span><br><span class="line"></span><br><span class="line">      result = libyuv::<span class="built_in">I420Copy</span>(src_y_data, src_y_stride, src_u_data, src_u_stride, src_v_data, src_v_stride,</span><br><span class="line">                          dst_y_data, dst_y_stride, dst_u_data, dst_u_stride, dst_v_data, dst_v_stride,</span><br><span class="line">                          image_width, image_height)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span>* temp = <span class="literal">nullptr</span>;</span><br><span class="line">      temp = <span class="built_in">new</span> (std::nothrow) <span class="type">unsigned</span> <span class="type">char</span>[src_y_stride*image_height*<span class="number">3</span>/<span class="number">2</span>+<span class="number">128</span>]();</span><br><span class="line">      <span class="keyword">if</span>(temp == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="comment">//log err :new fail</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-9999</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      result = <span class="built_in">YUVToI420</span>(src_y_data, src_y_stride,</span><br><span class="line">                          temp, src_y_stride, temp + src_y_data * image_width, src_y_stride, temp + src_y_data * image_width * <span class="number">5</span> / <span class="number">4</span>, src_y_stride,</span><br><span class="line">                          image_width, image_height,src_fourcc);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(result != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//log err</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      result = <span class="built_in">I420ToYUV</span>(temp, src_y_stride, temp + src_y_data * image_width, src_y_stride, temp + src_y_data * image_width * <span class="number">5</span> / <span class="number">4</span>,  src_y_stride,</span><br><span class="line">                    dst_y_data, dst_y_stride,</span><br><span class="line">                    image_width, image_height, dst_fourcc); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>libyuv学习笔记之YUV转RGBX的接口封装</title>
      <link href="/2023/11/23/libyuv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BYUV%E8%BD%ACRGBX%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B0%81%E8%A3%85/"/>
      <url>/2023/11/23/libyuv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BYUV%E8%BD%ACRGBX%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="YUVToRGBX的转换"><a href="#YUVToRGBX的转换" class="headerlink" title="YUVToRGBX的转换"></a>YUVToRGBX的转换</h2><p>通过libyuv的头文件：<br>我们可以发现头文件提供的接口并不足以满足我们的要求，因此我们可以参考convert_test.cc来基于这些函数进行二次封装：</p><p>对于I420ToRGBX的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.601</span></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420BT601ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, dst_stride_argb, &amp;kYuvI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420BT601ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_abgr, dst_stride_abgr, &amp;kYvuI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420BT601ConstantsToRGB24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToRGB24Matrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_adst_rgb24, dst_stride_rgb24, &amp;kYuvI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420BT601ConstantsToBGR24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_bgr24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_bgr24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToRGB24Matrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_bgr24, dst_stride_bgr24, &amp;kYvuI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.601</span></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420BT601FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, dst_stride_argb, &amp;kYuvJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420BT601FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_abgr, dst_stride_abgr, &amp;kYvuJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420BT601FullToRGB24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToRGB24Matrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_adst_rgb24, dst_stride_rgb24, &amp;kYuvJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420BT601FullToBGR24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_bgr24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_bgr24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToRGB24Matrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_bgr24, dst_stride_bgr24, &amp;kYvuJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.709</span></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420BT709ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, dst_stride_argb, &amp;kYuvH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420BT709ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_abgr, dst_stride_abgrdst_stride_abgr, &amp;kYvuH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420BT709ConstantsToRGB24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToRGB24Matrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_adst_rgb24, dst_stride_rgb24, &amp;kYuvH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420BT709ConstantsToBGR24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_bgr24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_bgr24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToRGB24Matrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_bgr24, dst_stride_bgr24, &amp;kYvuH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.709</span></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">I420BT709FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, dst_stride_argb, &amp;kYuvF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420BT709FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420BT709FullToRGB24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToRGB24Matrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_adst_rgb24, dst_stride_rgb24, &amp;kYuvF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420BT709FullToBGR24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_bgr24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_bgr24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToRGB24Matrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_bgr24, dst_stride_bgr24, &amp;kYvuF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.2020</span></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420BT2020ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, dst_stride_argb, &amp;kYuv2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420BT2020ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_abgr, dst_stride_abgr, &amp;kYvu2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420BT2020ConstantsToRGB24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToRGB24Matrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_adst_rgb24, dst_stride_rgb24, &amp;kYuv2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420BT2020ConstantsToBGR24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_bgr24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_bgr24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToRGB24Matrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_bgr24, dst_stride_bgr24, &amp;kYvu2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.2020</span></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">I420BT2020FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, dst_stride_argb, &amp;kYuvV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">I420BT2020FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_abgr, dst_stride_abgr, &amp;kYvuV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420BT2020FullToRGB24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToRGB24Matrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_adst_rgb24, dst_stride_rgb24, &amp;kYuvV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420BT2020FullToBGR24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">uint8_t</span>* dst_bgr24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> dst_stride_bgr24,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420ToRGB24Matrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_bgr24, dst_stride_bgr24, &amp;kYvuV2020Constants, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于I420AlphaToRGBX的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provide matrix wrappers for bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420AlphaBT601ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb,&amp;kYuvI601Constants,width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420AlphaBT601ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420AlphaToARGBMatrix</span>(src_y,src_stride_y,src_v,src_stride_v,src_u,src_stride_u,src_a,src_stride_a,dst_abgr,dst_stride_abgr, &amp;kYvuI601Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420AlphaBT601FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvJPEGConstants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420AlphaBT601FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420AlphaToARGBMatrix</span>(src_y,src_stride_y,src_v,src_stride_v,src_u,src_stride_u,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYvuJPEGConstants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420AlphaBT709ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvH709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420AlphaBT709ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420AlphaToARGBMatrix</span>(src_y,src_stride_y,src_v,src_stride_v,src_u,src_stride_u,src_a,src_stride_a,dst_abgr,dst_stride_abgr, &amp;kYvuH709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420AlphaBT709FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvF709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420AlphaBT709FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420AlphaToARGBMatrix</span>(src_y,src_stride_y,src_v,src_stride_v,src_u,src_stride_u,src_a,src_stride_a,dst_abgr,dst_stride_abgr, &amp;kYvuF709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420AlphaBT2020ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuv2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420AlphaBT2020ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420AlphaToARGBMatrix</span>(src_y,src_stride_y,src_v,src_stride_v,src_u,src_stride_u,src_a,src_stride_a,dst_abgr,dst_stride_abgr, &amp;kYvu2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420AlphaBT2020FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvV2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I420AlphaBT2020FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I420AlphaToARGBMatrix</span>(src_y,src_stride_y,src_v,src_stride_v,src_u,src_stride_u,src_a,src_stride_a,dst_abgr,dst_stride_abgr, &amp;kYvuV2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于I422ToRGBX的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provide matrix wrappers for bt.601</span></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422BT601ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvI601Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422BT601ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422BT601FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuJPEGConstants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422BT601FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvJPEGConstants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422BT709ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuH709Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422BT709ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvH709Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422BT709FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuF709Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422BT709FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvF709Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422BT2020ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvu2020Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422BT2020ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuv2020Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422BT2020FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuV2020Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422BT2020FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvV2020Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于I422AlphaToRGBX的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provide matrix wrappers for bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422AlphaBT601ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvI601Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422AlphaBT601ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvI601Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422AlphaBT601FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvJPEGConstants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422AlphaBT601FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvJPEGConstants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422AlphaBT709ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvH709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422AlphaBT709ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvH709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422AlphaBT709FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvF709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422AlphaBT709FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvF709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422AlphaBT2020ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuv2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422AlphaBT2020ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuv2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422AlphaBT2020FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvV2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I422AlphaBT2020FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I422AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvV2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于I444ToRGBX的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provide matrix wrappers for bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444BT601ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span>  <span class="built_in">I444ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuI601Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444BT601ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvI601Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444BT601FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuJPEGConstants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444BT601FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvJPEGConstants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444BT709ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuH709Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444BT709ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvH709Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444BT709FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuF709Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444BT709FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvF709Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444BT2020ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvu2020Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444BT2020ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuv2020Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444BT2020FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuV2020Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444BT2020FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvV2020Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于I444AlphaToRGBX的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provide matrix wrappers for bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444AlphaBT601ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvI601Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444AlphaBT601ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvI601Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444AlphaBT601FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvJPEGConstants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444AlphaBT601FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvJPEGConstants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444AlphaBT709ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvH709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444AlphaBT709ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvH709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444AlphaBT709FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvF709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444AlphaBT709FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvF709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444AlphaBT2020ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuv2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444AlphaBT2020ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuv2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444AlphaBT2020FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvV2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I444AlphaBT2020FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I444AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvV2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于I010ToRGBX的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provide matrix wrappers for bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010BT601ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuI601Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010BT601ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvI601Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010BT601FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuJPEGConstants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010BT601FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvJPEGConstants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010BT709ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuH709Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010BT709ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvH709Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010BT709FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuF709Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010BT709FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvF709Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010BT2020ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvu2020Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010BT2020ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuv2020Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010BT2020FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuV2020Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010BT2020FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvV2020Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于I010AlphaToRGBX的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provide matrix wrappers for bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010AlphaBT601ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvI601Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010AlphaBT601ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvI601Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010AlphaBT601FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvJPEGConstants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010AlphaBT601FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvJPEGConstants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010AlphaBT709ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvH709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010AlphaBT709ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvH709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010AlphaBT709FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvF709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010AlphaBT709FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvF709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010AlphaBT2020ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuv2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010AlphaBT2020ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuv2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010AlphaBT2020FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvV2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I010AlphaBT2020FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I010AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvV2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于I210ToRGBX的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provide matrix wrappers for bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210BT601ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuI601Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210BT601ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvI601Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210BT601FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuJPEGConstants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210BT601FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvJPEGConstants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210BT709ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuH709Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210BT709ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvH709Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210BT709FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuF709Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210BT709FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvF709Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210BT2020ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvu2020Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210BT2020ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuv2020Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210BT2020FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuV2020Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210BT2020FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvV2020Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于I210AlphaToRGBX的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provide matrix wrappers for bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210AlphaBT601ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvI601Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210AlphaBT601ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvI601Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210AlphaBT601FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvJPEGConstants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210AlphaBT601FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvJPEGConstants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210AlphaBT709ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvH709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210AlphaBT709ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvH709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210AlphaBT709FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvF709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210AlphaBT709FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvF709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210AlphaBT2020ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuv2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210AlphaBT2020ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuv2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210AlphaBT2020FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvV2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I210AlphaBT2020FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I210AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvV2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于I410ToRGBX的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provide matrix wrappers for bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410BT601ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuI601Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410BT601ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvI601Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410BT601FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuJPEGConstants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410BT601FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvJPEGConstants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410BT709ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuH709Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410BT709ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvH709Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410BT709FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuF709Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410BT709FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvF709Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410BT2020ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvu2020Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410BT2020ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuv2020Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410BT2020FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410ToARGBMatrix</span>(src_y, src_stride_y, src_v, src_stride_v, src_u, src_stride_u, dst_argb, dst_stride_argb, &amp;kYvuV2020Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410BT2020FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410ToARGBMatrix</span>(src_y, src_stride_y, src_u, src_stride_u, src_v, src_stride_v, dst_argb, height, &amp;kYuvV2020Constants,  width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于I410AlphaToRGBX的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provide matrix wrappers for bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410AlphaBT601ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvI601Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410AlphaBT601ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvI601Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410AlphaBT601FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvJPEGConstants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410AlphaBT601FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvJPEGConstants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410AlphaBT709ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvH709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410AlphaBT709ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvH709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410AlphaBT709FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvF709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410AlphaBT709FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvF709Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410AlphaBT2020ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuv2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410AlphaBT2020ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuv2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410AlphaBT2020FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410AlphaToARGBMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvV2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I410AlphaBT2020FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">I410AlphaToABGRMatrix</span>(src_y,src_stride_y,src_u,src_stride_u,src_v,src_stride_v,src_a,src_stride_a,dst_argb,dst_stride_argb, &amp;kYuvV2020Constants, width,height,attenuate);            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他YUV定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provide matrix wrappers for bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT601ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT601ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT601ConstantsToRGB24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT601ConstantsToBGR24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT601ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT601ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT601ConstantsToRGB24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT601ConstantsToBGR24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P010BT601ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P010ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P010BT601ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P010ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P210BT601ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P210ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P210BT601ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P210ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P012BT601ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P012ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P012BT601ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P012ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P212BT601ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P212ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P212BT601ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P212ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P016BT601ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P016ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P016BT601ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P016ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P216BT601ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P216ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P216BT601ConstantsToABG</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P216ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuI601Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT601FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT601FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT601FullToRGB24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT601FullToBGR24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT601FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT601FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT601FullToRGB24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT601FullToBGR24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P010BT601FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P010ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P010BT601FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P010ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P210BT601FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P210ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P210BT601FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P210ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P012BT601FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P012ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P012BT601FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P012ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P212BT601FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P212ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P212BT601FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P212ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P016BT601FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P016ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P016BT601FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P016ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P216BT601FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P216ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P216BT601FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P216ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuJPEGConstants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT709ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT709ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT709ConstantsToRGB24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT709ConstantsToBGR24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT709ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT709ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT709ConstantsToRGB24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT709ConstantsToBGR24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P010BT709ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P010ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P010BT709ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P010ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P210BT709ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P210ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P210BT709ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P210ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P012BT709ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P012ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P012BT709ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P012ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P212BT709ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P212ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P212BT709ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P212ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P016BT709ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P016ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P016BT709ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P016ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P216BT709ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P216ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P216BT709ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P216ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuH709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.709</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT709FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT709FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT709FullToRGB24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT709FullToBGR24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT709FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT709FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT709FullToRGB24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT709FullToBGR24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P010BT709FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P010ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P010BT709FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P010ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P210BT709FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P210ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P210BT709FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P210ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P012BT709FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P012ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P012BT709FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P012ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P212BT709FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P212ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P212BT709FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P212ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P016BT709FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P016ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P016BT709FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P016ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P216BT709FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P216ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P216BT709FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P216ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuF709Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT2020ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuv2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT2020ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvu2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT2020ConstantsToRGB24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuv2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT2020ConstantsToBGR24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvu2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT2020ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuv2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT2020ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvu2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT2020ConstantsToRGB24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuv2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT2020ConstantsToBGR24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvu2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P010BT2020ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P010ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuv2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P010BT2020ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P010ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvu2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P210BT2020ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P210ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuv2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P210BT2020ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P210ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvu2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P012BT2020ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P012ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuv2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P012BT2020ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P012ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvu2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P212BT2020ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P212ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuv2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P212BT2020ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P212ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvu2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P016BT2020ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P016ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuv2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P016BT2020ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P016ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvu2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P216BT2020ConstantsToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P216ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuv2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P216BT2020ConstantsToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P216ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvu2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.2020</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT2020FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT2020FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT2020FullToRGB24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV12BT2020FullToBGR24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV12ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT2020FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT2020FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT2020FullToRGB24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NV21BT2020FullToBGR24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NV21ToRGB24Matrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P010BT2020FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P010ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P010BT2020FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P010ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P210BT2020FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P210ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P210BT2020FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P210ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P012BT2020FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P012ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P012BT2020FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P012ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P212BT2020FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P212ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P212BT2020FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P212ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P016BT2020FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P016ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P016BT2020FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P016ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P216BT2020FullToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P216ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYuvV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">P216BT2020FullToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">P216ToARGBMatrix</span>(src_y, src_stride_y, src_uv, src_stride_uv, dst_argb, dst_stride_argb, &amp;kYvuV2020Constants, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以看到上述定义的宏有点多，如果采用switch或者if的方式进行接口封装的话，那容易出现一层套一层的情况，且工作量巨大，因此我们可以根据输入的参数合成对应的函数名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*YUVPlanarToRGBXFunctionPtr)</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>;<span class="comment">// 定义函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*YUVPlanarAlphaToRGBXFunctionPtr)</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">uint8_t</span>* src_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> src_stride_a,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> attenuate)</span></span>;<span class="comment">// 定义函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*YUVSemiPlanarToRGBXFunctionPtr)</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint8_t</span>* src_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> src_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height)</span></span>;<span class="comment">// 定义函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">emYUVType</span>&#123;</span><br><span class="line">  I420,</span><br><span class="line">  I422,</span><br><span class="line">  I444,</span><br><span class="line">  I010,</span><br><span class="line">  I210,</span><br><span class="line">  I410,</span><br><span class="line">  NV12,</span><br><span class="line">  NV21,</span><br><span class="line">  P010,</span><br><span class="line">  P210,</span><br><span class="line">  P012,</span><br><span class="line">  P212,</span><br><span class="line">  P016,</span><br><span class="line">  P216</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">emYUVolorSpace</span>&#123;</span><br><span class="line">  BT601_Limited, </span><br><span class="line">  BT601_FULL,</span><br><span class="line">  BT709_Limited,</span><br><span class="line">  BT709_FULL,</span><br><span class="line">  BT2020_Limited,</span><br><span class="line">  BT2020_FULL</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">emRGBXType</span>&#123;</span><br><span class="line"></span><br><span class="line">  ARGB,     <span class="comment">// ARGB little endian (bgra in memory) </span></span><br><span class="line">  ABGR,     <span class="comment">// ABGR little endian (rgba in memory)</span></span><br><span class="line">  RGBA,     <span class="comment">// RGBA little endian (abgr in memory) </span></span><br><span class="line">  BGRA,     <span class="comment">// BGRA little endian (argb in memory) </span></span><br><span class="line">  RGB24,    <span class="comment">// RGB little endian (bgr in memory) </span></span><br><span class="line">  BGR24     <span class="comment">// RGB little endian (bgr in memory) </span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stYUVToRGBXKey</span> &#123;</span><br><span class="line">    emYUVType src_yuv_type;</span><br><span class="line">    emYUVolorSpace src_yuv_color_space;</span><br><span class="line">    emRGBXType dst_rgbx_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载&lt;运算符，用于在std::map中进行比较</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Key&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (src_yuv_type != other.src_yuv_type) &#123;</span><br><span class="line">            <span class="keyword">return</span> src_yuv_type &lt; other.src_yuv_type;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (src_yuv_color_space != other.src_yuv_color_space) &#123;</span><br><span class="line">            <span class="keyword">return</span> src_yuv_color_space &lt; other.src_yuv_color_space;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dst_rgbx_type &lt; other.dst_rgbx_type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> std::map&lt;stYUVToRGBXKey,YUVPlanarToRGBXFunctionPtr&gt;        YUVPlanarToRGBXFunctionMap; </span><br><span class="line"></span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT601_Limited,ARGB&#125;] = I420BT601ConstantsToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT601_Limited,ABGR&#125;] = I420BT601ConstantsToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT601_Limited,RGB24&#125;] = I420BT601ConstantsToRGB24;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT601_Limited,BGR24&#125;] = I420BT601ConstantsToBGR24;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT601_FULL,ARGB&#125;] = I420BT601FullToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT601_FULL,ABGR&#125;] = I420BT601FullToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT601_FULL,RGB24&#125;] = I420BT601FullToRGB24;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT601_FULL,BGR24&#125;] = I420BT601FullToBGR24;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT709_Limited,ARGB&#125;] = I420BT709ConstantsToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT709_Limited,ABGR&#125;] = I420BT709ConstantsToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT709_Limited,RGB24&#125;] = I420BT709ConstantsToRGB24;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT709_Limited,BGR24&#125;] = I420BT709ConstantsToBGR24;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT709_FULL,ARGB&#125;] = I420BT709FullToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT709_FULL,ABGR&#125;] = I420BT709FullToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT709_FULL,RGB24&#125;] = I420BT709FullToRGB24;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT709_FULL,BGR24&#125;] = I420BT709FullToBGR24;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT2020_Limited,ARGB&#125;] = I420BT2020ConstantsToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT2020_Limited,ABGR&#125;] = I420BT2020ConstantsToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT2020_Limited,RGB24&#125;] = I420BT2020ConstantsToRGB24;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT2020_Limited,BGR24&#125;] = I420BT2020ConstantsToBGR24;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT2020_FULL,ARGB&#125;] = I420BT2020FullToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT2020_FULL,ABGR&#125;] = I420BT2020FullToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT2020_FULL,RGB24&#125;] = I420BT2020FullToRGB24;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I420,BT2020_FULL,BGR24&#125;] = I420BT2020FullToBGR24;</span><br><span class="line"></span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I422,BT601_Limited,ARGB&#125;] = I422BT601ConstantsToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I422,BT601_Limited,ABGR&#125;] = I422BT601ConstantsToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I422,BT601_FULL,ARGB&#125;] = I422BT601FullToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I422,BT601_FULL,ABGR&#125;] = I422BT601FullToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I422,BT709_Limited,ARGB&#125;] = I422BT709ConstantsToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I422,BT709_Limited,ABGR&#125;] = I422BT709ConstantsToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I422,BT709_FULL,ARGB&#125;] = I422BT709FullToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I422,BT709_FULL,ABGR&#125;] = I422BT709FullToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I422,BT2020_Limited,ARGB&#125;] = I422BT2020ConstantsToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I422,BT2020_Limited,ABGR&#125;] = I422BT2020ConstantsToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I422,BT2020_FULL,ARGB&#125;] = I422BT2020FullToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I422,BT2020_FULL,ABGR&#125;] = I422BT2020FullToABGR;</span><br><span class="line"></span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I444,BT601_Limited,ARGB&#125;] = I444BT601ConstantsToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I444,BT601_Limited,ABGR&#125;] = I444BT601ConstantsToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I444,BT601_FULL,ARGB&#125;] = I444BT601FullToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I444,BT601_FULL,ABGR&#125;] = I444BT601FullToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I444,BT709_Limited,ARGB&#125;] = I444BT709ConstantsToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I444,BT709_Limited,ABGR&#125;] = I444BT709ConstantsToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I444,BT709_FULL,ARGB&#125;] = I444BT709FullToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I444,BT709_FULL,ABGR&#125;] = I444BT709FullToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I444,BT2020_Limited,ARGB&#125;] = I444BT2020ConstantsToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I444,BT2020_Limited,ABGR&#125;] = I444BT2020ConstantsToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I444,BT2020_FULL,ARGB&#125;] = I444BT2020FullToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I444,BT2020_FULL,ABGR&#125;] = I444BT2020FullToABGR;</span><br><span class="line"></span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I010,BT601_Limited,ARGB&#125;] = I010BT601ConstantsToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I010,BT601_Limited,ABGR&#125;] = I010BT601ConstantsToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I010,BT601_FULL,ARGB&#125;] = I010BT601FullToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I010,BT601_FULL,ABGR&#125;] = I010BT601FullToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I010,BT709_Limited,ARGB&#125;] = I010BT709ConstantsToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I010,BT709_Limited,ABGR&#125;] = I010BT709ConstantsToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I010,BT709_FULL,ARGB&#125;] = I010BT709FullToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I010,BT709_FULL,ABGR&#125;] = I010BT709FullToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I010,BT2020_Limited,ARGB&#125;] = I010BT2020ConstantsToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I010,BT2020_Limited,ABGR&#125;] = I010BT2020ConstantsToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I010,BT2020_FULL,ARGB&#125;] = I010BT2020FullToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I010,BT2020_FULL,ABGR&#125;] = I010BT2020FullToABGR;</span><br><span class="line"></span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I210,BT601_Limited,ARGB&#125;] = I210BT601ConstantsToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I210,BT601_Limited,ABGR&#125;] = I210BT601ConstantsToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I210,BT601_FULL,ARGB&#125;] = I210BT601FullToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I210,BT601_FULL,ABGR&#125;] = I210BT601FullToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I210,BT709_Limited,ARGB&#125;] = I210BT709ConstantsToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I210,BT709_Limited,ABGR&#125;] = I210BT709ConstantsToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I210,BT709_FULL,ARGB&#125;] = I210BT709FullToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I210,BT709_FULL,ABGR&#125;] = I210BT709FullToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I210,BT2020_Limited,ARGB&#125;] = I210BT2020ConstantsToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I210,BT2020_Limited,ABGR&#125;] = I210BT2020ConstantsToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I210,BT2020_FULL,ARGB&#125;] = I210BT2020FullToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I210,BT2020_FULL,ABGR&#125;] = I210BT2020FullToABGR;</span><br><span class="line"></span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I410,BT601_Limited,ARGB&#125;] = I410BT601ConstantsToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I410,BT601_Limited,ABGR&#125;] = I410BT601ConstantsToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I410,BT601_FULL,ARGB&#125;] = I410BT601FullToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I410,BT601_FULL,ABGR&#125;] = I410BT601FullToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I410,BT709_Limited,ARGB&#125;] = I410BT709ConstantsToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I410,BT709_Limited,ABGR&#125;] = I410BT709ConstantsToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I410,BT709_FULL,ARGB&#125;] = I410BT709FullToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I410,BT709_FULL,ABGR&#125;] = I410BT709FullToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I410,BT2020_Limited,ARGB&#125;] = I410BT2020ConstantsToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I410,BT2020_Limited,ABGR&#125;] = I410BT2020ConstantsToABGR;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I410,BT2020_FULL,ARGB&#125;] = I410BT2020FullToARGB;</span><br><span class="line">YUVPlanarToRGBXFunctionMap[&#123;I410,BT2020_FULL,ABGR&#125;] = I410BT2020FullToABGR;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> std::map&lt;stYUVToRGBXKey,YUVPlanarAlphaToRGBXFunctionPtr&gt;   YUVPlanarAlphaToRGBXFunctionMap;</span><br><span class="line"></span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I420,BT601_Limited,ARGB&#125;] = I420AlphaBT601ConstantsToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I420,BT601_Limited,ABGR&#125;] = I420AlphaBT601ConstantsToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I420,BT601_FULL,ARGB&#125;] = I420AlphaBT601FullToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I420,BT601_FULL,ABGR&#125;] = I420AlphaBT601FullToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I420,BT709_Limited,ARGB&#125;] = I420AlphaBT709ConstantsToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I420,BT709_Limited,ABGR&#125;] = I420AlphaBT709ConstantsToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I420,BT709_FULL,ARGB&#125;] = I420AlphaBT709FullToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I420,BT709_FULL,ABGR&#125;] = I420AlphaBT709FullToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I420,BT2020_Limited,ARGB&#125;] = I420AlphaBT2020ConstantsToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I420,BT2020_Limited,ABGR&#125;] = I420AlphaBT2020ConstantsToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I420,BT2020_FULL,ARGB&#125;] = I420AlphaBT2020FullToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I420,BT2020_FULL,ABGR&#125;] = I420AlphaBT2020FullToABGR;</span><br><span class="line"></span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I422,BT601_Limited,ARGB&#125;] = I422BT601ConstantsToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I422,BT601_Limited,ABGR&#125;] = I422BT601ConstantsToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I422,BT601_FULL,ARGB&#125;] = I422BT601FullToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I422,BT601_FULL,ABGR&#125;] = I422BT601FullToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I422,BT709_Limited,ARGB&#125;] = I422BT709ConstantsToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I422,BT709_Limited,ABGR&#125;] = I422BT709ConstantsToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I422,BT709_FULL,ARGB&#125;] = I422BT709FullToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I422,BT709_FULL,ABGR&#125;] = I422BT709FullToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I422,BT2020_Limited,ARGB&#125;] = I422BT2020ConstantsToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I422,BT2020_Limited,ABGR&#125;] = I422BT2020ConstantsToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I422,BT2020_FULL,ARGB&#125;] = I422BT2020FullToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I422,BT2020_FULL,ABGR&#125;] = I422BT2020FullToABGR;</span><br><span class="line"></span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I444,BT601_Limited,ARGB&#125;] = I444BT601ConstantsToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I444,BT601_Limited,ABGR&#125;] = I444BT601ConstantsToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I444,BT601_FULL,ARGB&#125;] = I444BT601FullToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I444,BT601_FULL,ABGR&#125;] = I444BT601FullToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I444,BT709_Limited,ARGB&#125;] = I444BT709ConstantsToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I444,BT709_Limited,ABGR&#125;] = I444BT709ConstantsToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I444,BT709_FULL,ARGB&#125;] = I444BT709FullToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I444,BT709_FULL,ABGR&#125;] = I444BT709FullToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I444,BT2020_Limited,ARGB&#125;] = I444BT2020ConstantsToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I444,BT2020_Limited,ABGR&#125;] = I444BT2020ConstantsToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I444,BT2020_FULL,ARGB&#125;] = I444BT2020FullToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I444,BT2020_FULL,ABGR&#125;] = I444BT2020FullToABGR;</span><br><span class="line"></span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I010,BT601_Limited,ARGB&#125;] = I010AlphaBT601ConstantsToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I010,BT601_Limited,ABGR&#125;] = I010AlphaBT601ConstantsToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I010,BT601_FULL,ARGB&#125;] = I010AlphaBT601FullToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I010,BT601_FULL,ABGR&#125;] = I010AlphaBT601FullToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I010,BT709_Limited,ARGB&#125;] = I010AlphaBT709ConstantsToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I010,BT709_Limited,ABGR&#125;] = I010AlphaBT709ConstantsToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I010,BT709_FULL,ARGB&#125;] = I010AlphaBT709FullToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I010,BT709_FULL,ABGR&#125;] = I010AlphaBT709FullToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I010,BT2020_Limited,ARGB&#125;] = I010AlphaBT2020ConstantsToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I010,BT2020_Limited,ABGR&#125;] = I010AlphaBT2020ConstantsToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I010,BT2020_FULL,ARGB&#125;] = I010AlphaBT2020FullToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I010,BT2020_FULL,ABGR&#125;] = I010AlphaBT2020FullToABGR;</span><br><span class="line"></span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I210,BT601_Limited,ARGB&#125;] = I210AlphaBT601ConstantsToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I210,BT601_Limited,ABGR&#125;] = I210AlphaBT601ConstantsToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I210,BT601_FULL,ARGB&#125;] = I210AlphaBT601FullToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I210,BT601_FULL,ABGR&#125;] = I210AlphaBT601FullToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I210,BT709_Limited,ARGB&#125;] = I210AlphaBT709ConstantsToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I210,BT709_Limited,ABGR&#125;] = I210AlphaBT709ConstantsToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I210,BT709_FULL,ARGB&#125;] = I210AlphaBT709FullToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I210,BT709_FULL,ABGR&#125;] = I210AlphaBT709FullToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I210,BT2020_Limited,ARGB&#125;] = I210AlphaBT2020ConstantsToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I210,BT2020_Limited,ABGR&#125;] = I210AlphaBT2020ConstantsToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I210,BT2020_FULL,ARGB&#125;] = I210AlphaBT2020FullToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I210,BT2020_FULL,ABGR&#125;] = I210AlphaBT2020FullToABGR;</span><br><span class="line"></span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I410,BT601_Limited,ARGB&#125;] = I410AlphaBT601ConstantsToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I410,BT601_Limited,ABGR&#125;] = I410AlphaBT601ConstantsToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I410,BT601_FULL,ARGB&#125;] = I410AlphaBT601FullToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I410,BT601_FULL,ABGR&#125;] = I410AlphaBT601FullToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I410,BT709_Limited,ARGB&#125;] = I410AlphaBT709ConstantsToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I410,BT709_Limited,ABGR&#125;] = I410AlphaBT709ConstantsToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I410,BT709_FULL,ARGB&#125;] = I410AlphaBT709FullToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I410,BT709_FULL,ABGR&#125;] = I410AlphaBT709FullToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I410,BT2020_Limited,ARGB&#125;] = I410AlphaBT2020ConstantsToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I410,BT2020_Limited,ABGR&#125;] = I410AlphaBT2020ConstantsToABGR;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I410,BT2020_FULL,ARGB&#125;] = I410AlphaBT2020FullToARGB;</span><br><span class="line">YUVPlanarAlphaToRGBXFunctionMap[&#123;I410,BT2020_FULL,ABGR&#125;] = I410AlphaBT2020FullToABGR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> std::map&lt;stYUVToRGBXKey,YUVSemiPlanarToRGBXFunctionPtr&gt;      YUVSemiPlanarToRGBXFunctionMap;     </span><br><span class="line"></span><br><span class="line"><span class="comment">//NV12</span></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT601_Limited,ARGB&#125;] = NV12BT601ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT601_Limited,ABGR&#125;] = NV12BT601ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT601_Limited,RGB24&#125;] = NV12BT601ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT601_Limited,BGR24&#125;] = NV12BT601ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT601_FULL,ARGB&#125;] = NV12BT601FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT601_FULL,ABGR&#125;] = NV12BT601FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT601_FULL,RGB24&#125;] = NV12BT601FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT601_FULL,BGR24&#125;] = NV12BT601FullToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT709_Limited,ARGB&#125;] = NV12BT709ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT709_Limited,ABGR&#125;] = NV12BT709ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT709_Limited,RGB24&#125;] = NV12BT709ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT709_Limited,BGR24&#125;] = NV12BT709ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT709_FULL,ARGB&#125;] = NV12BT709FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT709_FULL,ABGR&#125;] = NV12BT709FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT709_FULL,RGB24&#125;] = NV12BT709FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT709_FULL,BGR24&#125;] = NV12BT709FullToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT2020_Limited,ARGB&#125;] = NV12BT2020ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT2020_Limited,ABGR&#125;] = NV12BT2020ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT2020_Limited,RGB24&#125;] = NV12BT2020ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT2020_Limited,BGR24&#125;] = NV12BT2020ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT2020_FULL,ARGB&#125;] = NV12BT2020FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT2020_FULL,ABGR&#125;] = NV12BT2020FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT2020_FULL,RGB&#125;] = NV12BT2020FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV12,BT2020_FULL,BGR&#125;] = NV12BT2020FullToBGR24;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NV21</span></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT601_Limited,ARGB&#125;] = NV21BT601ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT601_Limited,ABGR&#125;] = NV21BT601ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT601_Limited,RGB24&#125;] = NV21BT601ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT601_Limited,BGR24&#125;] = NV21BT601ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT601_FULL,ARGB&#125;] = NV21BT601FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT601_FULL,ABGR&#125;] = NV21BT601FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT601_FULL,RGB24&#125;] = NV21BT601FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT601_FULL,BGR24&#125;] = NV21BT601FullToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT709_Limited,ARGB&#125;] = NV21BT709ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT709_Limited,ABGR&#125;] = NV21BT709ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT709_Limited,RGB24&#125;] = NV21BT709ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT709_Limited,BGR24&#125;] = NV21BT709ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT709_FULL,ARGB&#125;] = NV21BT709FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT709_FULL,ABGR&#125;] = NV21BT709FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT709_FULL,RGB24&#125;] = NV21BT709FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT709_FULL,BGR24&#125;] = NV21BT709FullToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT2020_Limited,ARGB&#125;] = NV21BT2020ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT2020_Limited,ABGR&#125;] = NV21BT2020ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT2020_Limited,RGB24&#125;] = NV21BT2020ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT2020_Limited,BGR24&#125;] = NV21BT2020ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT2020_FULL,ARGB&#125;] = NV21BT2020FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT2020_FULL,ABGR&#125;] = NV21BT2020FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT2020_FULL,RGB&#125;] = NV21BT2020FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;NV21,BT2020_FULL,BGR&#125;] = NV21BT2020FullToBGR24;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P010</span></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT601_Limited,ARGB&#125;] = P010BT601ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT601_Limited,ABGR&#125;] = P010BT601ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT601_Limited,RGB24&#125;] = P010BT601ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT601_Limited,BGR24&#125;] = P010BT601ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT601_FULL,ARGB&#125;] = P010BT601FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT601_FULL,ABGR&#125;] = P010BT601FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT601_FULL,RGB24&#125;] = P010BT601FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT601_FULL,BGR24&#125;] = P010BT601FullToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT709_Limited,ARGB&#125;] = P010BT709ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT709_Limited,ABGR&#125;] = P010BT709ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT709_Limited,RGB24&#125;] = P010BT709ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT709_Limited,BGR24&#125;] = P010BT709ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT709_FULL,ARGB&#125;] = P010BT709FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT709_FULL,ABGR&#125;] = P010BT709FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT709_FULL,RGB24&#125;] = P010BT709FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT709_FULL,BGR24&#125;] = P010BT709FullToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT2020_Limited,ARGB&#125;] = P010BT2020ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT2020_Limited,ABGR&#125;] = P010BT2020ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT2020_Limited,RGB24&#125;] = P010BT2020ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT2020_Limited,BGR24&#125;] = P010BT2020ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT2020_FULL,ARGB&#125;] = P010BT2020FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT2020_FULL,ABGR&#125;] = P010BT2020FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT2020_FULL,RGB&#125;] = P010BT2020FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P010,BT2020_FULL,BGR&#125;] = P010BT2020FullToBGR24;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P210</span></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT601_Limited,ARGB&#125;] = P210BT601ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT601_Limited,ABGR&#125;] = P210BT601ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT601_Limited,RGB24&#125;] = P210BT601ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT601_Limited,BGR24&#125;] = P210BT601ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT601_FULL,ARGB&#125;] = P210BT601FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT601_FULL,ABGR&#125;] = P210BT601FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT601_FULL,RGB24&#125;] = P210BT601FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT601_FULL,BGR24&#125;] = P210BT601FullToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT709_Limited,ARGB&#125;] = P210BT709ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT709_Limited,ABGR&#125;] = P210BT709ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT709_Limited,RGB24&#125;] = P210BT709ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT709_Limited,BGR24&#125;] = P210BT709ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT709_FULL,ARGB&#125;] = P210BT709FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT709_FULL,ABGR&#125;] = P210BT709FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT709_FULL,RGB24&#125;] = P210BT709FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT709_FULL,BGR24&#125;] = P210BT709FullToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT2020_Limited,ARGB&#125;] = P210BT2020ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT2020_Limited,ABGR&#125;] = P210BT2020ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT2020_Limited,RGB24&#125;] = P210BT2020ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT2020_Limited,BGR24&#125;] = P210BT2020ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT2020_FULL,ARGB&#125;] = P210BT2020FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT2020_FULL,ABGR&#125;] = P210BT2020FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT2020_FULL,RGB&#125;] = P210BT2020FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P210,BT2020_FULL,BGR&#125;] = P210BT2020FullToBGR24;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P012</span></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT601_Limited,ARGB&#125;] = P012BT601ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT601_Limited,ABGR&#125;] = P012BT601ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT601_Limited,RGB24&#125;] = P012BT601ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT601_Limited,BGR24&#125;] = P012BT601ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT601_FULL,ARGB&#125;] = P012BT601FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT601_FULL,ABGR&#125;] = P012BT601FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT601_FULL,RGB24&#125;] = P012BT601FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT601_FULL,BGR24&#125;] = P012BT601FullToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT709_Limited,ARGB&#125;] = P012BT709ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT709_Limited,ABGR&#125;] = P012BT709ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT709_Limited,RGB24&#125;] = P012BT709ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT709_Limited,BGR24&#125;] = P012BT709ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT709_FULL,ARGB&#125;] = P012BT709FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT709_FULL,ABGR&#125;] = P012BT709FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT709_FULL,RGB24&#125;] = P012BT709FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT709_FULL,BGR24&#125;] = P012BT709FullToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT2020_Limited,ARGB&#125;] = P012BT2020ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT2020_Limited,ABGR&#125;] = P012BT2020ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT2020_Limited,RGB24&#125;] = P012BT2020ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT2020_Limited,BGR24&#125;] = P012BT2020ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT2020_FULL,ARGB&#125;] = P012BT2020FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT2020_FULL,ABGR&#125;] = P012BT2020FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT2020_FULL,RGB&#125;] = P012BT2020FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P012,BT2020_FULL,BGR&#125;] = P012BT2020FullToBGR24;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P212</span></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT601_Limited,ARGB&#125;] = P212BT601ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT601_Limited,ABGR&#125;] = P212BT601ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT601_Limited,RGB24&#125;] = P212BT601ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT601_Limited,BGR24&#125;] = P212BT601ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT601_FULL,ARGB&#125;] = P212BT601FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT601_FULL,ABGR&#125;] = P212BT601FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT601_FULL,RGB24&#125;] = P212BT601FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT601_FULL,BGR24&#125;] = P212BT601FullToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT709_Limited,ARGB&#125;] = P212BT709ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT709_Limited,ABGR&#125;] = P212BT709ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT709_Limited,RGB24&#125;] = P212BT709ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT709_Limited,BGR24&#125;] = P212BT709ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT709_FULL,ARGB&#125;] = P212BT709FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT709_FULL,ABGR&#125;] = P212BT709FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT709_FULL,RGB24&#125;] = P212BT709FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT709_FULL,BGR24&#125;] = P212BT709FullToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT2020_Limited,ARGB&#125;] = P212BT2020ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT2020_Limited,ABGR&#125;] = P212BT2020ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT2020_Limited,RGB24&#125;] = P212BT2020ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT2020_Limited,BGR24&#125;] = P212BT2020ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT2020_FULL,ARGB&#125;] = P212BT2020FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT2020_FULL,ABGR&#125;] = P212BT2020FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT2020_FULL,RGB&#125;] = P212BT2020FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P212,BT2020_FULL,BGR&#125;] = P212BT2020FullToBGR24;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P016</span></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT601_Limited,ARGB&#125;] = P016BT601ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT601_Limited,ABGR&#125;] = P016BT601ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT601_Limited,RGB24&#125;] = P016BT601ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT601_Limited,BGR24&#125;] = P016BT601ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT601_FULL,ARGB&#125;] = P016BT601FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT601_FULL,ABGR&#125;] = P016BT601FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT601_FULL,RGB24&#125;] = P016BT601FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT601_FULL,BGR24&#125;] = P016BT601FullToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT709_Limited,ARGB&#125;] = P016BT709ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT709_Limited,ABGR&#125;] = P016BT709ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT709_Limited,RGB24&#125;] = P016BT709ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT709_Limited,BGR24&#125;] = P016BT709ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT709_FULL,ARGB&#125;] = P016BT709FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT709_FULL,ABGR&#125;] = P016BT709FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT709_FULL,RGB24&#125;] = P016BT709FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT709_FULL,BGR24&#125;] = P016BT709FullToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT2020_Limited,ARGB&#125;] = P016BT2020ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT2020_Limited,ABGR&#125;] = P016BT2020ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT2020_Limited,RGB24&#125;] = P016BT2020ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT2020_Limited,BGR24&#125;] = P016BT2020ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT2020_FULL,ARGB&#125;] = P016BT2020FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT2020_FULL,ABGR&#125;] = P016BT2020FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT2020_FULL,RGB&#125;] = P016BT2020FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P016,BT2020_FULL,BGR&#125;] = P016BT2020FullToBGR24;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P216</span></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT601_Limited,ARGB&#125;] = P216BT601ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT601_Limited,ABGR&#125;] = P216BT601ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT601_Limited,RGB24&#125;] = P216BT601ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT601_Limited,BGR24&#125;] = P216BT601ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT601_FULL,ARGB&#125;] = P216BT601FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT601_FULL,ABGR&#125;] = P216BT601FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT601_FULL,RGB24&#125;] = P216BT601FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT601_FULL,BGR24&#125;] = P216BT601FullToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT709_Limited,ARGB&#125;] = P216BT709ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT709_Limited,ABGR&#125;] = P216BT709ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT709_Limited,RGB24&#125;] = P216BT709ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT709_Limited,BGR24&#125;] = P216BT709ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT709_FULL,ARGB&#125;] = P216BT709FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT709_FULL,ABGR&#125;] = P216BT709FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT709_FULL,RGB24&#125;] = P216BT709FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT709_FULL,BGR24&#125;] = P216BT709FullToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT2020_Limited,ARGB&#125;] = P216BT2020ConstantsToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT2020_Limited,ABGR&#125;] = P216BT2020ConstantsToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT2020_Limited,RGB24&#125;] = P216BT2020ConstantsToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT2020_Limited,BGR24&#125;] = P216BT2020ConstantsToBGR24;</span><br><span class="line"></span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT2020_FULL,ARGB&#125;] = P216BT2020FullToARGB;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT2020_FULL,ABGR&#125;] = P216BT2020FullToABGR;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT2020_FULL,RGB&#125;] = P216BT2020FullToRGB24;</span><br><span class="line">YUVSemiPlanarToRGBXFunctionMap[&#123;P216,BT2020_FULL,BGR&#125;] = P216BT2020FullToBGR24;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着，我们通过输入参数的src_yuv_fourcc和dst_rgbx_fourcc来map中查找对应的函数</p><p>装成一个大的API:</p><p>&#96;&#96;&#96;C++</p><p>libyuv_API int __stdcall YUVAlphaToRGBX(const unsigned char* src_y_data, int src_y_stride,<br>  const unsigned char* src_u_data, int src_u_stride,<br>  const unsigned char* src_v_data, int src_v_stride,<br>  emYUVType src_yuv_type,emYUVolorSpace src_yuv_color_space,<br>  unsigned char* dst_rgbx_data, int dst_rgbx_stride,<br>  int image_width, int image_height,<br>  emRGBXType dst_rgbx_type,<br>  const unsigned char* src_alpha_data &#x3D; nullptr, int src_alpha_stride &#x3D; 0);</p><p>struct stUVInterlaceDataInfo{</p><p>  union{<br>    const unsigned char* uv_data;<br>    const unsigned char* vu_data;<br>  };</p><p>  union{<br>    int uv_stride;<br>    int vu_stride;<br>  };</p><p>};</p><p>struct stUVDataInfo{</p><p>  const unsigned char* u_data;<br>  int u_stride;<br>  const unsigned char* v_data;<br>  int v_stride;</p><p>};</p><p>struct stYUVDataInfo{</p><p>  const unsigned char* y_data;<br>  int y_stride;</p><p>  union</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>libyuv学习笔记之RGBX转YUV的接口封装</title>
      <link href="/2023/11/20/libyuv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BRGBX%E8%BD%ACYUV%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B0%81%E8%A3%85/"/>
      <url>/2023/11/20/libyuv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BRGBX%E8%BD%ACYUV%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="RGBXToYUV的转换"><a href="#RGBXToYUV的转换" class="headerlink" title="RGBXToYUV的转换"></a>RGBXToYUV的转换</h2><p>继续采用上一篇的YUVToRGBX的转换中定义的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">emYUVType</span>&#123;</span><br><span class="line">  I420,</span><br><span class="line">  I422,</span><br><span class="line">  I444,</span><br><span class="line">  I010,</span><br><span class="line">  I210,</span><br><span class="line">  I410,</span><br><span class="line">  NV12,</span><br><span class="line">  NV21,</span><br><span class="line">  P010,</span><br><span class="line">  P210,</span><br><span class="line">  P012,</span><br><span class="line">  P212,</span><br><span class="line">  P016,</span><br><span class="line">  P216</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">emYUVolorSpace</span>&#123;</span><br><span class="line">  BT601_Limited, </span><br><span class="line">  BT601_FULL,</span><br><span class="line">  BT709_Limited,</span><br><span class="line">  BT709_FULL,</span><br><span class="line">  BT2020_Limited,</span><br><span class="line">  BT2020_FULL</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">emRGBXType</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ARGB,     <span class="comment">// ARGB little endian (bgra in memory) </span></span><br><span class="line">  ABGR,     <span class="comment">// ABGR little endian (rgba in memory)</span></span><br><span class="line">  RGBA,     <span class="comment">// RGBA little endian (abgr in memory) </span></span><br><span class="line">  BGRA,     <span class="comment">// BGRA little endian (argb in memory) </span></span><br><span class="line">  RGB24,    <span class="comment">// RGB little endian (bgr in memory) </span></span><br><span class="line">  BGR24     <span class="comment">// RGB little endian (bgr in memory) </span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stUVInterlaceDataInfo</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">union</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* uv_data;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* vu_data;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">union</span>&#123;</span><br><span class="line">    <span class="type">int</span> uv_stride;</span><br><span class="line">    <span class="type">int</span> vu_stride;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stUVDataInfo</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* u_data;</span><br><span class="line">  <span class="type">int</span> u_stride;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* v_data;</span><br><span class="line">  <span class="type">int</span> v_stride;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stYUVDataInfo</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* y_data;</span><br><span class="line">  <span class="type">int</span> y_stride;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">union</span>&#123;&#123;</span><br><span class="line">    stUVInterlaceDataInfo uv_interlace;</span><br><span class="line">    stUVDataInfo uv;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* alpha_data;</span><br><span class="line">  <span class="type">int</span> alpha_stride;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stRGBXToYUVKey</span> &#123;</span><br><span class="line"></span><br><span class="line">    emRGBXType src_rgbx_type;</span><br><span class="line">    emYUVType dst_yuv_type;</span><br><span class="line">    emYUVolorSpace dst_yuv_color_space;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载&lt;运算符，用于在std::map中进行比较</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Key&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (src_rgbx_type != other.src_rgbx_type) &#123;</span><br><span class="line">            <span class="keyword">return</span> src_rgbx_type &lt; other.src_rgbx_type;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dst_yuv_color_space != other.dst_yuv_color_space) &#123;</span><br><span class="line">            <span class="keyword">return</span> dst_yuv_color_space &lt; other.dst_yuv_color_space;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dst_yuv_type &lt; other.dst_yuv_type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*RGBXToYUVPlanarFunctionPtr)</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*RGBXToYUVSemiPlanarFunctionPtr)</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> std::map&lt;stRGBXToYUVKey,RGBXToYUVPlanarFunctionPtr&gt;              RGBXToYUVPlanarFunctionMap; </span><br><span class="line"></span><br><span class="line"><span class="comment">//I420</span></span><br><span class="line">RGBXToYUVPlanarFunctionMap[&#123;ARGB,I420,BT601_Limited&#125;] = ARGBToI420BT601Constants;</span><br><span class="line">RGBXToYUVPlanarFunctionMap[&#123;ABGR,I420,BT601_Limited&#125;] = ABGRToI420BT601Constants;</span><br><span class="line">RGBXToYUVPlanarFunctionMap[&#123;RGBA,I420,BT601_Limited&#125;] = RGBAToI420BT601Constants;</span><br><span class="line">RGBXToYUVPlanarFunctionMap[&#123;BGRA,I420,BT601_Limited&#125;] = BGRAToI420BT601Constants;</span><br><span class="line">RGBXToYUVPlanarFunctionMap[&#123;RGB24,I420,BT601_Limited&#125;] = RGB24ToI420BT601Constants;</span><br><span class="line"></span><br><span class="line">RGBXToYUVPlanarFunctionMap[&#123;ARGB,I420,BT601_FULL&#125;] = ARGBToI420BT601Full;</span><br><span class="line">RGBXToYUVPlanarFunctionMap[&#123;RGB24,I420,BT601_FULL&#125;] = RGB24ToI420BT601Full;</span><br><span class="line"></span><br><span class="line"><span class="comment">//I422</span></span><br><span class="line">RGBXToYUVPlanarFunctionMap[&#123;ARGB,I422,BT601_Limited&#125;] = ARGBToI422BT601Constants;</span><br><span class="line"></span><br><span class="line">RGBXToYUVPlanarFunctionMap[&#123;ARGB,I422,BT601_FULL&#125;] = ARGBToI422BT601Full;</span><br><span class="line"></span><br><span class="line"><span class="comment">//I444</span></span><br><span class="line">RGBXToYUVPlanarFunctionMap[&#123;ARGB,I444,BT601_Limited&#125;] = ARGBToI444BT601Constants;</span><br><span class="line"></span><br><span class="line"><span class="comment">//I400</span></span><br><span class="line">RGBXToYUVPlanarFunctionMap[&#123;ARGB,I400,BT601_Limited&#125;] = ARGBToI400BT601Constants;</span><br><span class="line">RGBXToYUVPlanarFunctionMap[&#123;ABGR,I400,BT601_Limited&#125;] = ABGRToI400BT601Constants;</span><br><span class="line"></span><br><span class="line">RGBXToYUVPlanarFunctionMap[&#123;ARGB,I400,BT601_FULL&#125;] = ARGBToI400BT601Full;</span><br><span class="line">RGBXToYUVPlanarFunctionMap[&#123;RGBA,I400,BT601_FULL&#125;] = RGBAToI400BT601Full;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> std::map&lt;stRGBXToYUVKey,RGBXToYUVSemiPlanarFunctionPtr&gt;          RGBXToYUVSemiPlanarFunctionMap; </span><br><span class="line"></span><br><span class="line"><span class="comment">//NV12</span></span><br><span class="line">RGBXToYUVSemiPlanarFunctionMap[&#123;ARGB,NV12,BT601_Limited&#125;] = ARGBToNV12BT601Constants;</span><br><span class="line">RGBXToYUVSemiPlanarFunctionMap[&#123;ABGR,NV12,BT601_Limited&#125;] = ABGRToNV12BT601Constants;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NV21</span></span><br><span class="line">RGBXToYUVSemiPlanarFunctionMap[&#123;ARGB,NV21,BT601_Limited&#125;] = ARGBToNV21BT601Constants;</span><br><span class="line">RGBXToYUVSemiPlanarFunctionMap[&#123;ABGR,NV21,BT601_Limited&#125;] = ABGRToNV21BT601Constants;</span><br></pre></td></tr></table></figure><p>YUV420相关转换的API封装如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.601</span></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ARGBToI420BT601Constants</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ARGBToI420</span>(src_argb,src_stride_argb,dst_y,dst_stride_y,dst_u,dst_stride_u,dst_v,dst_stride_v,width,height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ABGRToI420BT601Constants</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ABGRToI420</span>(src_abgr,src_stride_abgr,dst_y,dst_stride_y,dst_u,dst_stride_u,dst_v,dst_stride_v,width,height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RGBAToI420BT601Constants</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_rgba,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_rgba,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">RGBAToI420</span>(src_rgba,src_stride_rgba,dst_y,dst_stride_y,dst_u,dst_stride_u,dst_v,dst_stride_v,width,height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BGRAToI420BT601Constants</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_bgra,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_bgra,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">BGRAToI420</span>(src_bgra,src_stride_bgra,dst_y,dst_stride_y,dst_u,dst_stride_u,dst_v,dst_stride_v,width,height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RGB24ToI420BT601Constants</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">RGB24ToI420</span>(src_rgb24,src_stride_rgb24,dst_y,dst_stride_y,dst_u,dst_stride_u,dst_v,dst_stride_v,width,height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ARGBToI420BT601Full</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ARGBToJ420</span>(src_argb,src_stride_argb,dst_y,dst_stride_y,dst_u,dst_stride_u,dst_v,dst_stride_v,width,height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RGB24ToI420BT601Full</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">RGB24ToJ420</span>(src_rgb24,src_stride_rgb24,dst_y,dst_stride_y,dst_u,dst_stride_u,dst_v,dst_stride_v,width,height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>YUV422相关转换的API封装如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.601</span></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ARGBToI422BT601Constants</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ARGBToI422</span>(src_argb,src_stride_argb,dst_y,dst_stride_y,dst_u,dst_stride_u,dst_v,dst_stride_v,width,height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ARGBToI422BT601Full</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ARGBToJ422</span>(src_argb,src_stride_argb,dst_y,dst_stride_y,dst_u,dst_stride_u,dst_v,dst_stride_v,width,height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>YUV444相关转换的API封装如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ARGBToI444BT601Constants</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ARGBToI444</span>(src_argb,src_stride_argb,dst_y,dst_stride_y,dst_u,dst_stride_u,dst_v,dst_stride_v,width,height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>YUV400相关转换的API封装如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for bt.601</span></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ARGBToI400BT601Constants</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ARGBToI400</span>(src_argb,src_stride_argb,dst_y,dst_stride_y,dst_u,dst_stride_u,dst_v,dst_stride_v,width,height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ABGRToI400BT601Constants</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ABGRToI400</span>(src_abgr,src_stride_abgr,dst_y,dst_stride_y,dst_u,dst_stride_u,dst_v,dst_stride_v,width,height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide matrix wrappers for full range bt.601</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ARGBToI400BT601Full</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ARGBToJ400</span>(src_argb,src_stride_argb,dst_y,dst_stride_y,dst_u,dst_stride_u,dst_v,dst_stride_v,width,height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RGBAToI400BT601Full</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_u,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_v,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">RGBAToJ400</span>(src_argb,src_stride_argb,dst_y,dst_stride_y,dst_u,dst_stride_u,dst_v,dst_stride_v,width,height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>NV12相关转换的API封装如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ARGBToNV12BT601Constants</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ARGBToNV12</span>(src_argb,src_stride_argb, dst_y,dst_stride_y,dst_uv,dst_stride_uv,width,height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ABGRToNV12BT601Constants</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_uv,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ABGRToNV12</span>(src_abgr,src_stride_abgr, dst_y,dst_stride_y,dst_uv,dst_stride_uv,width,height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>NV21相关转换的API封装如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ARGBToNV21BT601Constants</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_vu,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_vu,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ARGBToNV21</span>(src_argb,src_stride_argb, dst_y,dst_stride_y,dst_vu,dst_stride_vu,width,height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIBYvu_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ABGRToNV21BT601Constants</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_y,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_vu,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_vu,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ABGRToNV21</span>(src_abgr,src_stride_abgr, dst_y,dst_stride_y,dst_vu,dst_stride_vu,width,height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>头文件封装：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">libyuv_API <span class="type">int</span> __stdcall <span class="title">RGBXToYUV</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* src_rgbx_data, <span class="type">int</span> src_rgbx_stride,emRGBXType src_rgbx_type,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* dst_y_data, <span class="type">int</span> dst_y_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* dst_u_data, <span class="type">int</span> dst_u_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* dst_v_data, <span class="type">int</span> dst_v_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">    emYUVType dst_yuv_type,emYUVolorSpace dst_yuv_color_space,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> image_width, <span class="type">int</span> image_height)</span></span>;</span><br></pre></td></tr></table></figure><p>实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">libyuv_API <span class="type">int</span> __stdcall <span class="title">RGBXToYUV</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* src_rgbx_data, <span class="type">int</span> src_rgbx_stride,emRGBXType src_rgbx_type,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* dst_y_data, <span class="type">int</span> dst_y_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* dst_u_data, <span class="type">int</span> dst_u_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* dst_v_data, <span class="type">int</span> dst_v_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">    emYUVType dst_yuv_type,emYUVolorSpace dst_yuv_color_space,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> image_width, <span class="type">int</span> image_height)</span></span>&#123;</span><br><span class="line">                </span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        stRGBXToYUVKey key;</span><br><span class="line">        key.src_rgbx_type = src_rgbx_type;</span><br><span class="line">        key.dst_yuv_type = dst_yuv_type;</span><br><span class="line">        key.dst_yuv_color_space = dst_yuv_color_space;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it_RGBXToYUVPlanarFunctionMap = RGBXToYUVPlanarFunctionMap.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it_RGBXToYUVPlanarFunctionMap != RGBXToYUVPlanarFunctionMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> (it_RGBXToYUVPlanarFunctionMap-&gt;second)(src_rgbx_data,src_rgbx_stride,</span><br><span class="line">            dst_yuv_info.y_data,dst_yuv_info.y_stride,dst_yuv_info.uv.u_data,dst_yuv_info.uv.u_stride,dst_yuv_info.uv.v_data,dst_yuv_info.uv.v_stride,</span><br><span class="line">            image_width,image_height);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it_RGBXToYUVSemiPlanarFunctionMap = RGBXToYUVSemiPlanarFunctionMap.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it_RGBXToYUVSemiPlanarFunctionMap != RGBXToYUVSemiPlanarFunctionMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> (it_RGBXToYUVSemiPlanarFunctionMap-&gt;second)(src_rgbx_data,src_rgbx_stride,</span><br><span class="line">            dst_yuv_info.y_data,dst_yuv_info.y_stride,dst_yuv_info.uv_interlace.uv_data,dst_yuv_info.uv_interlace.uv_stride,</span><br><span class="line">            image_width,image_height);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//log err:Direct conversion between this format is not supported. Please convert the output format to I420 or NV12 first.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CUDA常用的脚本之颜色空间转换</title>
      <link href="/2023/11/15/CUDA%E5%B8%B8%E7%94%A8%E7%9A%84%E8%84%9A%E6%9C%AC%E4%B9%8B%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2/"/>
      <url>/2023/11/15/CUDA%E5%B8%B8%E7%94%A8%E7%9A%84%E8%84%9A%E6%9C%AC%E4%B9%8B%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>本篇博客的主要目的是讲述一下如何用cuda来实现常用的颜色空间的转换，目的是为搭建一套cuda管线的转换链路做前期的准备</p><p>颜色空间转换方面的脚本，使用nvidia的官方样例就基本够用了，只需要补充一下BGRA转(RGBA RGB BGR)的转换脚本就搭建出一套BGRA的CUDA管线</p><h1 id="BGRAX"><a href="#BGRAX" class="headerlink" title="BGRAX"></a>BGRAX</h1><p>&lt;cudaMath.h&gt;这个库是我们在写cuda算子的时候需要包含的一个头文件，一般来说，我们在开始写算子前，都会先看这个库里面有没有现成函数</p><p>PS:该<a href="https://github.com/vtsynergy/CU2CL">链接</a>是CUDA到OpenCL的一套转换器，可以用这个转换器将以下的所有CUDA脚本全部转成OpenCL脚本</p><p>对于nv12以及p016等yuv格式的转换，参考NvidiaCodecSDK提供的转换脚本即可，以下脚本更多情况是适配部分渲染算法或ai算法对输入源的颜色空间空间要求</p><p>PS:官方给的ColorSpace.cu脚本中只有BGRA64转P016,如果想Rgba32ToNv12如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rgba32ToNv12</span><span class="params">(<span class="type">uint8_t</span> *dpRgba, <span class="type">int</span> nRgbaPitch, <span class="type">uint8_t</span> *dpNv12, <span class="type">int</span> nNv12Pitch, <span class="type">int</span> nWidth, <span class="type">int</span> nHeight, <span class="type">int</span> iMatrix)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SetMatRgb2Yuv</span>(iMatrix);</span><br><span class="line">    RgbToYuvKernel&lt;uchar4, RGBA32, uchar2&gt;</span><br><span class="line">        &lt;&lt;&lt;<span class="built_in">dim3</span>((nWidth + <span class="number">31</span>) / <span class="number">32</span> / <span class="number">2</span>, (nHeight + <span class="number">1</span>) / <span class="number">2</span> / <span class="number">2</span>), <span class="built_in">dim3</span>(<span class="number">32</span>, <span class="number">2</span>)&gt;&gt;&gt;</span><br><span class="line">        (dpRgba, nRgbaPitch, dpNv12, nNv12Pitch, nWidth, nHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关头文件和用到的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cudaMath.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> __device__ __host__ <span class="type">float</span> <span class="title">step</span><span class="params">(<span class="type">float</span> a , <span class="type">float</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> __device__ __host__ uchar4 <span class="title">GetRGBXPixelClamped</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* input_data, <span class="type">unsigned</span> <span class="type">int</span> x,<span class="type">unsigned</span> <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">int</span> input_width, <span class="type">unsigned</span> <span class="type">int</span> input_height, <span class="type">unsigned</span> <span class="type">int</span> input_stride, <span class="type">unsigned</span> <span class="type">int</span> channel_nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> width = <span class="built_in">clamp</span>(x, <span class="number">0</span>, input_width - <span class="number">1</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> height = <span class="built_in">clamp</span>(y, <span class="number">0</span>, input_height - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (channel_nums == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        uchar4* src_data = (uchar4*)(input_data + height * input_stride + width * channel_nums);</span><br><span class="line">        <span class="keyword">return</span> src_data[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        uchar3* src_data = (uchar3*)(input_data + height * input_stride + width * channel_nums);</span><br><span class="line">        <span class="keyword">return</span> uchar4&#123; src_data[<span class="number">0</span>].x, src_data[<span class="number">0</span>].y, src_data[<span class="number">0</span>].z, <span class="number">255</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> __device__ __host__ float4 <span class="title">RGBXSampleBilinear</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* input_data, <span class="type">float</span> u, <span class="type">float</span> v, <span class="type">unsigned</span> <span class="type">int</span> input_width, <span class="type">unsigned</span> <span class="type">int</span> input_height, <span class="type">unsigned</span> <span class="type">int</span> input_stride, <span class="type">unsigned</span> <span class="type">int</span> channel_nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> x = u * (<span class="type">float</span>)input_width - <span class="number">0.5f</span>;</span><br><span class="line">    <span class="type">float</span> x_fract = x - <span class="built_in">floor</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> y = v * (<span class="type">float</span>)input_height - <span class="number">0.5f</span>;</span><br><span class="line">    <span class="type">float</span> y_fract = y - <span class="built_in">floor</span>(y);</span><br><span class="line"></span><br><span class="line">    uchar4 pixel_00 = <span class="built_in">GetRGBXPixelClamped</span>(input_data, (<span class="type">unsigned</span> <span class="type">int</span>)x + <span class="number">0</span>, (<span class="type">unsigned</span> <span class="type">int</span>)y + <span class="number">0</span>, input_width, input_height, input_stride, channel_nums);</span><br><span class="line">    uchar4 pixel_10 = <span class="built_in">GetRGBXPixelClamped</span>(input_data, (<span class="type">unsigned</span> <span class="type">int</span>)x + <span class="number">1</span>, (<span class="type">unsigned</span> <span class="type">int</span>)y + <span class="number">0</span>, input_width, input_height, input_stride, channel_nums);</span><br><span class="line">    uchar4 pixel_01 = <span class="built_in">GetRGBXPixelClamped</span>(input_data, (<span class="type">unsigned</span> <span class="type">int</span>)x + <span class="number">0</span>, (<span class="type">unsigned</span> <span class="type">int</span>)y + <span class="number">1</span>, input_width, input_height, input_stride, channel_nums);</span><br><span class="line">    uchar4 pixel_11 = <span class="built_in">GetRGBXPixelClamped</span>(input_data, (<span class="type">unsigned</span> <span class="type">int</span>)x + <span class="number">1</span>, (<span class="type">unsigned</span> <span class="type">int</span>)y + <span class="number">1</span>, input_width, input_height, input_stride, channel_nums);</span><br><span class="line"></span><br><span class="line">    float4 color_0 = <span class="built_in">lerp</span>(<span class="built_in">make_float4</span>(pixel_00), <span class="built_in">make_float4</span>(pixel_10), x_fract);</span><br><span class="line">    float4 color_1 = <span class="built_in">lerp</span>(<span class="built_in">make_float4</span>(pixel_01), <span class="built_in">make_float4</span>(pixel_11), x_fract);</span><br><span class="line">    float4 value = <span class="built_in">lerp</span>(color_0, color_1, y_fract);</span><br><span class="line">    float4 ret = <span class="built_in">clamp</span>(value, <span class="number">0.0f</span>, <span class="number">255.0f</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于RGBA转RGB或者是BGRA转BGR的cuda脚本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">RGBA2RGB</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* rgba, <span class="type">unsigned</span> <span class="type">int</span> rgba_stride, <span class="type">unsigned</span> <span class="type">char</span>* rgb,<span class="type">unsigned</span> <span class="type">int</span> rgb_stride, <span class="type">unsigned</span> <span class="type">int</span> rgba_width,<span class="type">unsigned</span> <span class="type">int</span> rgba_height, <span class="type">unsigned</span> <span class="type">int</span> rgb_width,<span class="type">unsigned</span> <span class="type">int</span> rgb_height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> y = blockIdx.y * blockDim.y + threadIdx.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; rgba_width &amp;&amp; y &lt; rgba_height)</span><br><span class="line">    &#123;</span><br><span class="line">        uchar3* rgb_data = (uchar3*)(rgb + y * rgb_stride + <span class="number">3</span> * x);</span><br><span class="line">        <span class="type">float</span> pos_x = (<span class="type">float</span>)x / (<span class="type">float</span>)rgb_width;</span><br><span class="line">        <span class="type">float</span> pos_y = (<span class="type">float</span>)y / (<span class="type">float</span>)rgb_height;</span><br><span class="line">        float4 ovlColor = <span class="built_in">RGBXSampleBilinear</span>(rgba, pos_x, pos_y, rgba_width, rgba_height, rgba_stride, <span class="number">4</span>);</span><br><span class="line">        rgb_data[<span class="number">0</span>] = <span class="built_in">make_uchar3</span>(ovlColor.x, ovlColor.y, ovlColor.z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">BGRA2BGR</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* bgra, <span class="type">unsigned</span> <span class="type">int</span> bgra_stride, <span class="type">unsigned</span> <span class="type">char</span>* bgr,<span class="type">unsigned</span> <span class="type">int</span> bgr_stride, <span class="type">unsigned</span> <span class="type">int</span> bgra_width,<span class="type">unsigned</span> <span class="type">int</span> bgra_height, <span class="type">unsigned</span> <span class="type">int</span> bgr_width,<span class="type">unsigned</span> <span class="type">int</span> bgr_height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">RGBA2RGB</span>(bgra,bgra_stride,bgr,bgr_stride,bgra_width,bgra_height,bgr_width,bgr_height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于RGBA转BGR或者BGRA转RGB：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">RGBA2BGR</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* rgba, <span class="type">unsigned</span> <span class="type">int</span> rgba_stride, <span class="type">unsigned</span> <span class="type">char</span>* bgr, <span class="type">unsigned</span> <span class="type">int</span> bgr_stride, <span class="type">int</span> rgba_width, <span class="type">int</span> rgba_height, <span class="type">int</span> bgr_width, <span class="type">int</span> bgr_height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> y = blockIdx.y * blockDim.y + threadIdx.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; rgba_width &amp;&amp; y &lt; rgba_height)</span><br><span class="line">    &#123;</span><br><span class="line">        uchar3* bgr_data = (uchar3*)(bgr + y * bgr_stride + <span class="number">3</span> * x);</span><br><span class="line">        <span class="type">float</span> pos_x = (<span class="type">float</span>)x / (<span class="type">float</span>)bgr_width;</span><br><span class="line">        <span class="type">float</span> pos_y = (<span class="type">float</span>)y / (<span class="type">float</span>)bgr_height;</span><br><span class="line">        float4 ovlColor = <span class="built_in">RGBXSampleBilinear</span>(rgba, pos_x, pos_y, rgba_width, rgba_height, rgba_stride, <span class="number">4</span>);</span><br><span class="line">        bgr_data[<span class="number">0</span>] = <span class="built_in">make_uchar3</span>(ovlColor.z, ovlColor.y, ovlColor.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">BGRA2RGB</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* bgra, <span class="type">int</span> bgra_stride, <span class="type">unsigned</span> <span class="type">char</span>* rgb, <span class="type">unsigned</span> <span class="type">int</span> rgb_stride, <span class="type">int</span> bgra_width, <span class="type">int</span> bgra_height, <span class="type">int</span> rgb_width, <span class="type">int</span> rgb_height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">RGBA2BGR</span>(bgra,bgra_stride,rgb,rgb_stride,bgra_width,bgra_height,rgb_width,rgb_height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于RGBA转BGRA或者是BGRA转RGBA：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">RGBA2BGRA</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* rgba, <span class="type">unsigned</span> <span class="type">int</span> rgba_stride, <span class="type">unsigned</span> <span class="type">char</span>* bgra, <span class="type">unsigned</span> <span class="type">int</span> bgra_stride, <span class="type">unsigned</span> <span class="type">int</span> rgba_width,  <span class="type">unsigned</span> <span class="type">int</span> rgba_height, <span class="type">unsigned</span> <span class="type">int</span> bgra_width,<span class="type">unsigned</span> <span class="type">int</span> bgra_height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> y = blockIdx.y * blockDim.y + threadIdx.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; rgba_width &amp;&amp; y &lt; rgba_height)</span><br><span class="line">    &#123;</span><br><span class="line">        uchar4* bgra_data = (uchar4*)(bgra + y * bgra_stride + <span class="number">4</span> * x);</span><br><span class="line">        <span class="type">float</span> pos_x = (<span class="type">float</span>)x / (<span class="type">float</span>)bgra_width;</span><br><span class="line">        <span class="type">float</span> pos_y = (<span class="type">float</span>)y / (<span class="type">float</span>)rgba_height;</span><br><span class="line">        float4 ovlColor = <span class="built_in">RGBXSampleBilinear</span>(rgba, pos_x, pos_y, rgba_width, rgba_height, rgba_stride, <span class="number">4</span>);</span><br><span class="line">        bgra_data[<span class="number">0</span>] = <span class="built_in">make_uchar4</span>(ovlColor.z, ovlColor.y, ovlColor.x, ovlColor.w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">BGRA2RGBA</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* bgra, <span class="type">unsigned</span> <span class="type">int</span> bgra_stride, <span class="type">unsigned</span> <span class="type">char</span>* rgba, <span class="type">unsigned</span> <span class="type">int</span> rgba_stride, <span class="type">unsigned</span> <span class="type">int</span> bgra_width,<span class="type">unsigned</span> <span class="type">int</span> bgra_height, <span class="type">unsigned</span> <span class="type">int</span> rgba_width,  <span class="type">unsigned</span> <span class="type">int</span> rgba_height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">RGBA2BGRA</span>(bgra,bgra_stride,rgba,rgba_stride,bgra_width,bgra_height,rgba_width,rgba_height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于RGB转RGBA或者是BGR转BGRA：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">RGB2RGBA</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* rgb, <span class="type">unsigned</span> <span class="type">int</span> rgb_stride, <span class="type">unsigned</span> <span class="type">char</span>* rgba, <span class="type">unsigned</span> <span class="type">int</span> rgba_stride, <span class="type">unsigned</span> <span class="type">int</span> rgb_width, <span class="type">unsigned</span> <span class="type">int</span> rgb_height, <span class="type">unsigned</span> <span class="type">int</span> rgba_width, <span class="type">unsigned</span> <span class="type">int</span> rgba_height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> y = blockIdx.y * blockDim.y + threadIdx.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; rgb_width &amp;&amp; y &lt; rgb_height)</span><br><span class="line">    &#123;</span><br><span class="line">        uchar4* rgba_data = (uchar4*)(rgba + y * rgba_stride + <span class="number">4</span> * x);</span><br><span class="line">        <span class="type">float</span> pos_x = (<span class="type">float</span>)x / (<span class="type">float</span>)rgba_width;</span><br><span class="line">        <span class="type">float</span> pos_y = (<span class="type">float</span>)y / (<span class="type">float</span>)rgba_height;</span><br><span class="line">        float4 ovlColor = <span class="built_in">RGBXSampleBilinear</span>(rgb, pos_x, pos_y, rgb_width, rgb_height, rgb_stride, <span class="number">3</span>);</span><br><span class="line">        rgba_data[<span class="number">0</span>] = <span class="built_in">make_uchar4</span>(ovlColor.x, ovlColor.y, ovlColor.z, <span class="number">255</span>);<span class="comment">//alpha = 255</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">BGR2BGRA</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* bgr, <span class="type">unsigned</span> <span class="type">int</span> bgr_stride, <span class="type">unsigned</span> <span class="type">char</span>* bgra, <span class="type">unsigned</span> <span class="type">int</span> bgra_stride, <span class="type">unsigned</span> <span class="type">int</span> bgr_width, <span class="type">unsigned</span> <span class="type">int</span> bgr_height, <span class="type">unsigned</span> <span class="type">int</span> bgra_width, <span class="type">unsigned</span> <span class="type">int</span> bgra_height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">RGB2RGBA</span>(bgr,bgr_stride,bgra,bgra_stride,bgr_width,bgr_height,bgra_width,bgra_height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于RGB转BGRA或者是BGR转RGBA：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">RGB2BGRA</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* rgb, <span class="type">unsigned</span> <span class="type">int</span> rgb_stride, <span class="type">unsigned</span> <span class="type">char</span>* bgra,<span class="type">unsigned</span> <span class="type">int</span> bgra_stride, <span class="type">unsigned</span> <span class="type">int</span> rgb_width, <span class="type">unsigned</span> <span class="type">int</span> rgb_height, <span class="type">unsigned</span> <span class="type">int</span> bgra_width, <span class="type">unsigned</span> <span class="type">int</span> bgra_height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> y = blockIdx.y * blockDim.y + threadIdx.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; rgb_width &amp;&amp; y &lt; rgb_height)</span><br><span class="line">    &#123;</span><br><span class="line">        uchar4* bgra_data = (uchar4*)(bgra + y * bgra_stride + <span class="number">4</span> * x);</span><br><span class="line">        <span class="type">float</span> pos_x = (<span class="type">float</span>)x / (<span class="type">float</span>)bgra_width;</span><br><span class="line">        <span class="type">float</span> pos_y = (<span class="type">float</span>)y / (<span class="type">float</span>)bgra_height;</span><br><span class="line">        float4 ovlColor = <span class="built_in">RGBXSampleBilinear</span>(rgb, pos_x, pos_y, rgb_width, rgb_height, rgb_stride, <span class="number">3</span>);</span><br><span class="line">        bgra_data[<span class="number">0</span>] = <span class="built_in">make_uchar4</span>(ovlColor.z, ovlColor.y, ovlColor.x, <span class="number">255</span>);<span class="comment">//alpha = 255</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">BGR2RGBA</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* bgr, <span class="type">unsigned</span> <span class="type">int</span> bgr_stride, <span class="type">unsigned</span> <span class="type">char</span>* rgba,<span class="type">unsigned</span> <span class="type">int</span> rgba_stride, <span class="type">unsigned</span> <span class="type">int</span> bgr_width, <span class="type">unsigned</span> <span class="type">int</span> bgr_height, <span class="type">unsigned</span> <span class="type">int</span> rgba_width, <span class="type">unsigned</span> <span class="type">int</span> rgba_height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">RGB2BGRA</span>(bgr,bgr_stride,rgba,rgba_stride,bgr_width,bgr_height,rgba_width,rgba_height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS:block和grid的设置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dim3 <span class="title">block</span><span class="params">(<span class="number">32</span>, <span class="number">16</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">dim3 <span class="title">grid</span><span class="params">((width + (block.x - <span class="number">1</span>)) / (block.x), (height + (block.y - <span class="number">1</span>)) / block.y, <span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>libyuv学习笔记之RGBX之间转换的接口封装</title>
      <link href="/2023/11/15/libyuv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BRGBX%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B0%81%E8%A3%85/"/>
      <url>/2023/11/15/libyuv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BRGBX%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>对于RGBX的支持,在正常的使用场景下，一般是支持以下几种：RGB24,BGR24,RGBA32,BGRA32这四种即可</p><p>libyuv提供的相关API接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy ARGB to ARGB.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARGBToARGB ARGBCopy</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ARGBCopy</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">int</span> src_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert ARGB To BGRA.</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ARGBToBGRA</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_bgra,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_bgra,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert ARGB To ABGR.</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ARGBToABGR</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert ARGB To RGBA.</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ARGBToRGBA</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_rgba,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_rgba,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert ARGB To RGB24.</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ARGBToRGB24</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> src_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">uint8_t</span>* dst_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> dst_stride_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BGRA little endian (argb in memory) to ARGB.</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BGRAToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_bgra,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_bgra,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ABGR little endian (rgba in memory) to ARGB.</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ABGRToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RGBA little endian (abgr in memory) to ARGB.</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RGBAToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_rgba,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> src_stride_rgba,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deprecated function name.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BG24ToARGB RGB24ToARGB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RGB little endian (bgr in memory) to ARGB.</span></span><br><span class="line"><span class="function">LIBYUV_API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RGB24ToARGB</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> src_stride_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">uint8_t</span>* dst_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> dst_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> height)</span></span>;</span><br></pre></td></tr></table></figure><p>封装：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">emRGBXType</span>&#123;</span><br><span class="line">    RGBA,</span><br><span class="line">    BGRA,</span><br><span class="line">    ARGB,</span><br><span class="line">    ABGR,</span><br><span class="line">    RGB24,</span><br><span class="line">    BGR24</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RGBAToRGBX</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* src_rgba,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> src_stride_rgba,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">unsigned</span> <span class="type">char</span>* dst_rgbx,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> dst_stride_rgbx,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> image_width,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> image_height,</span></span></span><br><span class="line"><span class="params"><span class="function">                enumm emRGBXType type)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::RGBA:&#123;</span><br><span class="line">            </span><br><span class="line">            result = libyuv::<span class="built_in">ARGBCopy</span>(src_rgba, src_stride_rgba, dst_rgbx, dst_stride_rgbx, image_width, image_height);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::BGRA:&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span>* temp = <span class="literal">nullptr</span>;</span><br><span class="line">            temp = <span class="built_in">new</span> (std::nothrow) <span class="type">unsigned</span> <span class="type">char</span>[image_width*image_height*<span class="number">4</span>]();</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">nullptr</span> == temp)&#123;</span><br><span class="line">                <span class="comment">//log err: new fail</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-9999</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = libyuv::<span class="built_in">ARGBToBGRA</span>(src_rgba, src_stride_rgba, temp, image_width*<span class="number">4</span>, image_width, image_height);</span><br><span class="line">            <span class="keyword">if</span>(result! = <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//log err</span></span><br><span class="line">                <span class="keyword">delete</span>[] temp;</span><br><span class="line">                temp = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            result = libyuv::<span class="built_in">ARGBToRGBA</span>(temp, image_width*<span class="number">4</span>, dst_rgbx, dst_stride_rgbx, image_width, image_height);</span><br><span class="line">            <span class="keyword">delete</span>[] temp;</span><br><span class="line">            temp = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::RGB24:&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span>* temp = <span class="literal">nullptr</span>;</span><br><span class="line">            temp = <span class="built_in">new</span> (std::nothrow) <span class="type">unsigned</span> <span class="type">char</span>[image_width*image_height*<span class="number">4</span>]();</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">nullptr</span> == temp)&#123;</span><br><span class="line">                <span class="comment">//log err: new fail</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-9999</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = libyuv::<span class="built_in">RGBAToARGB</span>(src_rgba, src_stride_rgba, temp, image_width*<span class="number">4</span>, image_width, image_height);</span><br><span class="line">            <span class="keyword">if</span>(result! = <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//log err</span></span><br><span class="line">                <span class="keyword">delete</span>[] temp;</span><br><span class="line">                temp = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            result = libyuv::<span class="built_in">ARGBToRGB24</span>(temp, image_width*<span class="number">4</span>, dst_rgbx, dst_stride_rgbx, image_width, image_height);</span><br><span class="line">            <span class="keyword">delete</span>[] temp;</span><br><span class="line">            temp = <span class="literal">nullptr</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::BGR24:&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span>* temp = <span class="literal">nullptr</span>;</span><br><span class="line">            temp = <span class="built_in">new</span> (std::nothrow) <span class="type">unsigned</span> <span class="type">char</span>[image_width*image_height*<span class="number">4</span>]();</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">nullptr</span> == temp)&#123;</span><br><span class="line">                <span class="comment">//log err: new fail</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-9999</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = libyuv::<span class="built_in">ARGBToBGRA</span>(src_rgba, src_stride_rgba, temp, image_width*<span class="number">4</span>, image_width, image_height);</span><br><span class="line">            <span class="keyword">if</span>(result! = <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//log err</span></span><br><span class="line">                <span class="keyword">delete</span>[] temp;</span><br><span class="line">                temp = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            result = libyuv::<span class="built_in">ARGBToRGB24</span>(temp, image_width*<span class="number">4</span>, dst_rgbx, dst_stride_rgbx, image_width, image_height);            </span><br><span class="line">            <span class="keyword">delete</span>[] temp;</span><br><span class="line">            temp = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::ARGB:&#123;</span><br><span class="line">            result = libyuv::<span class="built_in">ConvertToARGB</span>(src_rgba, src_stride_rgba, </span><br><span class="line">                dst_rgbx, dst_stride_rgbx, </span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, image_width, image_height,image_width, image_height, <span class="number">0</span>,emRGBXType::RGBA);                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::ABGR:&#123;</span><br><span class="line">            result = libyuv::<span class="built_in">ConvertToARGB</span>(src_rgba, src_stride_rgba, </span><br><span class="line">                dst_rgbx, dst_stride_rgbx, </span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, image_width, image_height,image_width, image_height, <span class="number">0</span>,emRGBXType::BGRA);                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:&#123;</span><br><span class="line">            <span class="comment">//log err</span></span><br><span class="line">            result = <span class="number">-99</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BGRAToRGBX</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* src_bgra,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> src_stride_bgra,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">uint8_t</span>* dst_rgbx,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> dst_stride_rgbx,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> image_width,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> image_height,</span></span></span><br><span class="line"><span class="params"><span class="function">                enumm emRGBXType type)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::RGBA:&#123;</span><br><span class="line">            </span><br><span class="line">            result = <span class="built_in">RGBAToRGBX</span>(src_bgra, src_stride_bgra, dst_rgbx, dst_stride_rgbx, image_width, image_height, emRGBXType::BGRA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::BGRA:&#123;</span><br><span class="line">            </span><br><span class="line">            result = <span class="built_in">RGBAToRGBX</span>(src_bgra, src_stride_bgra, dst_rgbx, dst_stride_rgbx, image_width, image_height, emRGBXType::RGBA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::RGB24:&#123;</span><br><span class="line"></span><br><span class="line">            result = <span class="built_in">RGBAToRGBX</span>(src_bgra, src_stride_bgra, dst_rgbx, dst_stride_rgbx, image_width, image_height, emRGBXType::BGR24);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::BGR24:&#123;</span><br><span class="line">            </span><br><span class="line">            result = <span class="built_in">RGBAToRGBX</span>(src_bgra, src_stride_bgra, dst_rgbx, dst_stride_rgbx, image_width, image_height, emRGBXType::RGB24);          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::ARGB:&#123;</span><br><span class="line">            result = libyuv::<span class="built_in">ConvertToARGB</span>(src_bgra, src_stride_bgra, </span><br><span class="line">                dst_rgbx, dst_stride_rgbx, </span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, image_width, image_height,image_width, image_height, <span class="number">0</span>,emRGBXType::BGRA);                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::ABGR:&#123;</span><br><span class="line">            result = libyuv::<span class="built_in">ConvertToARGB</span>(src_bgra, src_stride_bgra, </span><br><span class="line">                dst_rgbx, dst_stride_rgbx, </span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, image_width, image_height,image_width, image_height, <span class="number">0</span>,emRGBXType::RGBA);                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:&#123;</span><br><span class="line">            <span class="comment">//log err</span></span><br><span class="line">            result = <span class="number">-99</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;                    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RGB24ToRGBX</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* src_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> src_stride_rgb24,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">unsigned</span> <span class="type">char</span>* dst_rgbx,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> dst_stride_rgbx,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> image_width,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> image_height,</span></span></span><br><span class="line"><span class="params"><span class="function">                enumm emRGBXType type)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::RGBA:&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span>* temp = <span class="literal">nullptr</span>;</span><br><span class="line">            temp = <span class="built_in">new</span> (std::nothrow) <span class="type">unsigned</span> <span class="type">char</span>[image_width*image_height*<span class="number">4</span>]();</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">nullptr</span> == temp)&#123;</span><br><span class="line">                <span class="comment">//log err: new fail</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-9999</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = libyuv::<span class="built_in">RGB24ToARGB</span>(src_rgb24, src_stride_rgb24, temp, image_width*<span class="number">4</span>, image_width, image_height);</span><br><span class="line">                <span class="comment">//log err</span></span><br><span class="line">                <span class="keyword">delete</span>[] temp;</span><br><span class="line">                temp = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            result = libyuv::<span class="built_in">ARGBToRGBA</span>(temp, image_width*<span class="number">4</span>, dst_rgbx, dst_stride_rgbx, image_width, image_height);</span><br><span class="line">            <span class="keyword">delete</span>[] temp;</span><br><span class="line">            temp = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::BGRA:&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span>* temp = <span class="literal">nullptr</span>;</span><br><span class="line">            temp = <span class="built_in">new</span> (std::nothrow) <span class="type">unsigned</span> <span class="type">char</span>[image_width*image_height*<span class="number">4</span>]();</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">nullptr</span> == temp)&#123;</span><br><span class="line">                <span class="comment">//log err: new fail</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-9999</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = libyuv::<span class="built_in">RGB24ToARGB</span>(src_rgb24, src_stride_rgb24, temp, image_width*<span class="number">4</span>, image_width, image_height);</span><br><span class="line">            <span class="keyword">if</span>(result! = <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//log err</span></span><br><span class="line">                <span class="keyword">delete</span>[] temp;</span><br><span class="line">                temp = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            result = libyuv::<span class="built_in">ARGBToBGRA</span>(temp, image_width*<span class="number">4</span>, dst_rgbx, dst_stride_rgbx, image_width, image_height); </span><br><span class="line">            <span class="keyword">delete</span>[] temp;</span><br><span class="line">            temp = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::RGB24:&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                std::<span class="built_in">copy</span>(src_rgb24, src_rgb24 + src_stride_rgb24*image_height, dst_stride_rgbx);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; ex)&#123;</span><br><span class="line">                <span class="comment">//log err ex.what();</span></span><br><span class="line">                result = <span class="number">-9999</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::BGR24:&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span>* temp = <span class="literal">nullptr</span>;</span><br><span class="line">            temp = <span class="built_in">new</span> (std::nothrow) <span class="type">unsigned</span> <span class="type">char</span>[image_width*image_height*<span class="number">4</span>]();</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">nullptr</span> == temp)&#123;</span><br><span class="line">                <span class="comment">//log err: new fail</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-9999</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = libyuv::<span class="built_in">RGB24ToARGB</span>(src_rgb24, src_stride_rgb24, temp, image_width*<span class="number">4</span>, image_width, image_height);</span><br><span class="line">            <span class="keyword">if</span>(result! = <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//log err</span></span><br><span class="line">                <span class="keyword">delete</span>[] temp;</span><br><span class="line">                temp = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span>* temp2 = <span class="literal">nullptr</span>;</span><br><span class="line">            temp2 = <span class="built_in">new</span> (std::nothrow) <span class="type">unsigned</span> <span class="type">char</span>[image_width*image_height*<span class="number">4</span>]();</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">nullptr</span> == temp2)&#123;</span><br><span class="line">                <span class="comment">//log err: new fail</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-9999</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = libyuv::<span class="built_in">ARGBToABGR</span>(temp, image_width*<span class="number">4</span>, temp2, image_width*<span class="number">4</span>, image_width, image_height);</span><br><span class="line">            <span class="keyword">if</span>(result! = <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//log err</span></span><br><span class="line">                <span class="keyword">delete</span>[] temp;</span><br><span class="line">                temp = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">delete</span>[] temp2;</span><br><span class="line">                temp2 = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = libyuv::<span class="built_in">ARGBToRGB24</span>(temp2, image_width*<span class="number">4</span>, dst_rgbx, dst_stride_rgbx, image_width, image_height);</span><br><span class="line">            <span class="keyword">delete</span>[] temp;</span><br><span class="line">            temp = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">delete</span>[] temp2;</span><br><span class="line">            temp2 = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::ARGB:&#123;</span><br><span class="line">            result = libyuv::<span class="built_in">ConvertToARGB</span>(src_rgb24, src_stride_rgb24, </span><br><span class="line">                dst_rgbx, dst_stride_rgbx, </span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, image_width, image_height,image_width, image_height, <span class="number">0</span>,emRGBXType::RGB24);                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::ABGR:&#123;</span><br><span class="line">            result = libyuv::<span class="built_in">ConvertToARGB</span>(src_rgb24, src_stride_rgb24, </span><br><span class="line">                dst_rgbx, dst_stride_rgbx, </span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, image_width, image_height,image_width, image_height, <span class="number">0</span>,emRGBXType::BGR24);                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:&#123;</span><br><span class="line">            <span class="comment">//log err</span></span><br><span class="line">            result = <span class="number">-99</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BGR24ToRGBX</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* src_bgr24,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> src_stride_bgr24,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">unsigned</span> <span class="type">char</span>* dst_rgbx,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> dst_stride_rgbx,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> image_width,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> image_height,</span></span></span><br><span class="line"><span class="params"><span class="function">                enumm emRGBXType type)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::RGBA:&#123;</span><br><span class="line">            result = <span class="built_in">RGB24ToRGBX</span>(src_bgr24, src_stride_bgr24, dst_rgbx, dst_stride_rgbx, image_width, image_height, emRGBXType::BGRA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::BGRA:&#123;</span><br><span class="line">            result = <span class="built_in">RGB24ToRGBX</span>(src_bgr24, src_stride_bgr24, dst_rgbx, dst_stride_rgbx, image_width, image_height, emRGBXType::RGBA);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::RGB24:&#123;</span><br><span class="line">            result = <span class="built_in">RGB24ToRGBX</span>(src_bgr24, src_stride_bgr24, dst_rgbx, dst_stride_rgbx, image_width, image_height, emRGBXType::BGR24);                     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::BGR24:&#123;</span><br><span class="line">            result = <span class="built_in">RGB24ToRGBX</span>(src_bgr24, src_stride_bgr24, dst_rgbx, dst_stride_rgbx, image_width, image_height, emRGBXType::RGB24);                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::ARGB:&#123;</span><br><span class="line">            result = libyuv::<span class="built_in">ConvertToARGB</span>(src_bgr24, src_stride_bgr24, </span><br><span class="line">                dst_rgbx, dst_stride_rgbx, </span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, image_width, image_height,image_width, image_height, <span class="number">0</span>,emRGBXType::BGR24);                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::ABGR:&#123;</span><br><span class="line">            result = libyuv::<span class="built_in">ConvertToARGB</span>(src_bgr24, src_stride_bgr24, </span><br><span class="line">                dst_rgbx, dst_stride_rgbx, </span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, image_width, image_height,image_width, image_height, <span class="number">0</span>,emRGBXType::RGB24);                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:&#123;</span><br><span class="line">            <span class="comment">//log err</span></span><br><span class="line">            result = <span class="number">-99</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ARGBToRGBX</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* src_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> src_stride_argb,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">unsigned</span> <span class="type">char</span>* dst_rgbx,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> dst_stride_rgbx,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> image_width,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> image_height,</span></span></span><br><span class="line"><span class="params"><span class="function">                enumm emRGBXType type)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::RGBA:&#123;</span><br><span class="line"></span><br><span class="line">            result = libyuv::<span class="built_in">ARGBToRGBA</span>(src_argb, src_stride_argb,dst_rgbx, dst_stride_rgbx, image_width, image_height);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::BGRA:&#123;</span><br><span class="line"></span><br><span class="line">            result = libyuv::<span class="built_in">ARGBToBGRA</span>(src_argb, src_stride_argb,dst_rgbx, dst_stride_rgbx, image_width, image_height);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::RGB24:&#123;</span><br><span class="line"></span><br><span class="line">            result = libyuv::<span class="built_in">ARGBToRGB24</span>(src_argb, src_stride_argb,dst_rgbx, dst_stride_rgbx, image_width, image_height);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::BGR24:&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span>* temp = <span class="literal">nullptr</span>;</span><br><span class="line">            temp = <span class="built_in">new</span> (std::nothrow) <span class="type">unsigned</span> <span class="type">char</span>[image_width*image_height*<span class="number">4</span>]();</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">nullptr</span> == temp)&#123;</span><br><span class="line">                <span class="comment">//log err: new fail</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-9999</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            result = libyuv::<span class="built_in">ARGBToRGBA</span>(src_argb, src_stride_argb,temp, image_width*<span class="number">4</span>, image_width, image_height);</span><br><span class="line">            <span class="keyword">if</span>(result != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//log err </span></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            result = libyuv::<span class="built_in">ARGBToRGB24</span>(temp, image_width*<span class="number">4</span>,dst_stride_rgbx, dst_stride_rgbx, image_width, image_height);      </span><br><span class="line">            <span class="keyword">delete</span>[] temp;</span><br><span class="line">            temp = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::ARGB:&#123;</span><br><span class="line"></span><br><span class="line">            result = libyuv::<span class="built_in">ARGBCopy</span>(src_argb, src_stride_argb,dst_rgbx, dst_stride_rgbx, image_width, image_height);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::ABGR:&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span>* temp = <span class="literal">nullptr</span>;</span><br><span class="line">            temp = <span class="built_in">new</span> (std::nothrow) <span class="type">unsigned</span> <span class="type">char</span>[image_width*image_height*<span class="number">4</span>]();</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">nullptr</span> == temp)&#123;</span><br><span class="line">                <span class="comment">//log err: new fail</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-9999</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            result = libyuv::<span class="built_in">ARGBToBGRA</span>(src_argb, src_stride_argb,temp, image_width*<span class="number">4</span>, image_width, image_height);</span><br><span class="line">            <span class="keyword">if</span>(result != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//log err </span></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            result = libyuv::<span class="built_in">RGBAToARGB</span>(temp, image_width*<span class="number">4</span>,dst_stride_rgbx, dst_stride_rgbx, image_width, image_height);      </span><br><span class="line">            <span class="keyword">delete</span>[] temp;</span><br><span class="line">            temp = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:&#123;</span><br><span class="line">            <span class="comment">//log err</span></span><br><span class="line">            result = <span class="number">-99</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;                    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ABGRToRGBX</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* src_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> src_stride_abgr,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">unsigned</span> <span class="type">char</span>* dst_rgbx,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> dst_stride_rgbx,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> image_width,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> image_height,</span></span></span><br><span class="line"><span class="params"><span class="function">                enumm emRGBXType type)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::RGBA:&#123;</span><br><span class="line"></span><br><span class="line">            result = libyuv::<span class="built_in">ARGBToBGRA</span>(src_argb, src_stride_argb,dst_rgbx, dst_stride_rgbx, image_width, image_height);           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::BGRA:&#123;</span><br><span class="line">            </span><br><span class="line">            result = libyuv::<span class="built_in">ARGBToRGBA</span>(src_argb, src_stride_argb,dst_rgbx, dst_stride_rgbx, image_width, image_height);                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::RGB24:&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span>* temp = <span class="literal">nullptr</span>;</span><br><span class="line">            temp = <span class="built_in">new</span> (std::nothrow) <span class="type">unsigned</span> <span class="type">char</span>[image_width*image_height*<span class="number">4</span>]();</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">nullptr</span> == temp)&#123;</span><br><span class="line">                <span class="comment">//log err: new fail</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-9999</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            result = libyuv::<span class="built_in">ARGBToRGBA</span>(src_argb, src_stride_argb,temp, image_width*<span class="number">4</span>, image_width, image_height);</span><br><span class="line">            <span class="keyword">if</span>(result != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//log err </span></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            result = libyuv::<span class="built_in">ARGBToRGB24</span>(temp, image_width*<span class="number">4</span>,dst_stride_rgbx, dst_stride_rgbx, image_width, image_height);      </span><br><span class="line">            <span class="keyword">delete</span>[] temp;</span><br><span class="line">            temp = <span class="literal">nullptr</span>;                      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::BGR24:&#123;</span><br><span class="line"></span><br><span class="line">            result = libyuv::<span class="built_in">ARGBToRGB24</span>(src_argb, src_stride_argb,dst_rgbx, dst_stride_rgbx, image_width, image_height);                  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::ARGB:&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span>* temp = <span class="literal">nullptr</span>;</span><br><span class="line">            temp = <span class="built_in">new</span> (std::nothrow) <span class="type">unsigned</span> <span class="type">char</span>[image_width*image_height*<span class="number">4</span>]();</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">nullptr</span> == temp)&#123;</span><br><span class="line">                <span class="comment">//log err: new fail</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-9999</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            result = libyuv::<span class="built_in">ARGBToBGRA</span>(src_argb, src_stride_argb,temp, image_width*<span class="number">4</span>, image_width, image_height);</span><br><span class="line">            <span class="keyword">if</span>(result != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//log err </span></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            result = libyuv::<span class="built_in">RGBAToARGB</span>(temp, image_width*<span class="number">4</span>,dst_stride_rgbx, dst_stride_rgbx, image_width, image_height);      </span><br><span class="line">            <span class="keyword">delete</span>[] temp;</span><br><span class="line">            temp = <span class="literal">nullptr</span>;              </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::ABGR:&#123;</span><br><span class="line"></span><br><span class="line">            result = libyuv::<span class="built_in">ARGBCopy</span>(src_argb, src_stride_argb,dst_rgbx, dst_stride_rgbx, image_width, image_height);           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:&#123;</span><br><span class="line">            <span class="comment">//log err</span></span><br><span class="line">            result = <span class="number">-99</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;                    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终封装的对外API接口:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ConvertRGBX</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* src_rgbx,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> src_stride_rgbx,</span></span></span><br><span class="line"><span class="params"><span class="function">                enumm emRGBXType src_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">unsigned</span> <span class="type">char</span>* dst_rgbx,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> dst_stride_rgbx,</span></span></span><br><span class="line"><span class="params"><span class="function">                enumm emRGBXType dst_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> image_width,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> image_height)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(src_type)&#123;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::RGBA:&#123;</span><br><span class="line">            result = <span class="built_in">RGBAToRGBX</span>(src_rgbx, src_stride_rgbx, dst_rgbx, dst_stride_rgbx, image_width, image_height, dst_type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::BGRA:&#123;</span><br><span class="line">            result = <span class="built_in">BGRAToRGBX</span>(src_rgbx, src_stride_rgbx, dst_rgbx, dst_stride_rgbx, image_width, image_height, dst_type);        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::RGB24:&#123;</span><br><span class="line">            result = <span class="built_in">RGB24ToRGBX</span>(src_rgbx, src_stride_rgbx, dst_rgbx, dst_stride_rgbx, image_width, image_height, dst_type);                       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::BGR24:&#123;</span><br><span class="line">            result = <span class="built_in">BGR24ToRGBX</span>(src_rgbx, src_stride_rgbx, dst_rgbx, dst_stride_rgbx, image_width, image_height, dst_type);                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::ARGB:&#123;</span><br><span class="line">            result = <span class="built_in">ARGBToRGBX</span>(src_rgbx, src_stride_rgbx, dst_rgbx, dst_stride_rgbx, image_width, image_height, dst_type);                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> emRGBXType::ABGR:&#123;</span><br><span class="line">            result = <span class="built_in">ABGRToRGBX</span>(src_rgbx, src_stride_rgbx, dst_rgbx, dst_stride_rgbx, image_width, image_height, dst_type);                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:&#123;</span><br><span class="line">            <span class="comment">//log err</span></span><br><span class="line">            result = <span class="number">-99</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;         </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CUDA常用的脚本之BGRA的缩放</title>
      <link href="/2023/11/12/CUDA%E5%B8%B8%E7%94%A8%E7%9A%84%E8%84%9A%E6%9C%AC%E4%B9%8BBGRA%E7%9A%84%E7%BC%A9%E6%94%BE/"/>
      <url>/2023/11/12/CUDA%E5%B8%B8%E7%94%A8%E7%9A%84%E8%84%9A%E6%9C%AC%E4%B9%8BBGRA%E7%9A%84%E7%BC%A9%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<p>本篇博客主要介绍对于RGBAorBGRA格式的图片进行缩放操作的脚本实现．</p><p>实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__  <span class="type">void</span> <span class="title">RGBAResize</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* input_data,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">unsigned</span> <span class="type">int</span> input_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">unsigned</span> <span class="type">char</span>* output_data,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">unsigned</span> <span class="type">int</span> output_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">unsigned</span> <span class="type">int</span> input_width ,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">unsigned</span> <span class="type">int</span> input_height ,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">unsigned</span> <span class="type">int</span> output_width,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">unsigned</span> <span class="type">int</span> output_height,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> y = blockIdx.y * blockDim.y + threadIdx.y;</span><br><span class="line">    uchar4* data = (uchar4*)(output_data + y * output_stride + x * <span class="built_in">sizeof</span>(uchar4));</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> u = (<span class="type">float</span>)x / (<span class="type">float</span>)(output_width - <span class="number">1</span>);</span><br><span class="line">    <span class="type">float</span> v = (<span class="type">float</span>)y / (<span class="type">float</span>)(output_height - <span class="number">1</span>);</span><br><span class="line">    float2 temCoord = <span class="built_in">make_float2</span>(u , v);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> f_srcWidth = (<span class="type">float</span>)(input_width);</span><br><span class="line">    <span class="type">float</span> f_srcHeight = (<span class="type">float</span>)(input_height);</span><br><span class="line">    <span class="type">float</span> f_dstWidth = (<span class="type">float</span>)(output_width);</span><br><span class="line">    <span class="type">float</span> f_dstHeight = (<span class="type">float</span>)(output_height);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> scalFactorX = f_dstWidth / f_srcWidth;</span><br><span class="line"><span class="type">float</span> scalFactorY = f_dstHeight / f_srcHeight;</span><br><span class="line">    <span class="type">float</span> resizeCoord_x = temCoord.x;</span><br><span class="line"><span class="type">float</span> resizeCoord_y = temCoord.y;</span><br><span class="line">    <span class="type">float</span> matt = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> src_ratio = f_srcWidth / f_srcHeight;</span><br><span class="line">        <span class="type">float</span> dst_ratio = f_dstWidth / f_dstHeight;</span><br><span class="line">        <span class="type">float</span> tmpDstH = <span class="built_in">ceilf</span>(f_dstWidth * f_srcHeight / f_srcWidth);</span><br><span class="line">        <span class="keyword">if</span>(f_dstHeight &gt;= tmpDstH) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> dstH = tmpDstH / f_dstHeight ;</span><br><span class="line">            <span class="type">float</span> roiY0 = (<span class="number">1.0</span> - dstH) * <span class="number">0.5</span>;</span><br><span class="line">            <span class="type">float</span> roiY1 = roiY0 + dstH;</span><br><span class="line">            matt = <span class="built_in">step</span>(roiY0 ,temCoord.y) * <span class="built_in">step</span>(temCoord.y , roiY1);</span><br><span class="line">            resizeCoord_y = (temCoord.y - roiY0) / dstH;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> tmpDstW = <span class="built_in">ceilf</span>(f_dstHeight * src_ratio);</span><br><span class="line">            <span class="type">float</span> dstW =  tmpDstW / f_dstWidth;</span><br><span class="line">            <span class="type">float</span> roiX0 = (<span class="number">1.0</span> - dstW) * <span class="number">0.5</span>;</span><br><span class="line">            <span class="type">float</span> roiX1 = roiX0 + dstW;</span><br><span class="line">            matt = <span class="built_in">step</span>(roiX0 ,temCoord.x) * <span class="built_in">step</span>(temCoord.x , roiX1);</span><br><span class="line">            resizeCoord_x = (temCoord.x - roiX0) / dstW;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(type == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> temp_srcHeight = f_srcHeight;</span><br><span class="line"><span class="type">float</span> temp_srcWidth  = f_srcWidth;</span><br><span class="line"><span class="keyword">if</span>(f_srcWidth * <span class="number">9</span> &gt; f_srcHeight * <span class="number">16</span>)</span><br><span class="line">&#123;</span><br><span class="line">f_srcHeight = <span class="built_in">ceilf</span>(f_srcWidth * <span class="number">9</span> / <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">f_srcWidth = <span class="built_in">ceilf</span>(f_srcHeight * <span class="number">16</span> / <span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> tempWidth =  f_srcWidth  * f_dstHeight;</span><br><span class="line"><span class="type">float</span> tempHeight = f_srcHeight * f_dstWidth;</span><br><span class="line"><span class="keyword">if</span>(tempHeight &gt;= tempWidth)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> w = tempWidth / f_srcHeight;</span><br><span class="line"><span class="type">float</span> dstW = w / f_dstWidth;</span><br><span class="line"><span class="type">float</span> roiX0 = (<span class="number">1.0</span> - dstW) * <span class="number">0.5</span>;</span><br><span class="line"><span class="type">float</span> roiX1 = roiX0 + dstW;</span><br><span class="line">matt = <span class="built_in">step</span>(roiX0,temCoord.x) * <span class="built_in">step</span>(temCoord.x,roiX1);</span><br><span class="line">resizeCoord_x = (temCoord.x - roiX0) / dstW;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> h = tempHeight / f_srcWidth;</span><br><span class="line"><span class="type">float</span> dstH = h / f_dstHeight;</span><br><span class="line"><span class="type">float</span> roiY0 = (<span class="number">1.0</span> - dstH) * <span class="number">0.5</span>;</span><br><span class="line"><span class="type">float</span> roiY1 = roiY0  + dstH;</span><br><span class="line">matt = <span class="built_in">step</span>(roiY0, temCoord.y) * <span class="built_in">step</span>(temCoord.y, roiY1);</span><br><span class="line">resizeCoord_y = (temCoord.y - roiY0) / dstH;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(type == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> temp_srcHeight = f_srcHeight;</span><br><span class="line"><span class="type">float</span> temp_srcWidth  = f_srcWidth;</span><br><span class="line"><span class="keyword">if</span>(f_srcWidth * <span class="number">3</span> &gt; f_srcHeight * <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">f_srcHeight = f_srcWidth * <span class="number">3</span> / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">f_srcWidth = f_srcHeight * <span class="number">4</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> tempWidth =  f_srcWidth  * f_dstHeight;</span><br><span class="line"><span class="type">float</span> tempHeight = f_srcHeight * f_dstWidth;</span><br><span class="line"><span class="keyword">if</span>(tempHeight &gt;= tempWidth)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> w = tempWidth / f_srcHeight;</span><br><span class="line"><span class="type">float</span> dstW = w / f_dstWidth;</span><br><span class="line"><span class="type">float</span> roiX0 = (<span class="number">1.0</span> - dstW) * <span class="number">0.5</span>;</span><br><span class="line"><span class="type">float</span> roiX1 = roiX0 + dstW;</span><br><span class="line">matt = <span class="built_in">step</span>(roiX0,temCoord.x) * <span class="built_in">step</span>(temCoord.x,roiX1);</span><br><span class="line">resizeCoord_x = (temCoord.x - roiX0) / dstW;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> h = tempHeight / f_srcWidth;</span><br><span class="line"><span class="type">float</span> dstH = h / f_dstHeight;</span><br><span class="line"><span class="type">float</span> roiY0 = (<span class="number">1.0</span> - dstH) * <span class="number">0.5</span>;</span><br><span class="line"><span class="type">float</span> roiY1 = roiY0  + dstH;</span><br><span class="line">matt = <span class="built_in">step</span>(roiY0, temCoord.y) * <span class="built_in">step</span>(temCoord.y, roiY1);</span><br><span class="line">resizeCoord_y = (temCoord.y - roiY0 ) / dstH;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(type == <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(f_srcWidth * <span class="number">16</span> &gt; f_srcHeight * <span class="number">9</span>)</span><br><span class="line">&#123;</span><br><span class="line">f_srcWidth = <span class="built_in">ceilf</span>(f_srcHeight * <span class="number">9</span> / <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">f_srcHeight = <span class="built_in">ceilf</span>(f_srcWidth * <span class="number">16</span> / <span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> tempWidth  =  f_srcWidth  * f_dstHeight;</span><br><span class="line"><span class="type">float</span> tempHeight =  f_srcHeight  * f_dstWidth;</span><br><span class="line"><span class="keyword">if</span>(tempHeight &gt;= tempWidth)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> w = tempWidth / f_srcHeight;</span><br><span class="line"><span class="type">float</span> dstW = w / f_dstWidth;</span><br><span class="line"><span class="type">float</span> roiX0 = (<span class="number">1.0</span> - dstW) * <span class="number">0.5</span>;</span><br><span class="line"><span class="type">float</span> roiX1 = roiX0 + dstW;</span><br><span class="line">matt = <span class="built_in">step</span>(roiX0,temCoord.x) * <span class="built_in">step</span>(temCoord.x,roiX1);</span><br><span class="line">resizeCoord_x = (temCoord.x - roiX0) / dstW;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> h = tempHeight / f_srcWidth;</span><br><span class="line"><span class="type">float</span> dstH = h / f_dstHeight;</span><br><span class="line"><span class="type">float</span> roiY0 = (<span class="number">1.0</span> - dstH) * <span class="number">0.5</span>;</span><br><span class="line"><span class="type">float</span> roiY1 = roiY0  + dstH;</span><br><span class="line">matt = <span class="built_in">step</span>(roiY0, temCoord.y) * <span class="built_in">step</span>(temCoord.y, roiY1);</span><br><span class="line">resizeCoord_y = (temCoord.y - roiY0 ) / dstH;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(type == <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> temp_srcHeight = f_srcHeight;</span><br><span class="line"><span class="type">float</span> temp_srcWidth  = f_srcWidth;</span><br><span class="line"><span class="keyword">if</span>(f_srcWidth &gt;= f_srcHeight)</span><br><span class="line">&#123;</span><br><span class="line">f_srcWidth = f_srcHeight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">f_srcHeight = f_srcWidth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> tempWidth  =  f_srcWidth  * f_dstHeight;</span><br><span class="line"><span class="type">float</span> tempHeight =  f_srcHeight  * f_dstWidth;</span><br><span class="line"><span class="keyword">if</span>(tempHeight &gt;= tempWidth)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> w = tempWidth / f_srcHeight;</span><br><span class="line"><span class="type">float</span> dstW = w / f_dstWidth;</span><br><span class="line"><span class="type">float</span> roiX0 = (<span class="number">1.0</span> - dstW) * <span class="number">0.5</span>;</span><br><span class="line"><span class="type">float</span> roiX1 = roiX0 + dstW;</span><br><span class="line">matt = <span class="built_in">step</span>(roiX0 , temCoord.x) * <span class="built_in">step</span>(temCoord.x , roiX1);</span><br><span class="line">resizeCoord_x = (temCoord.x - roiX0) / dstW;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> h = tempHeight / f_srcWidth;</span><br><span class="line"><span class="type">float</span> dstH = h / f_dstHeight;</span><br><span class="line"><span class="type">float</span> roiY0 = (<span class="number">1.0</span> - dstH) * <span class="number">0.5</span>;</span><br><span class="line"><span class="type">float</span> roiY1 = roiY0  + dstH;</span><br><span class="line">matt = <span class="built_in">step</span>(roiY0, temCoord.y) * <span class="built_in">step</span>(temCoord.y, roiY1);</span><br><span class="line">resizeCoord_y = (temCoord.y - roiY0 ) / dstH;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(type == <span class="number">6</span>) <span class="comment">/* IRM_PAN_SCAN */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> scaleFactor = scalFactorX &gt; scalFactorY ? scalFactorX : scalFactorY;</span><br><span class="line">resizeCoord_x = (resizeCoord_x - <span class="number">0.5f</span>) * scalFactorX / scaleFactor + <span class="number">0.5</span>;</span><br><span class="line">resizeCoord_y = (resizeCoord_y - <span class="number">0.5f</span>) * scalFactorY / scaleFactor + <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line">    float2 uv = <span class="built_in">make_float2</span>(resizeCoord_x , resizeCoord_y);</span><br><span class="line">float4 ovlCol = <span class="built_in">SampleBilinear</span>(input_data, uv.x, uv.y, input_width, input_height , input_stride) * matt;</span><br><span class="line">    data[<span class="number">0</span>] = <span class="built_in">make_uchar4</span>(ovlCol);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure><p>其中：<br>type &#x3D; 1：按比例缩放，保持原始图像的宽高比，将图像缩放到目标尺寸内，多余的部分会被裁剪掉。<br>type &#x3D; 2：按比例缩放，保持原始图像的宽高比，将图像缩放到目标尺寸内，多余的部分会留有黑边。<br>type &#x3D; 3：按比例缩放，保持原始图像的宽高比，将图像缩放到目标尺寸内，多余的部分会留有白边。<br>type &#x3D; 4：按比例缩放，保持原始图像的宽高比，将图像缩放到目标尺寸内，多余的部分会根据宽高比进行裁剪。<br>type &#x3D; 5：按比例缩放，保持原始图像的宽高比，将图像缩放到目标尺寸内，多余的部分会根据宽高比进行留白。<br>type &#x3D; 6：IRM_PAN_SCAN，按比例缩放，将图像缩放到目标尺寸内，多余的部分会根据缩放比例进行裁剪。</p><p>PS:IRM_PAN_SCAN是一种DVD视频格式中的一种画面缩放类型，用于将16:9宽屏电影缩放成4:3标准屏幕的格式。在IRM_PAN_SCAN模式下，画面会被裁剪并缩放，以适应4:3的屏幕比例。这种缩放方式可能会导致画面的部分内容被裁剪掉，因此在观看时可能会出现一些不完整的画面</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>libyuv学习笔记之常用接口的封装</title>
      <link href="/2023/11/10/libyuv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B0%81%E8%A3%85/"/>
      <url>/2023/11/10/libyuv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要是介绍如何搭建一套用于cpu的color space接口．</p><h1 id="libyuv简介"><a href="#libyuv简介" class="headerlink" title="libyuv简介"></a>libyuv简介</h1><p>libyuv是一个开源项目，包括 YUV 缩放和转换功能。</p><ul><li>使用点、双线性或盒式滤波器缩放 YUV 以准备压缩内容。</li><li>从网络摄像头格式转换为 YUV 进行压缩。</li><li>转换为RGB格式以进行渲染&#x2F;效果。</li><li>旋转90&#x2F;180&#x2F;270度以适应移动设备的纵向模式。</li><li>针对x86&#x2F;x64上的SSSE3&#x2F;AVX2进行了优化。</li><li>针对Arm上的Neon进行了优化。</li><li>针对Mips上的MSA进行了优化。</li><li>针对RISC-V上的RVV进行了优化。</li></ul><p>libyuv源代码GitHub链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://chromium.googlesource.com/libyuv/libyuv</span><br></pre></td></tr></table></figure><p>由于所封装的API接口主要用于编解码底层常见的颜色空间转换以及缩放旋转场景，因此本篇文章仅针对这些常见进行相关接口的封装，后续如果有其他新的接口需求，也可在此基础上继续添加对应的API接口．</p><p>首先，我们先举例一下，在上述常见应用场景下有哪些接口需求：</p><ul><li>YV12和NV12之间的互转</li><li>YUV和RGBX之间的互转</li><li>RGBX之间的互转</li><li>YV12的旋转</li><li>NV12的旋转</li><li>RGBX的旋转</li><li>YV12的缩放</li><li>NV12的缩放</li><li>RGBX的缩放</li><li>YV12的Crop</li><li>NV12的Crop</li><li>RGBX的Crop</li></ul><p>接下来，我们将针对上述的接口需求进行API的封装工作</p><p>首先，我们先include相关头文件，以及对导出接口进行宏的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libyuv/scale_uv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libyuv/convert_argb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libyuvReplace.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libyuv/video_common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libyuv/convert.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libyuv/convert_from_argb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> libyuv_EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> libyuv_API extern <span class="string">&quot;C&quot;</span> __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> libyuv_API extern <span class="string">&quot;C&quot;</span> __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> libyuv_API extern <span class="string">&quot;C&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>PS: 关于YUV和RGBA的相关介绍可以参考网上的这篇<a href="https://blog.csdn.net/xkuzhang/article/details/115423061">文章</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CUDA常用的脚本之BGRA的旋转</title>
      <link href="/2023/11/09/CUDA%E5%B8%B8%E7%94%A8%E7%9A%84%E8%84%9A%E6%9C%AC%E4%B9%8BBGRA%E7%9A%84%E6%97%8B%E8%BD%AC/"/>
      <url>/2023/11/09/CUDA%E5%B8%B8%E7%94%A8%E7%9A%84%E8%84%9A%E6%9C%AC%E4%B9%8BBGRA%E7%9A%84%E6%97%8B%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p>本篇博客主要介绍对于RGBAorBGRA格式的图片进行旋转操作的脚本实现，旋转分为正常的90,180,270度旋转，同时还有上下或者左右进行镜像翻转的操作．</p><p>实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">RGBARotate</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* input_data ,<span class="type">unsigned</span> <span class="type">int</span> input_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">unsigned</span> <span class="type">char</span>* output_data ,<span class="type">int</span> output_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">unsigned</span> <span class="type">int</span> input_width,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">unsigned</span> <span class="type">int</span> input_height,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">unsigned</span> <span class="type">int</span> output_width,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">unsigned</span> <span class="type">int</span> output_height,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">unsigned</span> <span class="type">int</span> channel_nums,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">int</span> RotateType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> y = blockIdx.y * blockDim.y + threadIdx.y;  </span><br><span class="line">    uchar4* data = (uchar4*)(output_data + y * output_stride + <span class="number">4</span> * x);</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> u = (<span class="type">float</span>)x / (<span class="type">float</span>)output_width;</span><br><span class="line">    <span class="type">float</span> v = (<span class="type">float</span>)y / (<span class="type">float</span>)output_height;</span><br><span class="line">    float2 temCoord = <span class="built_in">make_float2</span>(u , v);</span><br><span class="line">    </span><br><span class="line">    float4 color = <span class="built_in">make_float4</span>(<span class="number">0.0f</span>); </span><br><span class="line">    <span class="keyword">switch</span>(RotateType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">case</span>(<span class="number">0</span>):<span class="comment">//90</span></span><br><span class="line">                temCoord = <span class="built_in">make_float2</span>(temCoord.y , <span class="number">1.0f</span>- temCoord.x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">case</span>(<span class="number">1</span>):<span class="comment">//180</span></span><br><span class="line">                temCoord = <span class="built_in">make_float2</span>(<span class="number">1.0f</span>) - temCoord;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">case</span>(<span class="number">2</span>):<span class="comment">//270</span></span><br><span class="line">                temCoord =  <span class="built_in">make_float2</span>(<span class="number">1.0f</span> - temCoord.y , temCoord.x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">case</span>(<span class="number">3</span>):<span class="comment">//PMIRROR VERT</span></span><br><span class="line">                temCoord =  <span class="built_in">make_float2</span>(<span class="number">1.0f</span> - temCoord.x , temCoord.y); </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">case</span>(<span class="number">4</span>):<span class="comment">//PMIRROR_HORZ</span></span><br><span class="line">                temCoord =  <span class="built_in">make_float2</span>(temCoord.x , <span class="number">1.0f</span> - temCoord.y); </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">5</span>):<span class="comment">//PMIRROR VERT+PMIRROR_HORZ</span></span><br><span class="line">                temCoord = <span class="built_in">make_float2</span>(<span class="number">1.0f</span> - temCoord.x , <span class="number">1.0f</span> - temCoord.y); </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="comment">//Default rotation is 90 degrees</span></span><br><span class="line">                temCoord = <span class="built_in">make_float2</span>(temCoord.y , <span class="number">1.0f</span> - temCoord.x);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">color = <span class="built_in">RGBXSampleBilinear</span>(input_data, temCoord.x, temCoord.y, input_width, input_height , input_stride,channel_nums);</span><br><span class="line">    data[<span class="number">0</span>] = <span class="built_in">make_uchar4</span>(color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS:相关头文件和用到的两个函数参考Crop那篇文章</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CUDA常用的脚本之BGRA的crop</title>
      <link href="/2023/11/07/CUDA%E5%B8%B8%E7%94%A8%E7%9A%84%E8%84%9A%E6%9C%AC%E4%B9%8BBGRA%E7%9A%84crop/"/>
      <url>/2023/11/07/CUDA%E5%B8%B8%E7%94%A8%E7%9A%84%E8%84%9A%E6%9C%AC%E4%B9%8BBGRA%E7%9A%84crop/</url>
      
        <content type="html"><![CDATA[<p>本篇博客主要介绍对于RGBAorBGRA格式的图片进行Crop操作的脚本实现（该算法使用场景较少），可以了解一下即可</p><p>实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">RGBACrop</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* input_data ,<span class="type">unsigned</span> <span class="type">int</span> input_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">unsigned</span> <span class="type">char</span>* output_data ,<span class="type">unsigned</span> <span class="type">int</span> output_stride,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">unsigned</span> <span class="type">int</span> input_width,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">unsigned</span> <span class="type">int</span> input_height,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">unsigned</span> <span class="type">int</span> channel_nums,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">float</span> roi_x,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">float</span> roi_y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> y = blockIdx.y * blockDim.y + threadIdx.y;  </span><br><span class="line">    uchar4* data = (uchar4*)(output_data + y * output_stride + x * <span class="built_in">sizeof</span>(uchar4));</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> roi_x0 = roi_x * (<span class="type">float</span>)input_width;</span><br><span class="line">    <span class="type">float</span> roi_y0 = roi_y * (<span class="type">float</span>)input_height;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> u = (<span class="type">float</span>)x + roi_x0;</span><br><span class="line">    <span class="type">float</span> v = (<span class="type">float</span>)y + roi_y0;</span><br><span class="line">    <span class="type">float</span> t = u / (<span class="type">float</span>)input_width;</span><br><span class="line">    <span class="type">float</span> c = v / (<span class="type">float</span>)input_height;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> grid = (<span class="built_in">step</span>(<span class="number">0.0f</span> , t) - <span class="built_in">step</span>(<span class="number">1.0</span> , t)) * (<span class="built_in">step</span>(<span class="number">0.0</span> , c) - <span class="built_in">step</span>(<span class="number">1.0</span> , c));</span><br><span class="line">    float4 ovlColor = <span class="built_in">make_float4</span>(<span class="built_in">RGBXSampleBilinear</span>(input_data, t, c, input_width, input_height , input_stride,channel_nums)) * grid;</span><br><span class="line">    data[<span class="number">0</span>] = <span class="built_in">make_uchar4</span>(ovlColor);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CUDA核函数的使用</title>
      <link href="/2023/11/01/CUDA%E6%A0%B8%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/11/01/CUDA%E6%A0%B8%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>本篇文章，将结合之前的cuda脚本来实现一套基于cuda的.cu和.ptx预加载模式的ColorSpace接口．主要功能是实现颜色空间转换以及常用特效处理（缩放旋转Crop）</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>什么是PT预加载模式？<br>PTX是NVIDIACUDA编译器使用的一种中间语言，用于将CUDA代码转换为可以在NVIDIAGPU上运行的机器代码。它是一种低级、类似汇编的语言，旨在独立于平台并优化GPU的性能。PTX并不意味着要手动编写，而是由CUDA编译器从C或C++等高级编程语言生成</p><p>CUDA采用PTX（ParallelThreadExecution）预加载的方式有以下优点：</p><ul><li>灵活性：PTX是一种中间表示形式，可以在不同的GPU架构上进行编译和优化。通过预加载PTX代码，可以在运行时根据当前GPU架构进行即时编译和优化，以获得最佳的性能。</li><li>可移植性：PTX代码可以在不同的GPU架构上进行编译和执行，而不需要重新编写和优化代码。这使得开发人员可以编写一次代码，然后在不同的GPU上运行，从而提高了代码的可移植性。</li><li>动态优化：通过PTX预加载，CUDA可以根据当前GPU架构的特性和资源进行动态优化。这意味着在运行时可以根据实际情况对代码进行优化，以获得更好的性能。</li><li>简化开发流程：PTX预加载可以简化开发流程，因为开发人员不需要手动编写和优化针对特定GPU架构的代码。相反，他们可以编写一次代码，然后在不同的GPU上运行，而不需要进行额外的优化工作。</li></ul><p>总的来说，CUDA采用PTX预加载的方式可以提供更好的灵活性、可移植性和动态优化能力，从而简化开发流程并提高代码的性能。</p><p> CUBIN&#x2F;PTX</p><p>参考资料：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/tpn/cuda-samples/blob/master/v9.0/3_Imaging/cudaDecodeGL/cudaProcessFrame.h</span><br><span class="line"></span><br><span class="line">Samples/0_Introduction/simpleTextureDrv/simpleTextureDrv.cpp:* the CUDA ptx (*.ptx) kernel just prior to kernel launch.</span><br><span class="line">Samples/3_CUDA_Features/ptxjit/ptxjit.cpp:#define PTX_FILE &quot;ptxjit_kernel64.ptx&quot;</span><br><span class="line">Samples/3_CUDA_Features/memMapIPCDrv/memMapIpc.cpp:#define PTX_FILE &quot;memMapIpc_kernel32.ptx&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设计初衷：保证转换流程的效率最大化，因此对于整个转换流程的话，选择ptx模式则是一种最优解</p><p>开始之初，先对整个系统环境进行判断，看是否符合cuda的运行环境，符合的话，创建单例：log、cudakernelmode，dx，。。。</p><p>现在底层的方式是没有对ptx这些操作进行封装，而是看在哪里使用到cudakernel的话，再临时加载对应的funtion，用完后就丢弃掉，这样的话导致不同filter如果用到相同的funtion的话，就得自己重复进行ptx文件的加载，并且每当结束一次播放or转换的话，对应的ptx相关资源都被释放掉，后续要用的话只能重新加载，因此最好是将其搞成单例，这样一开始就可以全部加载完，等到整个app退出后再进行ptx的相关资源释放</p><p>接下来，我们将使用内部静态变量的懒汉单例来设计一个cuda的ptx文件的管理类</p><p>还有一个问题就是我们正常会有几个ptx文件？正常来说是一个ptx文件，但是后续随着快速迭代的需求压力，可能出现没办法每次将写的或者找的.cu文件合并到一个.cu文件上，再用nvcc编译成ptx文件，因此这个类应该是能注册无限制的ptx文件，而且每个ptx文件里面都至少存在一个，甚至更多的funtion．因此该类进行注册的话，我们可以设置成指定文件夹路径，这就要求所有的ptx必须按照要求放在统一的文件夹路径下，然后我们在该路径下添加一个xml&#x2F;json&#x2F;YAML</p><p>相关头文件的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cudaModuleMgr.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stCudaFunctionInfo</span>&#123;</span><br><span class="line">    CudaKernels                         cuda_kernels;</span><br><span class="line">    std::map&lt;std::string,<span class="type">int</span>&gt;           cuda_function_param;</span><br><span class="line">    std::string                         cuda_function_description;</span><br><span class="line">    CUresult                            result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stCudaPTXFileInfo</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>                          *filename_module;                            <span class="comment">//  filename_module     - CUDA or PTX file path</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>                          *exec_path;                                  <span class="comment">//  exec_path           - execution path</span></span><br><span class="line">    <span class="type">int</span>                                 kernels;                                     <span class="comment">//  kernels             - total # of different CUDA kernel functions in the CUBIN/OTX</span></span><br><span class="line">    <span class="type">int</span>                                 global_memory;                               <span class="comment">//  global_memory       - total # of Global Memory arrays defined in the CUBIN/PTX (i.e. constants)</span></span><br><span class="line">    <span class="type">int</span>                                 texture_references;                          <span class="comment">//  texture_references  - total # of Texture References arrays defined in the CUBIN/PTX (i.e. texture arrays)</span></span><br><span class="line">    std::shared_ptr&lt;CUmoduleManager&gt;    pCUmoduleManager;</span><br><span class="line">    vector&lt;stCudaFunctionInfo&gt;          function_info;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stCudaDataInfo</span>&#123;</span><br><span class="line"></span><br><span class="line">    CUdeviceptr     src_data;</span><br><span class="line">    <span class="type">int</span>             src_stride;</span><br><span class="line">    <span class="type">int</span>             src_width;</span><br><span class="line">    <span class="type">int</span>             srt_height;</span><br><span class="line"></span><br><span class="line">    CUdeviceptr     dst_data;</span><br><span class="line">    <span class="type">int</span>             dst_stride;</span><br><span class="line">    <span class="type">int</span>             dst_width;</span><br><span class="line">    <span class="type">int</span>             dst_height;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>             function_param;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>*           extra_info[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">emCudaKernelGridSetMode</span>&#123;</span><br><span class="line"></span><br><span class="line">    CUSTOMIZE_GRID_VALUE,</span><br><span class="line">    DEFAULT_GRID_VALUE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stCustomizeGridValue</span>&#123;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> x;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> y; </span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stDefaultGridValue</span>&#123;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> width;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> height; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stCudaKernelGridInfo</span>&#123;</span><br><span class="line"></span><br><span class="line">    emCudaKernelGridSetMode     mode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        stGridData              grid_data;</span><br><span class="line">        stDefaultGridValue      grid_data;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stCudaKernelBlockInfo</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stCudaKernelBlockInfo</span>() : <span class="built_in">x</span>(<span class="number">32</span>), <span class="built_in">y</span>(<span class="number">16</span>), <span class="built_in">z</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">stCudaKernelBlockInfo</span>(<span class="type">int</span> x, <span class="type">int</span> y,<span class="type">int</span> z) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">z</span>(z) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stCudaKernelParam</span>&#123;</span><br><span class="line"></span><br><span class="line">    stCudaKernelBlockInfo   block_info;</span><br><span class="line">    stCudaKernelGridInfo    grid_info;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>            shared_mem_bytes;</span><br><span class="line">    CUstream                cuda_stream;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">emLoadCudaPtxFileLevel</span>&#123;</span><br><span class="line">    STRICT_LEVEL,   <span class="comment">//yaml描述文件中的所有ptx文件都需要加载成功</span></span><br><span class="line">    LOOSE_LEVEL     <span class="comment">//允许存在部分ptx加载失败</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>CCudaPTXScriptFileMgr类的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCudaPTXScriptFileMgr</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取单实例对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> CCudaPTXScriptFileMgr &amp;<span class="title">GetInstance</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ptx_info_description_yaml_file_name,<span class="type">const</span> <span class="type">char</span>* ptx_info_description_yaml_file_path，emLoadCudaPtxFileLevel level)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 局部静态特性的方式实现单实例</span></span><br><span class="line">        <span class="type">static</span> CCudaPTXScriptFileMgr signal;</span><br><span class="line">        signal.<span class="built_in">Init</span>(ptx_info_description_yaml_file_name,ptx_info_description_yaml_file_path,level)</span><br><span class="line">        <span class="keyword">return</span> signal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetAllCudaModuleInfo</span><span class="params">(std::vector&lt;stCudaPTXFileInfo&gt; &amp;info)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(m_vecAllCudaModuleInfo.<span class="built_in">size</span>())&#123;</span><br><span class="line">            info = m_vecAllCudaModuleInfo;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//log err:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止外部构造 &amp;&amp; 禁止默认构造函数</span></span><br><span class="line">    <span class="built_in">CCudaPTXScriptFileMgr</span>()=<span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止外部析构</span></span><br><span class="line">    ~<span class="built_in">CCudaPTXScriptFileMgr</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止外部复制构造</span></span><br><span class="line">    <span class="built_in">CCudaPTXScriptFileMgr</span>(<span class="type">const</span> CCudaPTXScriptFileMgr &amp;signal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止外部赋值操作</span></span><br><span class="line">    CCudaPTXScriptFileMgr &amp;<span class="keyword">operator</span>=(<span class="type">const</span> CCudaPTXScriptFileMgr &amp;signal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从yaml中读取ptx相关文件的描述信息，从而打开每个ptx文件进行预加载</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ptx_description_info_yaml_file_name,<span class="type">const</span> <span class="type">char</span>* ptx_description_info_yaml_file_path,emLoadCudaPtxFileLevel level)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SetParam</span><span class="params">(stCudaKernelParam param)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Process</span><span class="params">(stCudaFunctionInfo function_info,stCudaDataInfo cuda_data_info)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">InitCudaPTXFile</span><span class="params">(stCudaPTXFileInfo cuda_ptx_file_info)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SetCudaKernelCUstream</span><span class="params">(CUstream cuda_stream)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SetCudaKernelSharedMemBytes</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> shared_mem_bytes)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SetCudaKernelBlok</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> block_x, <span class="type">unsigned</span> <span class="type">int</span> block_y, <span class="type">unsigned</span> <span class="type">int</span> block_z)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SetCudaKernelGrid</span><span class="params">(stCudaKernelGridInfo info)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;stCudaPTXFileInfo&gt;  m_vecAllCudaModuleInfo;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>*                           m_chPTXDescriptionInfoYamlFileName;</span><br><span class="line">    <span class="type">char</span>*                           m_chPTXDescriptionInfoYamlFilePath;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">emLoadCudaPtxFileLevel</span>     m_emLevel;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CCudaPTXScriptFileMgr::<span class="built_in">CCudaPTXScriptFileMgr</span>():<span class="built_in">m_chPTXDescriptionInfoYamlFileName</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    , <span class="built_in">m_chPTXDescriptionInfoYamlFilePath</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    , <span class="built_in">m_emLevel</span>(emLoadCudaPtxFileLevel::STRICT_LEVEL)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    m_vecAllCudaModuleInfo.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CCudaPTXScriptFileMgr::~<span class="built_in">CCudaPTXScriptFileMgr</span>()&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_vecAllCudaModuleInfo.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"></span><br><span class="line">        m_vecAllCudaModuleInfo[i].filename_module = <span class="literal">nullptr</span>;</span><br><span class="line">        m_vecAllCudaModuleInfo[i].exec_path = <span class="literal">nullptr</span>;</span><br><span class="line">        m_vecAllCudaModuleInfo[i].kernels = <span class="number">0</span>;</span><br><span class="line">        m_vecAllCudaModuleInfo[i].global_memory = <span class="number">0</span>;</span><br><span class="line">        m_vecAllCudaModuleInfo[i].texture_references = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( m_vecAllCudaModuleInfo[i].pCUmoduleManager.<span class="built_in">get</span>())&#123;</span><br><span class="line"></span><br><span class="line">            m_vecAllCudaModuleInfo[i].pCUmoduleManager = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m_vecAllCudaModuleInfo[i].function_info.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line"></span><br><span class="line">            m_vecAllCudaModuleInfo[i].function_info[j].cuda_kernels.func_name = <span class="literal">nullptr</span>;</span><br><span class="line">            m_vecAllCudaModuleInfo[i].function_info[j].cuda_kernels.fpCuda = <span class="literal">nullptr</span>;</span><br><span class="line">            m_vecAllCudaModuleInfo[i].function_info[j].cuda_kernels.cuda_function_param.<span class="built_in">clear</span>();</span><br><span class="line">            m_vecAllCudaModuleInfo[i].function_info[j].cuda_kernels.cuda_function_description = <span class="literal">nullptr</span>;</span><br><span class="line">            m_vecAllCudaModuleInfo[i].function_info[j].cuda_kernels.result = CUresult::CUDA_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CCudaPTXScriptFileMgr::GetPTXFileCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//根据yaml描述文件，获取当前的ptx文件数量</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CCudaPTXScriptFileMgr::LoadCurrentPTXFileDescriptionInfo</span><span class="params">(stCudaPTXFileInfo cuda_ptx_file_info)</span></span>&#123;</span><br><span class="line">    <span class="comment">//从yaml中的描述信息创建stCudaFunctionInfo，并将对应的描述信息填充到cuda_function_param和cuda_function_description</span></span><br><span class="line"></span><br><span class="line">    stCudaFunctionInfo cuda_function_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...//</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CCudaPTXScriptFileMgr::InitCudaPTXFile</span><span class="params">(stCudaPTXFileInfo cuda_ptx_file_info)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    cuda_ptx_file_info.pCUmoduleManager = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Load the kernel function and perform color space conversion</span></span><br><span class="line">    cuda_ptx_file_info.pCUmoduleManager =  std::<span class="built_in">make_shared</span>&lt; CUmoduleManager &gt;(cuda_ptx_file_info.filename_module, </span><br><span class="line">        cuda_ptx_file_info.exec_path,</span><br><span class="line">        cuda_ptx_file_info.kernels,</span><br><span class="line">        cuda_ptx_file_info.global_memory,</span><br><span class="line">        cuda_ptx_file_info.texture_references);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (cuda_ptx_file_info.pCUmoduleManager.<span class="built_in">get</span>())&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (vector&lt;stCudaFunctionInfo&gt;::iterator iter = cuda_ptx_file_info.function_info.<span class="built_in">begin</span>(); iter != cuda_ptx_file_info.function_info.<span class="built_in">end</span>(); ++iter) &#123; </span><br><span class="line">            </span><br><span class="line">            (*iter)-&gt;result = cuda_ptx_file_info.pCUmoduleManager-&gt;<span class="built_in">GetCudaFunction</span>((*iter)-&gt;cuda_kernels.func_name,&amp;((*iter)-&gt;cuda_kernels.fpCuda));</span><br><span class="line">            <span class="keyword">if</span>((*iter)-&gt;result == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="comment">//log:warmming</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//log:err</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CCudaPTXScriptFileMgr::Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ptx_description_info_yaml_file_name,<span class="type">const</span> <span class="type">char</span>* ptx_description_info_yaml_file_path,emLoadCudaPtxFileLevel level)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    m_chPTXDescriptionInfoYamlFileName = ptx_description_info_yaml_file_name;</span><br><span class="line">    m_chPTXDescriptionInfoYamlFilePath = ptx_description_info_yaml_file_path;</span><br><span class="line">    m_emLevel = level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据yaml描述文件，加载所有的ptx文件</span></span><br><span class="line">    <span class="type">int</span> nCount = <span class="built_in">GetPTXFileCount</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nCount;i++&gt;)&#123;</span><br><span class="line"></span><br><span class="line">        stCudaPTXFileInfo cuda_ptx_file_info;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Load ptx_info_description_yaml_file</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">InitCudaPTXFile</span>(cuda_ptx_file_info);</span><br><span class="line">        <span class="keyword">if</span>(result != <span class="number">0</span>)&#123;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(m_emLevel == emLoadCudaPtxFileLevel::STRICT_LEVEL)&#123;</span><br><span class="line">                <span class="comment">//log:err</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//log:warmming</span></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_vecAllCudaModuleInfo.<span class="built_in">push</span>(cuda_ptx_file_info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//log:info success</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CCudaPTXScriptFileMgr::Process</span><span class="params">(stCudaFunctionInfo function_info,stCudaDataInfo cuda_data_info)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(function_info.result != CUresult::CUDA_SUCCESS)&#123;</span><br><span class="line">        <span class="comment">//log:err</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *kernelParams[] = &#123;&amp;cuda_data_info.src_data, &amp;cuda_data_info.src_stride, </span><br><span class="line">        &amp;cuda_data_info.dst_data,   &amp;cuda_data_info.dst_stride, </span><br><span class="line">        &amp;cuda_data_info.src_width,  &amp;cuda_data_info.srt_height, </span><br><span class="line">        &amp;cuda_data_info.dst_width,  &amp;cuda_data_info.dst_height, </span><br><span class="line">        &amp;cuda_data_info.function_param&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> **extra =  cuda_data_info.extra_info;</span><br><span class="line"></span><br><span class="line">    CUresult status = <span class="built_in">cuLaunchKernel</span>(cuda_ptx_file_info.cuda_kernels.fpCuda,</span><br><span class="line">        m_grid.x, m_grid.y, m_grid.z, </span><br><span class="line">        m_block.x, m_block.y, m_block.z, </span><br><span class="line">        m_sharedMemBytes, m_CUstream, kernelParams, extra);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(status != CUresult::CUDA_SUCCESS)&#123;</span><br><span class="line">        <span class="comment">//log err:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = <span class="built_in">cuStreamSynchronize</span>(m_CUstream);</span><br><span class="line">    <span class="keyword">if</span>(status != CUresult::CUDA_SUCCESS)&#123;</span><br><span class="line">        <span class="comment">//log err:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CCudaPTXScriptFileMgr::SetCudaKernelCUstream</span><span class="params">(CUstream cuda_stream)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    m_CUstream = cuda_stream;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CCudaPTXScriptFileMgr::SetCudaKernelSharedMemBytes</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> shared_mem_bytes)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    m_sharedMemBytes = shared_mem_bytes;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CCudaPTXScriptFileMgr::SetCudaKernelBlok</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> block_x, <span class="type">unsigned</span> <span class="type">int</span> block_y, <span class="type">unsigned</span> <span class="type">int</span> block_z)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((block_x &gt;<span class="number">0</span>) &amp;&amp; (block_y &gt;<span class="number">0</span>) &amp;&amp; (block_z &gt;<span class="number">0</span>))&#123;</span><br><span class="line"></span><br><span class="line">        m_block.x = block_x;</span><br><span class="line">        m_block.y = block_y;</span><br><span class="line">        m_block.z = block_z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//log:err</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CCudaPTXScriptFileMgr::SetCudaKernelGrid</span><span class="params">(stCudaKernelGridInfo info)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(info.mode == emCudaKernelGridSetMode::CUSTOMIZE_GRID_VALUE)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((info.grid_data.x &gt;<span class="number">0</span>) &amp;&amp; (info.grid_data.y &gt;<span class="number">0</span>) &amp;&amp; (info.grid_data.z &gt;<span class="number">0</span>))&#123;</span><br><span class="line"></span><br><span class="line">            m_grid.x = info.grid_data.x;</span><br><span class="line">            m_grid.y = info.grid_data.y;</span><br><span class="line">            m_grid.z = info.grid_data.z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//log:err</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(info.mode == emCudaKernelGridSetMode::DEFAULT_GRID_VALUE)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((info.grid_data.width &gt;<span class="number">0</span>) &amp;&amp; (info.grid_data.height &gt;<span class="number">0</span>))&#123;</span><br><span class="line">            </span><br><span class="line">            m_grid.x = (info.grid_data.width + (m_block.x - <span class="number">1</span>)) / m_block.x;</span><br><span class="line">            m_grid.y = (info.grid_data.height + (m_block.y - <span class="number">1</span>)) / m_block.y;</span><br><span class="line">            m_grid.z = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//log:err</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//log:err</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CCudaPTXScriptFileMgr::SetParam</span><span class="params">(stCudaKernelParam param)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">SetCudaKernelBlok</span>(param.block_info.x, param.block_info.y, param.block_info.z);</span><br><span class="line">    <span class="keyword">if</span>(result != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//log err:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = <span class="built_in">SetCudaKernelGrid</span>(param.grid_info);</span><br><span class="line">    <span class="keyword">if</span>(result != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//log err:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = <span class="built_in">SetCudaKernelSharedMemBytes</span>(param.shared_mem_bytes)</span><br><span class="line">    <span class="keyword">if</span>(result != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//log err:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = <span class="built_in">SetCudaKernelCUstream</span>(param.cuda_stream)</span><br><span class="line">    <span class="keyword">if</span>(result != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//log err:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//log:info SetCudaKernelParam success</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CUDA学习笔记</title>
      <link href="/2023/10/27/CUDA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/10/27/CUDA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="CUDA介绍"><a href="#CUDA介绍" class="headerlink" title="CUDA介绍"></a>CUDA介绍</h1><p>CUDA是2016年Nvida发布的一种建立在NVIDA的CPUs上的一个通用并行技术平台和编程模型。</p><p>基于CUDA编程可以利用GPUs的并行计算引擎来更高效率的解决复杂的计算难题，因此被广泛应用于深度学习领域。现如今基于GPU的并行计算已经成为了训练深度学习模型的标配，要是实验室连一块GPU都没有，怕是连论文都发不了。</p><p>需要注意的GPU并不是一个独立运行的计算平台，而需要与CPU协同工作，可以看成是CPU的<font color="red">协处理器</font>，因此当我们在说GPU并行计算时，其实是指的基于CPU+GPU的异构计算架构。在异构计算架构中，GPU与CPU通过PCIe总线连接在一起来协同工作，CPU所在位置称为为主机端（host），而GPU所在位置称为设备端（device）,具体示意图如下：</p><p><img src="/./picture/CPU+GPU%E7%9A%84%E5%BC%82%E6%9E%84.png"></p><p>从上图可以看出<font color="red">GPU包括更多的运算核心，其特别适合数据并行的计算密集型任务，如大型矩阵运算，而CPU的运算核心较少，但是其可以实现复杂的逻辑运算，因此其适合控制密集型任务。另外，CPU上的线程是重量级的，上下文切换开销大，但是GPU由于存在很多核心，其线程是轻量级的</font>。因此，基于CPU+GPU的异构计算平台可以优势互补，CPU负责处理逻辑复杂的串行程序，而GPU重点处理数据密集型的并行计算程序，从而发挥最大功效。</p><p>CUDA是NVIDIA公司所开发的GPU编程模型，它提供了GPU编程的简易接口，基于CUDA编程可以构建基于GPU计算的应用程序。CUDA提供了对其它编程语言的支持，如C&#x2F;C++，Python，Fortran等语言，这里我们选择CUDA C&#x2F;C++接口对CUDA编程进行讲解。</p><h1 id="CUDA编程模型基础"><a href="#CUDA编程模型基础" class="headerlink" title="CUDA编程模型基础"></a>CUDA编程模型基础</h1><p>CUDA编程模型是一个异构模型，<font color="red">需要CPU和GPU协同工作</font>。在CUDA中，host和device是两个重要的概念，我们用<font color="red">host指代CPU及其内存，而用device指代GPU及其内存</font>。<font color="yellow">CUDA程序中既包含host程序，又包含device程序，它们分别在CPU和GPU上运行</font>。同时，host与device之间可以进行通信，这样它们之间可以进行数据拷贝。典型的CUDA程序的执行流程如下：</p><ul><li>在CPU上分配host内存，并进行数据初始化；(Allocate CPU memory and init data)</li><li>在GPU上分配device内存，并从host将数据拷贝到device上；((Allocate GPU memory,CPU data copy to GPU)</li><li>调用CUDA的核函数在device上完成指定的运算；(GPU Working)</li><li>将device上的运算结果拷贝到host上；（GPU -&gt; CPU）</li><li>释放device和host上分配的内存。 (free CPU memory and GPU memory)</li></ul><p>上面流程中最重要的一个过程是调用CUDA的核函数来执行并行计算.这边涉及到CUDA中一个重要的概念kernel。</p><p>kernel是在GPU的device上线程中并行执行的一个函数。核函数用__global__符号声明，在调用时需要用&lt;&lt;&lt;grid, block&gt;&gt;&gt;来指定kernel要执行的线程数量，在CUDA中，每一个线程都要执行核函数，并且每个线程会分配一个唯一的线程号thread ID，这个ID值可以通过核函数的内置变量threadIdx来获得。</p><p>由于GPU实际上是异构模型，所以需要区分host和device上的代码，在CUDA中是通过函数类型限定词开区别host和device上的函数，主要的<font color="red">三个函数类型</font>限定词如下：</p><ul><li><strong>global</strong>：在device上执行，从host中调用（一些特定的GPU也可以从device上调用），返回类型必须是void，不支持可变参数参数，不能成为类成员函数。注意用__global__定义的kernel是异步的，这意味着host不会等待kernel执行完就执行下一步。</li><li><strong>device</strong>：在device上执行，单仅可以从device中调用，不可以和__global__同时用。</li><li><strong>host</strong>：在host上执行，仅可以从host上调用，一般省略不写，不可以和__global__同时用，但可和__device__，此时函数会在device和host都编译。</li></ul><p>由于GPU上面有很多并行化的轻量级线程，因此借助了线程间切换花销小这一特点。kernel在GPU上分配的device上执行的时候，实际上也是启动了非常多的线程，这里将一个kernel所启动的所有线程称为一个网格（grid）。grid内的所有线程共享相同的全局内存空间。<br>同时每个grid又可以分成很多个线程块（block）。而一个线程块里面又包含了很多的线程。</p><p><img src="/./picture/Kerne%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><pre><code>dim3 grid(3, 2);dim3 block(5, 3);kernel_fun&lt;&lt;&lt; grid, block &gt;&gt;&gt;(prams...);</code></pre><p>如图所示，这是一个gird和block均为2-dim的线程组织。grid和block都是定义为dim3类型的变量，dim3可以看成是包含三个无符号整数（x，y，z）成员的结构体变量，在定义时，缺省值初始化为1。因此grid和block可以灵活地定义为1-dim，2-dim以及3-dim结构，对于图中结构（主要水平方向为x轴），定义的grid和block如下所示，kernel在调用时也必须通过执行配置&lt;&lt;&lt;grid, block&gt;&gt;&gt;来指定kernel所使用的线程数及结构。</p><p><a href="https://zhuanlan.zhihu.com/p/34587739">https://zhuanlan.zhihu.com/p/34587739</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>libswresample音频重采样</title>
      <link href="/2023/10/18/libswresample%E9%9F%B3%E9%A2%91%E9%87%8D%E9%87%87%E6%A0%B7/"/>
      <url>/2023/10/18/libswresample%E9%9F%B3%E9%A2%91%E9%87%8D%E9%87%87%E6%A0%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ffmpeg有两套重采样方案：</p><ul><li><a href="https://blog.51cto.com/u_13861442/5252100">libswresample</a></li><li>AVAudioResampleContext(已废弃)</li></ul><p>除此之外还有一套：</p><ul><li><a href="https://github.com/erikd/libsamplerate">libsamplerate</a></li></ul><p>在实际产品开发测试过程中发现，libsamplerate在进行音频Clip的衔接处的处理会比libswresample的效果好，衔接处不容易产生毛刺的情况，因此本章节将讲述如何使用libsamplerate这个第三方库来进行音频的重采样．</p><h1 id="相关平台的编译"><a href="#相关平台的编译" class="headerlink" title="相关平台的编译"></a>相关平台的编译</h1><p>首先到github上下载<a href="https://github.com/erikd/libsamplerate">libsamplerate</a>，并切换到对应的版本分支．</p><p>同时，为了能够调试libsamplerate中的例程，我们还需要下载<a href="https://github.com/libsndfile/libsndfile/releases/download/1.2.2/libsndfile-1.2.2.tar.xz">libsndfile</a>和<a href="https://www.fftw.org/fftw-3.3.10.tar.gz">fftw</a></p><p>下载</p><h2 id="Linux平台的编译"><a href="#Linux平台的编译" class="headerlink" title="Linux平台的编译"></a>Linux平台的编译</h2><p>将以上下载到&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;libsamplerate路径下，解压对应压缩包．</p><p>首先是编译Debug版本的libsamplerate，需要先编译libsndfile和fftw</p><p>Debug:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">cd libsndfile<span class="number">-1.2</span><span class="number">.2</span></span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr    \</span><br><span class="line">            --docdir=/usr/share/doc/libsndfile<span class="number">-1.2</span><span class="number">.2</span> &amp;&amp;</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">cd ../fftw<span class="number">-3.3</span><span class="number">.10</span></span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr    \</span><br><span class="line">            --enable-shared  \</span><br><span class="line">            --disable-<span class="type">static</span> \</span><br><span class="line">            --enable-threads \</span><br><span class="line">            --enable-sse2    \</span><br><span class="line">            --enable-avx     \</span><br><span class="line">            --enable-avx2    &amp;&amp;</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">cd ../libsamplerate<span class="number">-0.1</span><span class="number">.9</span></span><br><span class="line"></span><br><span class="line">mkdir build_linux</span><br><span class="line"></span><br><span class="line">mkdir install_linux</span><br><span class="line"></span><br><span class="line">cd build_linux</span><br><span class="line"></span><br><span class="line">../configure --prefix=<span class="string">&#x27;/home/ws/Desktop/libsamplerate/libsamplerate-0.1.9/install_linux/Debug&#x27;</span> --enable-debug</span><br><span class="line">    </span><br><span class="line">make</span><br><span class="line">make install　</span><br></pre></td></tr></table></figure><p>Release:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    ../configure --prefix=<span class="string">&#x27;/home/ws/Desktop/libsamplerate/libsamplerate-0.1.9/install_linux/Release&#x27;</span></span><br><span class="line">make</span><br><span class="line">make install　</span><br></pre></td></tr></table></figure><h2 id="Mac平台的编译"><a href="#Mac平台的编译" class="headerlink" title="Mac平台的编译"></a>Mac平台的编译</h2><h2 id="Windows平台的编译"><a href="#Windows平台的编译" class="headerlink" title="Windows平台的编译"></a>Windows平台的编译</h2><h1 id="配置VSCode调试脚本"><a href="#配置VSCode调试脚本" class="headerlink" title="配置VSCode调试脚本"></a>配置VSCode调试脚本</h1><p>举例Linux端，其他平台类似</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) sndfile-resample&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/ws/Desktop/libsamplerate/libsamplerate-0.1.9/install_linux/Debug/bin/sndfile-resample&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;--version&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/ws/Desktop/libsamplerate/libsamplerate-0.1.9/install_linux/Debug/bin&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LD_LIBRARY_PATH&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;LD_LIBRARY_PATH&#125;:/home/ws/Desktop/libsamplerate/libsamplerate-0.1.9/install_linux/Debug/lib&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++ Runner: Debug Session&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/ws/Desktop/libsamplerate/libsamplerate-0.1.9/install_linux/Debug/bin&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/ws/Desktop/libsamplerate/libsamplerate-0.1.9/install_linux/Debug/bin/Debug/outDebug&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="调试sndfile-resample"><a href="#调试sndfile-resample" class="headerlink" title="调试sndfile-resample"></a>调试sndfile-resample</h1><p>首先用ffmpeg命令行生成测试文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i &#x27;/home/ws/Videos/1.mp4&#x27; -vn -acodec pcm_s16le -ar 48000 -ac 2 &#x27;/home/ws/Videos/48000-2ch_32.wav&#x27; </span><br></pre></td></tr></table></figure><p>接着，修改launch.json脚本<br>将:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;--version&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>改成:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;-to&quot;</span><span class="punctuation">,</span><span class="string">&quot;44100&quot;</span><span class="punctuation">,</span><span class="string">&quot;/home/ws/Videos/48000-2ch_32.wav&quot;</span><span class="punctuation">,</span><span class="string">&quot;/home/ws/Videos/44100.wav&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>然后运行即可开始调试</p><p><a href="https://blog.csdn.net/weixin_41965270/article/details/81272732?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=libsamplerate&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-81272732.142%5Ev93%5Econtrol&amp;spm=1018.2226.3001.4449">https://blog.csdn.net/weixin_41965270/article/details/81272732?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=libsamplerate&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-81272732.142^v93^control&amp;spm=1018.2226.3001.4449</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu上安装FFmpeg</title>
      <link href="/2023/10/13/Ubuntu%E4%B8%8A%E5%AE%89%E8%A3%85FFmpeg/"/>
      <url>/2023/10/13/Ubuntu%E4%B8%8A%E5%AE%89%E8%A3%85FFmpeg/</url>
      
        <content type="html"><![CDATA[<p>&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff</p><p>sudo apt install yum</p><p>curl -O -L <a href="https://www.nasm.us/pub/nasm/releasebuilds/2.15.05/nasm-2.15.05.tar.bz2">https://www.nasm.us/pub/nasm/releasebuilds/2.15.05/nasm-2.15.05.tar.bz2</a><br>tar xjvf nasm-2.15.05.tar.bz2<br>cd nasm-2.15.05<br>.&#x2F;autogen.sh<br>.&#x2F;configure –prefix&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” –bindir&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin”<br>make<br>make install</p><p>curl -O -L <a href="https://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gz">https://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gz</a><br>tar xzvf yasm-1.3.0.tar.gz<br>cd yasm-1.3.0<br>.&#x2F;configure –prefix&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” –bindir&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin”<br>make<br>make install</p><p>cd x264<br>PKG_CONFIG_PATH&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build&#x2F;lib&#x2F;pkgconfig” .&#x2F;configure –prefix&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” –bindir&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin” –enable-static<br>make<br>make install</p><p>cmake -S &#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;x265_git&#x2F;source -B .</p><p>cd ~&#x2F;ffmpeg_sources&#x2F;x265_git&#x2F;build&#x2F;linux<br>cmake -G “Unix Makefiles” -DCMAKE_INSTALL_PREFIX&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” -DENABLE_SHARED:bool&#x3D;off ..&#x2F;..&#x2F;source<br>make<br>make install</p><p>cd fdk-aac<br>autoreconf -fiv<br>.&#x2F;configure –prefix&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” –disable-shared<br>make<br>make install</p><p>cd lame-3.100<br>.&#x2F;configure –prefix&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” –bindir&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin” –disable-shared –enable-nasm<br>make<br>make install</p><p>sudo apt-get install automake<br>sudo apt-get install autoconf m4 perl</p><p>sudo apt-get update<br>sudo apt-get install aclocal-1.16</p><p><a href="https://blog.csdn.net/yuchunhai321/article/details/122937524">https://blog.csdn.net/yuchunhai321/article/details/122937524</a></p><p>cd opus-1.3.1<br>.&#x2F;configure –prefix&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” –disable-shared<br>make<br>make install</p><p>cd libvpx<br>.&#x2F;configure –prefix&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” –disable-examples –disable-unit-tests –enable-vp9-highbitdepth –as&#x3D;yasm –disable-shared<br>make<br>make install</p><p>编译libpng:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.sourceforge.net/libpng/libpng-1.6.39.tar.gz</span><br><span class="line"></span><br><span class="line">cd ./libpng-1.6.39</span><br><span class="line">./configure --prefix=/home/ws/Desktop/GitDemo/WES_WEBM_PLPHA_PREMULTIPLY/ff/ffmpeg_build --enable-shared --enable-static</span><br><span class="line">make -j</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>编译libopenjpeg:</p><p>&#96;&#96;&#96;<br>git clone -b version.2.1 <a href="https://github.com/uclouvain/openjpeg">https://github.com/uclouvain/openjpeg</a><br>cd .&#x2F;openjpeg<br>mkdir build<br>cd build<br>cmake -D CMAKE_BUILD_TYPE&#x3D;RELEASE <br>    -D CMAKE_INSTALL_PREFIX&#x3D;&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build -D BUILD_SHARED_LIBS&#x3D;OFF ..&#x2F;</p><p>make<br>make install</p><p>cd libwep<br>.&#x2F;configure –prefix&#x3D;&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build –enable-shared –enable-static<br>make -j<br>make install</p><p>LDFLAGS&#x3D;”-static” PATH&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin:$PATH” PKG_CONFIG_PATH&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build&#x2F;lib&#x2F;pkgconfig” .&#x2F;configure   –prefix&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build”   –pkg-config-flags&#x3D;”–static”   –extra-cflags&#x3D;”-I&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build&#x2F;include”   –extra-ldflags&#x3D;”-L&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build&#x2F;lib”   –extra-libs&#x3D;-lpthread   –extra-libs&#x3D;-lm   –bindir&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin”  –enable-gpl –enable-libfdk_aac –enable-libopus –enable-libvpx –enable-libx264 –disable-libx265 –enable-nonfree –enable-decoder&#x3D;png –enable-encoder&#x3D;png –enable-decoder&#x3D;bmp –enable-encoder&#x3D;bmp –enable-gray –enable-libopenjpeg –enable-libwebp –disable-hwaccels –disable-indevs –disable-outdevs –disable-vaapi<br>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;<br>tar -czvf web预乘Ubuntu18版本的ffmpeg.tar.gz &lt;要压缩的文件夹路径&gt;</p><p>wget <a href="https://www.nasm.us/pub/nasm/releasebuilds/2.16.01/nasm-2.16.01.tar.bz2">https://www.nasm.us/pub/nasm/releasebuilds/2.16.01/nasm-2.16.01.tar.bz2</a> &amp;&amp; <br>tar xjvf nasm-2.16.01.tar.bz2 &amp;&amp; <br>cd nasm-2.16.01 &amp;&amp; <br>.&#x2F;autogen.sh &amp;&amp; <br>PATH&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin:$PATH” .&#x2F;configure –prefix&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” –bindir&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin” &amp;&amp; <br>make &amp;&amp; <br>make install</p><p>curl -O -L <a href="https://www.nasm.us/pub/nasm/releasebuilds/2.15.05/nasm-2.15.05.tar.bz2">https://www.nasm.us/pub/nasm/releasebuilds/2.15.05/nasm-2.15.05.tar.bz2</a><br>tar xjvf nasm-2.15.05.tar.bz2<br>cd nasm-2.15.05<br>.&#x2F;autogen.sh<br>.&#x2F;configure –prefix&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” –bindir&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin”<br>make<br>make install</p><p>curl -O -L <a href="https://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gz">https://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gz</a><br>tar xzvf yasm-1.3.0.tar.gz<br>cd yasm-1.3.0<br>.&#x2F;configure –prefix&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” –bindir&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin”<br>make<br>make install</p><p>git -C x264 pull 2&gt; &#x2F;dev&#x2F;null || git clone –depth 1 <a href="https://code.videolan.org/videolan/x264.git">https://code.videolan.org/videolan/x264.git</a> &amp;&amp; <br>cd x264 &amp;&amp; <br>PATH&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin:$PATH” PKG_CONFIG_PATH&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build&#x2F;lib&#x2F;pkgconfig” .&#x2F;configure –prefix&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” –bindir&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin” –enable-static –enable-pic &amp;&amp; <br>PATH&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin:$PATH” make &amp;&amp; <br>make install</p><p>sudo apt-get install libnuma-dev &amp;&amp; <br>wget -O x265.tar.bz2 <a href="https://bitbucket.org/multicoreware/x265_git/get/master.tar.bz2">https://bitbucket.org/multicoreware/x265_git/get/master.tar.bz2</a> &amp;&amp; <br>tar xjvf x265.tar.bz2 &amp;&amp; <br>cd multicoreware*&#x2F;build&#x2F;linux &amp;&amp; <br>PATH&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin:$PATH” cmake -G “Unix Makefiles” -DCMAKE_INSTALL_PREFIX&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” -DENABLE_SHARED&#x3D;off ..&#x2F;..&#x2F;source &amp;&amp; <br>PATH&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin:$PATH” make &amp;&amp; <br>make install</p><p>git -C libvpx pull 2&gt; &#x2F;dev&#x2F;null || git clone –depth 1 <a href="https://chromium.googlesource.com/webm/libvpx.git">https://chromium.googlesource.com/webm/libvpx.git</a> &amp;&amp; <br>cd libvpx &amp;&amp; <br>PATH&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin:$PATH” .&#x2F;configure –prefix&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” –disable-examples –disable-unit-tests –enable-vp9-highbitdepth –as&#x3D;yasm &amp;&amp; <br>PATH&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin:$PATH” make &amp;&amp; <br>make install</p><p>git -C fdk-aac pull 2&gt; &#x2F;dev&#x2F;null || git clone –depth 1 <a href="https://github.com/mstorsjo/fdk-aac">https://github.com/mstorsjo/fdk-aac</a> &amp;&amp; <br>cd fdk-aac &amp;&amp; <br>autoreconf -fiv &amp;&amp; <br>.&#x2F;configure –prefix&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” –disable-shared &amp;&amp; <br>make &amp;&amp; <br>make install</p><p>git -C opus pull 2&gt; &#x2F;dev&#x2F;null || git clone –depth 1 <a href="https://github.com/xiph/opus.git">https://github.com/xiph/opus.git</a> &amp;&amp; <br>cd opus &amp;&amp; <br>.&#x2F;autogen.sh &amp;&amp; <br>.&#x2F;configure –prefix&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” –disable-shared &amp;&amp; <br>make &amp;&amp; <br>make install</p><p>git -C aom pull 2&gt; &#x2F;dev&#x2F;null || git clone –depth 1 <a href="https://aomedia.googlesource.com/aom">https://aomedia.googlesource.com/aom</a> &amp;&amp; <br>mkdir -p aom_build &amp;&amp; <br>cd aom_build &amp;&amp; <br>PATH&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin:$PATH” cmake -G “Unix Makefiles” -DCMAKE_INSTALL_PREFIX&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” -DENABLE_TESTS&#x3D;OFF -DENABLE_NASM&#x3D;on ..&#x2F;aom &amp;&amp; <br>PATH&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin:$PATH” make &amp;&amp; <br>make install</p><p>git -C SVT-AV1 pull 2&gt; &#x2F;dev&#x2F;null || git clone <a href="https://gitlab.com/AOMediaCodec/SVT-AV1.git">https://gitlab.com/AOMediaCodec/SVT-AV1.git</a> &amp;&amp; <br>mkdir -p SVT-AV1&#x2F;build &amp;&amp; <br>cd SVT-AV1&#x2F;build &amp;&amp; <br>PATH&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin:$PATH” cmake -G “Unix Makefiles” -DCMAKE_INSTALL_PREFIX&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” -DCMAKE_BUILD_TYPE&#x3D;Release -DBUILD_DEC&#x3D;OFF -DBUILD_SHARED_LIBS&#x3D;OFF .. &amp;&amp; <br>PATH&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin:$PATH” make &amp;&amp; <br>make install</p><p>sudo apt-get install python3-pip &amp;&amp; <br>pip3 install –user meson</p><p>git -C dav1d pull 2&gt; &#x2F;dev&#x2F;null || git clone –depth 1 <a href="https://code.videolan.org/videolan/dav1d.git">https://code.videolan.org/videolan/dav1d.git</a> &amp;&amp; <br>mkdir -p dav1d&#x2F;build &amp;&amp; <br>cd dav1d&#x2F;build &amp;&amp; <br>meson setup -Denable_tools&#x3D;false -Denable_tests&#x3D;false –default-library&#x3D;static .. –prefix “&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” –libdir&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build&#x2F;lib” &amp;&amp; <br>ninja &amp;&amp; <br>ninja install</p><p>wget <a href="https://github.com/Netflix/vmaf/archive/v2.3.1.tar.gz">https://github.com/Netflix/vmaf/archive/v2.3.1.tar.gz</a> &amp;&amp; <br>tar xvf v2.3.1.tar.gz &amp;&amp; <br>mkdir -p vmaf-2.3.1&#x2F;libvmaf&#x2F;build &amp;&amp;<br>cd vmaf-2.3.1&#x2F;libvmaf&#x2F;build &amp;&amp; <br>meson setup -Denable_tests&#x3D;false -Denable_docs&#x3D;false –buildtype&#x3D;release –default-library&#x3D;static .. –prefix “&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” –bindir&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin” –libdir&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build&#x2F;lib” &amp;&amp; <br>ninja &amp;&amp; <br>ninja install</p><p>sudo apt-get install libgnutls28-dev</p><p>wget -O ffmpeg-snapshot.tar.bz2 <a href="https://ffmpeg.org/releases/ffmpeg-snapshot.tar.bz2">https://ffmpeg.org/releases/ffmpeg-snapshot.tar.bz2</a> &amp;&amp; <br>tar xjvf ffmpeg-snapshot.tar.bz2 &amp;&amp; <br>cd ffmpeg &amp;&amp; <br>PATH&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin:$PATH” PKG_CONFIG_PATH&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build&#x2F;lib&#x2F;pkgconfig” .&#x2F;configure <br>  –prefix&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” <br>  –pkg-config-flags&#x3D;”–static” <br>  –extra-cflags&#x3D;”-I&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build&#x2F;include” <br>  –extra-ldflags&#x3D;”-L&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build&#x2F;lib” <br>  –extra-libs&#x3D;”-lpthread -lm” <br>  –ld&#x3D;”g++” <br>  –bindir&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin” <br>  –enable-gpl <br>  –enable-gnutls <br>  –enable-libaom <br>  –enable-libass <br>  –enable-libfdk-aac <br>  –enable-libfreetype <br>  –enable-libmp3lame <br>  –enable-libopus <br>  –enable-libsvtav1 <br>  –enable-libdav1d <br>  –enable-libvorbis <br>  –enable-libvpx <br>  –enable-libx264 <br>  –enable-libx265 <br>  –enable-nonfree <br>  –enable-debug <br>  –disable-x86asm <br>  –disable-stripping　&amp;&amp; <br>PATH&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin:$PATH” make &amp;&amp; <br>make install &amp;&amp; <br>hash -r</p><p>PATH&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin:$PATH” PKG_CONFIG_PATH&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build&#x2F;lib&#x2F;pkgconfig” .&#x2F;configure <br>  –prefix&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build” <br>  –pkg-config-flags&#x3D;”–static” <br>  –extra-cflags&#x3D;”-I&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build&#x2F;include” <br>  –extra-ldflags&#x3D;”-L&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build&#x2F;lib” <br>  –extra-libs&#x3D;”-lpthread -lm” <br>  –ld&#x3D;”g++” <br>  –bindir&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin” <br>  –enable-gpl <br>  –enable-gnutls <br>  –enable-libaom <br>  –enable-libass <br>  –enable-libfdk-aac <br>  –enable-libfreetype <br>  –enable-libmp3lame <br>  –enable-libopus <br>  –enable-libsvtav1 <br>  –enable-libdav1d <br>  –enable-libvorbis <br>  –enable-libvpx <br>  –enable-libx264 <br>  –enable-libx265 <br>  –enable-nonfree <br>  –enable-debug&#x3D;3 <br>  –disable-optimizations –disable-x86asm –extra-cflags&#x3D;-g –disable-stripping &amp;&amp; <br>PATH&#x3D;”&#x2F;home&#x2F;ws&#x2F;Desktop&#x2F;GitDemo&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin:$PATH” make &amp;&amp; <br>make install &amp;&amp; <br>hash -r</p><p>sudo apt-get update -qq &amp;&amp; sudo apt-get -y install autoconf automake  build-essential  cmake  git-core  ibass-dev  libfreetype6-dev  libgnutls28-dev libmp3lame-dev libsdl2-dev libtool libva-dev libvdpau-dev libvorbis-dev libxcb1-dev libxcb-shm0-dev libxcb-xfixes0-dev meson  inja-build pkg-config texinfo wget yasm zlib1g-dev</p><p>sudo apt install libunistring-dev libaom-dev libdav1d-dev</p><p>将下面这个ffmpeg命令修改成launch.json的”args”<br>.&#x2F;ffmpeg　-c:v libvpx -i &#x2F;home&#x2F;ws&#x2F;Videos&#x2F;input.webm -vcodec vp8 -auto-alt-ref 0 -vf “scale&#x3D;’min(896,trunc(iw&#x2F;2&#x2F;2)*2)’ :’min(504,trunc(ih&#x2F;2&#x2F;2)*2)’:force_original_aspect_ratio&#x3D;decrease:force_divisible_by&#x3D;2” -acodec copy &#x2F;home&#x2F;ws&#x2F;Videos&#x2F;output.webm</p><p>ffmpeg -i input.webm -metadata ffmpeg_version&#x3D;”$(ffmpeg -version | grep ‘ffmpeg version’ | cut -d’ ‘ -f3)” output.webm</p><p>int main(int argc, char **argv)<br>{<br>    Scheduler *sch &#x3D; NULL;<br>    AVFormatContext *format_ctx &#x3D; NULL;</p><pre><code>int ret;BenchmarkTimeStamps ti;init_dynload();setvbuf(stderr,NULL,_IONBF,0); /* win32 runtime needs this */av_log_set_flags(AV_LOG_SKIP_REPEATED);parse_loglevel(argc, argv, options);</code></pre><p>#if CONFIG_AVDEVICE<br>    avdevice_register_all();<br>#endif<br>    avformat_network_init();</p><pre><code>show_banner(argc, argv, options);sch = sch_alloc();if (!sch) &#123;    ret = AVERROR(ENOMEM);    goto finish;&#125;/* parse options and open all input/output files */ret = ffmpeg_parse_options(argc, argv, sch);if (ret &lt; 0)    goto finish;ret = avformat_find_stream_info(format_ctx, NULL);if (ret &lt; 0) &#123;    av_log(NULL, AV_LOG_ERROR, &quot;Failed to retrieve stream information\n&quot;);    goto finish;&#125;// Retrieve FFmpeg versionif (format_ctx-&gt;iformat &amp;&amp; strcmp(format_ctx-&gt;iformat-&gt;name, &quot;webm&quot;) == 0) &#123;    av_log(NULL, AV_LOG_INFO, &quot;FFmpeg version: %s\n&quot;, av_version_info());&#125;if (nb_output_files &lt;= 0 &amp;&amp; nb_input_files == 0) &#123;    show_usage();    av_log(NULL, AV_LOG_WARNING, &quot;Use -h to get full help or, even better, run &#39;man %s&#39;\n&quot;, program_name);    ret = 1;    goto finish;&#125;if (nb_output_files &lt;= 0) &#123;    av_log(NULL, AV_LOG_FATAL, &quot;At least one output file must be specified\n&quot;);    ret = 1;    goto finish;&#125;current_time = ti = get_benchmark_time_stamps();ret = transcode(sch);if (ret &gt;= 0 &amp;&amp; do_benchmark) &#123;    int64_t utime, stime, rtime;    current_time = get_benchmark_time_stamps();    utime = current_time.user_usec - ti.user_usec;    stime = current_time.sys_usec  - ti.sys_usec;    rtime = current_time.real_usec - ti.real_usec;    av_log(NULL, AV_LOG_INFO,           &quot;bench: utime=%0.3fs stime=%0.3fs rtime=%0.3fs\n&quot;,           utime / 1000000.0, stime / 1000000.0, rtime / 1000000.0);&#125;ret = received_nb_signals                 ? 255 :      (ret == FFMPEG_ERROR_RATE_EXCEEDED) ?  69 : ret;</code></pre><p>finish:<br>    if (ret &#x3D;&#x3D; AVERROR_EXIT)<br>        ret &#x3D; 0;</p><pre><code>ffmpeg_cleanup(ret);sch_free(&amp;sch);return ret;</code></pre><p>}</p><p>WES_WEBM_ALPHA_PREMULTIPLY_MACRO</p><p>void SetInputFileMetaDataEncoderValue(char* value)</p><p>ffmpeg修改源代码，将webm文件源的Lavf55.36.101写入到生成的webm文件中</p><p>Lavf60.20.100</p><p>encoder　encoding_tool</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Alpine上安装ffmpeg</title>
      <link href="/2023/10/09/Alpine%E4%B8%8A%E5%AE%89%E8%A3%85ffmpeg/"/>
      <url>/2023/10/09/Alpine%E4%B8%8A%E5%AE%89%E8%A3%85ffmpeg/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本章着重讲述一下，如何在Alpine Linux系统上进行ffmpeg的源代码编译工作，其他Linux系统编译步骤基本一致</p><h1 id="系统编译开发环境的搭建"><a href="#系统编译开发环境的搭建" class="headerlink" title="系统编译开发环境的搭建"></a>系统编译开发环境的搭建</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apk update &amp;&amp; apk add gcc g++ make git gnutls gnutls-dev gnutls-c++ pkgconfig perl perl-net-ssleay perl-io-socket-ssl perl-libwww openssh autoconf automake libtool cmake nasm yasm</span><br></pre></td></tr></table></figure><p>相关编译步骤是参考<a href="https://trac.ffmpeg.org/wiki/CompilationGuide/Centos">官方文档</a>进行编译的进行编译的，读者请先阅读完成该文章后再看本章的后续内容．</p><p>下面列举了当时我在k8s的docker上对于ffmpeg源码的confiure配置信息</p><pre><code>PATH=&quot;/data/www/vhosts/crontask/public/ffmpeg_6.0/bin:$PATH&quot; PKG_CONFIG_PATH=&quot;/data/www/vhosts/crontask/public/ffmpeg_6.0/ffmpeg_build/lib/pkgconfig&quot; ./configure   --prefix=&quot;/data/www/vhosts/crontask/public/ffmpeg_6.0/ffmpeg_build&quot;   --pkg-config-flags=&quot;--static&quot;   --extra-cflags=&quot;-I/data/www/vhosts/crontask/public/ffmpeg_6.0/ffmpeg_build/include&quot;   --extra-ldflags=&quot;-L/data/www/vhosts/crontask/public/ffmpeg_6.0/ffmpeg_build/lib&quot;   --extra-libs=-lpthread   --extra-libs=-lm   --bindir=&quot;/data/www/vhosts/crontask/public/ffmpeg_6.0/bin&quot;   --enable-gpl   --enable-libfdk_aac  --enable-libopus   --enable-libvpx   --enable-libx264   --disable-libx265   --enable-nonfree --disable-hwaccels --disable-indevs --disable-outdevs --disable-vaapi/data/www/vhosts/crontask/public/ffmpeg_6.0/bin:是最终ffmpeg 生成的可执行文件路径/data/www/vhosts/crontask/public/ffmpeg_6.0/ffmpeg_build/lib:是其他第三方插件(.so or .a)的生成路径，对应给ffmpeg源码识别的pkg　config信息在当前路径下的pkgconfig文件夹</code></pre><p>上述configure是生成静态库的ffmpeg文件，具体最终生成的ffmpeg的相关依赖可以通过命令ldd -r .&#x2F;ffmpeg来查看，由于我编译的第三方插件库均为静态库(.a) ,且ffmpeg也configure信息：–pkg-config-flags&#x3D;”–static”，因此均为静态链接．</p><p>对于用户而言，enable和disable哪些插件，需用户根据实际情况进行选择，用户可根据以下两条命令查看对应的编码解码插件支持有哪些：</p><pre><code>./configure –list-decoders./configure --list-encoders</code></pre><p>由于本次编译的目的是为了实现对图片类：png bmp jpg webp，视频文件:webm mp4 flv的支持，因此只针对性的enable了一部分编解码插件，同时为了保障整体编解码转换成功率，还禁止了I卡的硬件加速(vaapi).</p><p>以下是我在编译时，用到的第三方插件的相关编译步骤</p><p>编译libpng:</p><pre><code>wget https://download.sourceforge.net/libpng/libpng-1.6.39.tar.gzcd ./libpng-1.6.39./configure --prefix=/data/www/vhosts/crontask/public/ffmpeg_6.0/ffmpeg_build --enable-shared --enable-staticmake -jmakeinstall</code></pre><p>编译libopenjpeg:</p><pre><code>git clone -b version.2.1 https://github.com/uclouvain/openjpegcd ./openjpegmkdir buildcd buildcmake -D CMAKE_BUILD_TYPE=RELEASE \    -D CMAKE_INSTALL_PREFIX=/data/www/vhosts/crontask/public/ffmpeg_6.0/ffmpeg_build -D BUILD_SHARED_LIBS=OFF ../makemake install</code></pre><p>PS:<br>如果在编译opus报错WARNING: ‘aclocal-1.15’ is missing on your system的话，<br>查看一下版本：</p><pre><code>aclocal --version</code></pre><p>执行：</p><pre><code>autoreconf -f -i</code></pre><p>即可</p><p>PATH&#x3D;”&#x2F;data&#x2F;www&#x2F;vhosts&#x2F;crontask&#x2F;public&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin:$PATH” PKG_CONFIG_PATH&#x3D;”&#x2F;data&#x2F;www&#x2F;vhosts&#x2F;crontask&#x2F;public&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build&#x2F;lib&#x2F;pkgconfig” .&#x2F;configure   –prefix&#x3D;”&#x2F;data&#x2F;www&#x2F;vhosts&#x2F;crontask&#x2F;public&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build”   –pkg-config-flags&#x3D;”–static”   –extra-cflags&#x3D;”-I&#x2F;data&#x2F;www&#x2F;vhosts&#x2F;crontask&#x2F;public&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build&#x2F;include”   –extra-ldflags&#x3D;”-L&#x2F;data&#x2F;www&#x2F;vhosts&#x2F;crontask&#x2F;public&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;ffmpeg_build&#x2F;lib”   –extra-libs&#x3D;-lpthread   –extra-libs&#x3D;-lm   –bindir&#x3D;”&#x2F;data&#x2F;www&#x2F;vhosts&#x2F;crontask&#x2F;public&#x2F;WES_WEBM_PLPHA_PREMULTIPLY&#x2F;ff&#x2F;bin”  –enable-gpl –enable-libfdk_aac –enable-libopus –enable-libvpx –enable-libx264 –disable-libx265 –enable-nonfree –enable-decoder&#x3D;png –enable-encoder&#x3D;png –enable-decoder&#x3D;bmp –enable-encoder&#x3D;bmp –enable-gray –enable-libopenjpeg –enable-libwebp –disable-hwaccels –disable-indevs –disable-outdevs –disable-vaapi</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL和CUDA的互操作</title>
      <link href="/2023/08/03/OpenGL%E5%92%8CCUDA%E7%9A%84%E4%BA%92%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/08/03/OpenGL%E5%92%8CCUDA%E7%9A%84%E4%BA%92%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ImageOpenGL.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;helper_cuda_drvapi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cudaGL.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">CUDA OpenGL互操作:</span></span><br><span class="line"><span class="comment">    1.在OpenGL中分配和图像相同大小的PBO 和texture</span></span><br><span class="line"><span class="comment">    2.将PBO (unpack buffer）映射到CUDA地址空间</span></span><br><span class="line"><span class="comment">    3.将图像写人到映射后的空间内</span></span><br><span class="line"><span class="comment">    4.Unmap PBO并且使用PBO创建texture</span></span><br><span class="line"><span class="comment">    5.在framebuffer中进行绘制</span></span><br><span class="line"><span class="comment">    6.将framebuffer中的内容读到pack buffer中，并将其映射到CUDA地址空间中</span></span><br><span class="line"><span class="comment">    7.将地址中的内容写到输出帧中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ImageOpenGL::<span class="built_in">ImageOpenGL</span>(CUcontext cudaContext,</span><br><span class="line">                 <span class="type">unsigned</span> <span class="type">int</span> nDispWidth, <span class="type">unsigned</span> <span class="type">int</span> nDispHeight,</span><br><span class="line">                 <span class="type">unsigned</span> <span class="type">int</span> nTexWidth,  <span class="type">unsigned</span> <span class="type">int</span> nTexHeight,</span><br><span class="line">                 <span class="type">bool</span> bIsProgressive,</span><br><span class="line"> PixelFormat ePixelFormat)</span><br><span class="line">:<span class="built_in">ImageOpenGLBase</span>(nDispWidth, nDispHeight, nTexWidth, nTexHeight, bIsProgressive, ePixelFormat)</span><br><span class="line">, <span class="built_in">pFile_</span>(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setCUDAcontext</span>(cudaContext);</span><br><span class="line">    <span class="built_in">createresource</span>(nDispWidth, nDispHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageOpenGL::createresource</span><span class="params">(<span class="type">int</span> nwidth, <span class="type">int</span> nheight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nFrames = bIsProgressive_ ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    nWidth_ = nwidth;</span><br><span class="line">    nHeight_ = nheight;</span><br><span class="line">    nTexWidth_ = nwidth;</span><br><span class="line">    nTexHeight_ = nheight;</span><br><span class="line"></span><br><span class="line">std::mutex* pmutex = (std::mutex*)<span class="built_in">GetOpenGLLock</span>();</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(*pmutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_PBO_BUFFER</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.在OpenGL中分配和图像相同大小的PBO 和texture</span></span><br><span class="line">    <span class="comment">// Prepare OpenGL buffer object for uploading texture data</span></span><br><span class="line">    <span class="built_in">glGenBuffersARB</span>(nFrames, m_GLuintPBO);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; nFrames; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//向OpenGL里传输内容时需要GL_PIXEL_UNPACK_BUFFER，从OpenGL里往外传输内容时需要GL_PIXEL_PACK_BUFFER</span></span><br><span class="line">        <span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, m_GLuintPBO[n]);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NV_ENC_BUFFER_FORMAT_NV12_TYPE        </span></span><br><span class="line">        <span class="built_in">glBufferDataARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, nTexWidth_* nTexHeight_* <span class="number">3</span> / <span class="number">2</span>, <span class="literal">NULL</span>, GL_STREAM_DRAW_ARB);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">glBufferDataARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, nTexWidth_* nTexHeight_*<span class="number">4</span>, <span class="literal">NULL</span>, GL_STREAM_DRAW_ARB);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create OpenGL texture and upload frame data</span></span><br><span class="line">    <span class="comment">// create texture for display</span></span><br><span class="line">    m_pGLuintTextureID = <span class="keyword">new</span> GLuint[nFrames]();</span><br><span class="line">    <span class="built_in">glGenTextures</span>(nFrames, m_pGLuintTextureID);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">glIsTexture</span>(*((GLuint*)m_pGLuintTextureID) == <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">WSLogEx</span>(<span class="string">L&quot;wp_nvEnc ImageOpenGL::createresource: *((GLuint*)m_pGLuintTextureID) = %d \n &quot;</span>,*((GLuint*)m_pGLuintTextureID));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup the Texture filtering mode</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> field_num = <span class="number">0</span>; field_num &lt; nFrames; field_num++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_TYPE, m_pGLuintTextureID[field_num]);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NV_ENC_BUFFER_FORMAT_NV12_TYPE        </span></span><br><span class="line">        <span class="built_in">glTexImage2D</span>(GL_TEXTURE_TYPE, <span class="number">0</span>, GL_R8, nTexWidth_, nTexHeight_* <span class="number">3</span> / <span class="number">2</span>, <span class="number">0</span>, GL_RED, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">glTexImage2D</span>(GL_TEXTURE_TYPE, <span class="number">0</span>, GL_RGBA8, nTexWidth_, nTexHeight_, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">glTexParameteri</span>(GL_TEXTURE_TYPE, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_FILTER_TYPE);</span><br><span class="line">        <span class="built_in">glTexParameteri</span>(GL_TEXTURE_TYPE, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAG_FILTER_TYPE);</span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_TYPE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        CUresult result = <span class="built_in">cuCtxPushCurrent</span>(oContext_);</span><br><span class="line">        <span class="keyword">if</span> (result != CUDA_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">WSLogEx</span>(<span class="string">L&quot;wp_nvEnc ImageOpenGL ::cuCtxPushCurrent Failed \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">registerAsCudaResource</span>(field_num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分配空间并初始化</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NV_ENC_BUFFER_FORMAT_NV12_TYPE        </span></span><br><span class="line">        <span class="type">size_t</span> size = nWidth_ * nHeight_ * <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">3</span> / <span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="type">size_t</span> size = nWidth_ * nHeight_ * <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        result = <span class="built_in">cuMemAlloc</span>(&amp;cuDevPtr_[field_num], size);<span class="comment">//分配设备空间</span></span><br><span class="line">        <span class="keyword">if</span> (result != CUDA_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">assert</span>(cuDevPtr_[field_num]);</span><br><span class="line">            <span class="built_in">WSLogEx</span>(<span class="string">L&quot;wp_nvEnc ImageOpenGL ::cuMemAlloc Failed \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">cuMemsetD8</span>(cuDevPtr_[field_num], <span class="number">0</span>,size);<span class="comment">//初始化设备空间</span></span><br><span class="line">        <span class="keyword">if</span> (result != CUDA_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">WSLogEx</span>(<span class="string">L&quot;wp_nvEnc ImageOpenGL ::cuMemsetD8 Failed \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageOpenGL::destroysource</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nFrames = bIsProgressive_ ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glDeleteTextures</span>(nFrames, m_pGLuintTextureID);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_PBO_BUFFER</span></span><br><span class="line">    <span class="built_in">glDeleteBuffersARB</span>(nFrames, m_GLuintPBO);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> field_num = <span class="number">0</span>; field_num &lt; nFrames; field_num++)</span><br><span class="line">    &#123;</span><br><span class="line">        CUresult result = <span class="built_in">cuCtxPushCurrent</span>(oContext_);</span><br><span class="line">        <span class="keyword">if</span> (result != CUDA_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">WSLogEx</span>(<span class="string">L&quot;wp_nvEnc ImageOpenGL ::cuCtxPushCurrent Failed \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unregisterAsCudaResource</span>(field_num);</span><br><span class="line">        <span class="keyword">if</span> (cuDevPtr_[field_num])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cuMemFree</span>(cuDevPtr_[field_num]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ImageOpenGL::~<span class="built_in">ImageOpenGL</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">destroysource</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pFile_)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fclose</span>(pFile_);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageOpenGL::registerAsCudaResource</span><span class="params">(<span class="type">int</span> field_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register the OpenGL buffer object with CUDA and map a CUdeviceptr onto it</span></span><br><span class="line">    <span class="comment">// The decoder code will receive unregisterAsCudaResourcethis CUdeviceptr and copy the decoded frame into the associated device memory allocation</span></span><br><span class="line">    <span class="type">int</span> nFrames = bIsProgressive_ ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> field_num = <span class="number">0</span>; field_num &lt; nFrames; field_num++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在CUDA中注册Texture</span></span><br><span class="line">        <span class="comment">//注册由图像指定的纹理或渲染缓冲区对象以供CUDA访问</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_PBO_BUFFER</span></span><br><span class="line">        <span class="comment">// 2.将PBO (unpack buffer）映射到CUDA地址空间</span></span><br><span class="line">        CUresult uerr = <span class="built_in">cuGraphicsGLRegisterBuffer</span>(&amp;cuResource_[field_num], m_GLuintPBO[field_num],CU_GRAPHICS_REGISTER_FLAGS_NONE);<span class="comment">// CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD);</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        CUresult uerr = <span class="built_in">cuGraphicsGLRegisterImage</span>(&amp;cuResource_[field_num],</span><br><span class="line">            m_pGLuintTextureID[field_num], GL_TEXTURE_TYPE, CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (uerr != CUDA_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_PBO_BUFFER</span></span><br><span class="line">            <span class="built_in">WSLogEx</span>(<span class="string">L&quot;wp_nvEnc ImageOpenGL cuGraphicsGLRegisterBuffer: %d,Line: %d \n&quot;</span>, uerr, __LINE__);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="built_in">WSLogEx</span>(<span class="string">L&quot;wp_nvEnc ImageOpenGL cuGraphicsGLRegisterImage: %d,Line: %d \n&quot;</span>, uerr, __LINE__);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*describe</span></span><br><span class="line"><span class="comment">        Sets the flags used to map graphics resource resources.</span></span><br><span class="line"><span class="comment">        Changes to flags will take effect the next time the resource is mapped. The flags parameter can be any of the following:</span></span><br><span class="line"><span class="comment">        CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE: Specifies no hints on how to use this resource. Therefore, it is assumed that the resource will be read and written by CUDA kernels. This is the default value.</span></span><br><span class="line"><span class="comment">        CU_GRAPHICS_MAP_RESOURCE_FLAGS_READONLY: Specifies that CUDA kernels accessing this resource will not write to this resource.</span></span><br><span class="line"><span class="comment">        CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITEDISCARD: Specifies that CUDA kernels accessing this resource will not read from this resource,</span></span><br><span class="line"><span class="comment">        Instead, the entire content of the resource is overwritten, so any data previously stored in the resource is not preserved.</span></span><br><span class="line"><span class="comment">        Returns CUDA_ERROR_ALREADY_MAPPED if the resource is currently mapped for CUDA access. If flags is not one of the above values, return CUDA_ERROR_INVALID_VALUE.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="built_in">checkCudaErrors</span>(<span class="built_in">cuGraphicsResourceSetMapFlags</span>(cuResource_[field_num], CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE));</span><br><span class="line">    &#125;</span><br><span class="line">    bIsCudaResource_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unregister graphics resources for CUDA access.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageOpenGL::unregisterAsCudaResource</span><span class="params">(<span class="type">int</span> field_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//checkCudaErrors(cuGLUnregisterBufferObject(m_GLuintPBO[field_num]));//cuGLUnregisterBufferObject 这个接口已经在cuda 3之后的版本弃用了</span></span><br><span class="line">    <span class="built_in">checkCudaErrors</span>(<span class="built_in">cuGraphicsUnregisterResource</span>(cuResource_[field_num]));</span><br><span class="line"></span><br><span class="line">    bIsCudaResource_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将pOpenGLTextureIn地址上的纹理copy到m_pGLuintTextureID[0]上</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">ImageOpenGL::SetOpenGLTexture</span><span class="params">(<span class="type">void</span>* pOpenGLTextureIn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::mutex* pmutex = (std::mutex*)<span class="built_in">GetOpenGLLock</span>();</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(*pmutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_pGLuintTextureID[<span class="number">0</span>] &amp;&amp; pOpenGLTextureIn  &amp;&amp; (<span class="built_in">glIsTexture</span>(m_pGLuintTextureID[<span class="number">0</span>]) != <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">glIsTexture</span>(*((GLuint*)pOpenGLTextureIn)) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">WSLogEx</span>(<span class="string">L&quot;wp_nvEnc ImageOpenGL::SetOpenGLTexture: m_pGLuintTextureID[0] = %d \n ,pOpenGLTextureIn = %s \n &quot;</span>,m_pGLuintTextureID[<span class="number">0</span>], pOpenGLTextureIn);</span><br><span class="line"></span><br><span class="line">        GLenum glerror =  <span class="built_in">glGetError</span>();</span><br><span class="line">        GLuint fboBuffer = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;fboBuffer);<span class="comment">//声明一个帧缓冲区</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">GL_CHECKERROR</span>()) <span class="keyword">goto</span> fail;</span><br><span class="line">        <span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, fboBuffer);<span class="comment">//绑定</span></span><br><span class="line">        <span class="comment">//将纹理附加到帧缓冲区上</span></span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_READ_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class="line">                            GL_TEXTURE_2D,  m_pGLuintTextureID[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">glFramebufferTexture2D</span>(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT1,</span><br><span class="line">                            GL_TEXTURE_2D, *((GLuint*)pOpenGLTextureIn), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">GL_CHECKERROR</span>()) <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glReadBuffer</span>(GL_COLOR_ATTACHMENT0);</span><br><span class="line">        <span class="built_in">glDrawBuffer</span>(GL_COLOR_ATTACHMENT1);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">GL_CHECKERROR</span>()) <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//glBlitFramebuffer 一般用于帧缓冲区（颜色缓冲区）间高性能数据拷贝</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NV_ENC_BUFFER_FORMAT_NV12_TYPE    </span></span><br><span class="line">        <span class="built_in">glBlitFramebuffer</span>(<span class="number">0</span>, <span class="number">0</span>, nWidth_, nHeight_* <span class="number">3</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, nWidth_, nHeight_* <span class="number">3</span> / <span class="number">2</span>,</span><br><span class="line">                        GL_COLOR_BUFFER_BIT, GL_LINEAR);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">glBlitFramebuffer</span>(<span class="number">0</span>, <span class="number">0</span>, nWidth_, nHeight_, <span class="number">0</span>, <span class="number">0</span>, nWidth_, nHeight_,</span><br><span class="line">                        GL_COLOR_BUFFER_BIT, GL_LINEAR);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">GL_CHECKERROR</span>()) <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">glDeleteFramebuffers</span>(<span class="number">1</span>, &amp;fboBuffer);</span><br><span class="line">        <span class="built_in">glFinish</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">WSLogEx</span>(<span class="string">L&quot;wp_nvEnc ImageOpenGL::SetOpenGLTexture fail: m_pGLuintTextureID[0] = %d \n ,pOpenGLTextureIn = %s \n &quot;</span>,m_pGLuintTextureID[<span class="number">0</span>], pOpenGLTextureIn);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将m_pGLuintTextureID[0]纹理复制到,m_pGLuintTextureOutID[0]上，并将m_pGLuintTextureOutID作为返回值return出去</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ImageOpenGL::getOpenGLTexture</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::mutex* pmutex = (std::mutex*)<span class="built_in">GetOpenGLLock</span>();</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(*pmutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_pGLuintTextureID[<span class="number">0</span>] &amp;&amp; (<span class="built_in">glIsTexture</span>(m_pGLuintTextureID[<span class="number">0</span>]) != <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_pGLuintTextureOutID == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pGLuintTextureOutID = <span class="keyword">new</span> GLuint[<span class="number">1</span>]();</span><br><span class="line">            <span class="built_in">glGenTextures</span>(<span class="number">1</span>, (GLuint*)m_pGLuintTextureOutID);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">glIsTexture</span>(m_pGLuintTextureOutID[<span class="number">0</span>]) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">WSLogEx</span>(<span class="string">L&quot;wp_nvEnc ImageOpenGL::getOpenGLTexture: m_pGLuintTextureID[0] = %d \n ,m_pGLuintTextureOutID[0] =  %d \n &quot;</span>,m_pGLuintTextureID[<span class="number">0</span>], m_pGLuintTextureOutID[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        GLenum glerror =  <span class="built_in">glGetError</span>();</span><br><span class="line">        GLuint fboBuffer = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;fboBuffer);<span class="comment">//声明一个帧缓冲区</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">GL_CHECKERROR</span>()) <span class="keyword">goto</span> fail;</span><br><span class="line">        <span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, fboBuffer);<span class="comment">//绑定</span></span><br><span class="line">        <span class="comment">//将纹理附加到帧缓冲区上</span></span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_READ_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class="line">                            GL_TEXTURE_2D,  m_pGLuintTextureID[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">glFramebufferTexture2D</span>(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT1,</span><br><span class="line">                            GL_TEXTURE_2D, m_pGLuintTextureOutID[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">GL_CHECKERROR</span>()) <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glReadBuffer</span>(GL_COLOR_ATTACHMENT0);</span><br><span class="line">        <span class="built_in">glDrawBuffer</span>(GL_COLOR_ATTACHMENT1);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">GL_CHECKERROR</span>()) <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//glBlitFramebuffer 一般用于帧缓冲区（颜色缓冲区）间高性能数据拷贝</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NV_ENC_BUFFER_FORMAT_NV12_TYPE           </span></span><br><span class="line">        <span class="built_in">glBlitFramebuffer</span>(<span class="number">0</span>, <span class="number">0</span>, nWidth_, nHeight_* <span class="number">3</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, nWidth_, nHeight_* <span class="number">3</span> / <span class="number">2</span>,</span><br><span class="line">                        GL_COLOR_BUFFER_BIT, GL_LINEAR);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">glBlitFramebuffer</span>(<span class="number">0</span>, <span class="number">0</span>, nWidth_, nHeight_, <span class="number">0</span>, <span class="number">0</span>, nWidth_, nHeight_,</span><br><span class="line">                        GL_COLOR_BUFFER_BIT, GL_LINEAR);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">GL_CHECKERROR</span>()) <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">glDeleteFramebuffers</span>(<span class="number">1</span>, &amp;fboBuffer);</span><br><span class="line">        <span class="built_in">glFinish</span>();</span><br><span class="line">        <span class="keyword">return</span> m_pGLuintTextureOutID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">glDeleteTextures</span>(<span class="number">1</span>,(GLuint*)m_pGLuintTextureOutID);</span><br><span class="line">    <span class="built_in">WSLogEx</span>(<span class="string">L&quot;wp_nvEnc ImageOpenGL::getOpenGLTexture fail,m_pGLuintTextureID[0] = %d \n ,m_pGLuintTextureOutID[0] =  %d \n &quot;</span>,m_pGLuintTextureID[<span class="number">0</span>], m_pGLuintTextureOutID[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在CUDA中锁定资源，获得操作Texture的指针，这里是CudaArray*类型</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ImageOpenGL::map</span><span class="params">(CUdeviceptr *ppImageData, <span class="type">size_t</span> *pImagePitch, <span class="type">int</span> active_field)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//checkCudaErrors(cuGLMapBufferObject(ppImageData, pImagePitch, m_GLuintPBO[active_field]));//cuGLMapBufferObject 这个接口已经在cuda 3之后的版本弃用了</span></span><br><span class="line">    CUresult uerr = CUDA_SUCCESS;</span><br><span class="line"></span><br><span class="line">    std::mutex* pmutex = (std::mutex*)<span class="built_in">GetOpenGLLock</span>();</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(*pmutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    CUresult result = <span class="built_in">cuCtxPushCurrent</span>(oContext_);</span><br><span class="line">    <span class="keyword">if</span> (result != CUDA_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">WSLogEx</span>(<span class="string">L&quot;wp_nvEnc ImageOpenGL ::cuCtxPushCurrent Failed \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在CUDA中锁定资源，获得操作Texture的指针，这里是CudaArray*类型</span></span><br><span class="line">    uerr = (<span class="built_in">cuGraphicsMapResources</span>(<span class="number">1</span>, &amp;(cuResource_[active_field]), <span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">if</span> (uerr == CUDA_ERROR_LAUNCH_TIMEOUT)</span><br><span class="line">    &#123;</span><br><span class="line">        uerr = (<span class="built_in">cuGraphicsMapResources</span>(<span class="number">1</span>, &amp;(cuResource_[active_field]), <span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//USE_PBO_BUFFER用CU_MEMORYTYPE_DEVICE方式,纹理用CU_MEMORYTYPE_ARRAY方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> USE_PBO_BUFFER</span></span><br><span class="line">    uerr = (<span class="built_in">cuGraphicsSubResourceGetMappedArray</span>(&amp;cuArray_[active_field], cuResource_[active_field], <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (uerr == CUDA_ERROR_LAUNCH_TIMEOUT)</span><br><span class="line">    &#123;</span><br><span class="line">        uerr = (<span class="built_in">cuGraphicsSubResourceGetMappedArray</span>(&amp;cuArray_[active_field],cuResource_[active_field], <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//copy texture to pDevPtr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Source is dpFrame into which Decode() function writes data of individual frame present in BGRA32 format</span></span><br><span class="line">    <span class="comment">// Destination is OpenGL buffer object mapped as a CUDA resource</span></span><br><span class="line">    CUDA_MEMCPY2D copy = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;copy, <span class="number">0</span>, <span class="built_in">sizeof</span>(CUDA_MEMCPY2D));</span><br><span class="line"></span><br><span class="line">    copy.srcMemoryType = CUmemorytype::CU_MEMORYTYPE_DEVICE;</span><br><span class="line">    copy.srcDevice = cuDevPtr_[active_field];<span class="comment">// source,解码获得的NV12转成BGRA8的指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NV_ENC_BUFFER_FORMAT_NV12_TYPE   </span></span><br><span class="line">    copy.srcPitch = <span class="built_in">sizeof</span>(<span class="type">char</span>)*nWidth_;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    copy.srcPitch = <span class="number">4</span> * <span class="built_in">sizeof</span>(<span class="type">char</span>)*nWidth_;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//USE_PBO_BUFFER用CU_MEMORYTYPE_DEVICE方式,纹理用CU_MEMORYTYPE_ARRAY方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_PBO_BUFFER</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得cuResource映射到CUDA中的指针dpBackBuffer</span></span><br><span class="line">    CUdeviceptr dpBackBuffer;</span><br><span class="line">    <span class="type">size_t</span> nSize = <span class="number">0</span>;</span><br><span class="line">    uerr = <span class="built_in">cuGraphicsResourceGetMappedPointer</span>(&amp;dpBackBuffer, &amp;nSize, cuResource_[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (uerr == CUDA_ERROR_LAUNCH_TIMEOUT)</span><br><span class="line">    &#123;</span><br><span class="line">        uerr = <span class="built_in">cuGraphicsResourceGetMappedPointer</span>(&amp;dpBackBuffer, &amp;nSize, cuResource_[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    copy.dstDevice = dpBackBuffer;<span class="comment">// GL映射到CUDA中的指针</span></span><br><span class="line">    copy.dstMemoryType = CUmemorytype::CU_MEMORYTYPE_DEVICE;</span><br><span class="line">    copy.dstPitch = nSize / nHeight_;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">//checkCudaErrors(cuGLUnmapBufferObject(m_GLuintPBO[active_field]));//cuGLUnmapBufferObject 这个接口已经在cuda 3之后的版本弃用了</span></span><br><span class="line">    CUDA_ARRAY_DESCRIPTOR arrayDescriptor;</span><br><span class="line">    <span class="comment">//获取一维或二维 CUDA 数组描述符。</span></span><br><span class="line">    uerr = <span class="built_in">cuArrayGetDescriptor</span>(&amp;arrayDescriptor,cuArray_[active_field]);</span><br><span class="line">    <span class="keyword">if</span> (uerr == CUDA_ERROR_LAUNCH_TIMEOUT)</span><br><span class="line">    &#123;</span><br><span class="line">        uerr = <span class="built_in">cuArrayGetDescriptor</span>(&amp;arrayDescriptor, cuArray_[active_field]);</span><br><span class="line">    &#125;</span><br><span class="line">    copy.dstArray = cuArray_[active_field];</span><br><span class="line">    copy.dstMemoryType = CUmemorytype::CU_MEMORYTYPE_ARRAY;</span><br><span class="line">    copy.dstPitch =  <span class="built_in">sizeof</span>(<span class="type">char</span>)*nWidth_ ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    copy.WidthInBytes = <span class="built_in">sizeof</span>(<span class="type">char</span>)*nWidth_;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NV_ENC_BUFFER_FORMAT_NV12_TYPE      </span></span><br><span class="line">    copy.Height = nHeight_* <span class="number">3</span> / <span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    copy.Height = nHeight_;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//CUDA 中的解码数据是一个 CUdeviceptr。要填充映射的 OpenGL 纹理，我们可以使用cuMemcpy2D</span></span><br><span class="line">    uerr = <span class="built_in">cuMemcpy2D</span>(&amp;copy);<span class="comment">//cuMemcpy2DAsync是异步操作</span></span><br><span class="line">    <span class="keyword">if</span> (uerr == CUDA_ERROR_LAUNCH_TIMEOUT)</span><br><span class="line">    &#123;</span><br><span class="line">        uerr = <span class="built_in">cuMemcpy2DUnaligned</span>(&amp;copy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *ppImageData = cuDevPtr_[active_field];</span><br><span class="line"></span><br><span class="line">    *pImagePitch = nWidth_;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    cuArray_[active_field] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(<span class="number">0</span> != *ppImageData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageOpenGL::unmap</span><span class="params">(<span class="type">int</span> active_field)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::mutex* pmutex = (std::mutex*)<span class="built_in">GetOpenGLLock</span>();</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(*pmutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    CUresult result = <span class="built_in">cuCtxPushCurrent</span>(oContext_);</span><br><span class="line">    <span class="keyword">if</span> (result != CUDA_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">WSLogEx</span>(<span class="string">L&quot;wp_nvEnc ImageOpenGL ::cuCtxPushCurrent Failed \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nFrames = bIsProgressive_ ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完后即解除资源锁定，OpenGL可以利用得到的Texture对象进行纹理贴图操作了。</span></span><br><span class="line">    CUresult uerr = <span class="built_in">cuGraphicsUnmapResources</span>(nFrames, &amp;cuResource_[active_field], <span class="literal">NULL</span>);<span class="comment">//不要忘记取消映射资源。映射一个已经映射的资源可能会使你的程序崩溃。</span></span><br><span class="line">    <span class="keyword">if</span> (uerr == CUDA_ERROR_LAUNCH_TIMEOUT)</span><br><span class="line">    &#123;</span><br><span class="line">        uerr = <span class="built_in">cuGraphicsUnmapResources</span>(nFrames, &amp;cuResource_[active_field], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageOpenGL::loadTextureFromPBO</span><span class="params">(<span class="type">int</span> field_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_PBO_BUFFER    </span></span><br><span class="line">    <span class="comment">// load texture from pbo</span></span><br><span class="line">    <span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, m_GLuintPBO[field_num]);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_TYPE, *((GLuint*)m_pGLuintTextureID));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NV_ENC_BUFFER_FORMAT_NV12_TYPE         </span></span><br><span class="line">    <span class="built_in">glTexSubImage2D</span>(GL_TEXTURE_TYPE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, nTexWidth_, nTexHeight_* <span class="number">3</span> / <span class="number">2</span>, GL_RED, GL_UNSIGNED_BYTE, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">glTexSubImage2D</span>(GL_TEXTURE_TYPE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, nTexWidth_, nTexHeight_, GL_RGBA, GL_UNSIGNED_BYTE, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_TYPE, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glFinish</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL学习笔记（七）：crop脚本的实现</title>
      <link href="/2023/07/22/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9Acrop%E8%84%9A%E6%9C%AC%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/07/22/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9Acrop%E8%84%9A%E6%9C%AC%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight fs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#version <span class="number">120</span></span><br><span class="line"></span><br><span class="line">#pragma optimize(off)</span><br><span class="line"><span class="meta">#if</span> __VERSION__<span class="operator">&lt;</span><span class="number">130</span></span><br><span class="line">#define TEXTURE2D texture2D</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">#define TEXTURE2D texture</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">#define Texture2D sampler2D</span><br><span class="line"></span><br><span class="line">uniform Texture2D overlay;</span><br><span class="line">uniform float roi_x;</span><br><span class="line">uniform float roi_y;</span><br><span class="line">uniform int overlay_Width;</span><br><span class="line">uniform int overlay_Height;</span><br><span class="line"></span><br><span class="line">uniform int dst_Width;</span><br><span class="line">uniform int dst_Height;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> VS_INPUT</span><br><span class="line">&#123;</span><br><span class="line">    vec4 Position;<span class="comment">// vertex position</span></span><br><span class="line">    vec2 TextureUV;<span class="comment">// vertex texture coords</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> VS_OUTPUT</span><br><span class="line">&#123;</span><br><span class="line">    vec4 Position;<span class="comment">// vertex position</span></span><br><span class="line">    vec2 TextureUV;<span class="comment">// vertex texture coords</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> PS_OUTPUT</span><br><span class="line">&#123;</span><br><span class="line">    vec4 RGBColor;<span class="comment">// Pixel color</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vec2 rotateFunc(vec2 uv,vec2 center,float theta)</span><br><span class="line">&#123;</span><br><span class="line">    vec2 temp;</span><br><span class="line">    temp.x<span class="operator">=</span>dot(vec2(cos(theta),<span class="operator">-</span>sin(theta)),uv<span class="operator">-</span>center);</span><br><span class="line">    temp.y<span class="operator">=</span>dot(vec2(sin(theta),cos(theta)),uv<span class="operator">-</span>center);</span><br><span class="line">    <span class="keyword">return</span>(temp<span class="operator">+</span>center);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vec4 PS_2D(vec2 tc)</span><br><span class="line">&#123;</span><br><span class="line">    PS_OUTPUT Output;</span><br><span class="line">    float widthScale<span class="operator">=</span>float(dst_Width)<span class="operator">/</span>overlay_Width;</span><br><span class="line">    float heightScale<span class="operator">=</span>float(dst_Height)<span class="operator">/</span>overlay_Height;</span><br><span class="line">    vec2 scaledTC <span class="operator">=</span> vec2(tc.x<span class="operator">*</span>widthScale, tc.y<span class="operator">*</span>heightScale);</span><br><span class="line"></span><br><span class="line">    vec2 uv<span class="operator">=</span>vec2(tc.x<span class="operator">*</span>widthScale<span class="operator">+</span>roi_x,tc.y<span class="operator">*</span>heightScale<span class="operator">+</span>roi_y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> TEXTURE2D(overlay,uv);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">varying vec4 vs_output_position;<span class="comment">// vertex position</span></span><br><span class="line">varying vec2 vs_output_textureUV;<span class="comment">// vertex texture coords</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">    </span><br><span class="line">    gl_FragColor<span class="operator">=</span>PS_2D(vs_output_textureUV);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#version 120</span><br><span class="line"></span><br><span class="line">attribute vec4 position;</span><br><span class="line">attribute vec2 textureUV;</span><br><span class="line"></span><br><span class="line">varying vec4 vs_output_position;</span><br><span class="line">varying vec2 vs_output_textureUV;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    gl_Position=position;</span><br><span class="line">    vs_output_position=position;</span><br><span class="line">    vs_output_textureUV=textureUV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程下的OpenGL上下文创建</title>
      <link href="/2023/07/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84OpenGL%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%9B%E5%BB%BA/"/>
      <url>/2023/07/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84OpenGL%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>在实际工程场景下,我们经常会在多个线程中进行OpenGL的相关操作,而在进行OpenGL操作之前,我们都需要在使用到OpenGL的线程中创建独立的OpenGL上下文,否则在运行代码时,就会产生报错.<br>而如果当每次发生报错信息时候,再去对应的线程编写OpenGL上下文的创建代码又显得过于冗余.<br>一个较好的方式就是,创建一个threadInitOpenGLApi的对外API接口,每次在进行OpenGL操作之前都先调用这个API接口,而接口内部在运行时智能的判断当前线程有没有进行相关初始化操作以及创建OpenGL上下文.如果没有那么就进行创建,如果有则直接返回当前OpenGL的上下文指针.</p><p>为了让这个API达到这个目的,我们首先需要用thread_local static定义一个变量__init,用他来判断当前线程是否有进行OpenGL初始化操作同时也定义一个智能指针,用于存储当前OpenGLContext</p><p>PS:thread_local是C++ 11中引入的一个关键字，它可以用来声明线程本地存储（TLS）变量，即每个线程都有自己的存储空间，而不会与其他线程共享。它可以用来实现线程安全，以及提高程序的性能。</p><p>通过下面的threadInitOpenGLApi()函数的设计,我们可以看出,当__init &#x3D; false(也就是当前线程并没有开始进行初始化)时,会进入if语句,<br>进入if后,我们首先将__init置为true,同时通过std::this_thread::get_id()拿到当前线程的id</p><p>紧接着,我们进行加锁操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">access_Static_OpenGLContext</span><span class="params">(*(std::mutex*)GetOpenGLLock())</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> std::mutex gl_mutex;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">GetOpenGLLock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)&amp;gl_mutex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>PS:lock_guard是一种RAII（资源获取即初始化）锁定机制，它可以帮助程序员在编写多线程程序时保护临界区的数据。lock_guard可以在构造函数中获取锁，并在析构函数中释放锁，从而保证了临界区的数据在多线程程序中的安全性。</p><p>同时我们调用glfwSetErrorCallback来设置一个回调函数,用于接收回调的错误信息</p><p>然后我们在进行glew初始化(我这边用到的是glew,如果你用的是其他的那就进行对应的初始化操作即可)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> init = <span class="built_in">glfwInit</span>();</span><br></pre></td></tr></table></figure><p>之后我们调用glfwCreateWindow来创建窗口,相关参数参数[in]title：初始窗口标题，以UTF-8编码。参数[in]monitor：用于全屏模式的显示器，或者为“NULL”以使用窗口模式。参数[in]share：要共享资源的窗口，或者为“NULL”以不共享资源。</p><p>随后调用glfwMakeContextCurrent.(glfwMakeContextCurrent是GLFW函数，它用于将当前线程的上下文设置为给定窗口的上下文。它可以用来将OpenGL渲染上下文与特定的窗口关联起来，以便在该窗口中进行渲染)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    @ret return OpenGLContext for this thread if success</span></span><br><span class="line"><span class="comment">    call twice or more in one same thread is allowed</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span>* __stdcall <span class="title">threadInitOpenGLApi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> <span class="type">static</span> <span class="type">bool</span> __init = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">thread_local</span> std::shared_ptr&lt;GLFWwindow&gt; openglContext;<span class="comment">// context could be access by glfwcurrentContext</span></span><br><span class="line">    <span class="keyword">if</span> (!__init)</span><br><span class="line">    &#123;</span><br><span class="line">        __init = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">auto</span> id=std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">        <span class="keyword">auto</span> id_ul=*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>*)&amp;id;<span class="comment">//convert it to a format that printf can output normally.</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">/* access to  GetSharingOpenGLContext() */</span></span><br><span class="line">        <span class="comment">/* and glfwCreateWindow is not thread safe*/</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">access_Static_OpenGLContext</span><span class="params">(*(std::mutex*)GetOpenGLLock())</span></span>;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">        <span class="built_in">glfwSetErrorCallback</span>(glfw_error_callback);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// call this multitime is costless</span></span><br><span class="line">        <span class="keyword">auto</span> init = <span class="built_in">glfwInit</span>();</span><br><span class="line">        <span class="comment">// Decide GL+GLSL versions</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *glsl_version = <span class="string">&quot;#version 130&quot;</span>;</span><br><span class="line">        <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">glfwWindowHint</span>(GLFW_FOCUSED, GLFW_FALSE);</span><br><span class="line">        <span class="built_in">glfwWindowHint</span>(GLFW_VISIBLE, GLFW_FALSE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> &amp; global_first_glfw_context = *(std::shared_ptr&lt;GLFWwindow&gt; *)<span class="built_in">GetSharingOpenGLContext</span>();</span><br><span class="line">        GLFWwindow *first_context = global_first_glfw_context.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Create window with graphics context</span></span><br><span class="line">        GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(<span class="number">1280</span>, <span class="number">720</span>, first_context ? <span class="string">&quot;first context&quot;</span> : <span class="string">&quot;sharing context&quot;</span>, <span class="literal">NULL</span>, first_context);</span><br><span class="line">        <span class="keyword">if</span> (!window)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread[%lu:%s] glfwCreateWindow failed&quot;</span>,id_ul,<span class="built_in">GetThreadDesc</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (global_first_glfw_context == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            global_first_glfw_context = openglContext = std::<span class="built_in">shared_ptr</span>&lt;GLFWwindow&gt;(window, [id_ul](GLFWwindow *win)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">glfwTerminate</span>();</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;thread[%lu:%s] destroy OpenGLContext,and call glfwTerminate&quot;</span>,id_ul,<span class="built_in">GetThreadDesc</span>());</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* this only need call once */</span></span><br><span class="line">            <span class="keyword">auto</span> api_init_result = <span class="built_in">glewInit</span>();</span><br><span class="line">            <span class="keyword">if</span> (api_init_result != GLEW_OK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = <span class="built_in">glewGetErrorString</span>(api_init_result);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;thread[%lu:%s]  glewInit %s Failed \n&quot;</span>,id_ul, p,<span class="built_in">GetThreadDesc</span>());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread[%lu:%s] create first OpenGLContext for sharing&quot;</span>,id_ul,<span class="built_in">GetThreadDesc</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            openglContext = std::<span class="built_in">shared_ptr</span>&lt;GLFWwindow&gt;(window, [id_ul](GLFWwindow *ptr)</span><br><span class="line">                                                        &#123;</span><br><span class="line">                <span class="built_in">glfwDestroyWindow</span>(ptr);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;thread[%lu:%s] destroy OpenGLContext&quot;</span>,id_ul,<span class="built_in">GetThreadDesc</span>());</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread[%lu:%s] create OpenGLContext&quot;</span>, id_ul,<span class="built_in">GetThreadDesc</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;openglContext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __stdcall <span class="title">GetThreadID</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pthread_self</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *__stdcall <span class="title">GetThreadDesc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> pid=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">pid=<span class="built_in">pthread_self</span>();</span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">char</span> name[<span class="number">128</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (name[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"><span class="built_in">pthread_getname_np</span>(pid, name, <span class="number">128</span>);</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> std::mutex gl_mutex;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">GetOpenGLLock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)&amp;gl_mutex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> * __stdcall <span class="title">GetSharingOpenGLContext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> std::shared_ptr&lt;GLFWwindow&gt; __ins;</span><br><span class="line"><span class="keyword">return</span> &amp;__ins;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">glfw_error_callback</span><span class="params">(<span class="type">int</span> error, <span class="type">const</span> <span class="type">char</span> *description)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Glfw Error %d: %s\n&quot;</span>, error, description);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL学习笔记（六）：缩放脚本的实现</title>
      <link href="/2023/07/16/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E7%BC%A9%E6%94%BE%E8%84%9A%E6%9C%AC%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/07/16/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E7%BC%A9%E6%94%BE%E8%84%9A%E6%9C%AC%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本章将介绍如何使用OpenGL进行RGBA格式的视频帧缩放操作</p><h1 id="相关fs和vs脚本"><a href="#相关fs和vs脚本" class="headerlink" title="相关fs和vs脚本"></a>相关fs和vs脚本</h1><figure class="highlight fs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#version <span class="number">120</span></span><br><span class="line"></span><br><span class="line">#pragma optimize(off)</span><br><span class="line"><span class="meta">#if</span> __VERSION__<span class="operator">&lt;</span><span class="number">130</span></span><br><span class="line">#define TEXTURE2D texture2D</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">#define TEXTURE2D texture</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">#define Texture2D  sampler2D</span><br><span class="line"></span><br><span class="line">#define SWITCH(var)int v_var<span class="operator">=</span>var;&#123;<span class="keyword">do</span>&#123;</span><br><span class="line">    #define CASE(<span class="keyword">val</span>)&#125;<span class="keyword">if</span>(v_var<span class="operator">==</span><span class="keyword">val</span>)&#123;</span><br><span class="line">    #define DEFAULT()&#125;;</span><br><span class="line">#define ENDSWITCH()&#125;<span class="keyword">while</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">uniform sampler2D overlay;                    </span><br><span class="line">uniform int overlay_Width;</span><br><span class="line">uniform int overlay_Height;</span><br><span class="line">uniform int dst_Width;</span><br><span class="line">uniform int dst_Height;</span><br><span class="line">uniform int resize_type;</span><br><span class="line"></span><br><span class="line">vec4 PS_2D(vec2 TextureUV)&#123;</span><br><span class="line">    float f_srcWidth <span class="operator">=</span> float(overlay_Width);</span><br><span class="line">    float f_srcHeight <span class="operator">=</span> float(overlay_Height);</span><br><span class="line">    float f_dstWidth <span class="operator">=</span> float(dst_Width);</span><br><span class="line">    float f_dstHeight <span class="operator">=</span> float(dst_Height);</span><br><span class="line">   </span><br><span class="line">    vec2 tc <span class="operator">=</span> TextureUV;</span><br><span class="line"></span><br><span class="line">    float resizeCoord_x <span class="operator">=</span> tc.x;</span><br><span class="line">float resizeCoord_y <span class="operator">=</span> tc.y;</span><br><span class="line">    float matt <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(resize_type <span class="operator">==</span> <span class="number">1</span>)&#123;</span><br><span class="line">        float src_ratio <span class="operator">=</span> f_srcWidth <span class="operator">/</span> f_srcHeight;</span><br><span class="line">        float dst_ratio <span class="operator">=</span> f_dstWidth <span class="operator">/</span> f_dstHeight;</span><br><span class="line">        float tmpDstH <span class="operator">=</span> ceil(f_dstWidth <span class="operator">*</span> f_srcHeight <span class="operator">/</span> f_srcWidth);</span><br><span class="line">        <span class="keyword">if</span>(f_dstHeight <span class="operator">&gt;=</span> tmpDstH) &#123;</span><br><span class="line">            float dstH <span class="operator">=</span> tmpDstH <span class="operator">/</span> f_dstHeight ;</span><br><span class="line">            float roiY0 <span class="operator">=</span> (<span class="number">1.0</span> <span class="operator">-</span> dstH) <span class="operator">*</span> <span class="number">0.5</span>;</span><br><span class="line">            float roiY1 <span class="operator">=</span> roiY0 <span class="operator">+</span> dstH;</span><br><span class="line">            matt <span class="operator">=</span> step(roiY0 ,tc.y) <span class="operator">*</span> step(tc.y , roiY1);</span><br><span class="line">            resizeCoord_y <span class="operator">=</span> (tc.y <span class="operator">-</span> roiY0 ) <span class="operator">/</span> dstH;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            float tmpDstW <span class="operator">=</span> ceil(f_dstHeight <span class="operator">*</span> src_ratio);</span><br><span class="line">            float dstW <span class="operator">=</span>  tmpDstW <span class="operator">/</span> f_dstWidth;</span><br><span class="line">            float roiX0 <span class="operator">=</span> (<span class="number">1.0</span> <span class="operator">-</span> dstW) <span class="operator">*</span> <span class="number">0.5</span>;</span><br><span class="line">            float roiX1 <span class="operator">=</span> roiX0 <span class="operator">+</span> dstW;</span><br><span class="line">            matt <span class="operator">=</span> step(roiX0 ,tc.x) <span class="operator">*</span> step(tc.x , roiX1);</span><br><span class="line">            resizeCoord_x <span class="operator">=</span> (tc.x <span class="operator">-</span> roiX0) <span class="operator">/</span> dstW;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vec2 uv <span class="operator">=</span> vec2(resizeCoord_x,resizeCoord_y);</span><br><span class="line">vec4 ovlCol <span class="operator">=</span> TEXTURE2D(overlay,uv) <span class="operator">*</span> matt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  ovlCol;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">varying vec4 vs_output_position;</span><br><span class="line">varying vec2 vs_output_textureUV;</span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">gl_FragColor <span class="operator">=</span> PS_2D(vs_output_textureUV);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#version 120</span><br><span class="line"></span><br><span class="line">attribute vec4 position;</span><br><span class="line">attribute vec2 textureUV;</span><br><span class="line"></span><br><span class="line">varying vec4 vs_output_position;</span><br><span class="line">varying vec2 vs_output_textureUV;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    gl_Position=position;</span><br><span class="line">    vs_output_position=position;</span><br><span class="line">    vs_output_textureUV=textureUV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL学习笔记（五）：旋转脚本的实现</title>
      <link href="/2023/07/05/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%97%8B%E8%BD%AC%E8%84%9A%E6%9C%AC%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/07/05/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%97%8B%E8%BD%AC%E8%84%9A%E6%9C%AC%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>加载图片旋转的OpenGL脚本步骤如下：</p><ul><li>初始化OpenGL环境：包括创建窗口、设置视口大小等。</li><li>加载图片：使用OpenGL提供的纹理对象，将图片加载到显存中。</li><li>创建顶点和纹理坐标数据：定义一个矩形的顶点坐标和对应的纹理坐标。</li><li>编写顶点着色器和片段着色器：顶点着色器用于对顶点进行变换，片段着色器用于对像素进行处理。</li><li>创建着色器程序：将顶点着色器和片段着色器链接成一个着色器程序。</li><li>绑定纹理：将加载的图片纹理绑定到纹理单元上。</li><li>设置纹理参数：设置纹理的过滤方式和环绕方式。</li><li>渲染循环：在每一帧中，使用着色器程序绘制矩形，并根据需要对图片进行旋转。</li><li>清理资源：释放纹理对象和着色器程序等。</li></ul><p>我们先用chatGPU生成一个例程，来介绍如何旋转一个RGBA的视频帧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点着色器代码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* vertexShaderSource = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">    #version 330 core</span></span><br><span class="line"><span class="string">    layout (location = 0) in vec3 aPos;</span></span><br><span class="line"><span class="string">    layout (location = 1) in vec2 aTexCoord;</span></span><br><span class="line"><span class="string">    out vec2 TexCoord;</span></span><br><span class="line"><span class="string">    uniform mat4 transform;</span></span><br><span class="line"><span class="string">    void main()</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        gl_Position = transform * vec4(aPos, 1.0);</span></span><br><span class="line"><span class="string">        TexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段着色器代码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* fragmentShaderSource = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">    #version 330 core</span></span><br><span class="line"><span class="string">    in vec2 TexCoord;</span></span><br><span class="line"><span class="string">    out vec4 FragColor;</span></span><br><span class="line"><span class="string">    uniform sampler2D texture1;</span></span><br><span class="line"><span class="string">    void main()</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        FragColor = texture(texture1, TexCoord);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点数据</span></span><br><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 位置             // 纹理坐标</span></span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旋转角度</span></span><br><span class="line"><span class="type">float</span> angle = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口大小</span></span><br><span class="line"><span class="type">int</span> windowWidth = <span class="number">640</span>;</span><br><span class="line"><span class="type">int</span> windowHeight = <span class="number">480</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 着色器程序</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shaderProgram;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点缓冲对象、索引缓冲对象、纹理对象</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VBO, EBO, texture;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点数组对象</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取RGBA格式的视频帧</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; <span class="title">readFrame</span><span class="params">(<span class="type">const</span> string&amp; filename, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(filename, ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!file)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to open file: &quot;</span> &lt;&lt; filename &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; <span class="title">frame</span><span class="params">(width * height * <span class="number">4</span>)</span></span>;</span><br><span class="line">    file.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(frame.<span class="built_in">data</span>()), frame.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化OpenGL环境</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initOpenGL</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化GLFW</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to initialize GLFW&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建窗口</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(windowWidth, windowHeight, <span class="string">&quot;OpenGL Rotate Video Frame&quot;</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前窗口上下文</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化GLEW</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to initialize GLEW&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置视口大小</span></span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, windowWidth, windowHeight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译顶点着色器</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line">    <span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(vertexShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查顶点着色器是否编译成功</span></span><br><span class="line">    <span class="type">int</span> success;</span><br><span class="line">    <span class="type">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(vertexShader, <span class="built_in">sizeof</span>(infoLog), <span class="literal">nullptr</span>, infoLog);</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to compile vertex shader: &quot;</span> &lt;&lt; infoLog &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译片段着色器</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line">    <span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查片段着色器是否编译成功</span></span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(fragmentShader, <span class="built_in">sizeof</span>(infoLog), <span class="literal">nullptr</span>, infoLog);</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to compile fragment shader: &quot;</span> &lt;&lt; infoLog &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建着色器程序</span></span><br><span class="line">    shaderProgram = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(shaderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查着色器程序是否链接成功</span></span><br><span class="line">    <span class="built_in">glGetProgramiv</span>(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glGetProgramInfoLog</span>(shaderProgram, <span class="built_in">sizeof</span>(infoLog), <span class="literal">nullptr</span>, infoLog);</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to link shader program: &quot;</span> &lt;&lt; infoLog &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除着色器对象</span></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建顶点缓冲对象、索引缓冲对象、纹理对象</span></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;EBO);</span><br><span class="line">    <span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定顶点缓冲对象</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定索引缓冲对象</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定纹理对象</span></span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置纹理参数</span></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载视频帧</span></span><br><span class="line">    vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; frame = <span class="built_in">readFrame</span>(<span class="string">&quot;frame.rgba&quot;</span>, windowWidth, windowHeight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将视频帧上传到纹理对象中</span></span><br><span class="line">    <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, windowWidth, windowHeight, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, frame.<span class="built_in">data</span>());</span><br><span class="line">    <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建顶点数组对象</span></span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定顶点数组对象</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置顶点属性指针</span></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解绑顶点数组对象</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染循环</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">renderLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(<span class="built_in">glfwGetCurrentContext</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 清空颜色缓冲区</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用着色器程序</span></span><br><span class="line">        <span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定纹理</span></span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建变换矩阵</span></span><br><span class="line">        glm::mat4 transform = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        transform = glm::<span class="built_in">translate</span>(transform, glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>));</span><br><span class="line">        transform = glm::<span class="built_in">rotate</span>(transform, glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">        transform = glm::<span class="built_in">translate</span>(transform, glm::<span class="built_in">vec3</span>(<span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置变换矩阵</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> transformLoc = <span class="built_in">glGetUniformLocation</span>(shaderProgram, <span class="string">&quot;transform&quot;</span>);</span><br><span class="line">        <span class="built_in">glUniformMatrix4fv</span>(transformLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(transform));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定顶点数组对象</span></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制矩形</span></span><br><span class="line">        <span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span></span><br><span class="line">        ，GL_UNSIGNED_INT, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解绑顶点数组对象</span></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换缓冲区和轮询事件</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(<span class="built_in">glfwGetCurrentContext</span>());</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理资源</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 删除顶点缓冲对象、索引缓冲对象、纹理对象</span></span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;EBO);</span><br><span class="line">    <span class="built_in">glDeleteTextures</span>(<span class="number">1</span>, &amp;texture);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除顶点数组对象</span></span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除着色器程序</span></span><br><span class="line">    <span class="built_in">glDeleteProgram</span>(shaderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终止GLFW</span></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化OpenGL环境</span></span><br><span class="line">    <span class="built_in">initOpenGL</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="built_in">renderLoop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    <span class="built_in">cleanup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请注意，上述代码使用了GLFW和GLEW库来创建窗口和初始化OpenGL环境。要确保已正确安装和配置这些库，并将其链接到您的项目中。此外，上述代码使用了一个名为”frame.rgba”的文件作为输入视频帧。您需要将RGBA格式的视频帧保存为该文件，并将其放置在与源代码相同的目录下。在渲染循环中，我们使用了一个变换矩阵来实现对矩形的旋转操作。您可以根据需要调整旋转角度和变换矩阵的设置。</p><figure class="highlight fs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">#version <span class="number">120</span><span class="comment">//指定了使用的GLSL语言版本</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#if</span> __VERSION__<span class="operator">&lt;</span><span class="number">130</span> <span class="comment">//检查GLSL版本是否小于1.30</span></span><br><span class="line">#define TEXTURE2D texture2D</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">#define TEXTURE2D texture</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">#define Texture2D  sampler2D <span class="comment">//定义了一个名为Texture2D的宏，它表示一个sampler2D类型的变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了一个SWITCH宏，它接受一个变量作为参数，并开始了一个do-while循环。它还定义了一个CASE宏，它接受一个值作为参数，并开始了一个if语句。DEFAULT宏结束了CASE宏开始的if语句。ENDSWITCH宏结束了SWITCH宏开始的do-while循环</span></span><br><span class="line">#define SWITCH(var)int v_var<span class="operator">=</span>var;&#123;<span class="keyword">do</span>&#123;</span><br><span class="line">    #define CASE(<span class="keyword">val</span>)&#125;<span class="keyword">if</span>(v_var<span class="operator">==</span><span class="keyword">val</span>)&#123;</span><br><span class="line">    #define DEFAULT()&#125;;</span><br><span class="line">#define ENDSWITCH()&#125;<span class="keyword">while</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Global variables</span></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line">uniform int rotateType; <span class="comment">//行声明了一个uniform变量rotateType，它表示要应用的旋转类型;0:clockwise 90;1:clockwise 180;2:clockwise 270;3:flip X; 4:flip Y</span></span><br><span class="line">uniform Texture2D overlay;<span class="comment">//声明了一个uniform变量overlay，它表示覆盖纹理     </span></span><br><span class="line">uniform float    g_fTime; <span class="comment">//行声明了一个uniform变量g_fTime，它表示时间            </span></span><br><span class="line">uniform int overlay_Width;<span class="comment">//声明了一个uniform变量overlay_Width，它表示覆盖纹理的宽度</span></span><br><span class="line">uniform int overlay_Height;<span class="comment">//声明了一个uniform变量overlay_Height，它表示覆盖纹理的高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了两个结构体，VS_INPUT和VS_OUTPUT，它们分别表示顶点输入和输出</span></span><br><span class="line"><span class="keyword">struct</span> VS_INPUT</span><br><span class="line">&#123;</span><br><span class="line">    vec4 Position; <span class="comment">// vertex position </span></span><br><span class="line">    vec2 TextureUV;   <span class="comment">// vertex texture coords </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> VS_OUTPUT</span><br><span class="line">&#123;</span><br><span class="line">    vec4 Position; <span class="comment">// vertex position </span></span><br><span class="line">    vec2 TextureUV;  <span class="comment">// vertex texture coords </span></span><br><span class="line">&#125;vs_output;</span><br><span class="line"></span><br><span class="line">varying vec4 vs_output_position;<span class="comment">//声明了一个varying变量vs_output_position，它将保存顶点的变换后的位置</span></span><br><span class="line">varying vec2 vs_output_textureUV;<span class="comment">//声明了一个varying变量vs_output_textureUV，它将保存顶点的纹理坐标</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示像素着色器的输出</span></span><br><span class="line"><span class="keyword">struct</span> PS_OUTPUT</span><br><span class="line">&#123;</span><br><span class="line">    vec4 RGBA;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了一个像素着色器函数PS_2D，它接受一个VS_OUTPUT结构体作为输入。它根据旋转类型对纹理坐标进行变换，并使用TEXTURE2D宏获取覆盖纹理的颜色。最后，它将颜色赋值给输出结构体的RRGBA分量</span></span><br><span class="line">PS_OUTPUT PS_2D( VS_OUTPUT In)</span><br><span class="line">&#123; </span><br><span class="line">    PS_OUTPUT Output;</span><br><span class="line">    float ow <span class="operator">=</span> float(overlay_Width);</span><br><span class="line">    float oh <span class="operator">=</span> float(overlay_Height);</span><br><span class="line">   </span><br><span class="line">    vec2 tc <span class="operator">=</span> In.TextureUV;</span><br><span class="line">    vec2 temCoord <span class="operator">=</span> tc;</span><br><span class="line">    vec4 color <span class="operator">=</span> vec4(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>); </span><br><span class="line">    SWITCH(rotateType )</span><br><span class="line">    &#123;</span><br><span class="line">        CASE(<span class="number">0</span>)</span><br><span class="line">                temCoord <span class="operator">=</span> vec2(temCoord.y,<span class="number">1.0</span> <span class="operator">-</span> temCoord.x);</span><br><span class="line">                break;</span><br><span class="line">        CASE(<span class="number">1</span>)</span><br><span class="line">                temCoord <span class="operator">=</span> <span class="number">1.0</span> <span class="operator">-</span> temCoord;</span><br><span class="line">                break;</span><br><span class="line">        CASE(<span class="number">2</span>)</span><br><span class="line">                temCoord <span class="operator">=</span>  vec2(<span class="number">1.0</span> <span class="operator">-</span> temCoord.y,temCoord.x);</span><br><span class="line">                break;</span><br><span class="line">        CASE(<span class="number">3</span>)</span><br><span class="line">                temCoord <span class="operator">=</span>  vec2(<span class="number">1.0</span> <span class="operator">-</span> temCoord.x,temCoord.y); </span><br><span class="line">                break;</span><br><span class="line">        CASE(<span class="number">4</span>)</span><br><span class="line">                temCoord <span class="operator">=</span>  vec2(temCoord.x,<span class="number">1.0</span> <span class="operator">-</span> temCoord.y); </span><br><span class="line">                break;</span><br><span class="line">        DEFAULT()</span><br><span class="line">                temCoord <span class="operator">=</span> vec2(temCoord.y,<span class="number">1.0</span> <span class="operator">-</span> temCoord.x);</span><br><span class="line">break;</span><br><span class="line">        ENDSWITCH()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">color <span class="operator">=</span> TEXTURE2D(overlay,temCoord);</span><br><span class="line"></span><br><span class="line">Output.RGBA <span class="operator">=</span> color;</span><br><span class="line">    <span class="keyword">return</span> Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了一个顶点着色器函数VS_2D，它接受一个VS_INPUT结构体作为输入，并返回一个VS_OUTPUT结构体</span></span><br><span class="line">VS_OUTPUT VS_2D(VS_INPUT vin)</span><br><span class="line">&#123;</span><br><span class="line">VS_OUTPUT vOut;</span><br><span class="line">vOut.Position <span class="operator">=</span> vin.Position;</span><br><span class="line">vOut.TextureUV <span class="operator">=</span> vin.TextureUV;</span><br><span class="line"><span class="keyword">return</span> vOut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将vs_output_position和vs_output_textureUV变量的值分别赋值给vs_output结构体的Position和TextureUV分量</span></span><br><span class="line">    vs_output.Position<span class="operator">=</span>vs_output_position;</span><br><span class="line">    vs_output.TextureUV<span class="operator">=</span>vs_output_textureUV;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用PS_2D函数，将vs_output结构体作为输入，并将返回的颜色赋值给ps_output变量</span></span><br><span class="line">    PS_OUTPUT ps_output<span class="operator">=</span>PS_2D(vs_output);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将ps_output变量的RGBA分量赋值给gl_FragColor，它表示像素的最终颜色</span></span><br><span class="line">    gl_FragColor<span class="operator">=</span>ps_output.RGBA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个基于GLSL的像素着色器代码，用于实现视频帧的旋转和翻转操作。该代码接受一个输入纹理（即视频帧），并根据旋转类型和翻转类型对其进行变换。在代码中，我们使用了一个switch语句来根据旋转类型和翻转类型选择不同的变换方式。具体来说，我们使用了以下旋转类型和翻转类型：</p><ul><li>0：顺时针旋转90度</li><li>1：顺时针旋转180度</li><li>2：顺时针旋转270度</li><li>3：水平翻转</li><li>4：垂直翻转<br>对于每种类型，我们使用不同的变换方式来计算输出纹理坐标。最后，我们使用TEXTURE2D函数从输入纹理中获取像素颜色，并将其作为输出像素颜色。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 120 <span class="comment">//指定了使用的GLSL语言版本</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWITCH(var)int v_var = var;&#123;do&#123;<span class="comment">//定义了一个名为SWITCH的宏，它接受一个变量作为参数。它声明了一个局部变量v_var，并将其赋值为输入变量的值。它还开始了一个do-while循环。</span></span></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> CASE(val)&#125;<span class="keyword">if</span>(v_var == val)&#123;<span class="comment">//定义了一个名为CASE的宏，它接受一个值作为参数。它检查v_var的值是否等于输入值。</span></span></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> DEFAULT()&#125;;<span class="comment">//定义了一个名为DEFAULT的宏，它结束了CASE宏开始的if语句。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENDSWITCH()&#125;while(false);<span class="comment">//定义了一个名为ENDSWITCH的宏，它结束了SWITCH宏开始的do-while循环。</span></span></span><br><span class="line"></span><br><span class="line">attribute vec4 position;<span class="comment">//声明了一个属性变量position，它表示顶点的位置</span></span><br><span class="line">attribute vec2 textureUV;<span class="comment">//声明了一个属性变量textureUV，它表示顶点的纹理坐标</span></span><br><span class="line"></span><br><span class="line">varying vec4 vs_output_position;<span class="comment">//声明了一个varying变量vs_output_position，它将保存顶点的变换后的位置</span></span><br><span class="line">varying vec2 vs_output_textureUV;<span class="comment">//声明了一个varying变量vs_output_textureUV，它将保存顶点的纹理坐标</span></span><br><span class="line">uniform <span class="type">int</span> rotateType;<span class="comment">//声明了一个uniform变量rotateType，它表示要应用的旋转类型,PS:0:clockwise 90;1:clockwise 180;2:clockwise 270;3:flip X; 4:flip Y</span></span><br><span class="line"></span><br><span class="line">uniform <span class="type">int</span> overlay_Width;<span class="comment">//声明了一个uniform变量overlay_Width，它表示覆盖纹理的宽度</span></span><br><span class="line">uniform <span class="type">int</span> overlay_Height;<span class="comment">//声明了一个uniform变量overlay_Height，它表示覆盖纹理的高度</span></span><br><span class="line"><span class="comment">// if rotate 180k+90, the output vertex coord should be shrink into rectangle</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算了输出位置的缩放因子，根据覆盖纹理的尺寸和旋转类型。它检查覆盖纹理的高度是否大于宽度，如果是，则缩放位置属性的x坐标。否则，缩放y坐标</span></span><br><span class="line">    <span class="type">float</span> k = <span class="built_in">float</span>(overlay_Height)/overlay_Width;</span><br><span class="line">    vec2 rotateScale = <span class="built_in">vec2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(rotateType==<span class="number">0</span> || rotateType==<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span>( k&lt;<span class="number">1.</span> )&#123;</span><br><span class="line">        rotateScale.x = k*k;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        rotateScale.y = <span class="number">1</span>/k;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// scale output</span></span><br><span class="line">    rotateScale = <span class="built_in">vec2</span>(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//将rotateScale变量重置为(1,1)。</span></span><br><span class="line">    vec2 pos = vs_output_position.xy;<span class="comment">//将vs_output_position变量的xy分量赋值给pos变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将位置属性的xy分量乘以rotateScale变量，并将结果赋值给vs_output_position变量。它还将相同的值赋给gl_Position变量，它表示顶点的最终位置。</span></span><br><span class="line">    gl_Position = vs_output_position = <span class="built_in">vec4</span>(position.xy*rotateScale,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将textureUV属性的值赋给vs_output_textureUV变量</span></span><br><span class="line">    vs_output_textureUV = textureUV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个基于GLSL的顶点着色器代码，用于实现视频帧的旋转和翻转操作。该代码接受一个输入顶点坐标和纹理坐标，并根据旋转类型和翻转类型对其进行变换。</p><p>在代码中，我们首先计算了旋转后输出纹理的宽高比，并根据宽高比调整输出顶点坐标的比例。然后，我们使用一个switch语句来根据旋转类型和翻转类型选择不同的变换方式。具体来说，我们使用了以下旋转类型和翻转类型：</p><ul><li>0：顺时针旋转90度</li><li>1：顺时针旋转180度</li><li>2：顺时针旋转270度</li><li>3：水平翻转</li><li>4：垂直翻转<br>对于每种类型，我们使用不同的变换方式来计算输出顶点坐标。最后，我们将变换后的顶点坐标和纹理坐标传递给像素着色器进行渲染。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL学习笔记（四）：着色器</title>
      <link href="/2023/07/01/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%9D%80%E8%89%B2%E5%99%A8/"/>
      <url>/2023/07/01/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%9D%80%E8%89%B2%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>本节对于着色器的讲解,不仅仅只限于<a href="https://learnopengl.com/Getting-started/Shaders">learnopengl.com</a> 对于三角形的颜色变化的讲解.</p><p>先讲基础知识</p><h2 id="GLSL基础知识"><a href="#GLSL基础知识" class="headerlink" title="GLSL基础知识"></a>GLSL基础知识</h2><h3 id="GLSL的基本数据类型"><a href="#GLSL的基本数据类型" class="headerlink" title="GLSL的基本数据类型"></a>GLSL的基本数据类型</h3><p>GLSL具备C语言的:int float double uint等基础数据类型.</p><p>在GLSL语法中,引入了一个重要的概念:向量</p><p>GLSL 中的向量是用于刚才提到的任何基本类型的2,3或4个分量容器。它们可以采用以下形式（n代表组件的数量）：</p><ul><li>vecn：默认的浮点数向量n。</li><li>bvecn：布尔向量n。</li><li>ivecn：整数向量n。</li><li>uvecn：无符号整数向量n。</li><li>dvecn：双分量向量n</li></ul><p>绝大多数情况下,我们都是采用默认的vecn(默认的浮点数向量n),因为其基本上能满足我们日常使用的所有应用场景.</p><p>vec.x可以通过x向量的第一个分量来访问向量的分量,vec.y,vec.z,vec.w同理.</p><p>同时在GLSL中向量这种矢量数据类型,还允许它们之间进行组合(当然前提是这些向量的类型得是一样的,比如都是默认的浮点数向量)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vec2 someVec;</span><br><span class="line">vec4 differentVec = someVec.xyxx;</span><br><span class="line">vec3 anotherVec = differentVec.zyw;</span><br><span class="line">vec4 otherVec = someVec.xxxx + anotherVec.yxzy;</span><br><span class="line"></span><br><span class="line">vec2 vect = vec2(0.5, 0.7);</span><br><span class="line">vec4 result = vec4(vect, 0.0, 0.0);</span><br><span class="line">vec4 otherResult = vec4(result.xyz, 1.0);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="GLSL-三种变量类型（uniform，attribute和varying）理解"><a href="#GLSL-三种变量类型（uniform，attribute和varying）理解" class="headerlink" title="GLSL 三种变量类型（uniform，attribute和varying）理解"></a>GLSL 三种变量类型（uniform，attribute和varying）理解</h3><p>1.uniform变量</p><p>uniform变量是外部程序传递给（vertex和fragment）shader的变量。因此它是application通过函数glUniform**（）函数赋值的。在（vertex和fragment）shader程序内部，uniform变量就像是C语言里面的常量（const ），它不能被shader程序修改。（shader只能用，不能改）</p><p>如果uniform变量在vertex和fragment两者之间声明方式完全一样，则它可以在vertex和fragment共享使用。（相当于一个被vertex和fragment shader共享的全局变量）</p><p>uniform变量一般用来表示：变换矩阵，材质，光照参数和颜色等信息。</p><p>2.attribute变量<br>attribute变量是只能在vertex shader中使用的变量。（它不能在fragment shader中声明attribute变量，也不能被fragment shader中使用）</p><p>一般用attribute变量来表示一些顶点的数据，如：顶点坐标，法线，纹理坐标，顶点颜色等。</p><p>在application中，一般用函数glBindAttribLocation（）来绑定每个attribute变量的位置，然后用函数glVertexAttribPointer（）为每个attribute变量赋值。</p><p>3.varying变量</p><p>varying变量是vertex和fragment shader之间做数据传递用的。一般vertex shader修改varying变量的值，然后fragment shader使用该varying变量的值。因此varying变量在vertex和fragment shader二者之间的声明必须是一致的。application不能使用此变量。</p><h3 id="in-out-关键字的作用"><a href="#in-out-关键字的作用" class="headerlink" title="in out 关键字的作用"></a>in out 关键字的作用</h3><h3 id="version-version-number的作用"><a href="#version-version-number的作用" class="headerlink" title="#version version_number的作用"></a>#version version_number的作用</h3><p>每个GLSL编写的着色器程序的第一行中都需要写上这句话,作用是指定当前OpenGL的版本,一般我们都是定义为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br></pre></td></tr></table></figure><p>或者:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#version 330</span><br></pre></td></tr></table></figure><p>加不加core都行</p><p>当然,如果在实际的应用生产环境下,用户的PC上的OpenGL可能是低版本的,当我们没有用到 OpenGL 3.1 的任何扩展功能的时候,我们为了兼容性,可以将其设置为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#version 120</span><br></pre></td></tr></table></figure><h3 id="layout-qualifier1​-qualifier2​-x3D-value-…-variable-definition-的作用"><a href="#layout-qualifier1​-qualifier2​-x3D-value-…-variable-definition-的作用" class="headerlink" title="layout(qualifier1​, qualifier2​ &#x3D; value, …) variable definition 的作用"></a>layout(qualifier1​, qualifier2​ &#x3D; value, …) variable definition 的作用</h3><p>layout(location &#x3D; 0)，叫做布局限定符，目的是为了方便给变量提供数据，layout()的还有其他的选项，在这里location相当于设定了变量在着色器程序中的访问位置(GLSL除了这个限定符，还有很多其它限定符，比如存储限定符、内存限定符、插值限定符等)。</p><p><a href="https://blog.csdn.net/hankern/article/details/89325452">https://blog.csdn.net/hankern/article/details/89325452</a></p><h2 id="learnopengl-例程讲解"><a href="#learnopengl-例程讲解" class="headerlink" title="learnopengl 例程讲解"></a>learnopengl 例程讲解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *vertexShaderSource =<span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   gl_Position = vec4(aPos, 1.0);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *fragmentShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;uniform vec4 ourColor;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   FragColor = ourColor;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\n\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">    <span class="comment">// ------------------------------</span></span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build and compile our shader program</span></span><br><span class="line">    <span class="comment">// ------------------------------------</span></span><br><span class="line">    <span class="comment">// vertex shader</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);<span class="comment">//创建顶点着色器</span></span><br><span class="line">    <span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);<span class="comment">//绑定顶点着色器的Shader脚本</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(vertexShader);<span class="comment">//编译顶点着色器Shader脚本</span></span><br><span class="line">    <span class="comment">// check for shader compile errors</span></span><br><span class="line">    <span class="type">int</span> success;</span><br><span class="line">    <span class="type">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success);<span class="comment">//检测顶点着色器Shader脚本是否成功编译</span></span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fragment shader</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);<span class="comment">//创建片元着色器</span></span><br><span class="line">    <span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);<span class="comment">//绑定片元着色器的Shader脚本</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(fragmentShader);<span class="comment">//编译片元着色器Shader脚本</span></span><br><span class="line">    <span class="comment">// check for shader compile errors</span></span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(fragmentShader, GL_COMPILE_STATUS, &amp;success);<span class="comment">//检测片元着色器Shader脚本是否成功编译</span></span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// link shaders</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> shaderProgram = <span class="built_in">glCreateProgram</span>();<span class="comment">//创建一个空的程序对象并返回一个可以引用它的非零值</span></span><br><span class="line">    <span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);<span class="comment">//将顶点着色器对象附加到程序对象</span></span><br><span class="line">    <span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);<span class="comment">//将片元着色器对象附加到程序对象</span></span><br><span class="line">    <span class="built_in">glLinkProgram</span>(shaderProgram);<span class="comment">//将所有的着色器链接到最终的程序对象上</span></span><br><span class="line">    <span class="comment">// check for linking errors</span></span><br><span class="line">    <span class="built_in">glGetProgramiv</span>(shaderProgram, GL_LINK_STATUS, &amp;success);<span class="comment">//检测程序对象是否成功链接</span></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="built_in">glGetProgramInfoLog</span>(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放内存并使与着色器指定的着色器对象关联的名称无效。此命令有效地撤消了调用glCreateShader的效果</span></span><br><span class="line">    <span class="comment">//如果要删除的着色器对象附加到程序对象，则它会被标记为删除，但不会被删除，直到它不再附加到任何程序对象</span></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up vertex data (and buffer(s)) and configure vertex attributes</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="type">float</span> vertices[] = &#123;<span class="comment">//想要渲染单个三角形，所以我们想要指定总共三个顶点，每个顶点都有一个 3D 位置</span></span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// bottom right</span></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// bottom left</span></span><br><span class="line">         <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// top </span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> VBO, VAO;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);<span class="comment">//生成一个顶点数组对象</span></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);<span class="comment">//生成一个缓冲区对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);<span class="comment">//绑定顶点数组对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定并设置顶点缓冲区</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<span class="comment">//分配内存,并将顶点数据存储在当前绑定的缓冲区对象的初始化内存中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置顶点属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    glVertexAttribPointer有相当多的参数，所以让我们仔细看看它们：</span></span><br><span class="line"><span class="comment">        第一个参数指定我们要配置的顶点属性。请记住，我们使用指定了顶点着色器中位置顶点属性的位置layout (location = 0)。</span></span><br><span class="line"><span class="comment">            这将顶点属性的位置设置为0，并且由于我们想要将数据传递给该顶点属性，因此我们传入0。</span></span><br><span class="line"><span class="comment">        第二个参数指定顶点属性的大小。顶点属性是一个vec3，因此它由值组成3。</span></span><br><span class="line"><span class="comment">        第三个参数指定数据类型GL_FLOAT（GLSL 中的 avec*由浮点值组成）。</span></span><br><span class="line"><span class="comment">        第四个参数指定我们是否希望数据标准化。如果我们输入整数数据类型（int、byte）并将其设置为GL_TRUE，</span></span><br><span class="line"><span class="comment">            则​​整数数据将标准化为0（或-1有符号数据）并1在转换为浮点数时。这与我们无关，因此我们将其保留为GL_FALSE。</span></span><br><span class="line"><span class="comment">        第五个参数称为跨步并告诉我们连续顶点属性之间的空间。</span></span><br><span class="line"><span class="comment">            由于下一组位置数据恰好位于距离大小的3倍处，因此float我们将该值指定为步幅。请注意，</span></span><br><span class="line"><span class="comment">            由于我们知道数组是紧密排列的（下一个顶点属性值之间没有空格），因此我们还可以指定步幅，以便让0OpenGL确定步幅（这仅在值紧密排列时有效）。</span></span><br><span class="line"><span class="comment">            每当我们有更多顶点属性时，我们都必须仔细定义每个顶点属性之间的间距。</span></span><br><span class="line"><span class="comment">        最后一个参数是类型void*，因此需要奇怪的强制转换。这是抵消位置数据在缓冲区中开始的位置。由于位置数据位于数据数组的开头，因此该值只是0。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);<span class="comment">//指定要启动的顶点属性的索引</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 您可以随后取消绑定 VAO，这样其他 VAO 调用就不会意外修改此 VAO，但这种情况很少发生。修改其他</span></span><br><span class="line">    <span class="comment">// VAO 无论如何都需要调用 glBindVertexArray，所以当不是直接需要时我们通常不会取消绑定 VAO（也不是 VBO）。</span></span><br><span class="line">    <span class="comment">// glBindVertexArray(0);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定 VAO（它已经绑定，但只是为了演示）：因为我们只有一个 VAO，所以我们可以</span></span><br><span class="line">    <span class="comment">// 在渲染相应的三角形之前预先绑定它；这是另一种方法。</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// while循环实时渲染画面</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        <span class="comment">// ------</span></span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);<span class="comment">//指定颜色缓冲区的清除值 rgba分量</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<span class="comment">//指定清除颜色缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// be sure to activate the shader before any calls to glUniform</span></span><br><span class="line">        <span class="built_in">glUseProgram</span>(shaderProgram);<span class="comment">//将给定的程序对象设置成当前活动的着色器程序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// update shader uniform</span></span><br><span class="line">        <span class="type">double</span>  timeValue = <span class="built_in">glfwGetTime</span>();<span class="comment">//获取时间</span></span><br><span class="line">        <span class="type">float</span> greenValue = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(<span class="built_in">sin</span>(timeValue) / <span class="number">2.0</span> + <span class="number">0.5</span>);<span class="comment">//根据当前时间实时改变g分量值</span></span><br><span class="line">        <span class="type">int</span> vertexColorLocation = <span class="built_in">glGetUniformLocation</span>(shaderProgram, <span class="string">&quot;ourColor&quot;</span>);<span class="comment">//检索给定的着色器程序的统一位置和统一对象</span></span><br><span class="line">        <span class="built_in">glUniform4f</span>(vertexColorLocation, <span class="number">0.0f</span>, greenValue, <span class="number">0.0f</span>, <span class="number">1.0f</span>);<span class="comment">//设置当前活动着色器程序的统一值(uniform vec4 ourColo:刚好对应设置rgba分量)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// render the triangle</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        glDrawArrays(int mode, int first,int count)</span></span><br><span class="line"><span class="comment">            参数1：有三种取值</span></span><br><span class="line"><span class="comment">                1.GL_TRIANGLES：每三个顶之间绘制三角形，之间不连接</span></span><br><span class="line"><span class="comment">                2.GL_TRIANGLE_FAN：以V0V1V2,V0V2V3,V0V3V4，……的形式绘制三角形</span></span><br><span class="line"><span class="comment">                3.GL_TRIANGLE_STRIP：顺序在每三个顶点之间均绘制三角形。这个方法可以保证从相同的方向上所有三角形均被绘制。以V0V1V2,V1V2V3,V2V3V4……的形式绘制三角形</span></span><br><span class="line"><span class="comment">            参数2：从数组缓存中的哪一位开始绘制，一般都定义为0</span></span><br><span class="line"><span class="comment">            参数3：顶点的数量</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfw：交换缓冲区和轮询 IO 事件（按键按下/释放、鼠标移动等）</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);<span class="comment">//交换指定窗口双缓冲区的前后缓冲区</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();<span class="comment">//轮询 IO 事件.判断是否触发回调framebuffer_size_callback</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional: de-allocate all resources once they&#x27;ve outlived their purpose:</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="built_in">glDeleteProgram</span>(shaderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放glfw资源</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();<span class="comment">//释放所有先前分配的GLFW资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the viewport matches the new window dimensions; note that width and </span></span><br><span class="line">    <span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>总结遇到“undefined reference to&quot;问题的解决方法</title>
      <link href="/2023/06/19/%E6%80%BB%E7%BB%93%E9%81%87%E5%88%B0%E2%80%9Cundefined%20reference%20to%22%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2023/06/19/%E6%80%BB%E7%BB%93%E9%81%87%E5%88%B0%E2%80%9Cundefined%20reference%20to%22%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在进行编解码底层代码迁移时，经常在CodeBloks编译时遇到“undefined reference to”的编译报错问题，因此在此进行记录和总结。</p><p>一般来说，出现“undefined reference to”报错主要是因为如下几种原因</p><ul><li>链接时候缺少了相关的目标文件（也就是找不到某个函数的实现文件xx.o）</li><li>链接时候缺少相关库函数（一般是找不到相关的静态库xx.a）</li><li>所链接的库文件中还用到了其他的库文件（mian.o链接到lib_A.a,但是lib_A.o的库文件中某个函数其实又使用到其他的库函数（比如lib_B.a），此时应该把该静态库使用到的其他静态库也一起添加进来）</li><li>多个库文件链接时候顺序有问题（只有MAC上才允许顺序可以随意，而我们在Linux上进行CodeBloks上编译，要特别注意，这种问题非常隐蔽，所以在编译时候使用库的要求是越是基础的库越要写在后面,无论是静态还动态）</li><li>所依赖的库中，某个被调用到的函数存在定义和实现不一致的情况（例如在生成lib_A.a的文件a.cpp中，存在定义void Fun(int x);而实现却是void Fun(unsigned int);)</li><li>在C++代码中链接了C语言的库（例如main.cpp为C++函数，而静态库Lib_A.a所在的a.c为C函数，此时需要在a.c中的函数中添加extern “C”作为声明）</li><li>如果提示未定义的函数是程序中的函数，除了检查是否在头文件中声明之外，还有一种很隐蔽的可能：检查改函数的代码的上下文是否有#ifdef或者#ifndef等预编译信息，这也很有可能导致相关代码没有被编译而出现“undefined reference to”提示（在某些第三方库，例如FFmpeg，会利用config.h文件中的#define xxx 0或#define xxx 1来控制是否打开某个功能或适配某个操作系统）。<br>CheckPointer</li></ul><p>如果实在程序运行时候报该错误，就要注意是否是由于某些库没有链接进来或者某些接口没有实现的原因；一般来说基本上是由于程序使用了dlopen方式载入.so, 但.so没有把所有需要的库都链接上。因此对于动态链接库，实际的符号定位是在运行期进行的．在编译.so的时候，如果没有把它需要的库和他一起进行联编，比如libx.so 需要使用uldict, 但是忘记在编译libx.so的时候加上-luldict的话，在编译libx.so的时候不会报错，因为这个时候libx.so被认为是一个库，它里面存在一些不知道具体实现的符号是合法的，是可以在运行期指定或者编译另外的二进制程序的时候指定．</p><h3 id="Linux-gcc链接规则："><a href="#Linux-gcc链接规则：" class="headerlink" title="Linux gcc链接规则："></a>Linux gcc链接规则：</h3><p>链接的时候查找顺序是:</p><ul><li>-L 指定的路径, 从左到右依次查找</li><li>由 环境变量 LIBRARY_PATH 指定的路径,使用”:”分割从左到右依次查找</li><li>&#x2F;etc&#x2F;ld.so.conf 指定的路径顺序</li><li>&#x2F;lib 和 &#x2F;usr&#x2F;lib (64位下是&#x2F;lib64和&#x2F;usr&#x2F;lib64)</li></ul><p>动态库调用的查找顺序:</p><ul><li>ld的-rpath参数指定的路径, 这是写死在代码中的</li><li>ld脚本指定的路径</li><li>LD_LIBRARY_PATH 指定的路径</li><li>&#x2F;etc&#x2F;ld.so.conf 指定的路径</li><li>&#x2F;lib和&#x2F;usr&#x2F;lib(64位下是&#x2F;lib64和&#x2F;usr&#x2F;lib64)</li></ul><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;一般情况链接的时候我们采用-L的方式指定查找路径, 调用动态链接库的时候采用LD_LIBRARY_PATH的方式指定链接路径.</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;另外注意一个问题,就是只要查找到第一个就会返回,后面的不会再查找. 比如-L.&#x2F;A -L.&#x2F;B -lx 在A中有libx.a B中有libx.a和libx.so, 这个时候会使用在.&#x2F;A的libx.a 而不会遵循动态库优先的原则,因为.&#x2F;A是先找到的,并且没有同名动态库存在</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果是采用　g++ -Lpath -lx 的方式进行编译，链接器会发现所需要的uldict的符号表找不到从而报错，但是如果是程序采用dlopen的方式载入，由于是运行期，这个程序在这个地方就直接运行报错了．另外还有一种情况就是一个对外的接口在动态库中已经声明定义了，但是忘记实现了，这个时候也会产生类似的错误．</p><p>在CodeBloks上编译Linux版本FFMPEG中的kernaldec-4.2.1时，遇到“Undefined reference to operator new”和”Undefined reference to operator delete“的报错，跟据网上资料显示需要将-lstdc++标志添加到链接器，但是在CodeBlosks的Linker settings中的Other linker options里面添加-lstdc++时却没有效果，原因是在这里面添加该标志时，该标志会出现在中间，这样将可能会造成参数失效情况，因此最好是直接添加在最后面，也就是在CodeBlosks的Linker settings中的 Link libraries最后面加上该标准：<br>![](.&#x2F;总结遇到“undefined reference to”问题的解决方法&#x2F;1.png)</p><p>最终正确的gcc编译命令如下（-lstdc++ -lm放在最后面）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared  obj/Release/FFMPEG/FFmpeg-n4.2.1/libavcodec/allcodecs.o obj/Release/FFMPEG/FFmpeg-n4.2.1/libavcodec/avpicture.o obj/Release/FFMPEG/FFmpeg-n4.2.1/libavcodec/bitstream_filters.o obj/Release/FFMPEG/FFmpeg-n4.2.1/libavcodec/bsf.o obj/Release/FFMPEG/FFmpeg-n4.2.1/libavcodec/imgconvert.o obj/Release/FFMPEG/FFmpeg-n4.2.1/libavcodec/parsers.o obj/Release/FFMPEG/FFmpeg-n4.2.1/libavcodec/utils.o obj/Release/FFMPEG/FFmpeg-n4.2.1/libavformat/allformats.o obj/Release/FFMPEG/FFmpeg-n4.2.1/libavformat/utils.o obj/Release/FFMPEG/FFmpeg-n4.2.1/libavresample/options.o obj/Release/FFMPEG/FFmpeg-n4.2.1/libavresample/utils.o obj/Release/FFMPEG/FFmpeg-n4.2.1/libavutil/audio_fifo.o obj/Release/FFMPEG/FFmpeg-n4.2.1/libavutil/intmath.o obj/Release/FFMPEG/FFmpeg-n4.2.1/libswresample/swresample.o obj/Release/FFMPEG/FFmpeg-n4.2.1/libswscale/swscale.o obj/Release/FFMPEG/FFmpeg-n4.2.1/libswscale/swscale_unscaled.o obj/Release/FFMPEG/FFmpeg-n4.2.1/libswscale/utils.o  -o ../../../../BinUbuntu/x64/Release/libkernaldec.so -static-libstdc++ -static-libgcc -Wl,-Bsymbolic -s -Wl,--unresolved-symbols=report-all -lm -Bsymbolic -fvisibility=hidden -static-libstdc++ -m64  ../libs/Release/libavformat.a ../libs/Release/libavcodec_decoders.a ../libs/Release/libavcodec_encoders.a ../libs/Release/libavcodec_parsers.a ../libs/Release/libavcodec.a ../libs/Release/libavresample.a ../libs/Release/libswresample.a ../libs/Release/libswscale.a ../libs/Release/libavutil.a ../libs/Release/libffmpegx86.a ../libs/Release/libamrnb.a ../libs/Release/libamrwb.a ../libs/Release/libvpx.a ../libs/Release/libvorbis.a ../libs/Release/libogg.a ../libs/Release/libx264.a ../libs/Release/libx265.a ../libs/Release/libopus.a ../libs/Release/libmp3lame.a ../libs/Release/libzvbi.a ../libs/Release/libiconv.a ../libs/Release/libbzip.a ../libs/Release/libaom.a ../libs/Release/libzlib.a ../libs/Release/libcharset.a -lpthread -lstdc++ -lm</span><br></pre></td></tr></table></figure><p>在用第三方OpenCV和libyuv来替换inter的IPP时候，出现以下报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undefined reference to `cv::imwrite(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, cv::_InputArray const&amp;, std::vector&lt;int, std::allocator&lt;int&gt; &gt; const&amp;)&#x27;</span><br></pre></td></tr></table></figure><p>网上搜了一下，基本是说注意上面的那个__cxx11。旧版本编译器编译出来的代码中，不会有这个符号。<br>用于编译该代码的gcc编译器的版本是5.5.0，而该代码所需要的opencv所使用的编译器的版本是4.8.0。</p><p>解决办法：</p><p>第一种：在编译的时候加上-D_GLIBCXX_USE_CXX11_ABI&#x3D;0即可（参考《g++命令行参数》的-Dmacro&#x3D;defn部分）。</p><p>第二种：在每个源文件中添加一个宏定义：# define _GLIBCXX_USE_CXX11_ABI 0。</p><p>亲自测试过后发现还是不行，最后研究发现是少加了libopencv_imgcodecs.so这个库。<br>![](.&#x2F;总结遇到“undefined reference to”问题的解决方法&#x2F;2.png)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL学习笔记（三）：画一个三角形</title>
      <link href="/2023/06/05/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%94%BB%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
      <url>/2023/06/05/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%94%BB%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<p>接下来，我们来学习一下，如何画一个三角形．<br>在学习此节之前，需要知道三个概念：</p><ul><li>顶点数组对象：Vertex Array Object，VAO</li><li>顶点缓冲对象：Vertex Buffer Object，VBO</li><li>元素缓冲对象：Element Buffer Object，EBO 或 索引缓冲对象 Index Buffer Object，IBO</li></ul><p>具体知识点请查看这篇<a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/">文章</a></p><p>用OpenGL来绘制一个三角形主要有以下几个步骤：</p><ul><li>创建一个顶点着色器（得知道三角形的三个点的坐标位置）</li><li>创建一个片段着色器（得知道这个三角形是什么颜色的）</li><li>编译顶点着色器和片段着色器</li><li>把这两个着色器对象链接到一个用来渲染的着色器程序对象（如果要使用刚才编译的着色器我们必须把它们链接为一个着色器程序对象）</li><li>告诉OpenGL该如何将顶点数据链接到顶点着色器的属性上</li><li>创建一个顶点数组对象（Vertex Array Object, VAO）来存储顶点属性</li><li>调用glUseProgram激活着色器程序对象，调用glBindVertexArray绑定VAO，调用glDrawArrays完成三角形的绘制</li></ul><h2 id="步骤一：创建一个顶点着色器"><a href="#步骤一：创建一个顶点着色器" class="headerlink" title="步骤一：创建一个顶点着色器"></a>步骤一：创建一个顶点着色器</h2><p>首先我们需要先给OpenGL输入一些顶点数据。<br>OpenGL是一个3D图形库，所以在OpenGL中我们指定的所有坐标都是3D坐标（x、y和z）。<br>OpenGL不是简单地把所有的3D坐标变换为屏幕上的2D像素；<br>OpenGL仅当3D坐标在3个轴（x、y和z）上-1.0到1.0的范围内时才处理它。<br>所有在这个范围内的坐标叫做标准化设备坐标，此范围内的坐标最终显示在屏幕上（在这个范围以外的坐标则不会显示）。</p><p>由于我们希望渲染一个三角形，我们一共要指定三个顶点数据</p><p>定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。</p><p>我们通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。</p><h2 id="步骤二：创建一个片段着色器"><a href="#步骤二：创建一个片段着色器" class="headerlink" title="步骤二：创建一个片段着色器"></a>步骤二：创建一个片段着色器</h2><h2 id="步骤三：编译顶点着色器和片段着色器"><a href="#步骤三：编译顶点着色器和片段着色器" class="headerlink" title="步骤三：编译顶点着色器和片段着色器"></a>步骤三：编译顶点着色器和片段着色器</h2><h2 id="步骤四：把这两个着色器对象链接到一个用来渲染的着色器程序对象"><a href="#步骤四：把这两个着色器对象链接到一个用来渲染的着色器程序对象" class="headerlink" title="步骤四：把这两个着色器对象链接到一个用来渲染的着色器程序对象"></a>步骤四：把这两个着色器对象链接到一个用来渲染的着色器程序对象</h2><h2 id="步骤五：告诉OpenGL该如何将顶点数据链接到顶点着色器的属性上"><a href="#步骤五：告诉OpenGL该如何将顶点数据链接到顶点着色器的属性上" class="headerlink" title="步骤五：告诉OpenGL该如何将顶点数据链接到顶点着色器的属性上"></a>步骤五：告诉OpenGL该如何将顶点数据链接到顶点着色器的属性上</h2><h2 id="步骤六：创建一个顶点数组对象（Vertex-Array-Object-VAO）来存储顶点属性"><a href="#步骤六：创建一个顶点数组对象（Vertex-Array-Object-VAO）来存储顶点属性" class="headerlink" title="步骤六：创建一个顶点数组对象（Vertex Array Object, VAO）来存储顶点属性"></a>步骤六：创建一个顶点数组对象（Vertex Array Object, VAO）来存储顶点属性</h2><h2 id="步骤七：调用glUseProgram激活着色器程序对象，调用glBindVertexArray绑定VAO，调用glDrawArrays完成三角形的绘制"><a href="#步骤七：调用glUseProgram激活着色器程序对象，调用glBindVertexArray绑定VAO，调用glDrawArrays完成三角形的绘制" class="headerlink" title="步骤七：调用glUseProgram激活着色器程序对象，调用glBindVertexArray绑定VAO，调用glDrawArrays完成三角形的绘制"></a>步骤七：调用glUseProgram激活着色器程序对象，调用glBindVertexArray绑定VAO，调用glDrawArrays完成三角形的绘制</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    现代OpenGL需要我们至少设置一个顶点和一个片段着色器。</span></span><br><span class="line"><span class="comment">    #version 330 core</span></span><br><span class="line"><span class="comment">    layout (location = 0) in vec3 aPos;</span></span><br><span class="line"><span class="comment">    void main()</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    每个着色器都起始于一个版本声明。OpenGL 3.3以及和更高版本中，GLSL版本号和OpenGL的版本是匹配的（比如说GLSL 420版本对应于OpenGL 4.2）。我们同样明确表示我们会使用核心模式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    下一步，使用in关键字，在顶点着色器中声明所有的输入顶点属性(Input Vertex Attribute)。现在我们只关心位置(Position)数据，所以我们只需要一个顶点属性。</span></span><br><span class="line"><span class="comment">    GLSL有一个向量数据类型，它包含1到4个float分量，包含的数量可以从它的后缀数字看出来。由于每个顶点都有一个3D坐标，我们就创建一个vec3输入变量aPos。我们同样也通过layout (location = 0)设定了输入变量的位置值(Location)你后面会看到为什么我们会需要这个位置值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在图形编程中我们经常会使用向量这个数学概念，因为它简明地表达了任意空间中的位置和方向，并且它有非常有用的数学属性。在GLSL中一个向量有最多4个分量，每个分量值都代表空间中的一个坐标，它们可以通过vec.x、vec.y、vec.z和vec.w来获取。注意vec.w分量不是用作表达空间中的位置的（我们处理的是3D不是4D），而是用在所谓透视除法(Perspective Division)上。我们会在后面的教程中更详细地讨论向量。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    为了设置顶点着色器的输出，我们必须把位置数据赋值给预定义的gl_Position变量，它在幕后是vec4类型的。在main函数的最后，我们将gl_Position设置的值会成为该顶点着色器的输出。由于我们的输入是一个3分量的向量，我们必须把它转换为4分量的。我们可以把vec3的数据作为vec4构造器的参数，同时把w分量设置为1.0f（我们会在后面解释为什么）来完成这一任务。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//将顶点着色器的源代码硬编码在代码文件顶部的C风格字符串中,使得能在运行时动态编译它的源代码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在计算机图形中颜色被表示为有4个元素的数组：红色、绿色、蓝色和alpha(透明度)分量，通常缩写为RGBA。</span></span><br><span class="line"><span class="comment">    当在OpenGL或GLSL中定义一个颜色的时候，我们把颜色每个分量的强度设置在0.0到1.0之间。比如说我们设置红为1.0f，绿为1.0f，我们会得到两个颜色的混合色，即黄色。</span></span><br><span class="line"><span class="comment">    这三种颜色分量的不同调配可以生成超过1600万种不同的颜色！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #version 330 core</span></span><br><span class="line"><span class="comment">    out vec4 FragColor;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    void main()</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">    片段着色器只需要一个输出变量，这个变量是一个4分量向量，它表示的是最终的输出颜色，我们应该自己将其计算出来。</span></span><br><span class="line"><span class="comment">    声明输出变量可以使用out关键字，这里我们命名为FragColor。</span></span><br><span class="line"><span class="comment">    下面，我们将一个Alpha值为1.0(1.0代表完全不透明)的橘黄色的vec4赋值给颜色输出。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *fragmentShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\n\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">    <span class="comment">// ------------------------------</span></span><br><span class="line">    <span class="built_in">glfwInit</span>();<span class="comment">//初始化glfw</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">//主版本号(Major)设为3</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//次版本号(Minor)设为3</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<span class="comment">//使用核心模式(Core-profile)。明确告诉GLFW我们需要使用核心模式意味着我们只能使用OpenGL功能的一个子集</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接下来我们创建一个窗口对象，这个窗口对象存放了所有和窗口相关的数据，而且会被GLFW的其他函数频繁地用到。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//glfwCreateWindow函数需要窗口的宽和高作为它的前两个参数。第三个参数表示这个窗口的名称（标题），这里我们使用&quot;LearnOpenGL&quot;。最后两个参数我们暂时忽略。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();<span class="comment">//正确释放/删除之前的分配的所有资源</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);<span class="comment">//设置已创建窗口的Context为当前线程的主Context：</span></span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);<span class="comment">//注册窗口调整的回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))<span class="comment">//给GLAD传入了用来加载系统相关的OpenGL函数指针地址的函数。GLFW给我们的是glfwGetProcAddress，它根据我们编译的系统定义了正确的函数。</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// build and compile our shader program</span></span><br><span class="line">    <span class="comment">// ------------------------------------</span></span><br><span class="line">    <span class="comment">//顶点着色器：vertex shader</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);<span class="comment">//创建一个着色器对象，注意还是用ID来引用的。储存这个顶点着色器为unsigned int，然后用glCreateShader创建这个着色器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//glShaderSource函数把要编译的着色器对象作为第一个参数。第二参数指定了传递的源码字符串数量，这里只有一个。第三个参数是顶点着色器真正的源码，第四个参数我们先设置为NULL</span></span><br><span class="line">    <span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(vertexShader);</span><br><span class="line">    <span class="comment">// check for shader compile errors</span></span><br><span class="line">    <span class="type">int</span> success;</span><br><span class="line">    <span class="type">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success);<span class="comment">//glGetShaderiv检查在调用glCompileShader后编译是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);<span class="comment">//如果编译失败，我们会用glGetShaderInfoLog获取错误消息，然后打印它。</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//片段着色器：fragment shader</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);<span class="comment">//编译片段着色器的过程与顶点着色器类似，只不过我们使用GL_FRAGMENT_SHADER常量作为着色器类型：</span></span><br><span class="line">    <span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line">    <span class="comment">// check for shader compile errors</span></span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(fragmentShader, GL_COMPILE_STATUS, &amp;success);<span class="comment">//glGetShaderiv检查在调用glCompileShader后编译是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);<span class="comment">//如果编译失败，我们会用glGetShaderInfoLog获取错误消息，然后打印它。</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个着色器现在都编译了，剩下的事情是把两个着色器对象链接到一个用来渲染的着色器程序(Shader Program)中。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        着色器程序对象(Shader Program Object)是多个着色器合并之后并最终链接完成的版本。</span></span><br><span class="line"><span class="comment">        如果要使用刚才编译的着色器我们必须把它们链接(Link)为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。</span></span><br><span class="line"><span class="comment">        已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。</span></span><br><span class="line"><span class="comment">        当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，你会得到一个连接错误。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//link shaders</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> shaderProgram = <span class="built_in">glCreateProgram</span>();<span class="comment">//glCreateProgram函数创建一个程序，并返回新创建程序对象的ID引用。现在我们需要把之前编译的着色器附加到程序对象上，然后用glLinkProgram链接它们</span></span><br><span class="line">    <span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(shaderProgram);<span class="comment">//把着色器附加到了程序上，然后用glLinkProgram链接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// check for linking errors</span></span><br><span class="line">    <span class="comment">//就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志。与上面不同，我们不会调用glGetShaderiv和glGetShaderInfoLog而是glGetProgramiv和glGetProgramInfoLog</span></span><br><span class="line">    <span class="built_in">glGetProgramiv</span>(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="built_in">glGetProgramInfoLog</span>(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vertexShader);<span class="comment">//在把着色器对象链接到程序对象以后，就可以把之前创建的着色器对象删除了</span></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up vertex data (and buffer(s)) and configure vertex attributes</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="type">float</span> vertices[] = &#123;<span class="comment">//由于OpenGL是在3D空间中工作的，而我们渲染的是一个2D三角形，我们将它顶点的z坐标设置为0.0。这样子的话三角形每一点的深度(Depth，译注2)都是一样的，从而使它看上去像是2D的。</span></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// left  </span></span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// right </span></span><br><span class="line">         <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>  <span class="comment">// top   </span></span><br><span class="line">    &#125;; </span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> VBO, VAO;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);<span class="comment">//创建一个顶点数组对象</span></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);<span class="comment">//顶点缓冲具有一个独一无二的ID，所以我们可以使用glGenBuffers函数和一个缓冲ID生成一个VBO对象：</span></span><br><span class="line">    <span class="comment">// bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER。OpenGL允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型。我们可以使用glBindBuffer函数把新创建的缓冲绑定到GL_ARRAY_BUFFER目标上</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<span class="comment">//从这一刻起，我们使用的任何（在GL_ARRAY_BUFFER目标上的）缓冲调用都会用来配置当前绑定的缓冲(VBO)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        glBufferData是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。</span></span><br><span class="line"><span class="comment">        它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上。</span></span><br><span class="line"><span class="comment">        第二个参数指定传输数据的大小(以字节为单位)；用一个简单的sizeof计算出顶点数据大小就行。</span></span><br><span class="line"><span class="comment">        第三个参数是我们希望发送的实际数据。</span></span><br><span class="line"><span class="comment">        第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式：</span></span><br><span class="line"><span class="comment">                                                    GL_STATIC_DRAW ：数据不会或几乎不会改变。</span></span><br><span class="line"><span class="comment">                                                    GL_DYNAMIC_DRAW：数据会被改变很多。</span></span><br><span class="line"><span class="comment">                                                    GL_STREAM_DRAW ：数据每次绘制时都会改变。</span></span><br><span class="line"><span class="comment">        三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是GL_STATIC_DRAW。</span></span><br><span class="line"><span class="comment">        如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW或GL_STREAM_DRAW，这样就能确保显卡把数据放在能够高速写入的内存部分。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<span class="comment">//调用glBufferData函数，它会把之前定义的顶点数据复制到缓冲的内存中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    glVertexAttribPointer:</span></span><br><span class="line"><span class="comment">    第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用layout(location = 0)定义了position顶点属性的位置值(Location)吗？它可以把顶点属性的位置值设置为0。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入0。</span></span><br><span class="line"><span class="comment">    第二个参数指定顶点属性的大小。顶点属性是一个vec3，它由3个值组成，所以大小是3。</span></span><br><span class="line"><span class="comment">    第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的)。</span></span><br><span class="line"><span class="comment">    第四个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。</span></span><br><span class="line"><span class="comment">    第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个float之后，我们把步长设置为3 * sizeof(float)。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子（译注: 这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节）。</span></span><br><span class="line"><span class="comment">    第六个参数的类型是void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);<span class="comment">//glVertexAttribPointer函数告诉OpenGL该如何解析顶点数据（应用到逐个顶点属性上）</span></span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);<span class="comment">//glEnableVertexAttribArray，以顶点属性位置值作为参数，启用顶点属性；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute&#x27;s bound vertex buffer object so afterwards we can safely unbind</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// You can unbind the VAO afterwards so other VAO calls won&#x27;t accidentally modify this VAO, but this rarely happens. Modifying other</span></span><br><span class="line">    <span class="comment">// VAOs requires a call to glBindVertexArray anyways so we generally don&#x27;t unbind VAOs (nor VBOs) when it&#x27;s not directly necessary.</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// uncomment this call to draw in wireframe polygons.</span></span><br><span class="line">    <span class="comment">//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// render loop</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        <span class="comment">// ------</span></span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);<span class="comment">//用来设置清除后的背景颜色</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<span class="comment">//GL_COLOR_BUFFER_BIT: 当前可写的颜色缓冲</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// draw our first triangle</span></span><br><span class="line">        <span class="built_in">glUseProgram</span>(shaderProgram);<span class="comment">//我们可以调用glUseProgram函数，用刚创建的程序对象作为它的参数，以激活这个程序对象</span></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);<span class="comment">//glDrawArrays函数第一个参数是我们打算绘制的OpenGL图元的类型。由于我们在一开始时说过，我们希望绘制的是一个三角形，这里传递GL_TRIANGLES给它。第二个参数指定了顶点数组的起始索引，我们这里填0。最后一个参数指定我们打算绘制多少个顶点，这里是3（我们只从我们的数据中渲染一个三角形，它只有3个顶点长）。</span></span><br><span class="line">        <span class="comment">// glBindVertexArray(0); // no need to unbind it every time </span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional: de-allocate all resources once they&#x27;ve outlived their purpose:</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="built_in">glDeleteProgram</span>(shaderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();<span class="comment">//正确释放/删除之前的分配的所有资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span><span class="comment">//在GLFW中实现一些输入控制</span></span></span><br><span class="line"><span class="function"></span>&#123;LearnOpenGL/src/<span class="number">1.</span>getting_started/<span class="number">1.2</span>.<span class="function">hello_window_clear</span></span><br><span class="line"><span class="function">    <span class="title">if</span><span class="params">(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><span class="comment">//用GLFW的glfwGetKey函数，它需要一个窗口以及一个按键作为输入。这个函数将会返回这个按键是否正在被按下。</span></span></span><br><span class="line"><span class="function">        <span class="title">glfwSetWindowShouldClose</span><span class="params">(window, <span class="literal">true</span>)</span></span>;<span class="comment">//如果没有按下，glfwGetKey将会返回GLFW_RELEASE。如果用户的确按下了返回键，我们将通过glfwSetwindowShouldClose使用把WindowShouldClose属性设置为 true的方法关闭GLFW。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span><span class="comment">//对窗口注册一个回调函数(Callback Function)，它会在每次窗口大小被调整的时候被调用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the viewport matches the new window dimensions; note that width and </span></span><br><span class="line">    <span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">    <span class="comment">//通过调用glViewport函数来设置窗口的维度，告诉OpenGL渲染窗口的尺寸大小，即视口(Viewport)，</span></span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);<span class="comment">//glViewport函数前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素）。</span></span><br><span class="line">    <span class="comment">//ps:OpenGL幕后使用glViewport中定义的位置和宽高进行2D坐标的转换，将OpenGL中的位置坐标转换为你的屏幕坐标。例如，OpenGL中的坐标(-0.5, 0.5)有可能（最终）被映射为屏幕中的坐标(200,450)。注意，处理过的OpenGL坐标范围只为-1到1，因此我们事实上将(-1到1)范围内的坐标映射到(0, 800)和(0, 600)。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd LearnOpenGL/src/1.getting_started/2.1.hello_triangle</span><br><span class="line">g++ ../../glad.c hello_triangle.cpp -o hello_triangle -l GL -l GLU -l glut -l glfw3 -l dl -l pthread </span><br><span class="line">./hello_window</span><br></pre></td></tr></table></figure><p><img src="/./picture/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3/1.png"></p><p>g++ ..&#x2F;..&#x2F;glad.c ..&#x2F;..&#x2F;stb_image.cpp textures.cpp -o textures -I ..&#x2F;..&#x2F;..&#x2F;configuration -I ..&#x2F;..&#x2F;..&#x2F;includes -l GL -l GLU -l glut -l glfw3 -l dl -l pthread </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL学习笔记（一）：安装Ubuntu开发环境</title>
      <link href="/2023/06/04/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AE%89%E8%A3%85Ubuntu%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2023/06/04/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AE%89%E8%A3%85Ubuntu%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential   #编译器与基本的函式库</span><br><span class="line">sudo apt-get install libgl1-mesa-dev   #安装OpenGL Library</span><br><span class="line">sudo apt-get install libglu1-mesa-dev  #安装OpenGL Utilities,OpenGL Utilities是一组建构于 OpenGL Library 之上的工具组</span><br><span class="line">sudo apt-get install freeglut3-dev  #如果报错的话就改成输入：sudo apt-get install freeglut3-dev</span><br></pre></td></tr></table></figure><p>测试Demo如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ColoredVertex(c, v) do&#123; glColor3fv(c); glVertex3fv(v); &#125;while(0)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> angle = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> rotateMode = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myDisplay</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> list = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (list == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">GLfloat</span><br><span class="line">PointA[] = &#123; <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">-0.5f</span> &#125;,</span><br><span class="line">PointB[] = &#123; <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span> &#125;,</span><br><span class="line">PointC[] = &#123; <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span> &#125;,</span><br><span class="line">PointD[] = &#123; <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">-0.5f</span> &#125;,</span><br><span class="line">PointE[] = &#123; <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span> &#125;,</span><br><span class="line">PointF[] = &#123; <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.5f</span> &#125;,</span><br><span class="line">PointG[] = &#123; <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.5f</span> &#125;,</span><br><span class="line">PointH[] = &#123; <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span> &#125;;</span><br><span class="line">GLfloat</span><br><span class="line">ColorA[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">ColorB[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> &#125;,</span><br><span class="line">ColorC[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;,</span><br><span class="line">ColorD[] = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;,</span><br><span class="line">ColorE[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> &#125;,</span><br><span class="line">ColorF[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">ColorG[] = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">ColorH[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"> </span><br><span class="line">list = <span class="built_in">glGenLists</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">glNewList</span>(list, GL_COMPILE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 面1</span></span><br><span class="line"><span class="built_in">glBegin</span>(GL_POLYGON);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorA, PointA);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorE, PointE);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorH, PointH);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorD, PointD);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 面2</span></span><br><span class="line"><span class="built_in">glBegin</span>(GL_POLYGON);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorD, PointD);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorC, PointC);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorB, PointB);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorA, PointA);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 面3</span></span><br><span class="line"><span class="built_in">glBegin</span>(GL_POLYGON);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorA, PointA);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorB, PointB);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorF, PointF);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorE, PointE);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 面4</span></span><br><span class="line"><span class="built_in">glBegin</span>(GL_POLYGON);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorE, PointE);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorH, PointH);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorG, PointG);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorF, PointF);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 面5</span></span><br><span class="line"><span class="built_in">glBegin</span>(GL_POLYGON);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorF, PointF);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorB, PointB);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorC, PointC);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorG, PointG);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 面6</span></span><br><span class="line"><span class="built_in">glBegin</span>(GL_POLYGON);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorG, PointG);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorH, PointH);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorD, PointD);</span><br><span class="line"><span class="built_in">ColoredVertex</span>(ColorC, PointC);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br><span class="line"><span class="built_in">glEndList</span>();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已经创建了显示列表，在每次绘制正四面体时将调用它</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">glPushMatrix</span>();</span><br><span class="line"><span class="built_in">glRotatef</span>(angle / <span class="number">10</span>, <span class="number">1</span>, <span class="number">0.5</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="built_in">glCallList</span>(list);</span><br><span class="line"><span class="built_in">glPopMatrix</span>();</span><br><span class="line"><span class="built_in">glutSwapBuffers</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myIdle</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">++angle;</span><br><span class="line"><span class="keyword">if</span> (angle &gt;= <span class="number">3600.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line">angle = <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">myDisplay</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glutInit</span>(&amp;argc, argv);</span><br><span class="line"><span class="built_in">glutInitDisplayMode</span>(GLUT_RGBA | GLUT_DOUBLE);</span><br><span class="line"><span class="built_in">glutInitWindowPosition</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">glutInitWindowSize</span>(<span class="number">700</span>, <span class="number">700</span>);</span><br><span class="line"><span class="built_in">glutCreateWindow</span>(<span class="string">&quot;First OpenGL Program&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glutDisplayFunc</span>(&amp;myDisplay);</span><br><span class="line"><span class="built_in">glutIdleFunc</span>(&amp;myIdle);     <span class="comment">//空闲调用</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">glutMainLoop</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存退出后，在当前test.cpp文件下进入命令行窗口，进行编译连接的生成．</p><p>C++编译器编译生成输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp -o test  -l GL -l GLU -l glut</span><br></pre></td></tr></table></figure><p>C编译器编译生成输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.cpp -o test  -l GL -l GLU -l glut</span><br></pre></td></tr></table></figure><p>编译成功会输出名为test的执行文件， 接下来可以执行test文件，输入.&#x2F;test，效果如下：<br><img src="/./picture/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1/%E6%90%AD%E5%BB%BAOpenGL%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.png"></p><p>在我们画出出色的效果之前，首先要做的就是创建一个OpenGL上下文(Context)和一个用于显示的窗口。然而，这些操作在每个系统上都是不一样的，OpenGL有意将这些操作抽象(Abstract)出去。这意味着我们不得不自己处理创建窗口，定义OpenGL上下文以及处理用户输入。幸运的是，有一些库已经提供了我们所需的功能，其中一部分是特别针对OpenGL的。这些库节省了我们书写操作系统相关代码的时间，提供给我们一个窗口和一个OpenGL上下文用来渲染。</p><p>本文的OpenGL学习笔记是基于<a href="https://learnopengl-cn.github.io的linux学习笔记,因此,也根据learnopengl的教程要求,选择glad./">https://learnopengl-cn.github.io的Linux学习笔记，因此，也根据learnopengl的教程要求，选择GLAD．</a><br>glad 是继 gl3w，glew 之后，当前最新的用来访问 OpenGL 规范接口的第三方库。简单说 glad 是 glew 的升级版，就是说 glew 比较老，glad 比较新</p><h1 id="编译GLEW库"><a href="#编译GLEW库" class="headerlink" title="编译GLEW库"></a>编译GLEW库</h1><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/glfw/glfw.git</span><br></pre></td></tr></table></figure><p>接着打开Cmake gui,完成build路径设置后，点击Configure<br><img src="/./picture/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1/Cmake%E6%9E%84%E5%BB%BAGLFW.png"><br>先设置CMAKE_INSTALL_PREFIX将生成的so库先放到当前的install文件夹中,CMAKE_BUILD_TYPE设置为Release.接着点击Generate进行生成<br>然后退出Cmake gui软件，进入到glfw文件夹的build文件夹中，继续打开命令行，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j 15 #我的电脑是20核的cpu，所以可以支持15个编译命令同时执行，如果不清楚的话就输入make就行，只是编译速度会慢一点</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>接着我们再把install你面的文件copy出去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ../install</span><br><span class="line">sudo cp include/* -r /usr/include</span><br><span class="line">sudo cp lib/libglfw3.a /usr/lib/</span><br></pre></td></tr></table></figure><h1 id="编译GLAD库"><a href="#编译GLAD库" class="headerlink" title="编译GLAD库"></a>编译GLAD库</h1><p>因此我们先用Git下载GLAD源代码，并生成对应的libglad.so文件，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Dav1dde/glad.git</span><br><span class="line"></span><br><span class="line">cd glad</span><br><span class="line">git branch -a</span><br><span class="line">git checkout c</span><br><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p>成功切换后输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo cp include/* -r /usr/include</span><br><span class="line">gcc -fpic src/glad.c -c</span><br><span class="line">gcc -shared -Wl,-z,relro,-z,now -o libglad.so glad.o</span><br><span class="line">sudo cp libglad.so /usr/lib/</span><br></pre></td></tr></table></figure><p>此时就完成了GLAD的安装啦</p><p><font color = red>PS:当然如果你需要指定GLAD的安装版本的话</font>，那么可以进入GLAD<a href="https://glad.dav1d.de/">在线服务</a></p><p>将语言(Language)设置为 C &#x2F; C++，在 API 选项中，选择3.3 以上的 OpenGL(gl) 版本（我们的教程中将使用 3.3 版本，但更新的版本也能用）。之后将模式 (Profile) 设置为 Core，并且保证选中了生成加载器(Generate a loader) 选项。现在可以先（暂时）忽略扩展(Extensions)中的内容。都选择完之后，点击生成 (Generate) 按钮来生成库文件。</p><p>GLAD 现在应该提供给你了一个 zip 压缩文件，点击glad.zip进行下载，解压后的glad文件夹包含两个头文件目录，和一个glad.c文件。<br>接着重复上面的步骤进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd glad</span><br><span class="line">sudo cp include/* -r /usr/include</span><br><span class="line">gcc -fpic src/glad.c -c</span><br><span class="line">gcc -shared -Wl,-z,relro,-z,now -o libglad.so glad.o</span><br><span class="line">sudo cp libglad.so /usr/lib/</span><br></pre></td></tr></table></figure><p>最后我们来测试一下上面的安装是否成功，下载LearnOpenGL仓库代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/JoeyDeVries/LearnOpenGL.git</span><br></pre></td></tr></table></figure><p>接着输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd LearnOpenGL/src/1.getting_started/1.1.hello_window</span><br><span class="line">g++ ../../glad.c hello_window.cpp -o hello_window -l GL -l GLU -l glut -l glfw3 -l dl -l pthread </span><br><span class="line">./hello_window</span><br></pre></td></tr></table></figure><p>如果出现一个黑色窗口，则代表OpenGL的开发环境搭建成功啦！！！</p><p>接下来的章节，我们将通过学习LearnOpenGL中src文件夹里面的参考例程来学习OpenGL啦</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL学习笔记（二）：画个窗口界面</title>
      <link href="/2023/06/04/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%94%BB%E4%B8%AA%E7%AA%97%E5%8F%A3%E7%95%8C%E9%9D%A2/"/>
      <url>/2023/06/04/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%94%BB%E4%B8%AA%E7%AA%97%E5%8F%A3%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>衔接上一章节的内容，我们今天来讲解一下hello_window.cpp代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">    <span class="comment">// ------------------------------</span></span><br><span class="line">    <span class="built_in">glfwInit</span>();<span class="comment">//初始化glfw</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">//主版本号(Major)设为3</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//次版本号(Minor)设为3</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<span class="comment">//使用核心模式(Core-profile)。明确告诉GLFW我们需要使用核心模式意味着我们只能使用OpenGL功能的一个子集</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接下来我们创建一个窗口对象，这个窗口对象存放了所有和窗口相关的数据，而且会被GLFW的其他函数频繁地用到。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//glfwCreateWindow函数需要窗口的宽和高作为它的前两个参数。第三个参数表示这个窗口的名称（标题），这里我们使用&quot;LearnOpenGL&quot;。最后两个参数我们暂时忽略。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();<span class="comment">//正确释放/删除之前的分配的所有资源</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);<span class="comment">//设置已创建窗口的Context为当前线程的主Context：</span></span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);<span class="comment">//注册窗口调整的回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//GLAD是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLAD</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))<span class="comment">//给GLAD传入了用来加载系统相关的OpenGL函数指针地址的函数。GLFW给我们的是glfwGetProcAddress，它根据我们编译的系统定义了正确的函数。</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// render loop</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))<span class="comment">//渲染循环,glfwWindowShouldClose函数在我们每次循环的开始前检查一次GLFW是否被要求退出，如果是的话该函数返回true然后渲染循环便结束了，</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);<span class="comment">//glfwSwapBuffers函数会交换颜色缓冲（它是一个储存着GLFW窗口每一个像素颜色值的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();<span class="comment">//glfwPollEvents函数检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();<span class="comment">//渲染结束，正确释放/删除之前的分配的所有资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span><span class="comment">//在GLFW中实现一些输入控制</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<span class="comment">//用GLFW的glfwGetKey函数，它需要一个窗口以及一个按键作为输入。这个函数将会返回这个按键是否正在被按下。</span></span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);<span class="comment">//如果没有按下，glfwGetKey将会返回GLFW_RELEASE。如果用户的确按下了返回键，我们将通过glfwSetwindowShouldClose使用把WindowShouldClose属性设置为 true的方法关闭GLFW。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span><span class="comment">//对窗口注册一个回调函数(Callback Function)，它会在每次窗口大小被调整的时候被调用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the viewport matches the new window dimensions; note that width and </span></span><br><span class="line">    <span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">    <span class="comment">//通过调用glViewport函数来设置窗口的维度，告诉OpenGL渲染窗口的尺寸大小，即视口(Viewport)，</span></span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);<span class="comment">//glViewport函数前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素）。</span></span><br><span class="line">    <span class="comment">//ps:OpenGL幕后使用glViewport中定义的位置和宽高进行2D坐标的转换，将OpenGL中的位置坐标转换为你的屏幕坐标。例如，OpenGL中的坐标(-0.5, 0.5)有可能（最终）被映射为屏幕中的坐标(200,450)。注意，处理过的OpenGL坐标范围只为-1到1，因此我们事实上将(-1到1)范围内的坐标映射到(0, 800)和(0, 600)。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd LearnOpenGL/src/1.getting_started/1.1.hello_window</span><br><span class="line">g++ ../../glad.c hello_window.cpp -o hello_window -l GL -l GLU -l glut -l glfw3 -l dl -l pthread </span><br><span class="line">./hello_window</span><br></pre></td></tr></table></figure><p><img src="/./picture/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2/1.png"></p><p>接着说一下LearnOpenGL&#x2F;src&#x2F;1.getting_started&#x2F;1.2.hello_window_clear．cpp代码，它在hello_window．cpp的基础上在while循环渲染语句内添加了以下两行代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空背景颜色</span></span><br><span class="line"><span class="comment">// 当调用glClear函数，清除颜色缓冲之后，</span></span><br><span class="line"><span class="comment">// 整个颜色缓冲都会被填充为glClearColor里所设置的颜色</span></span><br><span class="line"><span class="comment">// 在这里，我们将屏幕设置为了类似黑板的深蓝绿色</span></span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);<span class="comment">//用来设置清除后的背景颜色</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<span class="comment">//GL_COLOR_BUFFER_BIT: 当前可写的颜色缓冲</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">    <span class="comment">// ------------------------------</span></span><br><span class="line">    <span class="built_in">glfwInit</span>();<span class="comment">//初始化glfw</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">//主版本号(Major)设为3</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//次版本号(Minor)设为3</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<span class="comment">//使用核心模式(Core-profile)。明确告诉GLFW我们需要使用核心模式意味着我们只能使用OpenGL功能的一个子集</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接下来我们创建一个窗口对象，这个窗口对象存放了所有和窗口相关的数据，而且会被GLFW的其他函数频繁地用到。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//glfwCreateWindow函数需要窗口的宽和高作为它的前两个参数。第三个参数表示这个窗口的名称（标题），这里我们使用&quot;LearnOpenGL&quot;。最后两个参数我们暂时忽略。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();<span class="comment">//正确释放/删除之前的分配的所有资源</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);<span class="comment">//设置已创建窗口的Context为当前线程的主Context：</span></span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);<span class="comment">//注册窗口调整的回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//GLAD是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLAD</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))<span class="comment">//给GLAD传入了用来加载系统相关的OpenGL函数指针地址的函数。GLFW给我们的是glfwGetProcAddress，它根据我们编译的系统定义了正确的函数。</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空背景颜色</span></span><br><span class="line">    <span class="comment">// 当调用glClear函数，清除颜色缓冲之后，</span></span><br><span class="line">    <span class="comment">// 整个颜色缓冲都会被填充为glClearColor里所设置的颜色</span></span><br><span class="line">    <span class="comment">// 在这里，我们将屏幕设置为了类似黑板的深蓝绿色</span></span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);<span class="comment">//用来设置清除后的背景颜色</span></span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<span class="comment">//GL_COLOR_BUFFER_BIT: 当前可写的颜色缓冲</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// render loop</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))<span class="comment">//渲染循环,glfwWindowShouldClose函数在我们每次循环的开始前检查一次GLFW是否被要求退出，如果是的话该函数返回true然后渲染循环便结束了，</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        <span class="comment">// ------</span></span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);<span class="comment">//用来设置清除后的背景颜色</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<span class="comment">//GL_COLOR_BUFFER_BIT: 当前可写的颜色缓冲</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);<span class="comment">//glfwSwapBuffers函数会交换颜色缓冲（它是一个储存着GLFW窗口每一个像素颜色值的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();<span class="comment">//glfwPollEvents函数检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();<span class="comment">//渲染结束，正确释放/删除之前的分配的所有资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span><span class="comment">//在GLFW中实现一些输入控制</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<span class="comment">//用GLFW的glfwGetKey函数，它需要一个窗口以及一个按键作为输入。这个函数将会返回这个按键是否正在被按下。</span></span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);<span class="comment">//如果没有按下，glfwGetKey将会返回GLFW_RELEASE。如果用户的确按下了返回键，我们将通过glfwSetwindowShouldClose使用把WindowShouldClose属性设置为 true的方法关闭GLFW。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span><span class="comment">//对窗口注册一个回调函数(Callback Function)，它会在每次窗口大小被调整的时候被调用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the viewport matches the new window dimensions; note that width and </span></span><br><span class="line">    <span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">    <span class="comment">//通过调用glViewport函数来设置窗口的维度，告诉OpenGL渲染窗口的尺寸大小，即视口(Viewport)，</span></span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);<span class="comment">//glViewport函数前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素）。</span></span><br><span class="line">    <span class="comment">//ps:OpenGL幕后使用glViewport中定义的位置和宽高进行2D坐标的转换，将OpenGL中的位置坐标转换为你的屏幕坐标。例如，OpenGL中的坐标(-0.5, 0.5)有可能（最终）被映射为屏幕中的坐标(200,450)。注意，处理过的OpenGL坐标范围只为-1到1，因此我们事实上将(-1到1)范围内的坐标映射到(0, 800)和(0, 600)。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd LearnOpenGL/src/1.getting_started/1.2.hello_window_clear</span><br><span class="line">g++ ../../glad.c hello_window_clear.cpp -o hello_window_clear -l GL -l GLU -l glut -l glfw3 -l dl -l pthread </span><br><span class="line">./hello_window</span><br></pre></td></tr></table></figure><p><img src="/./picture/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3/1.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编译x264源代码的具体步骤</title>
      <link href="/2023/06/03/x264%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/"/>
      <url>/2023/06/03/x264%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<p>首先cd到对应文件夹中</p><p>赋予权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./configure</span><br></pre></td></tr></table></figure><p>执行configure后提示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./configure </span><br><span class="line">./configure: line 551: ./config.guess: Permission denied</span><br><span class="line">./configure: line 554: ./config.sub: Permission denied</span><br><span class="line">Unknown system , edit the configure</span><br></pre></td></tr></table></figure><p>说明也要给这两个文件权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./config.guess</span><br><span class="line">chmod +x ./config.sub</span><br></pre></td></tr></table></figure><p>接着继续运行configure后提示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">./configure </span><br><span class="line">./configure: line 1353: ./version.sh: Permission denied</span><br><span class="line">platform:      X86_64</span><br><span class="line">byte order:    little-endian</span><br><span class="line">system:        LINUX</span><br><span class="line">cli:           yes</span><br><span class="line">libx264:       internal</span><br><span class="line">shared:        no</span><br><span class="line">static:        no</span><br><span class="line">asm:           yes</span><br><span class="line">interlaced:    yes</span><br><span class="line">avs:           avxsynth</span><br><span class="line">lavf:          yes</span><br><span class="line">ffms:          no</span><br><span class="line">mp4:           no</span><br><span class="line">gpl:           yes</span><br><span class="line">thread:        posix</span><br><span class="line">opencl:        yes</span><br><span class="line">filters:       resize crop select_every</span><br><span class="line">lto:           no</span><br><span class="line">debug:         no</span><br><span class="line">gprof:         no</span><br><span class="line">strip:         no</span><br><span class="line">PIC:           no</span><br><span class="line">bit depth:     all</span><br><span class="line">chroma format: all</span><br></pre></td></tr></table></figure><p>可以看出还需要给.&#x2F;version.sh权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./version.sh</span><br></pre></td></tr></table></figure><p>此时运行就没有提示了:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">./configure </span><br><span class="line">platform:      X86_64</span><br><span class="line">byte order:    little-endian</span><br><span class="line">system:        LINUX</span><br><span class="line">cli:           yes</span><br><span class="line">libx264:       internal</span><br><span class="line">shared:        no</span><br><span class="line">static:        no</span><br><span class="line">asm:           yes</span><br><span class="line">interlaced:    yes</span><br><span class="line">avs:           avxsynth</span><br><span class="line">lavf:          yes</span><br><span class="line">ffms:          no</span><br><span class="line">mp4:           no</span><br><span class="line">gpl:           yes</span><br><span class="line">thread:        posix</span><br><span class="line">opencl:        yes</span><br><span class="line">filters:       resize crop select_every</span><br><span class="line">lto:           no</span><br><span class="line">debug:         no</span><br><span class="line">gprof:         no</span><br><span class="line">strip:         no</span><br><span class="line">PIC:           no</span><br><span class="line">bit depth:     all</span><br><span class="line">chroma format: all</span><br></pre></td></tr></table></figure><p>make后提示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">make </span><br><span class="line">cat common/opencl/x264-cl.h common/opencl/motionsearch.cl common/opencl/subpel.cl common/opencl/intra.cl common/opencl/bidir.cl common/opencl/weightp.cl common/opencl/downscale.cl | ./tools/cltostr.sh common/oclobj.h</span><br><span class="line">/bin/sh: 1: ./tools/cltostr.sh: Permission denied</span><br><span class="line">Makefile:217: recipe for target &#x27;common/oclobj.h&#x27; failed</span><br><span class="line">make: *** [common/oclobj.h] Error 126</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续给权限:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./tools/cltostr.sh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习笔记之迭代器模式</title>
      <link href="/2023/06/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/06/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>迭代器模式作用是:提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><ul><li>当集合背后为复杂的数据结构,并且我们希望对外隐藏其复杂性时（出于使用便利性或安全性(避免客户端在直接与集合交互时执行错误或有害的操作)的考虑），可以使用迭代器模式(迭代器封装了与复杂数据结构进行交互的细节)</li><li>减少程序中重复的遍历代码(遍历代码出现在程序业务逻辑中时，会让原始代码的职责模糊不清，降低其可维护性,将遍历代码移到特定的迭代器中可使程序代码更加精炼)</li><li>代码能够遍历不同的甚至是无法预知的数据结构，可以使用迭代器模式</li></ul><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点:</p><ul><li>访问一个聚合对象的内容而无须暴露它的内部表示。</li><li>遍历任务交由迭代器完成，这简化了聚合类,这种通过将体积庞大的遍历算法代码抽取为独立的类的方式符合单一职责原则。</li><li>它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。</li><li>增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li><li>封装性良好，为遍历不同的聚合结构提供一个统一的接口。</li><li>可以并行遍历同一集合，因为每个迭代器对象都包含其自身的遍历状态。</li></ul><p>缺点:</p><ul><li>增加了类的个数，这在一定程度上增加了系统的复杂性(如果你的程序只与简单的集合进行交互， 应用该模式可能会矫枉过正)</li><li>对于某些特殊集合，使用迭代器可能比直接遍历的效率低</li></ul><h1 id="举例实操"><a href="#举例实操" class="headerlink" title="举例实操"></a>举例实操</h1><p>我们以用Qt设计播放器APP时候,遇到的文件导入模块的设计为例,在设计播放器的文件导入模块时,需要考虑用户存在批量导入的操作,同时还会删除特定的文件,因此我们需要记录这些文件的路径信息,同时,在用户点击某个文件的时候,我们还需要通过ui层返回的id号来对用户点击的文件进行该文件的删除&#x2F;媒体信息获取&#x2F;文件播放&#x2F;转换操作.</p><p>因此,我们需要具备一个存储文件路径信息的容器,最简单的方式就是用一个std::list<a href="std::string">std::string</a>来记录文件的路径,然后通过STL的list自带的迭代器来进行相关文件信息的访问.</p><p>但是,现在有一个性能优化点需要我们实现,就是对媒体文件信息的获取(无论是播放还是转换都必须先知道媒体文件的信息),在最优状态下,应用层点击该文件进行文件信息显示&#x2F;播放&#x2F;转换时,我们需要判断当前文件之前是否已经获取过该文件的媒体信息,如果没有的话再调用对应的编解码底层API接口进行文件的媒体信息获取,这样就能极大的减少应用层对底层接口的重复访问.</p><p>因此,我们需要还需要一个容器来存放该文件的媒体信息.当前最简单的方式就是把std::list<a href="std::string">std::string</a>改成一个结构体的list,即:std::list&lt;struct stFileInfo&gt;:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stFileInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    string file_name_;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stVideoInfo</span> video_info_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stAudioInfo</span> Audio_info_;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stSubPicInfo</span> SubPic_info_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stExtraInfo</span> extra_info_; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileInput</span> : <span class="keyword">public</span> Object</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">FileInput</span>()</span><br><span class="line">~<span class="built_in">FileInput</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FileCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddFile</span><span class="params">(std::string s)</span></span></span><br><span class="line"><span class="function">std::string <span class="title">RemoveFile</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">GetFirstFileInfo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">GetNextFileInfo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">CurrentFileInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::list&lt;<span class="keyword">struct</span> stFileInfo&gt; m_vecFileInfo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样写方便是方便,但是聚合类中除了实现添加删除文件的功能以外,还实现了获取第一个&#x2F;当前&#x2F;下一个文件信息的功能.<br>如果我们使用迭代器模式的话,这样的获取第一个&#x2F;当前&#x2F;下一个文件信息的遍历任务就可以交给迭代器来完成，大大的简化了聚合类.</p><p>并且整个播放器的设计中,其实有很多地方是需要存储用户的中间数据信息以及操作信息的,比如对子界面中导入的文件进行对应特效处理(存储该文件的特效参数)或者是勾选的文件进行转换处理(存储编码参数),如果采用上述的方式,则在对应的FileEffect类和FileOutput类中都需要重复的实现了获取第一个&#x2F;当前&#x2F;下一个文件相关特效信息&#x2F;编码参数信息的功能.</p><p>而如果我们采用迭代器模式的话,我们在增加新的聚合类和迭代器类都很方便，如果之前的迭代器类不符合当前该模块的实际应用场景的话,我们还可以自定义迭代器的子类以支持新的遍历方式,这样在对应的模块类中只要在CreateIterator这个函数中new对应的迭代器子类即可实现所需要的遍历功能!!!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 简单概述</span></span><br><span class="line"><span class="comment">* @brief 迭代器抽象类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Iterator</span>() &#123;&#125;</span><br><span class="line">~<span class="built_in">Iterator</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::string <span class="title">First</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::string <span class="title">Next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::string <span class="title">Current</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsEnd</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 简单概述</span></span><br><span class="line"><span class="comment">* @brief 音视频文件输入的基类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Object</span>() &#123;&#125;</span><br><span class="line">~<span class="built_in">Object</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Iterator* <span class="title">CreateIterator</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">FileCount</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AddFile</span><span class="params">(std::string)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::string <span class="title">RemoveFile</span><span class="params">(<span class="type">int</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 简单概述</span></span><br><span class="line"><span class="comment">* @brief 迭代器实现类,具备获取:第一个元素/下一个元素/当前元素/最后一个元素的功能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubIterator</span> : <span class="keyword">public</span> Iterator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SubIterator</span>(Object* obj):<span class="built_in">Iterator</span>(), <span class="built_in">m_pObj</span>(obj), <span class="built_in">m_Cur</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">~<span class="built_in">SubIterator</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">First</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_pObj-&gt;<span class="built_in">Pop</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Next</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::string str;</span><br><span class="line"><span class="keyword">if</span> (m_Cur &lt; m_pObj-&gt;<span class="built_in">Count</span>() - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">m_Cur++;</span><br><span class="line">str = m_pObj-&gt;<span class="built_in">Pop</span>(m_Cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Current</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_pObj-&gt;<span class="built_in">Pop</span>(m_Cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (m_Cur == m_pObj-&gt;<span class="built_in">Count</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Object* m_pObj;</span><br><span class="line"><span class="type">int</span> m_Cur;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 简单概述</span></span><br><span class="line"><span class="comment">* @brief 音视频文件输入类,具备迭代器创建/获取文件个数/添加文件/删除文件功能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileInput</span> : <span class="keyword">public</span> Object</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">FileInput</span>() : <span class="built_in">Object</span>(), <span class="built_in">m_pIterator</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">~<span class="built_in">FileInput</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator* <span class="title">CreateIterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(m_pIterator == <span class="literal">NULL</span>)</span><br><span class="line">m_pIterator = <span class="keyword">new</span> <span class="built_in">SubIterator</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> m_pIterator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FileCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_vecFilePath.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddFile</span><span class="params">(std::string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_vecFilePath.<span class="built_in">push_back</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">RemoveFile</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::string str;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; m_vecFilePath.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">str = m_vecFilePath[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::vector&lt;std::string&gt; m_vecFilePath;</span><br><span class="line">Iterator*m_pIterator;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>main函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">FileInput fileInput;</span><br><span class="line">fileInput.<span class="built_in">AddFile</span>(FilePath_1);</span><br><span class="line">fileInput.<span class="built_in">AddFile</span>(FilePath_2);</span><br><span class="line">fileInput.<span class="built_in">AddFile</span>(FilePath_3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Iterator* itr = fileInput.<span class="built_in">CreateIterator</span>();!itr-&gt;<span class="built_in">IsEnd</span>();itr-&gt;<span class="built_in">Next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//对当前文件进行解码,媒体信息获取或者转换操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习笔记之命令行模式</title>
      <link href="/2023/06/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/06/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>命令模式也叫作:动作、事务、Action、Transaction、Command.</p><p>将命令的请求者和命令执行者两者之间实现“松耦合”，方便对行为进行“记录、撤销”等操作</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><ul><li>解耦发送者与接收者: 请求发送者和请求接收者(执行者)需要解耦,发送者与接收者之间不直接进行交互 ;</li><li>抽象行为: 需要将等待执行的行为抽象出来;</li></ul><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点:</p><ul><li>降低系统耦合度</li><li>操作命令更加方便，符合“开闭原则”</li><li>方便实现“撤销”，“恢复”的功能</li></ul><p>缺点:</p><ul><li>可能产生大量的具体命令类，增加系统复杂度</li></ul><h1 id="举例实操"><a href="#举例实操" class="headerlink" title="举例实操"></a>举例实操</h1><p>我们以AI算法为例子,进行举例实操.</p><p>首先,我们先定义一个AIAlgorithms类,里面包含了对Nakedeye3D和NakedeyeVR算法的具体调用逻辑代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 简单概述</span></span><br><span class="line"><span class="comment">* @brief 命令具体执行类:实现相关AI算法调用的逻辑代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AIAlgorithms</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">InitNakedeye3DAlgorithm</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//1.对Nakedeye3D模型进行解密</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.对Nakedeye3D模型进行加载</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3,对Nakedeye3D算法相关接口进行初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">InitNakedeyeVRAlgorithm</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//1.对NakedeyeVR模型进行解密</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.对NakedeyeVR模型进行加载</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3,对NakedeyeVR算法相关接口进行初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetNakedeye3DAlgorithmInputParam</span><span class="params">(<span class="type">void</span>* param)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//调用Nakedeye3D算法的输入参数接口,进行输入参数设置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetNakedeyeVRAlgorithmInputParam</span><span class="params">(<span class="type">void</span>* param)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//调用NakedeyeVR算法的输入参数接口,进行输入参数设置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetNakedeye3DAlgorithmResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//调用Nakedeye3D算法中获取结果的接口,并将结果return出去</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetNakedeyeVRAlgorithmResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//调用Nakedeye3D算法中获取结果的接口,并将结果return出去</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在正常情况下,我们是直接将这个类扔给应用层进行调用,此时我们会发现,应用层直接操作这个类,即:请求发送者和请求接收者(执行者)之间直接进行交互;这样就使得系统的耦合度变高,同时该方案也不符合“开闭原则”,但如果我们采用了命令模式的话:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 简单概述</span></span><br><span class="line"><span class="comment">* @brief 命令类的抽象接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Command</span>(AIAlgorithms *pAIAlgorithms)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pAIAlgorithms = pAIAlgorithms;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Init</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//执行初始化AI算法的命令</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">SetAIAlgorithmsInputParam</span><span class="params">(<span class="type">void</span>* param)</span> </span>= <span class="number">0</span>;<span class="comment">//执行设置AI算法输入参数的命令</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> *<span class="title">GetAIAlgorithmsResult</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//执行获取AI算法结果的命令</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    AIAlgorithms *m_pAIAlgorithms;        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 简单概述</span></span><br><span class="line"><span class="comment">* @brief Nakedeye3D命令类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Nakedeye3DAlgorithmCmd</span>: <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Nakedeye3DAlgorithmCmd</span>(AIAlgorithms *pAIAlgorithms):<span class="built_in">Command</span>(pAIAlgorithms)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pAIAlgorithms-&gt;<span class="built_in">InitNakedeye3DAlgorithm</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetAIAlgorithmsInputParam</span><span class="params">(<span class="type">void</span>* param)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pAIAlgorithms-&gt;<span class="built_in">SetNakedeye3DAlgorithmInputParam</span>(param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">GetAIAlgorithmsResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pAIAlgorithms-&gt;<span class="built_in">GetNakedeye3DAlgorithmResult</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 简单概述</span></span><br><span class="line"><span class="comment">* @brief NakedeyeVR命令类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NakedeyeVRAlgorithmCmd</span>: <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NakedeyeVRAlgorithmCmd</span>(AIAlgorithms *pAIAlgorithms):<span class="built_in">Command</span>(pAIAlgorithms)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pAIAlgorithms-&gt;<span class="built_in">InitNakedeyeVRAlgorithm</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetAIAlgorithmsInputParam</span><span class="params">(<span class="type">void</span>* param)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pAIAlgorithms-&gt;<span class="built_in">SetNakedeyeVRAlgorithmInputParam</span>(param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">GetAIAlgorithmsResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pAIAlgorithms-&gt;<span class="built_in">GetNakedeyeVRAlgorithmResult</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 简单概述</span></span><br><span class="line"><span class="comment">* @brief 命令管理类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommandMgr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CommandMgr</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BindNakedeye3DAlgorithmCmd</span><span class="params">(Command *pCmd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pNakedeye3DAlgorithmCmd = pCmd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BindNakedeyeVRAlgorithmCmd</span><span class="params">(Command *pCmd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pNakedeyeVRAlgorithmCmd = pCmd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">ControlNakedeye3DGetResult</span><span class="params">(<span class="type">void</span>* pSetParam)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_pNakedeye3DAlgorithmCmd-&gt;<span class="built_in">Init</span>() == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Nakedeye3D Init fail \n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(m_pNakedeye3DAlgorithmCmd-&gt;<span class="built_in">SetAIAlgorithmsInputParam</span>(param) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Nakedeye3D SetAIAlgorithmsInputParam fail \n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_pNakedeye3DAlgorithmCmd-&gt;<span class="built_in">GetAIAlgorithmsResult</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">ControlNakedeyeVRGetResult</span><span class="params">(<span class="type">void</span>* pSetParam)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_pNakedeyeVRAlgorithmCmd-&gt;<span class="built_in">Init</span>() == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NakedeyeVR Init fail \n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(m_pNakedeyeVRAlgorithmCmd-&gt;<span class="built_in">SetAIAlgorithmsInputParam</span>(param) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NakedeyeVR SetAIAlgorithmsInputParam fail \n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_pNakedeyeVRAlgorithmCmd-&gt;<span class="built_in">GetAIAlgorithmsResult</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Command *m_pNakedeye3DAlgorithmCmd;</span><br><span class="line">    Command *m_pNakedeyeVRAlgorithmCmd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>main函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">AIAlgorithms *pAIAlgorithms = <span class="keyword">new</span> <span class="built_in">AIAlgorithms</span>();<span class="comment">//创建命令具体执行角色</span></span><br><span class="line">CommandMgr *pCommandMgr = <span class="keyword">new</span> <span class="built_in">CommandMgr</span>();<span class="comment">//创建命令管理类</span></span><br><span class="line">Command *pNakedeye3DAlgorithmCmd = <span class="keyword">new</span> <span class="built_in">Nakedeye3DAlgorithmCmd</span>(pAIAlgorithms);<span class="comment">//创建Nakedeye3D算法命令类</span></span><br><span class="line">Command *pNakedeyeVRAlgorithmCmd = <span class="keyword">new</span> <span class="built_in">NakedeyeVRAlgorithmCmd</span>(pAIAlgorithms);<span class="comment">//创建NakedeyeVR算法命令类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定对应算法命令类到命令管理类</span></span><br><span class="line">pCommandMgr-&gt;<span class="built_in">BindNakedeye3DAlgorithmCmd</span>(pNakedeye3DAlgorithmCmd);</span><br><span class="line">pCommandMgr-&gt;<span class="built_in">BindNakedeyeVRAlgorithmCmd</span>(pNakedeyeVRAlgorithmCmd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行命令</span></span><br><span class="line">    <span class="type">void</span>* pNakedeye3DResult = pCommandMgr-&gt;<span class="built_in">ControlNakedeye3DGetResult</span>(param);</span><br><span class="line">    <span class="type">void</span>* pNakedeyeVRResult = pCommandMgr-&gt;<span class="built_in">ControlNakedeyeVRGetResult</span>(param);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pNakedeyeVRAlgorithmCmd;</span><br><span class="line">    <span class="keyword">delete</span> pNakedeye3DAlgorithmCmd;</span><br><span class="line">    <span class="keyword">delete</span> pCommandMgr;</span><br><span class="line">    <span class="keyword">delete</span> pAIAlgorithms;</span><br><span class="line">    pNakedeyeVRAlgorithmCmd = <span class="literal">NULL</span>;</span><br><span class="line">    pNakedeye3DAlgorithmCmd = <span class="literal">NULL</span>;</span><br><span class="line">    pCommandMgr = <span class="literal">NULL</span>;</span><br><span class="line">    pAIAlgorithms = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是大多数人看完该例子的命令模式的代码还是会觉得,直接搞个AIAlgorithms给应用层就挺好了,没必要脱裤子放屁多此一举的搞了这么多类,这样搞的话系统的耦合度是降低了,确实也符合开闭原则,但是tm的整出了这么多的类,看起来更tm的烦人.说的没错!!!因为如果只是上面这种应用场景的话,完全没必要用什么命令模式,但是假如应用层的需求是要能实现撤销之前的命令的操作呢?这时候你就得用到命令模式了.</p><p>比如:我们现在有n个算法,应用层要求我们构建出一个视频特效链路也就是把之前的main函数改成下面这样的:<br>main函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">AIAlgorithms *pAIAlgorithms = <span class="keyword">new</span> <span class="built_in">AIAlgorithms</span>();<span class="comment">//创建命令具体执行角色</span></span><br><span class="line">CommandMgr *pCommandMgr = <span class="keyword">new</span> <span class="built_in">CommandMgr</span>();<span class="comment">//创建命令管理类</span></span><br><span class="line">Command *pNakedeye3DAlgorithmCmd = <span class="keyword">new</span> <span class="built_in">Nakedeye3DAlgorithmCmd</span>(pAIAlgorithms);<span class="comment">//创建Nakedeye3D算法命令类</span></span><br><span class="line">Command *pNakedeyeVRAlgorithmCmd = <span class="keyword">new</span> <span class="built_in">NakedeyeVRAlgorithmCmd</span>(pAIAlgorithms);<span class="comment">//创建NakedeyeVR算法命令类</span></span><br><span class="line">    Command *pSceneDetectionAlgorithmCmd = <span class="keyword">new</span> <span class="built_in">SceneDetectionAlgorithmCmd</span>(pAIAlgorithms);<span class="comment">//创建SceneDetection算法命令类</span></span><br><span class="line">Command *pAutoReframeAlgorithmCmd = <span class="keyword">new</span> <span class="built_in">AutoReframeAlgorithmCmd</span>(pAIAlgorithms);<span class="comment">//创建AutoReframe算法命令类</span></span><br><span class="line">Command *pWatermarkRemovalAlgorithmCmd = <span class="keyword">new</span> <span class="built_in">WatermarkRemovalAlgorithmCmd</span>(pAIAlgorithms);<span class="comment">//创建WatermarkRemoval算法命令类</span></span><br><span class="line">Command *pStablizationAlgorithmCmd = <span class="keyword">new</span> <span class="built_in">StablizationAlgorithmCmd</span>(pAIAlgorithms);<span class="comment">//创建Stablization算法命令类</span></span><br><span class="line">    Command *pFaceCompareAlgorithmCmd = <span class="keyword">new</span> <span class="built_in">FaceCompareAlgorithmCmd</span>(pAIAlgorithms);<span class="comment">//创建FaceCompare算法命令类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定对应算法命令类到命令管理类</span></span><br><span class="line">pCommandMgr-&gt;<span class="built_in">BindNakedeye3DAlgorithmCmd</span>(pNakedeye3DAlgorithmCmd);</span><br><span class="line">pCommandMgr-&gt;<span class="built_in">BindNakedeyeVRAlgorithmCmd</span>(pNakedeyeVRAlgorithmCmd);</span><br><span class="line">    pCommandMgr-&gt;<span class="built_in">BindSceneDetectionAlgorithmCmd</span>(pSceneDetectionAlgorithmCmd);</span><br><span class="line">pCommandMgr-&gt;<span class="built_in">BindAutoReframeAlgorithmCmd</span>(pAutoReframeAlgorithmCmd);</span><br><span class="line">    pCommandMgr-&gt;<span class="built_in">BindWatermarkRemovalAlgorithmCmd</span>(pWatermarkRemovalAlgorithmCmd);</span><br><span class="line">pCommandMgr-&gt;<span class="built_in">BindStablizationAlgorithmCmd</span>(pStablizationAlgorithmCmd);</span><br><span class="line">    pCommandMgr-&gt;<span class="built_in">BindFaceCompareAlgorithmCmd</span>(pFaceCompareAlgorithmCmd);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行命令:应用层现在有一个抖动的视频,需要Stablization算法调整画面的抖动,然后用SceneDetection进行帧的分析,最后用Nakedeye3D呈现3D画面效果</span></span><br><span class="line">    <span class="comment">//因此需要构建一条特效链路:Stablization-&gt;SceneDetection-&gt;Nakedeye3D</span></span><br><span class="line">    <span class="comment">//构建一条链路(将前一个算法的输出结果作为下一个算法的输入结果)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对pInputParam进行赋值</span></span><br><span class="line">    <span class="type">void</span> *pInputParam = <span class="keyword">new</span> stParam;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//链路构建</span></span><br><span class="line">    <span class="type">void</span>* pStablizationResult = pCommandMgr-&gt;<span class="built_in">ControlStablizationGetResult</span>(pInputParam);</span><br><span class="line">    <span class="type">void</span>* pSceneDetectionResult = pCommandMgr-&gt;<span class="built_in">ControlSceneDetectionGetResult</span>(pStablizationResult);</span><br><span class="line">    <span class="type">void</span>* pNakedeye3DResult = pCommandMgr-&gt;<span class="built_in">ControlNakedeye3DGetResult</span>(pSceneDetectionResult);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        此时,应用层希望将链路调整成:Stablization-&gt;SceneDetection-&gt;NakedeyeVR.</span></span><br><span class="line"><span class="comment">        我们如果不采用命令模式的话,而是直接采用传统模式的话,就得将pSceneDetectionResult值设置进去,同时还得删掉pNakedeye3DResult</span></span><br><span class="line"><span class="comment">        但本质上这种暴力的把pNakedeye3DResult置为空的操作,并不是真正意义上的回撤操作,因为ControlNakedeye3DGetResult这个接口还是调用了</span></span><br><span class="line"><span class="comment">        鬼知道ControlNakedeye3DGetResult这个接口里面有没有做一些new或者调用算法接口的操作,因此想要实现真正一样上的回撤操作就必须得用命令模式.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">void</span>* pNakedeyeVRResult = pCommandMgr-&gt;<span class="built_in">ControlNakedeyeVRGetResult</span>(pSceneDetectionResult);</span><br><span class="line">    pNakedeye3DResult = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//资源释放操作</span></span><br><span class="line">    <span class="comment">/* .... */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想用命令模式,我们就得对命令管理类进行一番魔改了,怎么魔改呢?我们需要引入两个list来存放操作的命令的记录和撤销的命令的记录:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 简单概述</span></span><br><span class="line"><span class="comment">* @brief 命令管理类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommandMgr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CommandMgr</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BindNakedeye3DAlgorithmCmd</span><span class="params">(Command *pCmd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pNakedeye3DAlgorithmCmd = pCmd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BindNakedeyeVRAlgorithmCmd</span><span class="params">(Command *pCmd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pNakedeyeVRAlgorithmCmd = pCmd;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">ControlNakedeye3DGetResult</span><span class="params">(<span class="type">void</span>* pSetParam)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//把操作记录到历史记录里面</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">stCommandInfo</span> info;</span><br><span class="line">        info.pCommand = m_pNakedeye3DAlgorithmCmd;</span><br><span class="line">        info.pSetParam = pSetParam;</span><br><span class="line">        <span class="built_in">m_lsUndoCmdInfo</span>(info);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m_pNakedeye3DAlgorithmCmd-&gt;<span class="built_in">Init</span>() == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Nakedeye3D Init fail \n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(m_pNakedeye3DAlgorithmCmd-&gt;<span class="built_in">SetAIAlgorithmsInputParam</span>(param) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Nakedeye3D SetAIAlgorithmsInputParam fail \n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_pNakedeye3DAlgorithmCmd-&gt;<span class="built_in">GetAIAlgorithmsResult</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">ControlNakedeyeVRGetResult</span><span class="params">(<span class="type">void</span>* pSetParam)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//把操作记录到历史记录里面</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">stCommandInfo</span> info;</span><br><span class="line">        info.pCommand = m_pNakedeyeVRAlgorithmCmd;</span><br><span class="line">        info.pSetParam = pSetParam;</span><br><span class="line">        <span class="built_in">m_lsUndoCmdInfo</span>(info);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m_pNakedeyeVRAlgorithmCmd-&gt;<span class="built_in">Init</span>() == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NakedeyeVR Init fail \n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(m_pNakedeyeVRAlgorithmCmd-&gt;<span class="built_in">SetAIAlgorithmsInputParam</span>(param) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NakedeyeVR SetAIAlgorithmsInputParam fail \n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_pNakedeyeVRAlgorithmCmd-&gt;<span class="built_in">GetAIAlgorithmsResult</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        撤销一步操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">UndoPressed</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_lsUndoCmdInfo.<span class="built_in">size</span>()&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//取出最后一个命令来撤销</span></span><br><span class="line">            stCommandInfo info = m_lsUndoCmdInfo.<span class="built_in">back</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//进行资源的释放操作</span></span><br><span class="line">            info.pCmd-&gt;<span class="built_in">ReleaseAIAlgorithmsResources</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//把这个命令记录到恢复的历史记录里面</span></span><br><span class="line">            m_lsRedoCmdInfo.<span class="built_in">push_back</span>(info);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//把最后一个命令删除掉，</span></span><br><span class="line">            m_lsUndoCmdInfo.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;很抱歉，没有可撤销的命令&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 恢复一步操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">RedoPressed</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_lsRedoCmdInfo.<span class="built_in">size</span>()&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">void</span>* pOutputResult = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//取出最后一个命令来恢复</span></span><br><span class="line">            stCommandInfo info = <span class="keyword">this</span>.m_lsRedoCmdInfo.<span class="built_in">back</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//恢复之前的操作</span></span><br><span class="line">            <span class="keyword">if</span>(info.pCmd-&gt;<span class="built_in">Init</span>() == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(info.type == Nakedeye3D)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Nakedeye3D Init fail \n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                     <span class="built_in">printf</span>(<span class="string">&quot;NakedeyeVR Init fail \n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span>(info.pCmd-&gt;<span class="built_in">SetAIAlgorithmsInputParam</span>(param) == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(info.type == Nakedeye3D)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Nakedeye3D SetAIAlgorithmsInputParam fail \n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                     <span class="built_in">printf</span>(<span class="string">&quot;NakedeyeVR SetAIAlgorithmsInputParam fail \n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pOutputResult = info.pCmd-&gt;<span class="built_in">GetAIAlgorithmsResult</span>();</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment">//把命令记录到可撤销的历史记录里面</span></span><br><span class="line">            m_lsUndoCmdInfo.<span class="built_in">push_back</span>(cmd);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//把最后一个命令删除掉</span></span><br><span class="line">            m_lsRedoCmdInfo.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;很抱歉，没有可恢复的命令&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pOutputResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Command *m_pNakedeye3DAlgorithmCmd;</span><br><span class="line">    Command *m_pNakedeyeVRAlgorithmCmd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AIAlgorithmsType</span></span><br><span class="line">    &#123;</span><br><span class="line">        Nakedeye3D,</span><br><span class="line">        NakedeyeVR,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stCommandInfo</span></span><br><span class="line">    &#123;</span><br><span class="line">        Command* pCommand;</span><br><span class="line">        <span class="type">void</span>* pSetParam;</span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">AIAlgorithmsType</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    操作的命令的记录，撤销时用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    stl::list&lt;stCommandInfo&gt; m_lsUndoCmdInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        撤销的命令的记录，恢复时用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    stl::list&lt;stCommandInfo&gt; m_lsRedoCmdInfo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对应的修改其他类(添加释放资源的功能):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 简单概述</span></span><br><span class="line"><span class="comment">* @brief 命令具体执行类:实现相关AI算法调用的逻辑代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AIAlgorithms</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">InitNakedeye3DAlgorithm</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//1.对Nakedeye3D模型进行解密</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.对Nakedeye3D模型进行加载</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3,对Nakedeye3D算法相关接口进行初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">InitNakedeyeVRAlgorithm</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//1.对NakedeyeVR模型进行解密</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.对NakedeyeVR模型进行加载</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3,对NakedeyeVR算法相关接口进行初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetNakedeye3DAlgorithmInputParam</span><span class="params">(<span class="type">void</span>* param)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//调用Nakedeye3D算法的输入参数接口,进行输入参数设置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetNakedeyeVRAlgorithmInputParam</span><span class="params">(<span class="type">void</span>* param)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//调用NakedeyeVR算法的输入参数接口,进行输入参数设置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetNakedeye3DAlgorithmResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//调用Nakedeye3D算法中获取结果的接口,并将结果return出去</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetNakedeyeVRAlgorithmResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//调用Nakedeye3D算法中获取结果的接口,并将结果return出去</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReleaseNakedeye3DAlgorithmResources</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//释放Nakedeye3D算法的相关资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReleaseNakedeyeVRAlgorithmResources</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//释放NakedeyeVR算法的相关资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 简单概述</span></span><br><span class="line"><span class="comment">* @brief 命令类的抽象接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Command</span>(AIAlgorithms *pAIAlgorithms)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pAIAlgorithms = pAIAlgorithms;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Init</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//执行初始化AI算法的命令</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">SetAIAlgorithmsInputParam</span><span class="params">(<span class="type">void</span>* param)</span> </span>= <span class="number">0</span>;<span class="comment">//执行设置AI算法输入参数的命令</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> *<span class="title">GetAIAlgorithmsResult</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//执行获取AI算法结果的命令</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ReleaseAIAlgorithmsResources</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//算法资源释放的命令</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    AIAlgorithms *m_pAIAlgorithms;        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 简单概述</span></span><br><span class="line"><span class="comment">* @brief Nakedeye3D命令类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Nakedeye3DAlgorithmCmd</span>: <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Nakedeye3DAlgorithmCmd</span>(AIAlgorithms *pAIAlgorithms):<span class="built_in">Command</span>(pAIAlgorithms)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pAIAlgorithms-&gt;<span class="built_in">InitNakedeye3DAlgorithm</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetAIAlgorithmsInputParam</span><span class="params">(<span class="type">void</span>* param)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pAIAlgorithms-&gt;<span class="built_in">SetNakedeye3DAlgorithmInputParam</span>(param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">GetAIAlgorithmsResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pAIAlgorithms-&gt;<span class="built_in">GetNakedeye3DAlgorithmResult</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReleaseAIAlgorithmsResources</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pAIAlgorithms-&gt;<span class="built_in">ReleaseNakedeye3DAlgorithmResources</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 简单概述</span></span><br><span class="line"><span class="comment">* @brief NakedeyeVR命令类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NakedeyeVRAlgorithmCmd</span>: <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NakedeyeVRAlgorithmCmd</span>(AIAlgorithms *pAIAlgorithms):<span class="built_in">Command</span>(pAIAlgorithms)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pAIAlgorithms-&gt;<span class="built_in">InitNakedeyeVRAlgorithm</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetAIAlgorithmsInputParam</span><span class="params">(<span class="type">void</span>* param)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pAIAlgorithms-&gt;<span class="built_in">SetNakedeyeVRAlgorithmInputParam</span>(param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">GetAIAlgorithmsResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pAIAlgorithms-&gt;<span class="built_in">GetNakedeyeVRAlgorithmResult</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReleaseAIAlgorithmsResources</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pAIAlgorithms-&gt;<span class="built_in">ReleaseNakedeyeVRAlgorithmResources</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时,我们的main函数就可以写成:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">AIAlgorithms *pAIAlgorithms = <span class="keyword">new</span> <span class="built_in">AIAlgorithms</span>();<span class="comment">//创建命令具体执行角色</span></span><br><span class="line">CommandMgr *pCommandMgr = <span class="keyword">new</span> <span class="built_in">CommandMgr</span>();<span class="comment">//创建命令管理类</span></span><br><span class="line">Command *pNakedeye3DAlgorithmCmd = <span class="keyword">new</span> <span class="built_in">Nakedeye3DAlgorithmCmd</span>(pAIAlgorithms);<span class="comment">//创建Nakedeye3D算法命令类</span></span><br><span class="line">Command *pNakedeyeVRAlgorithmCmd = <span class="keyword">new</span> <span class="built_in">NakedeyeVRAlgorithmCmd</span>(pAIAlgorithms);<span class="comment">//创建NakedeyeVR算法命令类</span></span><br><span class="line">    Command *pSceneDetectionAlgorithmCmd = <span class="keyword">new</span> <span class="built_in">SceneDetectionAlgorithmCmd</span>(pAIAlgorithms);<span class="comment">//创建SceneDetection算法命令类</span></span><br><span class="line">Command *pAutoReframeAlgorithmCmd = <span class="keyword">new</span> <span class="built_in">AutoReframeAlgorithmCmd</span>(pAIAlgorithms);<span class="comment">//创建AutoReframe算法命令类</span></span><br><span class="line">Command *pWatermarkRemovalAlgorithmCmd = <span class="keyword">new</span> <span class="built_in">WatermarkRemovalAlgorithmCmd</span>(pAIAlgorithms);<span class="comment">//创建WatermarkRemoval算法命令类</span></span><br><span class="line">Command *pStablizationAlgorithmCmd = <span class="keyword">new</span> <span class="built_in">StablizationAlgorithmCmd</span>(pAIAlgorithms);<span class="comment">//创建Stablization算法命令类</span></span><br><span class="line">    Command *pFaceCompareAlgorithmCmd = <span class="keyword">new</span> <span class="built_in">FaceCompareAlgorithmCmd</span>(pAIAlgorithms);<span class="comment">//创建FaceCompare算法命令类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定对应算法命令类到命令管理类</span></span><br><span class="line">pCommandMgr-&gt;<span class="built_in">BindNakedeye3DAlgorithmCmd</span>(pNakedeye3DAlgorithmCmd);</span><br><span class="line">pCommandMgr-&gt;<span class="built_in">BindNakedeyeVRAlgorithmCmd</span>(pNakedeyeVRAlgorithmCmd);</span><br><span class="line">    pCommandMgr-&gt;<span class="built_in">BindSceneDetectionAlgorithmCmd</span>(pSceneDetectionAlgorithmCmd);</span><br><span class="line">pCommandMgr-&gt;<span class="built_in">BindAutoReframeAlgorithmCmd</span>(pAutoReframeAlgorithmCmd);</span><br><span class="line">    pCommandMgr-&gt;<span class="built_in">BindWatermarkRemovalAlgorithmCmd</span>(pWatermarkRemovalAlgorithmCmd);</span><br><span class="line">pCommandMgr-&gt;<span class="built_in">BindStablizationAlgorithmCmd</span>(pStablizationAlgorithmCmd);</span><br><span class="line">    pCommandMgr-&gt;<span class="built_in">BindFaceCompareAlgorithmCmd</span>(pFaceCompareAlgorithmCmd);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行命令:应用层现在有一个抖动的视频,需要Stablization算法调整画面的抖动,然后用SceneDetection进行帧的分析,最后用Nakedeye3D呈现3D画面效果</span></span><br><span class="line">    <span class="comment">//因此需要构建一条特效链路:Stablization-&gt;SceneDetection-&gt;Nakedeye3D</span></span><br><span class="line">    <span class="comment">//构建一条链路(将前一个算法的输出结果作为下一个算法的输入结果)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对pInputParam进行赋值</span></span><br><span class="line">    <span class="type">void</span> *pInputParam = <span class="keyword">new</span> stParam;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//链路构建</span></span><br><span class="line">    <span class="type">void</span>* pStablizationResult = pCommandMgr-&gt;<span class="built_in">ControlStablizationGetResult</span>(pInputParam);</span><br><span class="line">    <span class="type">void</span>* pSceneDetectionResult = pCommandMgr-&gt;<span class="built_in">ControlSceneDetectionGetResult</span>(pStablizationResult);</span><br><span class="line">    <span class="type">void</span>* pNakedeye3DResult = pCommandMgr-&gt;<span class="built_in">ControlNakedeye3DGetResult</span>(pSceneDetectionResult);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//撤销上一步操作:pCommandMgr-&gt;ControlNakedeye3DGetResult</span></span><br><span class="line">    pCommandMgr-&gt;<span class="built_in">UndoPressed</span>();</span><br><span class="line">    pNakedeye3DResult = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成功构建新的链路:Stablization-&gt;SceneDetection-&gt;NakedeyeVR</span></span><br><span class="line">    <span class="type">void</span>* pNakedeyeVRResult = pCommandMgr-&gt;<span class="built_in">ControlNakedeyeVRGetResult</span>(pSceneDetectionResult);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//资源释放操作</span></span><br><span class="line">    <span class="comment">/* .... */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习笔记之责任链模式</title>
      <link href="/2023/05/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>责任链模式是一种行为设计模式，允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><ul><li>当程序需要使用不同方式处理不同种类请求， 而且请求类型和顺序预先未知时， 可以使用责任链模式。</li><li>当必须按顺序执行多个处理者时， 可以使用该模式。</li><li>如果所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。</li></ul><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点:</p><ul><li>请求处理的顺序可控(自定义责任链的链路顺序)。</li><li>单一职责原则。可对发起操作和执行操作的类进行解耦。</li><li>开闭原则。可以在不更改现有代码的情况下在程序中新增处理者。</li></ul><p>缺点:</p><ul><li>部分请求可能未被处理</li></ul><h1 id="举例实操"><a href="#举例实操" class="headerlink" title="举例实操"></a>举例实操</h1><p>我们用之前在抽象工厂模式时的stream流创建的例子来实际操一下责任链模式.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">STREAM_TYPE</span></span><br><span class="line">&#123;</span><br><span class="line">    VIDEO,</span><br><span class="line">    AUDIO,</span><br><span class="line">    SUBTITLE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂类(StreamFactory)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StreamFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StreamFactory</span>(StreamFactory* factory)</span><br><span class="line">        : <span class="built_in">m_factory</span>(factory)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Stream *<span class="title">CreateStream</span><span class="params">(<span class="keyword">enum</span> STREAM_TYPE type)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">StreamFactory</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    StreamFactory *m_factory;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视频流生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoProducer</span> : <span class="keyword">public</span> StreamFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VideoProducer</span>(StreamFactory* factory):<span class="built_in">StreamFactory</span>(factory)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Stream *<span class="title">CreateStream</span><span class="params">(<span class="keyword">enum</span> STREAM_TYPE type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type == STREAM_TYPE::VIDEO)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">VideoStream</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_factory-&gt;<span class="built_in">CreateStream</span>(type);<span class="comment">//向下传递责任</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 音频流生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioProducer</span> : <span class="keyword">public</span> StreamFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AudioProducer</span>(StreamFactory* factory):<span class="built_in">StreamFactory</span>(factory)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Stream *<span class="title">CreateStream</span><span class="params">(<span class="keyword">enum</span> STREAM_TYPE type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type == STREAM_TYPE::AUDIO)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AudioStream</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_factory-&gt;<span class="built_in">CreateStream</span>(type);<span class="comment">//向下传递责任</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字幕流生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubtitleProducer</span> : <span class="keyword">public</span> StreamFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SubtitleProducer</span>(StreamFactory* factory):<span class="built_in">StreamFactory</span>(factory)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Stream *<span class="title">CreateStream</span><span class="params">(<span class="keyword">enum</span> STREAM_TYPE type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type == STREAM_TYPE::SUBTITLE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SubtitleStream</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>main函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构建责任链:VideoProducer-&gt;AudioProducer-&gt;SubtitleProducer-&gt;NULL</span></span><br><span class="line">    StreamFactory *pSubtitleProducer = <span class="keyword">new</span> <span class="built_in">SubtitleProducer</span>(<span class="literal">NULL</span>);</span><br><span class="line">    StreamFactory *pAudioStreamFactory = <span class="keyword">new</span> <span class="built_in">AudioProducer</span>(pVideoStreamFactory);</span><br><span class="line">    StreamFactory *pFactory = <span class="keyword">new</span> <span class="built_in">VideoProducer</span>(pSubtitleProducer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先到VideoProducer会发现不属于这个类的责任,因此进入else语句向下传递责任,下一个AudioProducer发现是自己的责任,就进行处理</span></span><br><span class="line">    pFactory-&gt;<span class="built_in">CreateStream</span>(STREAM_TYPE::AUDIO);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习笔记之代理模式</title>
      <link href="/2023/05/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>我们举例了以下几种常见的代理模式:</p><ul><li>虚拟代理</li><li>保护代理</li><li>远程代理</li><li>日志记录代理</li><li>缓存代理</li><li>智能引用</li></ul><h2 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h2><p>虚拟代理其实就是对API的延迟初始化.其主要应用场景为:对于重量级对象的使用,例如:我们现在有一个AI算法SDK库,而这个库在进行使用前必须进行相关API的初始化操作,初始化的过程中,会先对整个AI算法SDK库中的所有算法模型进行解密操作,接着进行模型的加载,如果我们不采用代理模式,而是在一开始就进行初始化操作,且直到整个程序结束后再释放掉AI算法SDK库的资源,那么就会使得在整个程序运行的过程中一直占用着大量的系统资源(模型加载后占用大量内存资源),因此对于我们而言,最理想的情况就是在需要用到AI算法的时候再进行初始化,以避免系统资源的大量占用.</p><h2 id="保护代理"><a href="#保护代理" class="headerlink" title="保护代理"></a>保护代理</h2><p>保护代理的意思就是限制外界对相关SDK的访问,可以把外界认为是客户端,相关SDK认为是服务端,这个服务端对象可能是例如数据库等非常重要的部分,此时我们就需要使用代理模式,防止客户端或恶意程序直接对数据库进行访问操作!!!</p><p>在代理模式下,客户端需要满足一定的要求,才能将请求顺利的 传递给服务端,此时中间的代理层起到了一定的请求过滤和筛选作用</p><h2 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h2><p>远程代理通过名字我们也能知道他是一种在本地执行远程服务,通过代理的方式和远端的服务对象进行交互的模式,此时代理层负责处理所有与网络相关的复杂细节,并通过网络传递客户端的请求</p><h2 id="日志记录代理"><a href="#日志记录代理" class="headerlink" title="日志记录代理"></a>日志记录代理</h2><p>日志记录代理顾名思义就是进行日志信息的记录,一般用于保存客户端对服务对象的请求的历史记录,例如:学校有一套RFID的门禁识别系统,通过日志记录代理的方式,学校就能知道哪些同学晚归(正常情况下客户端发送学生刷卡的卡序列号信息,通过比对数据库中的卡序列号信息获得验证学生个人身份,此时代理层如果判断刷卡时间在晚上十点之后,则自动记录下该序列号和刷卡时间到日志中(代理可以在向服务传递请求前进行记录),后面学校只要根据日志中记录的序列号信息查询数据库后就能知道哪些同学晚归了)</p><h2 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h2><p>缓存代理就是对服务对象返回的结果信息进行暂缓的代理模式,例如:还是之前说的ai算法库,此时如果采用缓存代理的话,假如之前客户端调用了Nakedeye3D算法对某个音视频文件进行处理,此时算法SDK服务对象返回的处理结果就可以存放在代理层的缓冲区内,后面如果客户端又再一次对这个音视频文件做Nakedeye3D处理的话,那就没必要再访问服务端对象进行AI算法处理了,而是直接把之前代理层缓冲区内的结果返回给客户端.</p><h2 id="智能引用"><a href="#智能引用" class="headerlink" title="智能引用"></a>智能引用</h2><p>智能引用的模式作用是:代理层时不时地遍历各个客户端，检查它们是否仍在运行使用某个重量级对象,如果相应的客户端列表为空，代理就会销毁该服务对象，释放底层系统资源。例如:还是在之前的AI算法的例子,假如现在有n个客户端在使用不同的AI算法,因此服务端也相应的加载了这些AI算法的模型,此时代理层遍历客户端后发现,之前使用了NakedeyeVR的客户端已经不再使用这个算法了,此时代理层就会告诉服务端对象,让它将NakedeyeVR算法对应的算法模型释放掉</p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点:</p><ul><li>你可以在客户端毫无察觉的情况下控制服务对象</li><li>如果客户端对服务对象的生命周期没有特殊要求， 你可以对生命周期进行管理</li><li>即使服务对象还未准备好或不存在， 代理也可以正常工作</li><li>开闭原则。你可以在不对服务或客户端做出修改的情况下创建新代理</li></ul><p>缺点:</p><ul><li>代码可能会变得复杂， 因为需要新建许多类</li><li>因为多了一层代理,所以服务响应可能会有一定的延迟</li></ul><h1 id="举例实操"><a href="#举例实操" class="headerlink" title="举例实操"></a>举例实操</h1><p>我们以上面说的虚拟代理的例子进行举例实操.</p><p>此时,我们有两个ai算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">AIAlgorithmsName</span></span><br><span class="line">&#123;</span><br><span class="line">    NONE,</span><br><span class="line">    Nakedeye3D,</span><br><span class="line">    NakedeyeVR,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而AI算法SDK对外的接口有四个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitNakedeye3DAIAlgorithms</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitNakedeyeVRAIAlgorithms</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SetAIAlgorithmsParam</span><span class="params">(<span class="type">void</span>* pParam)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">GetAIAlgorithmsResult</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>此时,我们如果不使用代理模式的话,而是在程序运行时直接Init这两个AI算法,那么要是用户压根没用到这两个AI算法的话,那就白白占用了一大块内存(相关ai算法模型经过解密后加载到内存中,等待用户调用该模型进行算法处理)</p><p>此时,我们如果使用代理模式的话,首先将:AI算法SDK对外的四个接口封装成类AIAlgorithms,同时抽象出抽象类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 简单概述</span></span><br><span class="line"><span class="comment">* @brief 抽象的AIAlgorithms类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractAIAlgorithms</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AbstractAIAlgorithms</span>() &#123;&#125;</span><br><span class="line">~<span class="built_in">AbstractAIAlgorithms</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">InitNakedeye3DAIAlgorithms</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">InitNakedeyeVRAIAlgorithms</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">SetAIAlgorithmsParam</span><span class="params">(<span class="type">void</span>* pParam)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> *<span class="title">GetAIAlgorithmsResult</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 简单概述</span></span><br><span class="line"><span class="comment">* @brief AIAlgorithms类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AIAlgorithms</span>: <span class="keyword">public</span> AbstractAIAlgorithms</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AIAlgorithms</span>() &#123;&#125;</span><br><span class="line">~<span class="built_in">AIAlgorithms</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitNakedeye3DAIAlgorithms</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">InitNakedeyeVRAIAlgorithms</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetAIAlgorithmsParam</span><span class="params">(<span class="type">void</span>* pParam)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">GetAIAlgorithmsResult</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代理AI算法SDK的类,需要继承AIAlgorithms类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyAIAlgorithms</span> :<span class="keyword">public</span> AbstractAIAlgorithms</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ProxyAIAlgorithms</span>() </span><br><span class="line">    , <span class="built_in">m_pAIAlgorithms</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_pAIAlgorithms = <span class="keyword">new</span> AIAlgorithms;</span><br><span class="line">    &#125;</span><br><span class="line">~<span class="built_in">ProxyAIAlgorithms</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_pAIAlgorithms;</span><br><span class="line">        m_pAIAlgorithms = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitNakedeye3DAIAlgorithms</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bUseNakedeye3D == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_pAIAlgorithms-&gt;<span class="built_in">InitNakedeye3DAIAlgorithms</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">InitNakedeyeVRAIAlgorithms</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bUseNakedeye3D == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_pAIAlgorithms-&gt;<span class="built_in">InitNakedeye3DAIAlgorithms</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetAIAlgorithmsParam</span><span class="params">(<span class="type">void</span>* pParam)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//在代理层中,我们可以先对pParam进行检测,用一个vector来存放pParam对应的结构体中的关键参数,</span></span><br><span class="line">        <span class="comment">//通过这些参数来判断是否之前处理过这张图片,如果处理过不调用m_pAIAlgorithms-&gt;SetAIAlgorithmsParam(pParam);</span></span><br><span class="line">        <span class="comment">//而是去找之前的处理结果,等后续客户端需要处理结果时,直接返回给他即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">GetAIAlgorithmsResult</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> bUseNakedeye3D;</span><br><span class="line">    <span class="type">bool</span> bUseNakedeyeVR;</span><br><span class="line">    AIAlgorithms* m_pAIAlgorithms;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>main函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//客户端 通过登录代理服务器 访问 真实服务器</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;AbstractAIAlgorithms&gt; pProxy = std::<span class="built_in">make_shared</span>&lt;ProxyAIAlgorithms&gt;();<span class="comment">//登录代理服务器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过代理服务器,访问真正服务器</span></span><br><span class="line">    pProxy-&gt;<span class="built_in">InitNakedeye3DAIAlgorithms</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过代理服务器,代理层发现之前初始化过该算法,因此不访问真正服务器</span></span><br><span class="line">    pProxy-&gt;<span class="built_in">InitNakedeye3DAIAlgorithms</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*.....*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>音视频基础知识2</title>
      <link href="/2023/05/30/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%92/"/>
      <url>/2023/05/30/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%92/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么巨大的原始视频可以编码成很小的视频呢"><a href="#为什么巨大的原始视频可以编码成很小的视频呢" class="headerlink" title="为什么巨大的原始视频可以编码成很小的视频呢?"></a>为什么巨大的原始视频可以编码成很小的视频呢?</h1><p>因为原始视频存在一定的冗余.<br>比如：<br>同一个GOP中的帧往往存在较强的相似性，因此在时间的维度上存在着一定程度的冗余；<br>同一帧图像的像素之间同样也存在较强的相关性，因此在空间维度上也同样存在着一定程度的冗余；<br>同时由于人眼视觉系统的限制，对某些细节的敏感度不高，因此在视觉上也存在一定程度上的冗余；<br>除此之外还有编码层面上的冗余和知识冗余</p><p>参考答案:</p><p>1）空间冗余：图像相邻像素之间有较强的相关性<br>2）时间冗余：视频序列的相邻图像之间内容相似<br>3）编码冗余：不同像素值出现的概率不同<br>4）视觉冗余：人的视觉系统对某些细节不敏感<br>5）知识冗余：规律性的结构可由先验知识和背景知识得到</p><p>视觉冗余：利用人的视觉系统对某些细节不敏感。压缩视觉冗余度就是去掉那些相对人眼而言是看不到的或可有可无的图象数据</p><p>知识冗余：有许多图像的理解与某些基础知识有相当大的相关性。例如，人脸的图像有固定的结构，嘴的上方有鼻子，鼻子的上方有眼睛，鼻子位于正面图像的中线上等等。这类规律性的结构可由先验知识和背景知识得到，我们称此类冗余为知识冗余。根据已有知识，对某些图像中所包含的物体，可以构造其基本模型，并创建对应各种特征的图像库，进而图像的存储只需要保存一些特征参数，从而可以大大减少数据量。</p><p>编码冗余：首先介绍一下等长编码和变长编码：可以简单地理解为不同像素占用的空间都是一样的为等长编码，不同像素占用的空间不一样的为变成编码。可能听到比较多的变长编码就是哈夫曼编码，一幅图像中不同像素出现的概率是不同的。对出现次数比较多的像素，用少的位数来编码。对出现次数比较少的像素，用多的位数来编码，能够减少编码的大小。</p><h1 id="什么是GOP"><a href="#什么是GOP" class="headerlink" title="什么是GOP?"></a>什么是GOP?</h1><p>GOP ( Group of Pictures ) 是一组连续的画面，由一张 I 帧和数张 B &#x2F; P 帧组成，是视频图像编码器和解码器存取的基本单位。也就是说GOP组是指一个关键帧I帧所在的组的长度，每个 GOP 组只有 1 个 I 帧。GOP 组的长度格式也决定了码流的大小。GOP越大，中间的P帧和B帧的数量就越多，所以解码出来的视频质量就越高，但是会影响编码效率。</p><h1 id="AAC和PCM的区别？"><a href="#AAC和PCM的区别？" class="headerlink" title="AAC和PCM的区别？"></a>AAC和PCM的区别？</h1><p>AAC是在PCM数据的前面加上一些参数（采样率，声道数，采样大小）</p><h1 id="为什么会有-YUV-这种数据？它相比-RGB-数据有什么优点？"><a href="#为什么会有-YUV-这种数据？它相比-RGB-数据有什么优点？" class="headerlink" title="为什么会有 YUV 这种数据？它相比 RGB 数据有什么优点？"></a>为什么会有 YUV 这种数据？它相比 RGB 数据有什么优点？</h1><p>RGB 工业显示器要求一幅彩色图像由分开的 R、G、B 信号组成，而电视显示器则需要混合信号输入，为了实现对这两种标准的兼容，NTSC（美国国家电视系统委员会）制定了 YIQ 颜色模型，它的主要优点是可以实现对彩色电视和黑白电视的兼容，即可以用黑白电视收看彩色电视信号。YUV 颜色模型则是在 YIQ 的基础上发展而来。</p><p>YUV 颜色模型中用亮度、色度来表示颜色。它的亮度信息和色度信息是分离的，其中 Y 表示亮度通道，U 和 V 则表示色度通道。如果只有 Y 信息，没有 U、V 信息，那么表示的图像就是灰度图像。YUV 常用在各种影像处理场景中。YUV 在对照片或视频编码时，考虑到人眼对亮度信息的敏感度高于色度信息，允许降低色度的带宽。这样一来就可以对色度信息进行压缩，所以 YUV 可以相对 RGB 使用更少的数据带宽。比如常见的采样格式有：4:2:1、4:1:1、4:2:0 等，它们分别相对 RGB 压缩了 33.3%、50%、50% 的数据量。</p><h1 id="什么是-DTS-和-PTS？它们有什么区别？"><a href="#什么是-DTS-和-PTS？它们有什么区别？" class="headerlink" title="什么是 DTS 和 PTS？它们有什么区别？"></a>什么是 DTS 和 PTS？它们有什么区别？</h1><p>DTS 是解码时间戳；PTS 是显示时间戳。</p><p>虽然 DTS、PTS 是用于指导播放端的行为，但它们是在编码的时候由编码器生成的。</p><p>当视频流中没有 B 帧时，通常 DTS 和 PTS 的顺序是一致的。但如果有 B 帧时，就回到了我们前面说的问题：解码顺序和播放顺序不一致了。DTS 告诉我们该按什么顺序解码这几帧图像，PTS 告诉我们该按什么顺序显示这几帧图像。</p><h1 id="什么是-IDR-帧？它和-I-帧有什么区别？"><a href="#什么是-IDR-帧？它和-I-帧有什么区别？" class="headerlink" title="什么是 IDR 帧？它和 I 帧有什么区别？"></a>什么是 IDR 帧？它和 I 帧有什么区别？</h1><p>IDR 帧全称叫做 Instantaneous Decoder Refresh，是 I 帧的一种。IDR 帧的作用是立刻刷新，重新算一个新的序列开始编码，使错误不致传播。</p><p>IDR 帧有如下特性：</p><p>IDR 帧一定是 I 帧，严格来说 I 帧不一定是 IDR 帧（但一般 I 帧就是 IDR 帧）；<br>对于 IDR 帧来说，在 IDR 帧之后的所有帧都不能引用任何 IDR 帧之前的帧的内容。与此相反，对于普通的 I 帧来说，位于其之后的 B 和 P 帧可以引用位于普通 I 帧之前的 I 帧（普通 I 帧有被跨帧参考的可能）；<br>播放器永远可以从一个 IDR 帧播放，因为在它之后没有任何帧引用之前的帧。因此，视频开头的 I 帧一定是 IDR 帧；一个封闭类 GOP 的开头的 I 帧也一定是 IDR 帧。<br>所以，在直播场景通常每个 I 帧都是 IDR 帧，这样服务端下发流数据的时候总是从一个 I 帧开始，播放器就可以立即开始播放。</p><h1 id="什么是-SPS-和-PPS？它们有什么区别？"><a href="#什么是-SPS-和-PPS？它们有什么区别？" class="headerlink" title="什么是 SPS 和 PPS？它们有什么区别？"></a>什么是 SPS 和 PPS？它们有什么区别？</h1><p>SPS，Sequence Paramater Set，保存了一组编码后的图像序列所依赖的全局参数。</p><p>PPS，Picture Paramater Set，保存了每一帧编码后的图像所依赖的参数。</p><p>SPS 中的信息至关重要，如果其中的数据丢失，解码过程就可能失败。SPS 和 PPS 通常作为解码器的初始化参数。一般情况，SPS 和 PPS 所在的 NAL 单元位于整个码流的起始位置，但是在某些场景下，在码率中间也可能出现这两种结构：</p><p>解码器要在码流中间开始解码。比如，直播流。<br>编码器在编码过程中改变了码率的参数。比如，图像的分辨率。</p><h1 id="什么是-SEI？我们可以用它来做什么？"><a href="#什么是-SEI？我们可以用它来做什么？" class="headerlink" title="什么是 SEI？我们可以用它来做什么？"></a>什么是 SEI？我们可以用它来做什么？</h1><p>SEI 即补充增强信息（Supplemental Enhancement Information），属于码流范畴，它提供了向视频码流中加入额外信息的方法，是 H.264 标准的特性之一。</p><p>SEI的基本特征如下：</p><p>并非解码过程的必须选项；<br>可能对解码过程（容错、纠错）有帮助；<br>集成在视频码流中。<br>在直播场景，我们通常使用 SEI 来携带推流端的信息，一直随着直播流传输到播放端。由于 SEI 是绑定着视频帧，所以它可以支持诸如：</p><p>统计直播推流端到播放端延时。<br>支持和视频帧绑定的内容交互。比如，直播答题在播放端的弹窗等。</p><h1 id="什么是-MP4-的-moov-Box？我们在封装-MP4-时通常怎么处理它？为什么？"><a href="#什么是-MP4-的-moov-Box？我们在封装-MP4-时通常怎么处理它？为什么？" class="headerlink" title="什么是 MP4 的 moov Box？我们在封装 MP4 时通常怎么处理它？为什么？"></a>什么是 MP4 的 moov Box？我们在封装 MP4 时通常怎么处理它？为什么？</h1><p>moov Box 即 Movie Box，MP4 中存储所有媒体数据的索引信息的 Box。moov Box 可以说是 MP4 文件中最重要的 Box，一般播放器的实现都需要读取到 moov 的数据才能开始播放流程。</p><p>对于通过网络播放 MP4 视频的场景，都建议将视频处理为 moov 前置。因为 moov 前置后，从网络读取和播放 MP4 文件时，就可以较快获取到 moov 的数据并开始播放。</p><h1 id="简述一下FFmpeg的解码和编码流程"><a href="#简述一下FFmpeg的解码和编码流程" class="headerlink" title="简述一下FFmpeg的解码和编码流程"></a>简述一下FFmpeg的解码和编码流程</h1><p>解码流程：</p><ol><li>av_register_all</li><li>创建AVFormatContext的对象上下文</li><li>打开文件</li><li>avformat_find_stream_info</li><li>找到解码器</li><li>打开解码器</li><li>创建AVCodecContext上下文</li><li>av_read_frame ：将avPacket数据转换为avFrame数据</li></ol><p>编码流程：</p><ol><li>av_register_all</li><li>为AVFormatContext分配内存</li><li>打开文件</li><li>创建输出码流AVSream</li><li>找到编码器</li><li>打开编码器</li><li>写文件头，没有的就不写入</li><li>循环编码视频像素数据-&gt;视频压缩数据；<br>循环编码音频采样数据-&gt;音频压缩数据（AVFrame转化为AVPacket）</li><li>将编码后的视频码流写入文件（AVPacket转化为AVFormat）</li><li>关闭编码器</li><li>写文件尾</li><li>关闭资源文件</li></ol><h1 id="简述一下FFmpeg的数据结构"><a href="#简述一下FFmpeg的数据结构" class="headerlink" title="简述一下FFmpeg的数据结构"></a>简述一下FFmpeg的数据结构</h1><p>我们基于FFmpeg的解码和编码流程来简单描述一下FFmpeg的数据结构．</p><p>首先，无论通过FFmpeg开发任何功能，我们都需要先调用av_register_all这个函数．</p><p>av_register_all这个函数其实就一个功能：注册库所支持的容器格式及其对应的CODEC</p><p><font color = red >需要注意到的是：在使用结束后，要调用avformat_close_input关闭打开的流</font></p><p>注册完后，我们需要打开指定的音视频文件，此时我们调用的是avformat_open_input这个函数．</p><p>avformat_open_input的作用就是：打开多媒体文件，并读取文件的头，将读取到的信息填充到AVFormatContext结构体中．</p><p>这边我们首先需要简单介绍一下：多媒体文件的文件结构．</p><p>一个多媒体文件包含有多个流（视频流，音频流，字幕流等；<br>而流其实是一种抽象的概念，它代表着一连串的数据元素；而流中的数据元素称为帧（Frame）。</p><p>也就是说在多媒体文件中，主要有两种数据：流Stream及其数据元素帧Frame，而FFmpeg自然有与这两种数据相对应的抽象：AVStream和AVPacket。</p><p>我们在使用FFmpeg进行解码时，数据的传递过程如下：</p><ul><li>调用avformat_open_input打开流，将信息填充到AVFormatContext中</li><li>调用av_read_frame从流中读取数据帧到 AVPacket(AVPacket保存仍然是未解码的数据)。</li><li>调用avcodec_decode_video2将AVPacket的数据解码，并将解码后的数据填充到AVFrame中(AVFrame中保存的是解码后的原始数据)。</li></ul><p><font color = red >需要注意到的是：avformat_open_input只是读取文件的头来得到多媒体文件的信息，但是有些文件没有文件头或者文件头的格式不正确，这就造成只调用avformat_open_input可能得不到解码所需要的必要信息，因此如果想进一步得到流的具体信息，就需要调用avformat_find_stream_info．</font></p><p>同时，在FFmpeg中还有一个非常重要的结构体AVCodecContext，这个结构体描述了编解码器的上下文信息（包含了流中所使用的关于编解码器的所有信息）．我们一般是通过AVFormatContext-&gt;AVStream-&gt;AVCodecContext来得到，在有了AVCodecContext后，我们就可以通过codec_id来找到相应的解码器，从而通过avcodec_open2打开相应的编解码器</p><p><img src="/./picture/ffmpeg%E9%9D%A2%E8%AF%95%EF%BC%91.png"></p><ul><li>avcodec_find_decoder：可以通过codec_id或者名称来找到相应的解码器，返回值是一个AVCodec的指针。</li><li>avcodec_open2：打开相应的编解码器</li><li>av_read_frame：从流中读取数据帧暂存到AVPacket中</li><li>avcodec_decode_video2：从AVPacket中解码数据到AVFrame中</li></ul><p>经过以上的过程，AVFrame中的数据缓存中存放的就是解码后的原始数据了</p><h2 id="接着我们再介绍一下，在上述的解码过程使用到的结构体存储空间的分配与释放"><a href="#接着我们再介绍一下，在上述的解码过程使用到的结构体存储空间的分配与释放" class="headerlink" title="接着我们再介绍一下，在上述的解码过程使用到的结构体存储空间的分配与释放"></a>接着我们再介绍一下，在上述的解码过程使用到的结构体存储空间的分配与释放</h2><p>在FFmpeg其实并不存在所谓的垃圾回收机制，因此所分配的空间都是需要我们自己去维护的。同时由于进行视频处理过程中数据量是非常大，所以对于哪些动态内存的使用我们在编写相关代码的时候更是要非常的谨慎，否则很容易因为内容泄漏，导致出现一系列乱七八糟的问题。</p><p>接下来，我们通过下列在解码流程出现的几个结构体，来说明哪些地方的内存需要注意释放．</p><ul><li>AVFormatContext</li><li>AVStream</li><li>AVPacket</li><li>AVFrame</li></ul><p>AVFormatContext：描述一个多媒体文件的构成及其基本信息，存放了视频编解码过程中的大部分信息。</p><p>通常该结构体由avformat_open_input分配存储空间，在最后调用avformat_input_close关闭。</p><p>AVStream描述一个媒体流，在解码的过程中，作为 AVFormatContext的一个字段存在，不需要单独的处理。</p><p>AVPacket用来存放解码之前的数据，它只是一个容器，其data成员指向实际的数据缓冲区，在解码的过程中可有av_read_frame创建和填充AVPacket中的数据缓冲区，当数据缓冲区不再使用的时候可以调用av_packet_free释放这块缓冲区。</p><p>AVFrame存放从AVPacket中解码出来的原始数据；其必须通过av_frame_alloc来创建，通过av_frame_free来释放。</p><p>和AVPacket类似，AVFrame中也有一块数据缓存空间，在调用av_frame_alloc的时候并不会为这块缓存区域分配空间，需要使用其他的方法。</p><h2 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h2><p>在解码的过程使用了两个AVFrame，这两个AVFrame分配缓存空间的方法也不相同</p><p>一个 AVFrame 用来存放从 AVPacket 中解码出来的原始数据，这个 AVFrame 的数据缓存空间通过调 avcodec_decode_video 分配和填充。</p><p>另一个 AVFrame 用来存放将解码出来的原始数据变换为需要的数据格式（例如 RGB，RGBA）的数据，这个 AVFrame 需要手动的分配数据缓存空间。<br>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AVFrame* pFrameYUV;</span><br><span class="line">pFrameYUV = av_frame_alloc();</span><br><span class="line"><span class="comment">// 手动为 pFrameYUV分配数据缓存空间</span></span><br><span class="line"><span class="type">int</span> numBytes = avpicture_get_size(AV_PIX_FMT_YUV420P,pCodecCtx-&gt;widht,pCodecCtx-&gt;width);</span><br><span class="line"><span class="type">uint8_t</span>* buffer = (<span class="type">uint8_t</span>*)av_malloc(numBytes * <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line"><span class="comment">// 将分配的数据缓存空间和AVFrame关联起来</span></span><br><span class="line">avpicture_fill((AVPicture *)pFrameYUV, buffer, AV_PIX_FMT_YUV420P,pCodecCtx-&gt;width, pCodecCtx-&gt;height)</span><br></pre></td></tr></table></figure><p>首先计算需要缓存空间大小，调用av_malloc分配缓存空间，最后调用avpicture_fill将分配的缓存空间和 AVFrame 关联起来。</p><p>av_malloc只是在申请内存空间的时候会考虑到内存对齐（2字节，4字节对齐），其申请的空间要调用av_free释放。</p><h1 id="FFmpeg中AVPacket处理函数av-free-packet-和av-packet-free-的区别"><a href="#FFmpeg中AVPacket处理函数av-free-packet-和av-packet-free-的区别" class="headerlink" title="FFmpeg中AVPacket处理函数av_free_packet()和av_packet_free()的区别"></a>FFmpeg中AVPacket处理函数av_free_packet()和av_packet_free()的区别</h1><p>调用av_frame_free来释放 AVFrame，该函数不止释放 AVFrame 本身的空间，还会释放掉包含在其内的其他对象动态申请的空间，例如上面的缓存空间。</p><p>av_free_packet:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">av_free_packet</span><span class="params">(AVPacket *pkt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pkt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pkt-&gt;buf)</span><br><span class="line">            av_buffer_unref(&amp;pkt-&gt;buf);</span><br><span class="line">        pkt-&gt;data            = <span class="literal">NULL</span>;</span><br><span class="line">        pkt-&gt;size            = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        av_packet_free_side_data(pkt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//av_buffer_unref把pkt的buf置NULL</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">av_buffer_unref</span><span class="params">(AVBufferRef **buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!buf || !*buf)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    buffer_replace(buf, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把额外信息清除了</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">av_packet_free_side_data</span><span class="params">(AVPacket *pkt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pkt-&gt;side_data_elems; i++)</span><br><span class="line">        av_freep(&amp;pkt-&gt;side_data[i].data);</span><br><span class="line">    av_freep(&amp;pkt-&gt;side_data);</span><br><span class="line">    pkt-&gt;side_data_elems = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>av_packet_free:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">av_packet_free</span><span class="params">(AVPacket **pkt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pkt || !*pkt)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    av_packet_unref(*pkt);</span><br><span class="line">    av_freep(pkt);<span class="comment">//把指针彻底置空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>av_free_packet其实就是清空pkt中data以及buf的内容，并没有把pkt的指针清空;<br>而av_packet_free是先把pkt中的内容清空，然后再把指针清空，让pkt彻底无法使用了，如果需要重新使用，需要重新分配内存</p><p>因此简单来说：av_free_packet是清空里边的数据，如果不清空会发生什么情况呢，举个简单的例子，一个char数组大小为128，里边有100个字节的内容，第二次使用你没有清空第一次的内容，第二次数据的大小为60，那么第一次的最后40个字节的数据仍会保留，造成数据冗余，极大可能对你的处理造成影响</p><p>av_packet_free类似于free(p;)p&#x3D;NULL;</p><h1 id="简述一下AVFormatContext-和-AVInputFormat之间的关系"><a href="#简述一下AVFormatContext-和-AVInputFormat之间的关系" class="headerlink" title="简述一下AVFormatContext 和 AVInputFormat之间的关系"></a>简述一下AVFormatContext 和 AVInputFormat之间的关系</h1><p>AVInputFormat被封装在AVFormatContext里<br>AVFormatContext 作为API被外界调用<br>AVInputFormat 主要是FFmpeg内部调用<br>AVFormatContext里保存了视频文件封装格式相关信息，它是负责储存数据的结构体。而AVInputFormat代表了各个封装格式，属于方法，这是一种面向对象的封装。<br>通过 int avformat_open_input(AVFormatContext **ps, const char *filename,AVInputFormat *fmt, AVDictionary **options)函数装载解封装器. AVFormatContext 和 AVInputFormat之间的关系</p><h1 id="简述一下AVFormatContext-AVStream和AVCodecContext之间的关系"><a href="#简述一下AVFormatContext-AVStream和AVCodecContext之间的关系" class="headerlink" title="简述一下AVFormatContext, AVStream和AVCodecContext之间的关系"></a>简述一下AVFormatContext, AVStream和AVCodecContext之间的关系</h1><p>AVStream和AVpacket中都有index字段用于区分不同的码流（视频、音频、字幕等），AVFormatContext中包含输入的AVStream数组用于记录各个码流，nb_streams记录输入码流的数量。AVCodecContext记录着AVStream需要用那种解码器来进行解码。</p><h1 id="FFMPEG-图片如何合成视频"><a href="#FFMPEG-图片如何合成视频" class="headerlink" title="FFMPEG:图片如何合成视频"></a>FFMPEG:图片如何合成视频</h1><h1 id="怎么来解决音视频同步的问题"><a href="#怎么来解决音视频同步的问题" class="headerlink" title="怎么来解决音视频同步的问题"></a>怎么来解决音视频同步的问题</h1><p>生成数据流时要打上正确的时间戳。如果数据块上打的时间戳本身就有问题，那么播放时再怎么调整也于事无补。假如，视频流内容是从0s开始的，假设10s时有人开始说话，要求配上音频流，那么音频流的起始时间应该是10s，如果时间戳从0s或其它时间开始打，则这个混合的音视频流在时间同步上本身就出了问题。打时间戳时，视频流和音频流都是参考参考时钟的时间，而数据流之间不会发生参考关系；也就是说，视频流和音频流是通过一个中立的第三方（也就是参考时钟）来实现同步的。</p><p>第二个关键的地方，就是在播放时基于时间戳对数据流的控制，也就是对数据块早到或晚到采取不同的处理方法。图2.8中，参考时钟时间在0-10s内播放视频流内容过程中，即使收到了音频流数据块也不能立即播放它，而必须等到参考时钟的时间达到10s之后才可以，否则就会引起音视频不同步问题。</p><p>基于时间戳的播放过程中，仅仅对早到的或晚到的数据块进行等待或快速处理，有时候是不够的。如果想要更加主动并且有效地调节播放性能，需要引入一个反馈机制，也就是要将当前数据流速度太快或太慢的状态反馈给“源”，让源去放慢或加快数据流的速度。熟悉DirectShow的读者一定知道，DirectShow中的质量控制（Quality Control）就是这么一个反馈机制。DirectShow对于音视频同步的解决方案是相当出色的。但WMF SDK在播放时只负责将ASF数据流读出并解码，而并不负责音视频内容的最终呈现，所以它也缺少这样的一个反馈机制。</p><h1 id="如何根据-NALU-裸流数据来判断其是-H-264-编码还是-H-265-编码"><a href="#如何根据-NALU-裸流数据来判断其是-H-264-编码还是-H-265-编码" class="headerlink" title="如何根据 NALU 裸流数据来判断其是 H.264 编码还是 H.265 编码"></a>如何根据 NALU 裸流数据来判断其是 H.264 编码还是 H.265 编码</h1><h1 id="为什么视频会议用-UDP？如果用-TCP-实现音视频，需要建立几次连接？用-UDP-实现音视频，有什么方法可以保证通话质量？"><a href="#为什么视频会议用-UDP？如果用-TCP-实现音视频，需要建立几次连接？用-UDP-实现音视频，有什么方法可以保证通话质量？" class="headerlink" title="为什么视频会议用 UDP？如果用 TCP 实现音视频，需要建立几次连接？用 UDP 实现音视频，有什么方法可以保证通话质量？"></a>为什么视频会议用 UDP？如果用 TCP 实现音视频，需要建立几次连接？用 UDP 实现音视频，有什么方法可以保证通话质量？</h1><h1 id="CDN-在直播中有哪些运用？"><a href="#CDN-在直播中有哪些运用？" class="headerlink" title="CDN 在直播中有哪些运用？"></a>CDN 在直播中有哪些运用？</h1><h1 id="RTMP-消息分优先级的设计有什么好处？"><a href="#RTMP-消息分优先级的设计有什么好处？" class="headerlink" title="RTMP 消息分优先级的设计有什么好处？"></a>RTMP 消息分优先级的设计有什么好处？</h1><p>RTMP 的消息优先级是：控制消息 &gt; 音频消息 &gt; 视频消息。当网络传输能力受限时，优先传输高优先级消息的数据。</p><p>要使优先级能够有效执行，分块也很关键：将大消息切割成小块，可以避免大的低优先级的消息（如视频消息）堵塞了发送缓冲从而阻塞了小的高优先级的消息（如音频消息或控制消息）。</p><h1 id="如何根据推送过来的-NALU-裸流数据来判断其是-H-264-编码还是-H-265-编码，然后根据判断得到的编码方式进行对应的解码处理？"><a href="#如何根据推送过来的-NALU-裸流数据来判断其是-H-264-编码还是-H-265-编码，然后根据判断得到的编码方式进行对应的解码处理？" class="headerlink" title="如何根据推送过来的 NALU 裸流数据来判断其是 H.264 编码还是 H.265 编码，然后根据判断得到的编码方式进行对应的解码处理？"></a>如何根据推送过来的 NALU 裸流数据来判断其是 H.264 编码还是 H.265 编码，然后根据判断得到的编码方式进行对应的解码处理？</h1><p>H.265 如果解析出了 pps、sps、vps 的各字段信息符合规范，就认为它是 H.265 的编码；如果不是，在你们的码流格式范围中就只剩 H.264 了；接下来将码流数据交给对应的解码器解码即可。</p><p><a href="https://www.jianshu.com/p/5698063a2ba0">https://www.jianshu.com/p/5698063a2ba0</a></p><p><a href="https://www.jianshu.com/p/d268a01cb667">https://www.jianshu.com/p/d268a01cb667</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习笔记之享元模式</title>
      <link href="/2023/05/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>享元模式主要用于避免重复创建相同的对象，以减少内存占用和提高性能。</p><p>主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中<font color = red>已有的对象</font>，避免重新创建。</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><ul><li>系统中需要生成大量细粒度的类实例来表示数据。且这些实例除了几个参数外基本上都是相同的</li><li>对象消耗大量内存</li></ul><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点:</p><ul><li>大大减少对象的创建，减低系统的内存，使效率更高。</li></ul><p>缺点:</p><ul><li>提高了系统的复杂程度，需要分离外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部变化而变化，否则会造成系统的混乱。</li></ul><h1 id="举例实操"><a href="#举例实操" class="headerlink" title="举例实操"></a>举例实操</h1><p>回顾一下我们在简单工厂模式（Simple Factory）举的例子:要设计一个接口让应用层调用,这个接口的作用就是用于生成一条流(可以是视频流也可以是音频流或者字幕流).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//流的抽象类（基类）,接口函数为Log()，用于打印日志信息</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stream</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Stream</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Log</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下为具体流的的类，分别是视频、音频和字幕的流，它们都继承于Stream抽象类。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//视频流</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoStream</span> : <span class="keyword">public</span> Stream</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建一条视频流&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 音频流</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioStream</span> : <span class="keyword">public</span> Stream</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建一条音频流&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字幕流</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubtitleStream</span> : <span class="keyword">public</span> Stream</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建一条字幕流&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>StreamFactory为工厂类，类里实现根据流的类型创建对应流对象的CreatStream(STREAM_TYPE type)函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">STREAM_TYPE</span></span><br><span class="line">&#123;</span><br><span class="line">    VIDEO,</span><br><span class="line">    AUDIO,</span><br><span class="line">    SUBTITLE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂类:流的生产厂 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StreamFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 根据流的类型创建对应的流对象</span></span><br><span class="line">    <span class="function">Stream *<span class="title">CreateStream</span><span class="params">(STREAM_TYPE type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> VIDEO:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">VideoStream</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AUDIO:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AudioStream</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SUBTITLE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SubtitleStream</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>main函数，先是构造了工厂对象，后创建指定类型的具体流对象，创建了流的对象便可直接日志信息。因为采用的是<code>new</code>的方式创建了对象，用完了要通过<code>delete</code> 释放资源资源哦！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构造工厂对象</span></span><br><span class="line">    StreamFactory streamFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从流工厂对象创建一条视频流</span></span><br><span class="line">    Stream *pVideoStream = streamFactory.<span class="built_in">CreateStream</span>(VIDEO);</span><br><span class="line">    <span class="keyword">if</span> (pVideoStream != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//日志打印:创建一条视频流</span></span><br><span class="line">        pVideoStream-&gt;<span class="built_in">Log</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> pVideoStream;</span><br><span class="line">        pVideoStream = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从流工厂对象创建一条音频流</span></span><br><span class="line">    Stream *pAudioStream = streamFactory.<span class="built_in">CreateStream</span>(AUDIO);</span><br><span class="line">    <span class="keyword">if</span> (pAudioStream != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//日志打印:创建一条音频流</span></span><br><span class="line">        pAudioStream-&gt;<span class="built_in">Log</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> pAudioStream;</span><br><span class="line">        pAudioStream = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从流工厂对象创建一条字幕流</span></span><br><span class="line">    Stream *pSubtitleStream = streamFactory.<span class="built_in">CreateStream</span>(SUBTITLE);</span><br><span class="line">    <span class="keyword">if</span> (pSubtitleStream != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//日志打印:创建一条字幕流</span></span><br><span class="line">        pSubtitleStream-&gt;<span class="built_in">Log</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> pSubtitleStream;</span><br><span class="line">        pSubtitleStream = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们如果需要这个流工厂除了具备创建音视频文件的作用,还必须满足能能够判断之前是否创建过这种种类的流,如果创建过就不再进行创建,而是直接使用之前的流对象.<br>那么我们就需要用到享元模式了,我们稍微补全一下这些类,增加以下这几个函数接口,看起来更贴近实际开发需求</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">GetStreamInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Seek</span><span class="params">(<span class="type">double</span> time)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Forward</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">GetCurrentFrame</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//流的抽象类（基类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stream</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Stream</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> *<span class="title">GetStreamInfo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Seek</span><span class="params">(<span class="type">double</span> time)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Forward</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>* <span class="title">GetCurrentFrame</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下为具体流的的类，分别是视频、音频和字幕的流，它们都继承于Stream抽象类。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//视频流</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoStream</span> : <span class="keyword">public</span> Stream</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">VideoStream</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建一条视频流&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">GetStreamInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Seek</span><span class="params">(<span class="type">double</span> time)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Forward</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetCurrentFrame</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 音频流</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioStream</span> : <span class="keyword">public</span> Stream</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AudioStream</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建一条音频流&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">GetStreamInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Seek</span><span class="params">(<span class="type">double</span> time)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Forward</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetCurrentFrame</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字幕流</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubtitleStream</span> : <span class="keyword">public</span> Stream</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">SubtitleStream</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建一条字幕流&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">GetStreamInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Seek</span><span class="params">(<span class="type">double</span> time)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Forward</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetCurrentFrame</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>工厂类:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">STREAM_TYPE</span></span><br><span class="line">&#123;</span><br><span class="line">    VIDEO,</span><br><span class="line">    AUDIO,</span><br><span class="line">    SUBTITLE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂类:流的生产厂 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StreamFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">StreamFactory</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        m_StreamMap.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">~<span class="built_in">StreamFactory</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> itr = m_StreamMap.<span class="built_in">begin</span>();itr != m_StreamMap.<span class="built_in">end</span>();itr++)</span><br><span class="line">&#123;</span><br><span class="line">itr = m_StreamMap.<span class="built_in">erase</span>(itr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据流的类型创建对应的流对象</span></span><br><span class="line">    <span class="function">Stream *<span class="title">CreateStream</span><span class="params">(STREAM_TYPE type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> itr = m_StreamMap.<span class="built_in">find</span>(type);</span><br><span class="line"><span class="keyword">if</span> (itr != m_StreamMap.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;CreateStream new object!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> itr-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (type)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> VIDEO:</span><br><span class="line">&#123;</span><br><span class="line">VideoStream* pVideoStream = <span class="keyword">new</span> <span class="built_in">VideoStream</span>();</span><br><span class="line">m_StreamMap[VIDEO] = pVideoStream;</span><br><span class="line"><span class="keyword">return</span> pVideoStream;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> AUDIO:</span><br><span class="line">&#123;</span><br><span class="line">AudioStream* pAudioStream = <span class="keyword">new</span> <span class="built_in">AudioStream</span>();</span><br><span class="line">m_StreamMap[AUDIO] = pAudioStream;</span><br><span class="line"><span class="keyword">return</span> pAudioStream;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SUBTITLE:</span><br><span class="line">&#123;</span><br><span class="line">SubtitleStream* pSubtitleStream = <span class="keyword">new</span> <span class="built_in">SubtitleStream</span>();</span><br><span class="line">m_StreamMap[SUBTITLE] = pSubtitleStream;</span><br><span class="line"><span class="keyword">return</span> pSubtitleStream;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">break</span>;                </span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::map&lt;STREAM_TYPE, Stream*&gt; m_StreamMap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>main函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">StreamFactory* factory = <span class="keyword">new</span> <span class="built_in">StreamFactory</span>();</span><br><span class="line"></span><br><span class="line">Stream* pVideoStream = factory-&gt;<span class="built_in">CreateStream</span>(VIDEO);</span><br><span class="line"><span class="type">void</span>* pVideoStreamInfo = pVideoStream-&gt;<span class="built_in">GetStreamInfo</span>();</span><br><span class="line"></span><br><span class="line">Stream* pAudioStream = factory-&gt;<span class="built_in">CreateStream</span>(AUDIO);</span><br><span class="line"><span class="type">void</span>* pAudioStreamInfo = pAudioStream-&gt;<span class="built_in">GetStreamInfo</span>();</span><br><span class="line"></span><br><span class="line">    Stream* pSubtitleStream = factory-&gt;<span class="built_in">CreateStream</span>(SUBTITLE);</span><br><span class="line"><span class="type">void</span>* pSubtitleStreamInfo = pSubtitleStream-&gt;<span class="built_in">GetStreamInfo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//之前创建过这个种类的流,因此此时CreateStream并不创建流,而是直接返回之前创建的该种类的流的对象指针</span></span><br><span class="line">    Stream* pAudioStream = factory-&gt;<span class="built_in">CreateStream</span>(AUDIO);</span><br><span class="line"><span class="type">void</span>* pAudioStreamInfo = pAudioStream-&gt;<span class="built_in">GetStreamInfo</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实上面举例的这个例子,在实际开发的应用场景中基本上是不存在的,因为一个音视频文件是支持多路视频&#x2F;音频&#x2F;字幕流的(例如电影的中英文字幕和音频切换).因此其实可以在这个工厂类的基础上改成支持最多n路相同流的创建(这个还是有一定应用场景的)</p><p>当然,另一个更加容易理解的应用场景则是在ai算法的封装层架构设计上.<br>即:每个视频类型的ai算法都有具备相同的对外接口,并且同一种ai算法只允许创建一个对象实例(理解为单例模式的聚合).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">AIAlgorithmsType</span></span><br><span class="line">&#123;</span><br><span class="line">    NONE,</span><br><span class="line">    Nakedeye3D,</span><br><span class="line">    NakedeyeVR,</span><br><span class="line">    <span class="comment">//后期可能引入非常多算法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//视频类ai算法的抽象类（基类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AIAlgorithms</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AIAlgorithms</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Init</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">SetParam</span><span class="params">(<span class="type">void</span>* param)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>* <span class="title">GetOutputData</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Nakedeye3DAIAlgorithms</span>: <span class="keyword">public</span> AIAlgorithms</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Nakedeye3DAIAlgorithms</span>()&#123;&#125;</span><br><span class="line">~<span class="built_in">Nakedeye3DAIAlgorithms</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetParam</span><span class="params">(<span class="type">void</span>* param)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetOutputData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NakedeyeVRAIAlgorithms</span>: <span class="keyword">public</span> AIAlgorithms</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">NakedeyeVRAIAlgorithms</span>()&#123;&#125;</span><br><span class="line">~<span class="built_in">NakedeyeVRAIAlgorithms</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetParam</span><span class="params">(<span class="type">void</span>* param)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetOutputData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>工厂类:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂类:流的生产厂 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AIAlgorithmsFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AIAlgorithmsFactory</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        m_AIAlgorithmsMap.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">~<span class="built_in">AIAlgorithmsFactory</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> itr = m_AIAlgorithmsMap.<span class="built_in">begin</span>();itr != m_AIAlgorithmsMap.<span class="built_in">end</span>();itr++)</span><br><span class="line">&#123;</span><br><span class="line">itr = m_AIAlgorithmsMap.<span class="built_in">erase</span>(itr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据流的类型创建对应的流对象</span></span><br><span class="line">    <span class="function">AIAlgorithms *<span class="title">CreateAIAlgorithms</span><span class="params">(AIAlgorithmsType type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> itr = m_AIAlgorithmsMap.<span class="built_in">find</span>(type);</span><br><span class="line"><span class="keyword">if</span> (itr != m_AIAlgorithmsMap.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;CreateStream new object!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> itr-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (type)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> Nakedeye3D:</span><br><span class="line">&#123;</span><br><span class="line">Nakedeye3DAIAlgorithms* pNakedeye3DAIAlgorithms = <span class="keyword">new</span> <span class="built_in">Nakedeye3DAIAlgorithms</span>();</span><br><span class="line">m_AIAlgorithmsMap[Nakedeye3D] = pNakedeye3DAIAlgorithms;</span><br><span class="line"><span class="keyword">return</span> pNakedeye3DAIAlgorithms;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NakedeyeVR:</span><br><span class="line">&#123;</span><br><span class="line">NakedeyeVRAIAlgorithms* pNakedeyeVRAIAlgorithms = <span class="keyword">new</span> <span class="built_in">NakedeyeVRAIAlgorithms</span>();</span><br><span class="line">m_AIAlgorithmsMap[NakedeyeVR] = pNakedeyeVRAIAlgorithms;</span><br><span class="line"><span class="keyword">return</span> pNakedeyeVRAIAlgorithms;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::map&lt;AIAlgorithmsType, AIAlgorithms*&gt; m_AIAlgorithmsMap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>main函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AIAlgorithmsFactory* factory = <span class="keyword">new</span> <span class="built_in">AIAlgorithmsFactory</span>();</span><br><span class="line"></span><br><span class="line">AIAlgorithms* pNakedeye3DAIAlgorithms = factory-&gt;<span class="built_in">CreateAIAlgorithms</span>(Nakedeye3D);</span><br><span class="line">pNakedeye3DAIAlgorithms-&gt;<span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">AIAlgorithms* pNakedeyeVRAIAlgorithms = factory-&gt;<span class="built_in">CreateAIAlgorithms</span>(NakedeyeVR);</span><br><span class="line">pNakedeyeVRAIAlgorithms-&gt;<span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//之前创建过这个ai算法的对象了,因此此时CreateAIAlgorithms并不会再创建一个该类型的新对象,而是直接返回之前所创建的对象指针</span></span><br><span class="line">AIAlgorithms* pNakedeye3DAIAlgorithms = factory-&gt;<span class="built_in">CreateAIAlgorithms</span>(Nakedeye3D);</span><br><span class="line">pNakedeye3DAIAlgorithms-&gt;<span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面这个例子,我们就可以发现,假如我们在进行开发的过程中,只有一两个类(例如日志类)需要保证全局仅有一个实例的话,那么我们可以直接使用单例模式,但是如果我们存在像上面这个例子一样,有非常多类需要保证全局仅有一个实例的话,那么采用享元模式就非常合适了,不需要像单例模式一样一个个分开用,而是以一种可以理解为单例工厂的方式来统一管理.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习笔记之装饰模式</title>
      <link href="/2023/05/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>装饰器模式（Decorator Pattern）的作用是:动态的向一个现有的对象添加额外的新功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有类的一个包装。<br>以增加功能的目的来说:装饰模式比起通过生成一个个子类然后继承的方式而言,会更加的灵活.</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><ul><li>想为一个类添加额外的功能,但是又不想直接在里面添加函数,或者是弄个新的子类来实现这些额外功能,再让这个类继承新的子类</li></ul><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点:</p><ul><li>装饰类和被装饰类可以独立发展，不会互相耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</li></ul><p>缺点:</p><ul><li>多层装饰比较复杂</li></ul><h1 id="举例实操"><a href="#举例实操" class="headerlink" title="举例实操"></a>举例实操</h1><p>我们以上一篇文章(门面模式)中举的解码器的设计的例子来讲解:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CDecodec</span> : </span><br><span class="line">        <span class="keyword">public</span> CVideoDecodec,</span><br><span class="line">        <span class="keyword">public</span> CAudioDecodec,</span><br><span class="line">        <span class="keyword">public</span> CPictureDecodec</span><br><span class="line">        <span class="keyword">public</span> CSubtitlesDecodec</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们会发现我们在进行解码器解码类型的扩展中,是采用继承的方式进行扩展(通过对不同类型的文件创建对应的解码器,然后CDecodec继承这些子类)的.</p><p>但是这种继承方式有一个问题:由于继承的类会引入静态特征，并且随着扩展功能的增多，整个CDecodec会很膨胀,而我们并不想增加很多子类的,但是有想着扩展类,这就得使用到我们的装饰模式了.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 简单概述</span></span><br><span class="line"><span class="comment">* @brief 解码器抽象基类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDecodecBase</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span>* <span class="title">CreatDecodec</span><span class="params">(<span class="type">wchar_t</span>* pFilePath)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 这个解码器类只具备解码视频/音频/字幕的功能</span></span><br><span class="line"><span class="comment">* @brief 解码器类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDecodec</span>:<span class="keyword">public</span> CDecodecBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CDecodec</span>() &#123;&#125;</span><br><span class="line">~<span class="built_in">CDecodec</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">CreatDecodec</span><span class="params">(<span class="type">wchar_t</span>* pFilePath)</span><span class="comment">//输入的只要是视频/音频/字幕类型的文件就能解码</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//原本这个解码器类只具备解码视频/音频/字幕的功能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 原本这个解码器类只具备解码视频/音频/字幕的功能,现在我们需要抽象一个扩展类,来新增对图片解码的功能支持</span></span><br><span class="line"><span class="comment">* @brief 解码器扩展类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDecodecExtend</span> :<span class="keyword">public</span> CDecodecBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CDecodecExtend</span>(CDecodecBase* pCDecodecBase)</span><br><span class="line">&#123;</span><br><span class="line">m_pCDecodecBase = pCDecodecBase;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">CDecodecExtend</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span>* <span class="title">CreatDecodec</span><span class="params">(<span class="type">wchar_t</span>* pFilePath)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">CDecodecBase* m_pCDecodecBase;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 继承解码器扩展类,用于对之前解码器,新增一个对图片解码的功能支持</span></span><br><span class="line"><span class="comment">* @brief 图片文件解码器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPictureDecodec</span> :<span class="keyword">public</span> CDecodecExtend</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CPictureDecodec</span>(CDecodecBase* pCDecodecBase):<span class="built_in">CDecodecExtend</span>(pBeapCDecodecBasen)&#123;&#125;</span><br><span class="line">~<span class="built_in">CPictureDecodec</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">CreatDecodec</span><span class="params">(<span class="type">wchar_t</span>* pFilePath)</span><span class="comment">//扩展功能:输入的只能是图片类型的文件才能解码</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//这个函数是专门实现对图片文件的解码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对视频,音频,文件的解码</span></span><br><span class="line">CDecodec* pCDecodec = <span class="keyword">new</span> <span class="built_in">CDecodec</span>();</span><br><span class="line">pCDecodec-&gt;<span class="built_in">CreatDecodec</span>(pAVSFilePath);<span class="comment">//这个解码器只支持对视频/音频/字幕文件的解码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对图片文件的解码</span></span><br><span class="line">CPictureDecodec* pCPictureDecodec = <span class="keyword">new</span> <span class="built_in">CPictureDecodec</span>(pCDecodec);</span><br><span class="line">pCPictureDecodec-&gt;<span class="built_in">CreatDecodec</span>(pPictureFilePath);<span class="comment">//这个解码器实现了对图片文件的解码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习笔记组合模式</title>
      <link href="/2023/05/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>组合模式是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>比较适合一些具备层级结构的场景中,汇总结果,如计算国家的年GDP,而国家由省组成.省由市组成,市由县组成,…,以此类推</p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点:</p><ul><li>可以利用多态和递归机制更方便地使用复杂树结构</li><li>开闭原则。无需更改现有代码，你就可以在应用中添加新元素(多加个省&#x2F;市&#x2F;县&#x2F;..)，使其成为对象树的一部分</li></ul><p>缺点:</p><ul><li>对于功能差异较大的类，提供公共接口或许会有困难。</li></ul><h1 id="举例实操"><a href="#举例实操" class="headerlink" title="举例实操"></a>举例实操</h1><p>举例:我们就以视频类算法的封装架构设计为例子进行讲解,假设我们现在有好几种视频类算法,其中有传统的算法(旋转,缩放,crop)也有ai算法(3d,vr,..,,),而我们现在需要设计一套接口给应用层使用,要求是:这些算法可以单独使用,也可进行随意的组合成一条filter链路(即:一帧视频数据可以先调用旋转算法旋转90度,再将输出结果作为vr算法的输入,…,从而形成一条filter链路)</p><p>此时,对于应用层而言,希望能获得当前filter的信息(在这个filter之前挂了哪些filter,还有当前的pts,size等信息).因此,我们就可以使用到组合模式</p><p>我们先用以下几个算法举例如何用C++实现组合模式:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">VideoAlgorithmsName</span> &#123;</span><br><span class="line">    UnknownVideoMagicXEAlgorithmsName,</span><br><span class="line">    Rotation,</span><br><span class="line">    Resize,</span><br><span class="line">    Crop,</span><br><span class="line">    NakedeyeVR,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象的部件类描述将来所有filter共有的行为</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoAlgorithms</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="built_in">VideoAlgorithms</span>();</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">VideoAlgorithms</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">AddVideoAlgorithmsFilter</span><span class="params">(VideoAlgorithms* pVideoAlgorithmsFilter)</span></span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">RemoveVideoAlgorithmsFilter</span><span class="params">(VideoAlgorithms* pVideoAlgorithmsFilter)</span></span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">enum</span> VideoAlgorithmsName  <span class="title">GetCurrentVideoAlgorithmsName</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_emName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PrintFilterOrder</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;<span class="comment">//打印filter链路顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">InitAIAlgorithms</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//初始化相关参数(不同算法需要初始化的Api和参数都不一样)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetInputData</span><span class="params">(<span class="type">void</span>* pInputData,<span class="type">int</span> width, <span class="type">int</span> height)</span><span class="comment">//这个是所有视频类算法都必须设置的参数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pInputData = pInputData;</span><br><span class="line">        m_nWidth = width;</span><br><span class="line">        m_nHeight = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Process</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//进行算法处理的接口,需要子类根据对应的算法设置来调用对应的算法API接口</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetOutputData</span><span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span> <span class="comment">//获取当前处理的结果</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pOutputData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">VideoAlgorithmsName</span> m_emName;</span><br><span class="line">    <span class="type">void</span>* m_pInputData;</span><br><span class="line">    <span class="type">void</span>* m_pOutputData;</span><br><span class="line">    <span class="type">int</span> m_nWidth;</span><br><span class="line">    <span class="type">int</span> m_nHeight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VideoRotationAlgorithms</span> : <span class="keyword">public</span> VideoAlgorithms</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">VideoRotationAlgorithms</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_emName = VideoAlgorithmsName::Rotation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">VideoRotationAlgorithms</span>()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;VideoAlgorithms*&gt;::iterator it = m_vecVideoAlgorithms.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != m_vecVideoAlgorithms.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*it != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---delete&quot;</span> &lt;&lt; (*it)-&gt;<span class="built_in">GetCurrentVideoAlgorithmsName</span>() + <span class="string">&quot;---&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> *it;</span><br><span class="line">*it = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_vecVideoAlgorithms.<span class="built_in">erase</span>(it);</span><br><span class="line">it = m_vecVideoAlgorithms.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">AddVideoAlgorithmsFilter</span><span class="params">(VideoAlgorithms* pVideoAlgorithmsFilter)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!m_vecVideoAlgorithms.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m_vecVideoAlgorithms.<span class="built_in">push</span>(pVideoAlgorithmsFilter);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">RemoveVideoAlgorithmsFilter</span><span class="params">(VideoAlgorithms* pVideoAlgorithmsFilter)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_vecVideoAlgorithms.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;VideoAlgorithms*&gt;::iterator it = m_vecVideoAlgorithms.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">if</span>((*it)-&gt;<span class="built_in">GetCurrentVideoAlgorithmsName</span>() == pVideoAlgorithmsFilter-&gt;<span class="built_in">GetCurrentVideoAlgorithmsName</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                (*it)-&gt;<span class="built_in">RemoveVideoAlgorithmsFilter</span>((*it)-&gt;m_vecVideoAlgorithms);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (*it != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> *it;</span><br><span class="line">*it = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_vecVideoAlgorithms.<span class="built_in">erase</span>(it);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetRotationAngle</span><span class="params">(<span class="type">int</span> nRotationAngle)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//这个是旋转filter特有的接口,用于设置旋转角度参数</span></span><br><span class="line">        m_nRotationAngle = nRotationAngle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintCurrentFilterOrder</span><span class="params">()</span> <span class="type">const</span><span class="comment">//打印filter链路顺序</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_vecVideoAlgorithms.<span class="built_in">size</span>())<span class="comment">//在挂载旋转filter之前,已经挂了其他filter</span></span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;VideoAlgorithms*&gt;::iterator it = m_vecVideoAlgorithms.<span class="built_in">begin</span>(); </span><br><span class="line">            (*it)-&gt;<span class="built_in">PrintCurrentFilterOrder</span>();<span class="comment">//PrintCurrentFilterOrder()</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Rotation-&gt; \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//旋转filter之前没有挂任何其他的filter</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Rotation \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">InitAIAlgorithms</span><span class="params">()</span><span class="comment">//初始化相关参数(不同算法需要初始化的Api和参数都不一样)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">bool</span> bFlag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(m_vecVideoAlgorithms.<span class="built_in">size</span>())<span class="comment">//在挂载旋转filter之前,已经挂了其他filter</span></span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;VideoAlgorithms*&gt;::iterator it = m_vecVideoAlgorithms.<span class="built_in">begin</span>(); </span><br><span class="line">            bFlag = (*it)-&gt;<span class="built_in">InitAIAlgorithms</span>();</span><br><span class="line">            <span class="keyword">if</span>(bFlag == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> bFlag;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化旋转filter对应的参数和接口</span></span><br><span class="line">        bFlag = (*it)-&gt;<span class="built_in">VideoRotationInit</span>();</span><br><span class="line">        <span class="keyword">return</span> bFlag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Process</span><span class="params">()</span><span class="comment">//递归处理</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_vecVideoAlgorithms.<span class="built_in">size</span>())<span class="comment">//在挂载旋转filter之前,已经挂了其他filter</span></span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;VideoAlgorithms*&gt;::iterator it = m_vecVideoAlgorithms.<span class="built_in">begin</span>(); </span><br><span class="line">            (*it)-&gt;<span class="built_in">Process</span>();<span class="comment">//递归调用子节点的Process()</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取之前挂的filter的处理结果,作为当前filter的输入数据</span></span><br><span class="line">            <span class="type">void</span>* pRotationInputData = (*it)-&gt;m_pOutputData;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用Rotation算法,得到处理结果</span></span><br><span class="line">            m_pOutputData = <span class="built_in">VideoRotationProcess</span>(pRotationInputData, (*it)-&gt;m_nWidth, (*it)-&gt;m_nHeight,m_nRotationAngle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//旋转filter之前没有挂任何其他的filter</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//调用Rotation算法,得到处理结果</span></span><br><span class="line">            m_pOutputData = <span class="built_in">VideoRotationProcess</span>(m_pInputData, m_nWidth, m_nHeight,m_nRotationAngle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;VideoAlgorithms*&gt;  m_vecVideoAlgorithms;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_nRotationAngle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数:演示NakedeyeVR和Nakedeye3D这两个特效的链路构建,由于产品的应用场景较多,因此需要让应用层可以灵活的根据业务要求构建出各种filter链路</p><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>例如:</p><p>应用层现在需要用到一个NakedeyeVR算法,这个算法其实有几种filter的构建方式:</p><ul><li>缩放-&gt;NakedeyeVR</li><li>旋转(90度或270度)-&gt;crop-&gt;缩放-&gt;NakedeyeVR</li><li>旋转(180度)-&gt;缩放-&gt;NakedeyeVR</li><li>缩放-&gt;SceneDetection-&gt;NakedeyeVR</li><li>旋转(90度或270度)-&gt;crop-&gt;缩放-&gt;SceneDetection-&gt;NakedeyeVR</li><li>旋转(180度)-&gt;缩放-&gt;SceneDetection-&gt;NakedeyeVR</li></ul><p><img src="/./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/1.png"></p><p>第一种filter链路的构建是为了处理源视频文件携带了旋转信息,因此需要先对视频帧进行旋转处理后,缩放到对应的编码尺寸要求后再让NakedeyeVR进行处理</p><p>第二种filter链路的构建是为了满足用户对高精度处理的要求(挂上SceneDetection算法进行每帧的数据的针对性分析,从而让NakedeyeVR处理结果更精确,且不挂缩放filter以保证整体视频画面的输出质量)</p><p>第三种filter链路的构建是为了既保证较高的NakedeyeVR算法处理质量,并且还需要保证编码后的文件尺寸满足用户需求(因此需要上缩放filter)</p><p>对应的应用场景:</p><ul><li>第一种filter链路的构建:处理未携带旋转信息的源视频的链路构建,缩放filter的目的是进行输出文件视频size的调整</li><li>第二种filter链路的构建:处理携带旋转信息的源视频的链路构建,且旋转信息为90度或者270度,因此需要挂载crop进行调整,缩放filter的目的是进行输出文件视频size的调整</li><li>第三种filter链路的构建:处理携带旋转信息的源视频的链路构建,且旋转信息为180度,因此不需要挂载crop进行调整,缩放filter的目的是进行输出文件视频size的调整</li><li>第四种filter链路的构建:处理未携带旋转信息的源视频的链路构建,缩放filter的目的是进行输出文件视频size的调整,挂载SceneDetection这个filter后NakedeyeVR获取的效果会更好</li><li>第五种filter链路的构建:处理携带旋转信息的源视频的链路构建,且旋转信息为90度或者270度,因此需要挂载crop进行调整,缩放filter的目的是进行输出文件视频size的调整,挂载SceneDetection这个filter后NakedeyeVR获取的效果会更好</li><li>第六种filter链路的构建:处理携带旋转信息的源视频的链路构建,且旋转信息为180度,因此不需要挂载crop进行调整,缩放filter的目的是进行输出文件视频size的调整,挂载SceneDetection这个filter后NakedeyeVR获取的效果会更好</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">//组合模式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*                   第一种filter的构建:缩放-&gt;NakedeyeVR                  */</span></span><br><span class="line">    VideoAlgorithms* pVideoNakedeyeVRAlgorithms = <span class="keyword">new</span> <span class="built_in">VideoNakedeyeVRAlgorithms</span>();<span class="comment">//创建一个 NakedeyeVR filter</span></span><br><span class="line">    VideoAlgorithms* pVideoResizeAlgorithms = <span class="keyword">new</span> <span class="built_in">VideoResizeAlgorithms</span>();<span class="comment">//创建一个缩放filter</span></span><br><span class="line">    </span><br><span class="line">    pVideoNakedeyeVRAlgorithms-&gt;<span class="built_in">AddVideoAlgorithmsFilter</span>(pVideoResizeAlgorithms);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置filter链路中,第一个filter的参数</span></span><br><span class="line">    pVideoResizeAlgorithms-&gt;<span class="built_in">SetInputData</span>(pInputData,width,height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置中间filter的相关参数</span></span><br><span class="line">    pVideoResizeAlgorithms-&gt;<span class="built_in">SetOutputSize</span>(width,hegiht);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化整个filter链路</span></span><br><span class="line">    pVideoNakedeyeVRAlgorithms-&gt;<span class="built_in">InitAIAlgorithms</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行整个filter链路的算法处理</span></span><br><span class="line">    pVideoNakedeyeVRAlgorithms-&gt;<span class="built_in">Process</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果我们要获得当前缩放的效果:</span></span><br><span class="line">    <span class="type">void</span>* pResizeAlgorithmsOutputData = pVideoResizeAlgorithms-&gt;<span class="built_in">GetOutputData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果我们要获得整个filter链路最终的效果:</span></span><br><span class="line">    <span class="type">void</span>* pNakedeyeVRAlgorithmsOutputData = pVideoNakedeyeVRAlgorithms-&gt;<span class="built_in">GetOutputData</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*                   第二种filter的构建:旋转(90度或270度)-&gt;crop-&gt;缩放-&gt;NakedeyeVR                      */</span></span><br><span class="line">    VideoAlgorithms* pVideoNakedeyeVRAlgorithms = <span class="keyword">new</span> <span class="built_in">VideoNakedeyeVRAlgorithms</span>();<span class="comment">//创建一个 NakedeyeVR filter</span></span><br><span class="line">    VideoAlgorithms* pVideoRotationAlgorithms = <span class="keyword">new</span> <span class="built_in">VideoRotationAlgorithms</span>();<span class="comment">//创建一个旋转filter</span></span><br><span class="line">    VideoAlgorithms* pVideoCropAlgorithms = <span class="keyword">new</span> <span class="built_in">VideoCropAlgorithms</span>();<span class="comment">//创建一个crop filter</span></span><br><span class="line">    VideoAlgorithms* pVideoResizeAlgorithms = <span class="keyword">new</span> <span class="built_in">VideoResizeAlgorithms</span>();<span class="comment">//创建一个缩放filter</span></span><br><span class="line"></span><br><span class="line">    pVideoNakedeyeVRAlgorithms-&gt;<span class="built_in">AddVideoAlgorithmsFilter</span>(pVideoResizeAlgorithms);</span><br><span class="line">    pVideoResizeAlgorithms-&gt;<span class="built_in">AddVideoAlgorithmsFilter</span>(pVideoCropAlgorithms);</span><br><span class="line">    pVideoCropAlgorithms-&gt;<span class="built_in">AddVideoAlgorithmsFilter</span>(pVideoRotationAlgorithms);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置filter链路中,第一个filter的参数</span></span><br><span class="line">    pVideoRotationAlgorithms-&gt;<span class="built_in">SetInputData</span>(pInputData,width,height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置中间filter的相关参数</span></span><br><span class="line">    pVideoRotationAlgorithms-&gt;<span class="built_in">SetRotationAngle</span>(<span class="number">90</span>);</span><br><span class="line">    pVideoCropAlgorithms-&gt;<span class="built_in">SetCropSize</span>(<span class="number">0</span>, hegiht, <span class="number">0</span>, hegiht);</span><br><span class="line">    pVideoResizeAlgorithms-&gt;<span class="built_in">SetOutputSize</span>(width,hegiht);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化整个filter链路</span></span><br><span class="line">    pVideoNakedeyeVRAlgorithms-&gt;<span class="built_in">InitAIAlgorithms</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行整个filter链路的算法处理</span></span><br><span class="line">    pVideoNakedeyeVRAlgorithms-&gt;<span class="built_in">Process</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果我们要获得当前缩放的效果:</span></span><br><span class="line">    <span class="type">void</span>* pResizeAlgorithmsOutputData = pVideoResizeAlgorithms-&gt;<span class="built_in">GetOutputData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果我们要获得当前旋转的效果:</span></span><br><span class="line">    <span class="type">void</span>* pVideoRotationAlgorithmsOutputData = pVideoRotationAlgorithms-&gt;<span class="built_in">GetOutputData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果我们要获得当前crop的效果:</span></span><br><span class="line">    <span class="type">void</span>* pVideoCropAlgorithmsOutputData = pVideoCropAlgorithms-&gt;<span class="built_in">GetOutputData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果我们要获得整个filter链路最终的效果:</span></span><br><span class="line">    <span class="type">void</span>* pNakedeyeVRAlgorithmsOutputData = pVideoNakedeyeVRAlgorithms-&gt;<span class="built_in">GetOutputData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*   如果我们现在要从第二种filter切换到第一种filter链路的话,只需要舍弃缩放之后的链路,并设置缩放的SetInputData接口        */</span></span><br><span class="line">    pVideoResizeAlgorithms-&gt;<span class="built_in">RemoveVideoAlgorithmsFilter</span>(pVideoCropAlgorithms);</span><br><span class="line">    pVideoResizeAlgorithms-&gt;<span class="built_in">SetInputData</span>(pInputData,width,height);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化整个filter链路</span></span><br><span class="line">    pVideoNakedeyeVRAlgorithms-&gt;<span class="built_in">InitAIAlgorithms</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行整个filter链路的算法处理</span></span><br><span class="line">    pVideoNakedeyeVRAlgorithms-&gt;<span class="built_in">Process</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实这个例子并不是十分的符合组合模式的场景,组合模式更多时候是用于树状结构,而上述的举例则严格限制了m_vecVideoAlgorithms的size为1,也就是不允许分叉,因此也该例子的链路均为单项的:<br><img src="/./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/2.png"></p><p>而正常的组合模式更适合用于树状结构,更多的是用于计算根节点(具有多个子节点)的信息汇总,例如:以一个公司计算员工总人工成本为例,该树状结构的根节点是公司,根节点下面的子节点是每个部门,每个部门节点下面的子节点是每个组,每个组下面的子节点是每个人,此时要计算总用工成本就非常适合使用组合模式,只需要解除上面样例中m_vecVideoAlgorithms的size为1的限制,那么整个架构就成单向链路结构转成树状结构!</p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>上面举例的filter的架构设计,在实际产品开发模式下其实并不会做成这样,因此复杂性和灵活性太高,完全没必要.</p><p>正常我们中间filter链路的架构设计(解码后得到的帧,到送给编码器之间的帧,所构成的针对改帧的特效处理称为中间filter链路)并不是这样设计的,而是先将解码出的信息包装成一个结构体指针,然后利用流式方式进行架构设计.<br>即:每个filter类都继承一个Stream类,VideoInputStream类和VideoInputStream类,而这个类中有一些必须实现的接口:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stream</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stream</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Stream</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetStreamInfo</span><span class="params">(<span class="type">void</span>** ppStreamInfo)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">ChangeStream</span><span class="params">(<span class="type">int</span> id)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">Seek</span><span class="params">(<span class="type">double</span> time)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span>* <span class="title">GetSample</span><span class="params">(<span class="type">void</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Forward</span><span class="params">(<span class="type">void</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoInputStream</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VideoInputStream</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">VideoInputStream</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">SetVideoInput</span><span class="params">(Stream* pStream)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoOutputStream</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VideoOutputStream</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">VideoOutputStream</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span>  <span class="title">GetVideoOutput</span><span class="params">(Stream** ppStream)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解码器解码类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoStreamDecoder</span> :<span class="keyword">public</span> Stream</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VideoStreamDecoder</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">VideoStreamDecoder</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CreateVideoStreamDecoder</span><span class="params">(wchar* pFilePath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">CloseVideoStreamDecoder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetStreamInfo</span><span class="params">(<span class="type">void</span>** ppStreamInfo)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ChangeStream</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Seek</span><span class="params">(<span class="type">double</span> time)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">GetSample</span><span class="params">(<span class="type">void</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Forward</span><span class="params">(<span class="type">void</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缩放的filter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoResizeFilterStream</span> :<span class="keyword">public</span> Stream,</span><br><span class="line">                    <span class="keyword">public</span> VideoInputStream,</span><br><span class="line">                    <span class="keyword">public</span> VideoOutputStream,</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VideoResizeFilterStream</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">VideoResizeFilterStream</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SetVideoResizeSize</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetVideoInput</span><span class="params">(Stream *pStream)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pStream)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        m_pStream = pStream;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetVideoInput</span><span class="params">(Stream** ppStream)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        *ppStream = m_pStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetStreamInfo</span><span class="params">(<span class="type">void</span>** ppStreamInfo)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ChangeStream</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Seek</span><span class="params">(<span class="type">double</span> time)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">GetSample</span><span class="params">(<span class="type">void</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Forward</span><span class="params">(<span class="type">void</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Stream* m_pStream;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//旋转的filter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoRotationFilterStream</span> :<span class="keyword">public</span> Stream,</span><br><span class="line">                    <span class="keyword">public</span> VideoInputStream,</span><br><span class="line">                    <span class="keyword">public</span> VideoOutputStream,</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VideoRotationFilterStream</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">VideoRotationFilterStream</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SetVideoRotationAngle</span><span class="params">(<span class="type">int</span> angle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetVideoInput</span><span class="params">(Stream *pStream)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pStream)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        m_pStream = pStream;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetVideoOutput</span><span class="params">(Stream** ppStream)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        *ppStream = m_pStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetStreamInfo</span><span class="params">(<span class="type">void</span>** ppStreamInfo)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ChangeStream</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Seek</span><span class="params">(<span class="type">double</span> time)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">GetSample</span><span class="params">(<span class="type">void</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Forward</span><span class="params">(<span class="type">void</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Stream* m_pStream;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建解码器,并且进行解码</span></span><br><span class="line">    Stream* pVideoStreamDecoder = <span class="keyword">new</span> VideoStreamDecoder;</span><br><span class="line">    <span class="built_in">dynamic_cast</span>&lt;VideoStreamDecoder*&gt;(pVideoStreamDecoder)-&gt;<span class="built_in">CreateVideoStreamDecoder</span>(pFilePath);<span class="comment">//基类指针访问派生类函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建链路</span></span><br><span class="line">    VideoResizeFilterStream* pVideoResizeFilterStream = <span class="keyword">new</span> VideoResizeFilterStream;</span><br><span class="line">    pVideoResizeFilterStream-&gt;<span class="built_in">SetVideoInput</span>(pVideoStreamDecoder);</span><br><span class="line">    pVideoResizeFilterStream-&gt;<span class="built_in">SetVideoResizeSize</span>(<span class="number">1960.1080</span>);</span><br><span class="line">    </span><br><span class="line">    Stream* ppVideoResizeOutputStream = <span class="literal">NULL</span>;</span><br><span class="line">    pVideoResizeFilterStream-&gt;<span class="built_in">GetVideoOutput</span>(&amp;ppVideoResizeOutputStream);</span><br><span class="line"></span><br><span class="line">    VideoRotationFilterStream* pVideoRotationFilterStream = <span class="keyword">new</span> VideoRotationFilterStream;</span><br><span class="line">    pVideoRotationFilterStream-&gt;<span class="built_in">SetVideoInput</span>(ppVideoResizeOutputStream);</span><br><span class="line">    pVideoRotationFilterStream-&gt;<span class="built_in">SetVideoRotationAngle</span>(<span class="number">180</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取送给编码器的stream</span></span><br><span class="line">    Stream* pVideoStreamEncoder = <span class="literal">NULL</span>;</span><br><span class="line">    pVideoRotationFilterStream-&gt;<span class="built_in">GetVideoOutput</span>(pVideoStreamEncoder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接着把这个流送给编码器</span></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外,其实为了不对应用层暴露这些类的实现细节,我们一般还把需要对外暴露的函数(也就是上面调用到的函数),采用ATL组建的形式进行伪COM化(在特定的xml表中填写对应的GUID值,而不是直接注册到电脑的注册表中)</p><p>关于其具体的实现细节,等后面有空的话,我再专门出一篇文章介绍一下</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习笔记之适配器模式</title>
      <link href="/2023/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>适配器模式的功能就是实现不同接口间的适配,可以类比为:三孔插座和手机充电头的两孔插头对不上,此时用一个3孔转2孔的转换接口就可以对上进行充电.</p><p>因此,适配器模式本质上就是一种具备接口不兼容的对象能够相互合作的结构型设计模式，通过将一个类的接口转换成客户希望的另外一个接口，使得原本不兼容的接口一起工作。</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>适配其模式使用的场景一般就以下两种情况:</p><ul><li>我们自己写的代码在调用第三方API的时候；</li><li>我们的代码中要兼容多个版本的第三方接口；</li><li>统一多个类相同功能的接口</li></ul><h2 id="我们自己写的代码在调用第三方API的时候"><a href="#我们自己写的代码在调用第三方API的时候" class="headerlink" title="我们自己写的代码在调用第三方API的时候"></a>我们自己写的代码在调用第三方API的时候</h2><p>对于第一种场景:我们在使用到第三方库的API接口的时候,为了避免在我们的模块代码中直接调用这些第三方API接口,从而造成第三方接口和我们的功能模块出现过多耦合(如果直接在我们的代码中调用第三方接口的话,那么我们后面每次升级第三方接口的时候,如果这些第三方接口出现更新的话,就很有可能要在我们写的模块代码中大改一顿,这样后期的升级维护成本爆炸!!!)</p><h2 id="我们的代码中要兼容多个版本的第三方接口"><a href="#我们的代码中要兼容多个版本的第三方接口" class="headerlink" title="我们的代码中要兼容多个版本的第三方接口"></a>我们的代码中要兼容多个版本的第三方接口</h2><p>对于第二种场景:比如我们在进行音视频的开发过程中,需要做一个功能是实现Nvidia的GPU全流程(ffmpeg解复用-&gt;NvDec解码-&gt;CUDA颜色空间转换-&gt;OpenGL特效处理-&gt;NvEnc编码-&gt;ffmpeg复用并将数据写入到指定容器中).此时我们需要考虑到用户的显卡型号有哪些,此时我们就会发现13年之前的显卡还有用户在用,而他们的cuda版本是5以下的,但是现在cuda已经更新到12版本了,此时出现一个非常尴尬的问题,最新的NvEnc改了对于version的宏定义,这样造成了你如果用新版本的NvEnc接口的话,那么在例如GT 710的显卡上就会报错NV_ENC_ERR_INVALID_VERSION,这就尴尬了.</p><p>此时你为了兼容各个型号的显卡,你只有一种选最优选择:</p><ul><li>根据nvidia提供的接口检测显卡型号,然后针对性的打开对应的version的宏定义</li></ul><p>但是假如此时Nvidia不但改了这个结构体的定义,还增加或删除部分对外的API接口呢?</p><p>此时你要是没有使用适配器模式的话,那就有意思了,你代码里面就会出现一堆宏判断(根据nvidia提供的接口检测显卡型号,来选择调用哪个版本的API接口),那么久而久之,整套代码怕是连狗都懒得看,纯纯折磨人(我就被折磨过,太tm恶心了!!!看吐了)</p><h2 id="统一多个类相同功能的接口"><a href="#统一多个类相同功能的接口" class="headerlink" title="统一多个类相同功能的接口"></a>统一多个类相同功能的接口</h2><p>对于第三种场景:比如我们现在有多个视频类型的AI算法,每个算法封装成对应的一个类,而这些算法对外的接口都可以抽象成三个接口(内部实现细节均不相同):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SetParam</span><span class="params">(<span class="type">void</span>* param)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">GetOutputData</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>此时我们将每个算法封装成对应的一个类,如果我们需要调用对应的算法,此时就有两种方式:</p><ul><li>在我们的代码中把每个算法的对象都new出来,然后老老实实的调用每个ai算法的接口来实现功能；</li><li>在算法类和我们功能模块之间抽象出一个适配器类,功能模块通过设置算法名称(枚举类型变量)给适配器类,而该类在内部自己调用对应的ai算法</li></ul><p>对于第一种方式:每次新增一个新的算法,你都得在功能模块里面new对应的算法对象出来,并且在对应的地方加case语句,维护成本高</p><p>对于第二种方法:每次新增一个新的算法,你只需要对应的算法名称枚举变量中新增一个算法名称,然后对应的算法对象的new在适配器类中进行即可,这样维护成本就低了很多.</p><h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><p>我们就以视频类AI算法的封装架构设计为例子进行讲解.假设现在有两个Ai算法,一个是Nakedeye3D,另一个是Stabilization,我们将这两个算法封装成两个类,他们对外暴露的接口均为以下三个接口:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SetParam</span><span class="params">(<span class="type">void</span>* param)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">GetOutputData</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>此时这两个类的实现分别为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">AIAlgorithmsType</span></span><br><span class="line">&#123;</span><br><span class="line">    NONE,</span><br><span class="line">    Nakedeye3D,</span><br><span class="line">    Stabilization</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Nakedeye3DAIAlgorithms</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Nakedeye3DAIAlgorithms</span>()&#123;&#125;</span><br><span class="line">~<span class="built_in">Nakedeye3DAIAlgorithms</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetParam</span><span class="params">(<span class="type">void</span>* param)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetOutputData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StabilizationAIAlgorithms</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">StabilizationAIAlgorithms</span>()&#123;&#125;</span><br><span class="line">~<span class="built_in">StabilizationAIAlgorithms</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetParam</span><span class="params">(<span class="type">void</span>* param)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetOutputData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在,我们将其改造成适配器模式.</p><p>首先是对于功能模块的接口设计:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AIAlgorithms</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AIAlgorithms</span>()&#123;&#125;</span><br><span class="line">~<span class="built_in">AIAlgorithms</span>()&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Init</span><span class="params">(AIAlgorithmsType type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AIAlgorithms::Init() AIAlgorithmsType = %d \n&quot;</span> , type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">SetParam</span><span class="params">(<span class="type">void</span>* param)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>* <span class="title">GetOutputData</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>紧接着是需要的适配器类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Adaptee</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Adaptee</span>()</span><br><span class="line">     , <span class="built_in">m_pAIAlgorithms</span>(<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Adaptee</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_pAIAlgorithms;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitAIAlgorithms</span><span class="params">(AIAlgorithmsType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(type == AIAlgorithmsType::Nakedeye3D)</span><br><span class="line">        &#123;</span><br><span class="line">            Nakedeye3DAIAlgorithms *p = <span class="keyword">new</span> <span class="built_in">Nakedeye3DAIAlgorithms</span>();</span><br><span class="line">            m_pAIAlgorithms = (<span class="type">void</span>*)p;</span><br><span class="line">            <span class="keyword">return</span> ((Nakedeye3DAIAlgorithms*)m_pAIAlgorithms)-&gt;<span class="built_in">Init</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == AIAlgorithmsType::Stabilization)</span><br><span class="line">        &#123;</span><br><span class="line">            StabilizationAIAlgorithms *p = <span class="keyword">new</span> <span class="built_in">StabilizationAIAlgorithms</span>();</span><br><span class="line">            m_pAIAlgorithms = (<span class="type">void</span>*)p;</span><br><span class="line">            <span class="keyword">return</span> ((StabilizationAIAlgorithms*)m_pAIAlgorithms)-&gt;<span class="built_in">Init</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetAIAlgorithmsParam</span><span class="params">(<span class="type">void</span>* param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_pAIAlgorithms == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">if</span>(type == AIAlgorithmsType::Nakedeye3D)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Nakedeye3DAIAlgorithms*)m_pAIAlgorithms)-&gt;<span class="built_in">SetParam</span>(<span class="type">void</span>* param);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == AIAlgorithmsType::Stabilization)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">return</span> ((StabilizationAIAlgorithms*)m_pAIAlgorithms)-&gt;<span class="built_in">SetParam</span>(<span class="type">void</span>* param);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetAIAlgorithmsOutputData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_pAIAlgorithms == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">if</span>(type == AIAlgorithmsType::Nakedeye3D)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Nakedeye3DAIAlgorithms*)m_pAIAlgorithms)-&gt;<span class="built_in">GetOutputData</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == AIAlgorithmsType::Stabilization)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">return</span> ((StabilizationAIAlgorithms*)m_pAIAlgorithms)-&gt;<span class="built_in">GetOutputData</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">    <span class="type">void</span>* m_pAIAlgorithms;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>适配器模式有两种实现方法，对象适配器和类适配器。</p><h2 id="对象适配器的实现"><a href="#对象适配器的实现" class="headerlink" title="对象适配器的实现"></a>对象适配器的实现</h2><p>首先 是对象适配器的实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//对象适配器模式</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span>:<span class="keyword">public</span> AIAlgorithms</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Adapter</span>(Adaptee* adaptee)</span><br><span class="line">&#123;</span><br><span class="line">m_Adaptee = adaptee;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Adapter</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_Adaptee = <span class="keyword">new</span> <span class="built_in">Adaptee</span>();</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Adapter</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">(AIAlgorithmsType type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_Adaptee != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_Adaptee-&gt;<span class="built_in">InitAIAlgorithms</span>(type);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetParam</span><span class="params">(<span class="type">void</span>* param)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_Adaptee != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_Adaptee-&gt;<span class="built_in">SetAIAlgorithmsParam</span>();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetOutputData</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_Adaptee != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_Adaptee-&gt;<span class="built_in">GetAIAlgorithmsOutputData</span>();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Adaptee * m_Adaptee;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用方式:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Nakedeye3D</span></span><br><span class="line">AIAlgorithms *pNakedeye3D= <span class="keyword">new</span> <span class="built_in">Adapter</span>();</span><br><span class="line">pNakedeye3D-&gt;<span class="built_in">Init</span>(Nakedeye3D);</span><br><span class="line">pNakedeye3D-&gt;<span class="built_in">SetParam</span>(param);</span><br><span class="line"><span class="type">void</span>* p = pNakedeye3D-&gt;<span class="built_in">GetOutputData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Stabilization</span></span><br><span class="line">AIAlgorithms *pStabilization= <span class="keyword">new</span> <span class="built_in">Adapter</span>();</span><br><span class="line">pStabilization-&gt;<span class="built_in">Init</span>(Stabilization);</span><br><span class="line">pStabilization-&gt;<span class="built_in">SetParam</span>(param);</span><br><span class="line"><span class="type">void</span>* p = pStabilization-&gt;<span class="built_in">GetOutputData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pNakedeye3D;</span><br><span class="line">    <span class="keyword">delete</span> pStabilization;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类适配器的实现"><a href="#类适配器的实现" class="headerlink" title="类适配器的实现"></a>类适配器的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//类适配器模式 ，通过public继承获得接口，通过private继承获得实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span> :<span class="keyword">public</span> AIAlgorithms,<span class="keyword">private</span> Adaptee</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Adapter</span>()&#123;&#125;</span><br><span class="line">~<span class="built_in">Adapter</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">(AIAlgorithmsType type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">InitAIAlgorithms</span>(type);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetParam</span><span class="params">(<span class="type">void</span>* param)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">SetAIAlgorithmsParam</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetOutputData</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">GetAIAlgorithmsOutputData</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用方式:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Nakedeye3D</span></span><br><span class="line">AIAlgorithms *pNakedeye3D= <span class="keyword">new</span> <span class="built_in">Adapter</span>();</span><br><span class="line">pNakedeye3D-&gt;<span class="built_in">Init</span>(Nakedeye3D);</span><br><span class="line">pNakedeye3D-&gt;<span class="built_in">SetParam</span>(param);</span><br><span class="line"><span class="type">void</span>* p = pNakedeye3D-&gt;<span class="built_in">GetOutputData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Stabilization</span></span><br><span class="line">AIAlgorithms *pStabilization= <span class="keyword">new</span> <span class="built_in">Adapter</span>();</span><br><span class="line">pStabilization-&gt;<span class="built_in">Init</span>(Stabilization);</span><br><span class="line">pStabilization-&gt;<span class="built_in">SetParam</span>(param);</span><br><span class="line"><span class="type">void</span>* p = pStabilization-&gt;<span class="built_in">GetOutputData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pNakedeye3D;</span><br><span class="line">    <span class="keyword">delete</span> pStabilization;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到两种实现方式中，main中的代码都是一致的。说明两种实现方法对于应用层调用而言是无需关心的。两者执行结果一致，实现方式可相互替换。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习笔记之桥梁模式</title>
      <link href="/2023/05/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>桥梁模式一般我们也叫成:桥接模式</p><p>桥接模式是一种结构性的设计模式,其目的是将一个复杂的大类,拆分成不同的小类,然后采用类组合的方式去实现.</p><p>如果不采用桥接模式，一般我们的处理方式是直接使用继承来实现，这样双方之间处于强链接，类之间关联性极强，如要进行扩展，必然导致类结构急剧膨胀。采用桥接模式，正是为了避免这一情况的发生，将一方与桥绑定，即实现桥接口，另一方在抽象类中调用桥接口（指向的实现类），这样桥方可以通过实现桥接口进行单方面扩展，而另一方可以继承抽象类而单方面扩展，而之间的调用就从桥接口来作为突破口，不会受到双方扩展的任何影响。</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><ul><li>一个类具备了多个功能,现在你为了后期好维护,需要对这个类进行功能拆解</li></ul><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h2><ul><li>应用层的代码仅与高层抽象部分进行互动，不会接触到内部的具体实现。</li><li>开闭原则。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。</li><li>单一职责原则。 抽象部分专注于处理高层逻辑， 实现部分处理具体功能细节。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>对高内聚的类使用该模式可能会让代码更加复杂(因此桥接模式最好是在开发前期,就想好如何对整体功能架构进行拆分设计，使程序的各个部分独立,这样才方便使用 桥接模式,而不是等整个类变得十分杂乱的时候,才想着怎么样在类里面剥离代码)。</li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>现在我们举个例子来演示一下.</p><p>假如我们现在需要设计一个Class,这个类具备的功能就是对音频或视频数据进行ai算法处理,而ai算法又存在两种模式,一种是送一帧视频数据或固定长度的音频数据给算法后立马就能得到处理后的结果,而另一种模式则是预处理模式(需要将整个文件的音频或者视频数据作为输入参数设置进去,算法才会输出结果).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">AIAlgorithmsType</span></span><br><span class="line">&#123;</span><br><span class="line">    NONE,</span><br><span class="line">    VideoAIAlgorithms,</span><br><span class="line">    AudioAIAlgorithms,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">AIAlgorithmsModel</span></span><br><span class="line">&#123;</span><br><span class="line">    PreprocessMode,</span><br><span class="line">    DirectMode,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果我们按照正常的方式写的话:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AIAlgorithms</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AIAlgorithms</span>()&#123;&#125;</span><br><span class="line">~<span class="built_in">AIAlgorithms</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">(<span class="keyword">enum</span> AIAlgorithmsType type, <span class="keyword">enum</span> AIAlgorithmsModel model)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type == AIAlgorithmsType::VideoAIAlgorithms)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//进行视频类ai算法的初始化操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//进行音频类ai算法的初始化操作</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(model == AIAlgorithmsModel::PreprocessMode)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//进行预处理模式相关ai算法接口和变量的初始化操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//进行直接处理模式相关ai算法接口和变量的初始化操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="built_in">SetParam</span>(<span class="type">void</span>* param);</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetOutputData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时,如果新增了对于字幕类型,图片类型等AIAlgorithmsType的算法,或者新增了其他的AIAlgorithmsModel模式的话,那么我们不但需要在Init函数中增加对应的if语句进行对应的初始化操作,还需要在SetParam和GetOutputData的函数中调用对应的算法api接口,来实现对新增的AIAlgorithmsType或AIAlgorithmsModel的支持.</p><p>这样久而久之,整个class类就会变得非常的杂乱.</p><p>此时,我们如果采用桥接模式,将这个大类,拆分成两个单一职责的小类,一个负责AIAlgorithmsType,另一个负责AIAlgorithmsModel,那么对于后期的开发和维护就变得轻松了.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CAIAlgorithmsModel</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CAIAlgorithmsModel</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CAIAlgorithmsModel</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">InitAIAlgorithmsModel</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">SetAIAlgorithmsModelParam</span><span class="params">(<span class="type">void</span>* param)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CAIAlgorithmsPreprocessMode</span> : <span class="keyword">public</span> CAIAlgorithmsModel </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">InitAIAlgorithmsModel</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//进行预处理模式的相关ai接口初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetAIAlgorithmsModelParam</span><span class="params">(<span class="type">void</span>* param)</span> <span class="type">const</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//进行预处理模式的相关参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CAIAlgorithmsDirectMode</span> : <span class="keyword">public</span> CAIAlgorithmsModel </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">InitAIAlgorithmsModel</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//进行直接处理模式的相关ai接口初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetAIAlgorithmsModelParam</span><span class="params">(<span class="type">void</span>* param)</span> <span class="type">const</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//进行直接处理模式的相关参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CAIAlgorithms</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CAIAlgorithms</span>(CAIAlgorithmsModel* pCAIAlgorithmsModel) : <span class="built_in">m_pCAIAlgorithmsModel</span>(pCAIAlgorithmsModel) </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CAIAlgorithms</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Init</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_pCAIAlgorithmsModel-&gt;<span class="built_in">InitAIAlgorithmsModel</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">SetParam</span><span class="params">(<span class="type">void</span>* param)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_pCAIAlgorithmsModel-&gt;<span class="built_in">SetAIAlgorithmsModelParam</span>(param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>* <span class="title">GetOutputData</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    CAIAlgorithmsModel* m_pCAIAlgorithmsModel;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AIAlgorithmsType</span> m_Type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CVideoAIAlgorithms</span> : <span class="keyword">public</span> CAIAlgorithms </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CVideoAIAlgorithms</span>(CAIAlgorithmsModel* pCAIAlgorithmsModel) : <span class="built_in">CAIAlgorithms</span>(pCAIAlgorithmsModel) </span><br><span class="line">        , <span class="built_in">m_Type</span>(VideoAIAlgorithms)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">bool</span> bFlag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//进行视频类ai算法的AIAlgorithmsType相关api的初始化</span></span><br><span class="line">        bFlag = <span class="built_in">InitVideoAIAlgorithmsType</span>();</span><br><span class="line">        <span class="keyword">if</span>(bFlag == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> bFlag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行视频类ai算法的AIAlgorithmsModel相关api的初始化</span></span><br><span class="line">        bFlag = <span class="keyword">this</span>-&gt;m_pCAIAlgorithmsModel-&gt;<span class="built_in">InitAIAlgorithmsModel</span>();</span><br><span class="line">        <span class="keyword">return</span> bFlag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetParam</span><span class="params">(<span class="type">void</span>* param)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">bool</span> bFlag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//进行视频类ai算法的AIAlgorithmsType相关api的设置</span></span><br><span class="line">        bFlag = <span class="built_in">SetVideoAIAlgorithmsParamType</span>(param);</span><br><span class="line">        <span class="keyword">if</span>(bFlag == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> bFlag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行视频类ai算法的AIAlgorithmsModel相关api的设置</span></span><br><span class="line">        bFlag = <span class="keyword">this</span>-&gt;m_pCAIAlgorithmsModel-&gt;<span class="built_in">SetAIAlgorithmsModelParam</span>(param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetOutputData</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetVideoAIAlgorithmsResult</span>();<span class="comment">//返回处理结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CAudioAIAlgorithms</span> : <span class="keyword">public</span> CAIAlgorithms </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CAudioAIAlgorithms</span>(CAIAlgorithmsModel* pCAIAlgorithmsModel) : <span class="built_in">CAIAlgorithms</span>(pCAIAlgorithmsModel) </span><br><span class="line">        , <span class="built_in">m_Type</span>(AudioAIAlgorithms)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">bool</span> bFlag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//进行音频类ai算法的AIAlgorithmsType相关api的初始化</span></span><br><span class="line">        bFlag = <span class="built_in">InitAudioAIAlgorithmsType</span>();</span><br><span class="line">        <span class="keyword">if</span>(bFlag == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> bFlag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行音频类ai算法的AIAlgorithmsModel相关api的初始化</span></span><br><span class="line">        bFlag = <span class="keyword">this</span>-&gt;m_pCAIAlgorithmsModel-&gt;<span class="built_in">InitAIAlgorithmsModel</span>();</span><br><span class="line">        <span class="keyword">return</span> bFlag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetParam</span><span class="params">(<span class="type">void</span>* param)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">bool</span> bFlag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//进行音频类ai算法的AIAlgorithmsType相关api的设置</span></span><br><span class="line">        bFlag = <span class="built_in">SetAudioAIAlgorithmsParamType</span>(param);</span><br><span class="line">        <span class="keyword">if</span>(bFlag == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> bFlag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行音频类ai算法的AIAlgorithmsModel相关api的设置</span></span><br><span class="line">        bFlag = <span class="keyword">this</span>-&gt;m_pCAIAlgorithmsModel-&gt;<span class="built_in">SetAIAlgorithmsModelParam</span>(param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetOutputData</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetAudioAIAlgorithmsResult</span>();<span class="comment">//返回处理结果</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个预处理模式的视频ai算法</span></span><br><span class="line">    CAIAlgorithmsModel* pCAIAlgorithmsPreprocessMode = <span class="keyword">new</span> CAIAlgorithmsPreprocessMode;</span><br><span class="line">    CAIAlgorithms* pCVideoAIAlgorithms = <span class="keyword">new</span> <span class="built_in">CVideoAIAlgorithms</span>(pCAIAlgorithmsPreprocessMode);</span><br><span class="line">    pCVideoAIAlgorithms-&gt;<span class="built_in">Init</span>();</span><br><span class="line">    pCVideoAIAlgorithms-&gt;<span class="built_in">SetParam</span>(param);</span><br><span class="line">    <span class="type">void</span>* pData = pCVideoAIAlgorithms-&gt;GetOutputData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pCAIAlgorithmsPreprocessMode;</span><br><span class="line">    <span class="keyword">delete</span> pCVideoAIAlgorithms;</span><br><span class="line">    <span class="keyword">delete</span>[] pData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习笔记之创造型模式总结和梳理</title>
      <link href="/2023/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%E5%92%8C%E6%A2%B3%E7%90%86/"/>
      <url>/2023/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%E5%92%8C%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在前几篇的文章中,我们学习了设计模式中的创造形设计模式,即:以下几种模式:</p><h2 id="创建型设计模式包括"><a href="#创建型设计模式包括" class="headerlink" title="创建型设计模式包括:"></a>创建型设计模式包括:</h2><ul><li>简单工厂模式（Simple Factory）</li><li>工厂方法模式（Factory Method）</li><li>抽象工厂模式（Abstract Factory）</li><li>建造者模式</li><li>原型模式（Prototype）</li><li>单例模式（Singleton）</li></ul><p>因此,在此篇文章中,我们将对这些模式进行回顾总结和梳理.</p><p>首先,我们先简单描述一下这些方法的适用范围.</p><p>适用范围:</p><ul><li>简单工厂模式（Simple Factory）:适用于创建的对象比较少,客户端只知道传入工厂类的参数，对于如何创建对象的细节并不关心的场景。</li><li>工厂方法模式（Factory Method）:适用于生产较复杂，一个工厂生产单一的一种产品的时候；</li><li>抽象工厂模式（Abstract Factory）:适用于一个工厂生产多个相互依赖的产品；</li><li>建造者模式:适用于复杂对象的一步一步创建，组装产品的过程，并在创建的过程中，可以控制每一个简单对象的创建；</li><li>原型模式（Prototype）:适用于创建新对象成本较大(通过原型模式,可以利用已有的对象来快速克隆出新的对象),强调的是从自身复制自己；</li><li>单例模式（Singleton）:</li></ul><table><thead><tr><th>模式</th><th>场景</th><th>作用</th><th>局限</th></tr></thead><tbody><tr><td>简单工厂模式</td><td>单一产品需要提供不同实现,且不同实现的种类较少</td><td>对同一类型提供不同内部实现</td><td>扩展性非常差,只能用于不同实现的种类较少的情况</td></tr><tr><td>工厂方法模式</td><td>单一产品需要提供不同实现</td><td>对同一类型提供不同内部实现</td><td>对已实现的工厂方法重构，会破坏原有代码，扩展时，子类需提供一整套流程</td></tr><tr><td>抽象工厂模式</td><td>多个产品需要提供不同实现</td><td>对不同但关联类型提供不同实现</td><td>同上，且抽象工厂需要提供的代码更多</td></tr><tr><td>建造者模式</td><td>单一对象创建流程复杂</td><td>简化对象创建过程</td><td>如果需要构建的对象的不同实现间，存在较大差异，则构建者会及其庞大</td></tr><tr><td>原型模式</td><td>单个对象需要频繁创建；尤其是大对象；对象需要有多个副本</td><td>简化对象创建，对大对象的创建可提升性能</td><td>需要为每一个类配备一个克隆方法，而且该克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”</td></tr><tr><td>单例模式</td><td>创建开销大，可复用的对象</td><td>减少内存开销，全局行为统一</td><td>扩展性教差，且一般单例模式内部维护的逻辑较复杂，职责不够单一</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习笔记之门面模式</title>
      <link href="/2023/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>门面模式又叫外观模式，是一种结构型设计模式，其作用主要是封装一套一致对外的接口，具体实现由多个独立模块函数协作完成。</p><p>简单来说,就是将多个功能模块class,通过继承的方式,组合成一个大的class,提供给应用层调用.</p><p>举个例子,我们需要设计一个解码器模块,而解码又分为对视频,音频,图片,字幕文件的解码,此时我们使用门面模式的话,就可以先将每种类型的文件的解码设计成单独的解码器模块,然后通过继承方式组成一个大的class类,从而提供给应用层使用.</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><ul><li>需要将子系统组织为多层结构， 可以使用外观</li><li>需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式</li></ul><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点:</p><ul><li>让自己的代码独立于复杂子系统(例如:例子中应用层调用的class,就不涉及相关子系统解码模块的细节)。</li></ul><p>缺点:</p><ul><li>外观可能成为与程序中所有类都耦合的上帝对象(上帝对象(God object)是一个了解过多或者负责过多功能的对象)。</li></ul><h1 id="举例实操"><a href="#举例实操" class="headerlink" title="举例实操"></a>举例实操</h1><p>这个其实在组合模式的扩展中,我们就已经介绍了门面模式的例子.即:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缩放的filter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoResizeFilterStream</span> :<span class="keyword">public</span> Stream,</span><br><span class="line">                    <span class="keyword">public</span> VideoInputStream,</span><br><span class="line">                    <span class="keyword">public</span> VideoOutputStream,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br></pre></td></tr></table></figure><p>就是继承了三个class的门面模式.</p><p>我们以上面举例的设计解码器模块的例子,用C++语言简单进行描述一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">emDecodecType</span></span><br><span class="line">&#123;</span><br><span class="line">    VideoDecodec,</span><br><span class="line">    AudioDecodec,</span><br><span class="line">    PictureDecodec,</span><br><span class="line">    SubtitlesDecodec,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CVideoDecodec</span> : </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CVideoDecodec</span>();</span><br><span class="line">~<span class="built_in">CVideoDecodec</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">CreatVideoDecodec</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CAudioDecodec</span> : </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CAudioDecodec</span>();</span><br><span class="line">~<span class="built_in">CAudioDecodec</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">CreatAudioDecodec</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPictureDecodec</span> : </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CPictureDecodec</span>();</span><br><span class="line">~<span class="built_in">CPictureDecodec</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">CreatPictureDecodec</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSubtitlesDecodec</span> : </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CSubtitlesDecodec</span>();</span><br><span class="line">~<span class="built_in">CSubtitlesDecodec</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">CreatSubtitlesDecodec</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CDecodec</span> : </span><br><span class="line">        <span class="keyword">public</span> CVideoDecodec,</span><br><span class="line">        <span class="keyword">public</span> CAudioDecodec,</span><br><span class="line">        <span class="keyword">public</span> CPictureDecodec</span><br><span class="line">        <span class="keyword">public</span> CSubtitlesDecodec</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CDecodec</span>();</span><br><span class="line">~<span class="built_in">CDecodec</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">CreatDecodec</span><span class="params">(<span class="keyword">enum</span> emDecodecType type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">void</span> *pDecodec = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> VideoDecodec:</span><br><span class="line">                pDecodec = <span class="built_in">CreatVideoDecodec</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AudioDecodec:</span><br><span class="line">                pDecodec = <span class="built_in">CreatAudioDecodec</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PictureDecodec:</span><br><span class="line">                pDecodec = <span class="built_in">CreatPictureDecodec</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SubtitlesDecodec:</span><br><span class="line">                pDecodec = <span class="built_in">CreatSubtitlesDecodec</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">ASSERT</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;    </span><br><span class="line">        &#125;                                </span><br><span class="line">        <span class="keyword">return</span> pDecodec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>main函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDecodec* pCDecodec = <span class="keyword">new</span> CDecodec;</span><br><span class="line">    <span class="type">void</span>* pVideoDecodecHandle = pCDecodec-&gt;<span class="built_in">CreatDecodec</span>(emDecodecType::VideoDecodec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>音视频基础知识</title>
      <link href="/2023/05/19/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/05/19/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="H-26X系列"><a href="#H-26X系列" class="headerlink" title="H.26X系列"></a>H.26X系列</h1><p>H.26x有H.261,H.262， H.263, H.263v2以及H.264．<br>H.261基本上已经不再使用。其中H.262和H.264在MPEG系列中分别对应MPEG2的第2部和MPEG-4的第10部。</p><h2 id="H-261"><a href="#H-261" class="headerlink" title="H.261"></a>H.261</h2><p>H.261其速率为64kbps的整数倍（1～30倍）。它最初是针对在ISDN(综合业务数字网,Integrated Services Digital Network)上双向声像业务(特别是可视电话、视频会议)而设计的。后来的视频编码标准都可以说是在H.261的基础上进行逐步改进，引入新功能得到的。现在的视频编码标准比起H.261来在各性能方面都有了很大的提高，这使得H.261成为了过时的标准，除了在一些视频会议系统和网络视频中为了向后兼容还支持H.261，已经基本上看不到使用H.261的产品了。但是这并不妨碍H.261成为视频编码领域一个重要的里程碑式的标准。</p><h2 id="H-262"><a href="#H-262" class="headerlink" title="H.262"></a>H.262</h2><p>H.262是由ITU-T的VCEG组织和ISO&#x2F;IEC的MPEG组织联合制定的，所以制定完成后分别成为了两个组织的标准，正式名称是”ITU-T建议H.262”和”ISO&#x2F;IEC 13818-2”。这两个标准在所有的文字叙述上都是相同的(也许除了封面和标价之外)。</p><p>MPEG2 Video&#x2F;H.262：MPEG2(ISO&#x2F;IEC 13818-2)，也被称＃为ITU-T H.262，是目前消费类电子视频设备中使用最广泛的视频编码标准。MPE2视频用于数字电视广播：包括陆地，海底电缆和直接卫星广播。它能在25fps(PAL)或者30fps(NTSC)的固定帧率下达到720x576像素成像。此外，它也是DVD-V中必需的编解码器。</p><h2 id="H-263"><a href="#H-263" class="headerlink" title="H.263"></a>H.263</h2><p>H.263最初设计为基于H.324的系统进行传输 （即基于公共交换电话网和其它基于电路交换的网络进行视频会议和视频电话）。后来发现H.263也可以成功的应用与H.323（基于RTP／IP网络的视频会议系统），H.320（基于综合业务数字网的视频会议系统），RTSP（流式媒体传输系统）和SIP（基于因特网的视频会议）。</p><p>基于之前的视频编码国际标准（H.261，MPEG-1和H.262／MPEG-2），H.263的性能有了革命性的提高。它的第一版于1995年完 成，在所有码率下都优于之前的H.261。 之后还有在1998 年增加了新的功能的第二版H.263+，或者叫H.263v2，以及在2000年完 成的第三版H.263++，即H.263v3。</p><p>H.263v2（通常也叫做H.263+或者1998年版H.263）是ITU-T H.263 视频编 码标准第二版的非正式名称。 它保持了原先版本H.263的所有技术，但是通过增加了几个附录显著的提高了编码效率并提供了其它的一些能力，例如增强了抵抗传输信道的 数据丢失的能力（Robustness）。H.263+ 项目于1997年底／1998年初完成（这取决于我们怎么定义”完成”）。</p><h2 id="H-264【目前主流】"><a href="#H-264【目前主流】" class="headerlink" title="H.264【目前主流】"></a>H.264【目前主流】</h2><p>H.263之后，ITU-T（在与MPEG的合作下）的下一代视频编解码器是H.264，或者叫AVC以及MPEG-4第 10部分。由于H.264在性能上超越了H.263很多，现在通常认为H.263是一个过时的标准（虽然它的开发完成并不是很久以前的事情）。大多数新的视频会议产品都已经支持了H.264视频编解码器，就像以前支持H.263和H.261一样。</p><p>H.264／AVC可工作于多种速率，广泛应用于Internet／intranet上的多媒体流服务、视频点播、可视游戏、低码率移动多媒体通信(视频 手机等)、交互式多媒体应用、实时多媒体监控、数字电视与演播电视和虚拟视频会议等，大有在上述领域一统天下的趋势，有非常广泛的开发和应用前景。</p><p>H.264是一种视频高压缩技术，同时称为MPEG-4 AVC，或MPEG-4 Part10。ITU-T从1998年就H.26L的H.26S两个分组，H.26L研制节目时间较长的高压缩编码技术，H.26S则指短节目标准制订部 门。前面的H.263就是H.26S标准化技术，而H.264标准是在H.26L基础上发展而来的。为了不引起误解，ITU-T推荐使用H.264作为这 一标准的正式名称。H.264集中体现了当今国际视频编码解码技术的最新成果。在相同的重建图像质量下，H.264比其他视频压缩编码具有更高的压缩比、 更好的IP和无线网络信道适应性。</p><h2 id="H-265【应用趋势主流】"><a href="#H-265【应用趋势主流】" class="headerlink" title="H.265【应用趋势主流】"></a>H.265【应用趋势主流】</h2><p>H.265是ITU-T VCEG继H.264之后所制定的新的视频编码标准。H.265标准围绕着现有的视频编码标准H.264，保留原来的某些技术，同时对一些相关的技术加以改进。新技术使用先进的技术用以改善码流、编码质量、延时和算法复杂度之间的关系，达到最优化设置。具体的研究内容包括：提高压缩效率、提高鲁棒性和错误恢复能力、减少实时的时延、减少信道获取时间和随机接入时延、降低复杂度等。H.264由于算法优化，可以低于1Mbps的速度实现标清数字图像传送；H.265则可以实现利用1~2Mbps的传输速度传送720P（分辨率1280*720）普通高清音视频传送。</p><h1 id="MPEG-X系列"><a href="#MPEG-X系列" class="headerlink" title="MPEG-X系列"></a>MPEG-X系列</h1><p>MPEG（Moving Picture Experts Group，动态图像专家组）是ISO（International Standardization Organization，国际标准化组织）与IEC（International Electrotechnical Commission，国际电工委员会）于1988年成立的专门针对运动图像和语音压缩制定国际标准的组织。</p><h2 id="MPEG-1​【过旧-VCD-MP3】"><a href="#MPEG-1​【过旧-VCD-MP3】" class="headerlink" title="MPEG-1​【过旧 - VCD\MP3】"></a>MPEG-1​【过旧 - VCD\MP3】</h2><p>MPEG-1标准于1992年正式出版，标准的编号为ISO&#x2F;IEC11172，其标题为“码率约为1.5Mb&#x2F;s用于数字存贮媒体活动图像及其伴音的编码”。MPEG-1主要解决多媒体的存储问题，它的成功制定，使得以VCD和MP3为代表的MPEG-1产品迅速在世界范围内普及。</p><h2 id="MPEG-2【过旧-VCD-MP3】"><a href="#MPEG-2【过旧-VCD-MP3】" class="headerlink" title="MPEG-2【过旧 - VCD\MP3】"></a>MPEG-2【过旧 - VCD\MP3】</h2><p>MPEG-2制定于1994年，设计目标是高级工业标准的图象质量m以及更高的传输率。MPEG-2所能提供的传输率在3-10Mbits&#x2F;sec间，其在NTSC制式下的分辨率可达720X486，MPEG-2也可提供并能够提供广播级的视像和CD级的音质。MPEG-2的音频编码可提供左右中及两个环绕声道，以及一个加重低音声道，和多达7个伴音声道（DVD可有8种语言配音的原因）。由于MPEG-2在设计时的巧妙处理，使得大多数MPEG-2解码器也可播放MPEG-1格式的数据，如VCD。</p><h2 id="MPEG-4【主流格式】"><a href="#MPEG-4【主流格式】" class="headerlink" title="MPEG-4【主流格式】"></a>MPEG-4【主流格式】</h2><p>MPEG-4在1995年7月开始研究，1998年11月被ISO&#x2F;IEC批准为正式标准，正式标准编号是ISO&#x2F;IEC14496，它不仅针对一定比特率下的视频、音频编码，更加注重多媒体系统的交互性和灵活性。这个标准主要应用于视像电话、视像电子邮件等，对传输速率要求较低，在4800－6400bits&#x2F;s之间，分辨率为176*144。MPEG-4利用很窄的带宽，通过帧重建技术、数据压缩，以求用最少的数据获得最佳的图像质量。利用MPEG-4的高压缩率和高的图像还原质量可以把DVD里面的MPEG-2视频文件转换为体积更小的视频文件。经过这样处理，图像的视频质量下降不大但体积却可缩小几倍，可以很方便地用CD-ROM来保存DVD上面的节目。另外，MPEG-4在家庭摄影录像、网络实时影像播放也大有用武之地。</p><h2 id="MPEG-7【多媒体内容描述接口】"><a href="#MPEG-7【多媒体内容描述接口】" class="headerlink" title="MPEG-7【多媒体内容描述接口】"></a>MPEG-7【多媒体内容描述接口】</h2><p>MPEG-7（它的由来是1+2+4&#x3D;7，因为没有MPEG-3、MPEG-5、MPEG-6）于1996年10月开始研究。确切来讲，MPEG－7并不是一种压缩编码方法，其正规的名字叫做’多媒体内容描述接口，其目的是生成一种用来描述多媒体内容的标准，这个标准将对信息含义的解释提供一定的自由度，可以被传送给设备和电脑程序，或者被设备或电脑程序查取。MPEG-7并不针对某个具体的应用，而是针对被MPEG-7标准化了的图象元素，这些元素将支持尽可能多的各种应用。建立MPEG-7标准的出发点是依靠众多的参数对图象与声音实现分类，并对它们的数据库实现查询，就象我们今天查询文本数据库那样。可应用于数字图书馆，例如图象编目、音乐词典等；多媒体查询服务，如电话号码簿等；广播媒体选择，如广播与电视频道选取；多媒体编辑，如个性化的电子新闻服务、媒体创作等。</p><p>总之，无论最后储存的视频文件是 AVI还是 MOV，最后只是一个不同的容器封装起来了，真正的视频核心还是编码方式。也就是说 AVI 可以支持 H.265编码，MOV 也同样支持。也可以这样理解，不同的编码格式将会导致最后的视频有不同的画质，因为不同的编码有不同的压缩比例。</p><h1 id="XDCAM-系列编码"><a href="#XDCAM-系列编码" class="headerlink" title="XDCAM 系列编码"></a>XDCAM 系列编码</h1><p>Sony 在 2003 年所推出的无影带式专业录影系统。XDCAM 产品范围包括了摄影机和录影机，作为突发取代传统录影机的格式，容许 XDCAM 光碟可以应用在传统影带式的工作流程。其录影机亦可作为随机存取磁盘机，以IEEE 1394及以太网等途径容易汇入录像到非线性编辑系统。所以与过去使用影带的录影机系统比起来，进行非线性编辑更容易。</p><h2 id="XDCAM-HD422-MPEG-HD422"><a href="#XDCAM-HD422-MPEG-HD422" class="headerlink" title="XDCAM HD422 (MPEG HD422)"></a>XDCAM HD422 (MPEG HD422)</h2><p>第三代 XDCAM 使用 4:2:2 抽样的 MPEG-2 编码，比以往的格式有双倍色度分辨率。为可容纳更细致的色度，最大位元率增加至 50 Mbit&#x2F;s。2008年后期，Sony 推出了 PDW-700 摄影机及PDW-HD1500 半体积录影机。同时，Sony 亦藉着免费固件升级，扩展 XDCAM HD422 支援至 PDW-U1 录影机。</p><h1 id="Apple-ProRes-系列编码"><a href="#Apple-ProRes-系列编码" class="headerlink" title="Apple ProRes 系列编码"></a>Apple ProRes 系列编码</h1><p>Apple 开发的一种解码器，MOV 封装格式。MAC常用。普通PC安装Quick可以对其解码，要进行编码需要安装相关插件，文末会分享。ProRes 编解码器提供独一无二的多码流实时编辑性能、卓越图像质量和降低的存储率组合。Apple ProRes 编解码器充分利用多核处理，并具有快速、降低分辨率的解码模式。所有 Apple ProRes 编解码器都支持全分辨率的所有帧尺寸（包括 SD、HD、2K、4K 和 5K）。目前 ProRes 有6个版本（由低到高）：ProRes Proxy、ProRes 422 LT、ProRes 422、 ProRes 422 HQ、ProRes 4444 及 ProRes 4444 XQ 。</p><h2 id="ProRes-422-Proxy"><a href="#ProRes-422-Proxy" class="headerlink" title="ProRes 422 Proxy"></a>ProRes 422 Proxy</h2><p>​ProRes 422 Proxy 是比 Apple ProRes 422 LT 更高度压缩的编解码器，适用于需要低数据速率和全分辨率视频的离线工作流程。目标数据速率在 1920x1080 和 29.97 fps 时约为 45 Mbps。</p><h2 id="ProRes-422-LT"><a href="#ProRes-422-LT" class="headerlink" title="ProRes 422 LT"></a>ProRes 422 LT</h2><p>Apple ProRes 422 LT 是比 Apple ProRes 422 更高度压缩的编解码器，数据速率大概为 70%，文件小 30%。该编解码器非常适合追求最佳储存容量和数据速率的环境。目标数据速率在 1920x1080 和 29.97 fps 时约为 102 Mbps。</p><h2 id="ProRes-422"><a href="#ProRes-422" class="headerlink" title="ProRes 422"></a>ProRes 422</h2><p>Apple ProRes 422 是高质量的压缩编解码器，提供几乎所有 Apple ProRes 422 HQ 的优势，但是提供 66% 的数据速率，可实现更好的多码流实时编辑性能。目标数据速率在 1920x1080 和 29.97 fps 时约为 147 Mbps。在 Final Cut Pro X 中所有优化媒体的默认格式，能很出色的平衡画质和剪辑效率，也是大多数DSLR使用者的首选。</p><h2 id="ProRes-422-HQ"><a href="#ProRes-422-HQ" class="headerlink" title="ProRes 422 HQ"></a>ProRes 422 HQ</h2><p>Apple ProRes 422 HQ 是较高数据速率版本的 Apple ProRes 422，它可对 4:2:2 图像源保留与 Apple ProRes 4444 相同等级的视觉质量。随着视频后期制作行业广泛地采用 Apple ProRes 422 HQ，这种格式能在视觉上无损保留一个单链路 HD-SDI 信号可携带的最高质量专业 HD 视频。此编解码器支持全宽度、10 位像素深度的 4:2:2 视频源，同时通过多次解码和重编码保持了视觉无损状态。目标数据速率在 1920x1080 和 29.97 fps 时约为 220 Mbps。</p><h2 id="roRes-4444"><a href="#roRes-4444" class="headerlink" title="roRes 4444"></a>roRes 4444</h2><p>Apple ProRes 4444 是用于 4:4:4:4 图像源的最高品质的 Apple ProRes 版本（包含 alpha 通道）。此编解码器具有全分辨率、高质量 4:4:4:4 RGBA 颜色和与原始材料没有视觉区别的视觉保真度。Apple ProRes 4444 是一项高质量解决方案，用于储存和交换动态图形和复合视频，具有出色的多次编码性能和数学无损 alpha 通道（最高达 16 位）。与未压缩的 4:4:4 HD 相比，此编解码器具有卓越的低数据速率。对于 1920x1080 和 29.97 fps 的 4:4:4 源，具有大约 330 Mbps 的目标数据速率。它还提供到 RGB 和 Y’CBCR 像素格式的直接编码和解码。</p><h2 id="ProRes-4444-XQ"><a href="#ProRes-4444-XQ" class="headerlink" title="ProRes 4444 XQ"></a>ProRes 4444 XQ</h2><p>是ProRes家族最新的成员，它是一个非常专业高质量的格式，专为高端后期工作流程和设备而设计。Apple ProRes 4444 XQ 是用于 4:4:4:4 图像源的最高品质的 Apple ProRes 版本（包含 alpha 通道）。此格式具有非常高的数据速率，可以保留目前最高质量数字图像传感器生成的高动态范围图像中的详细信息。Apple ProRes 4444 XQ 可以保留大于 Rec. 709 图像的动态范围数倍的动态范围。即使在经过极端的视觉效果处理之后也是如此，这种处理过程会使色阶的暗部或亮部都得到显著延伸。像标准 Apple ProRes 4444 一样，此编解码器支持每图像通道高达 12 位，alpha 通道高达 16 位。对于 1920x1080 和 29.97 fps 的 4:4:4 源，Apple ProRes 4444 XQ 具有大约 500 Mbps 的目标数据速率。ProRes 4444 XQ 在 OS X Mountain Lion v10.8 或更高版本上受支持。</p><h1 id="DNx-系列编码"><a href="#DNx-系列编码" class="headerlink" title="DNx 系列编码"></a>DNx 系列编码</h1><p>Avid 推出的一种解码，mfx封装格式。 PC常用。现在用的基本上都是DNxHR，它比DNxHD有更大范围的分辨率支持4K。常用的有五个版本（从低到高）DNxHR LB、DNxHR SQ、DNxHR HQ、DNxHR HQX 及 DNxHR 444。</p><h2 id="DNxHR-LB"><a href="#DNxHR-LB" class="headerlink" title="DNxHR LB"></a>DNxHR LB</h2><p>低带宽；特别适合远程工作流程，并且可节约存储；LB 1&#x2F;4 分辨率和 LB 1&#x2F;16 分辨率也可用于大多数带宽&#x2F;空间受限的工作流程。</p><h2 id="DNxHR-SQ"><a href="#DNxHR-SQ" class="headerlink" title="DNxHR SQ"></a>DNxHR SQ</h2><p>标准品质；特别适用于编辑工作</p><h2 id="DNxHR-HQ"><a href="#DNxHR-HQ" class="headerlink" title="DNxHR HQ"></a>DNxHR HQ</h2><p>高品质；可实现精美图像与较小的编辑带宽之间的平衡</p><h2 id="DNxHR-HQX"><a href="#DNxHR-HQX" class="headerlink" title="DNxHR HQX"></a>DNxHR HQX</h2><p>增强高品质；精美的图像，适合色彩校正和母带后期处理</p><h2 id="DNxHR-444-4-4-4"><a href="#DNxHR-444-4-4-4" class="headerlink" title="DNxHR 444-4:4:4"></a>DNxHR 444-4:4:4</h2><p>色彩空间；出众的图像，特别适合高品质色彩校正和母带后期处理 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习笔记之单例模式</title>
      <link href="/2023/05/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>意图：保证一个类仅有一个实例(比如一个国家只能有一个总统)，并提供一个访问它的全局访问点。</p><p>主要解决：一个全局使用的类频繁地创建与销毁。</p><p>何时使用：当您想控制实例数目，节省系统资源的时候。</p><p>如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><p>关键代码：构造函数是私有的，指向本身实例的类属性为静态，通过一个static静态成员方法返回唯一的对象实例.</p><h2 id="单例类特点"><a href="#单例类特点" class="headerlink" title="单例类特点"></a>单例类特点</h2><ul><li>构造函数和析构函数为private类型，目的禁止外部构造和析构。</li><li>拷贝构造和赋值构造函数为private类型，目的是禁止外部拷贝和赋值，确保实例的唯一性。</li><li>类里有个获取实例的静态函数，可以全局访问。</li></ul><h2 id="单例模式分类"><a href="#单例模式分类" class="headerlink" title="单例模式分类"></a>单例模式分类</h2><p>单例模式可以分为懒汉式和饿汉式，两者之间的区别在于创建实例的时间不同：</p><ul><li>饿汉式：指系统一运行，就初始化创建实例，当需要时，直接调用即可。（本身就线程安全，没有多线程的问题）</li><li>懒汉式：指系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。（这种方式要考虑线程安全）</li></ul><h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围:"></a>适用范围:</h3><p>懒汉式:以时间换空间，适应于访问量较小时；推荐使用内部静态变量的懒汉单例，代码量少。</p><p>饿汉式:以空间换时间，适应于访问量较大时，或者线程比较多的的情况。</p><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><p>​饿汉式单例模式，程序启动时就实例化了该对象，并没有推迟到第一次使用该对象时再进行实例化；如果运行过程中没有使用到，该实例对象就被浪费掉了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放单实例，进程退出时调用</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deleteInstance</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印实例地址</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 将其构造和析构成为私有的, 禁止外部构造和析构</span></span><br><span class="line">    <span class="built_in">Singleton</span>();</span><br><span class="line">    ~<span class="built_in">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将其拷贝构造和赋值构造成为私有函数, 禁止外部拷贝和赋值</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;signal);</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;signal);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 唯一单实例对象指针</span></span><br><span class="line">    <span class="type">static</span> Singleton *g_pSingleton;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码一运行就初始化创建实例 ，本身就线程安全</span></span><br><span class="line">Singleton* Singleton::g_pSingleton = <span class="built_in">new</span> (std::nothrow) Singleton;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g_pSingleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Singleton::deleteInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_pSingleton)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> g_pSingleton;</span><br><span class="line">        g_pSingleton = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Singleton::Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;我的实例内存地址是:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton::<span class="built_in">Singleton</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton::~<span class="built_in">Singleton</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p>​懒汉式单例模式，要使用时候在进行对象的实例化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>    <span class="comment">// std::mutex</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> <span class="comment">// pthread_create</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleInstance</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> SingleInstance *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放单例，进程退出时调用</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DeleteInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印单例地址</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 将其构造和析构成为私有的, 禁止外部构造和析构</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>();</span><br><span class="line">    ~<span class="built_in">SingleInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将其拷贝构造和赋值构造成为私有函数, 禁止外部拷贝和赋值</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>(<span class="type">const</span> SingleInstance &amp;signal);</span><br><span class="line">    SingleInstance &amp;<span class="keyword">operator</span>=(<span class="type">const</span> SingleInstance &amp;signal);\</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        PS:</span></span><br><span class="line"><span class="comment">            写一个拷贝构造函数、赋值操作符，然后将其放在private限定符下。这样当外部想要拷贝或者赋值时，就会发现这个是私有的，禁止访问。</span></span><br><span class="line"><span class="comment">            使用这种方法时，函数本身仍是存在的，只是访问被限定了。</span></span><br><span class="line"><span class="comment">            此时于类的内部仍然可以进行拷贝或者赋值。所以当你仍然需要拷贝或者赋值，只是禁止从外部进行时，可以使用这种方式。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 唯一单例对象指针</span></span><br><span class="line">    <span class="type">static</span> SingleInstance *m_SingleInstance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化静态成员变量</span></span><br><span class="line">SingleInstance *SingleInstance::m_SingleInstance = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SingleInstance* <span class="title">SingleInstance::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_SingleInstance == <span class="literal">NULL</span>)<span class="comment">//应用层调用到GetInstance后再new</span></span><br><span class="line">&#123;</span><br><span class="line">m_SingleInstance = <span class="built_in">new</span> (std::nothrow) SingleInstance;  <span class="comment">// 没有加锁是线程不安全的，当线程并发时会创建多个实例</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            PS:</span></span><br><span class="line"><span class="comment">                std::bad_alloc在操作符new 和new [ ]内存分配失败的时候抛出的异常，在分配异常的情况下这时的指针myarray不为NULL；</span></span><br><span class="line"><span class="comment">                &quot;new(std::nothrow)&quot;在分配内存失败时会返回一个空指针。而不是触发std::bad_alloc,可以方便的进行Test-for-NULL检查。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_SingleInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SingleInstance::DeleteInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_SingleInstance)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_SingleInstance;</span><br><span class="line">        m_SingleInstance = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SingleInstance::Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我的实例内存地址是:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingleInstance::<span class="built_in">SingleInstance</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingleInstance::~<span class="built_in">SingleInstance</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////  普通懒汉式实现 -- 线程不安全  //////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">PrintHello</span><span class="params">(<span class="type">void</span> *threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 主线程与子线程分离，两者相互不干涉，子线程结束同时子线程的资源自动回收</span></span><br><span class="line">    <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        PS:</span></span><br><span class="line"><span class="comment">            1. pthread_join是一个阻塞函数，调用方会阻塞到pthread_join所指定的tid的线程结束后才被回收，但是在此之前，调用方是霸占系统资源的。</span></span><br><span class="line"><span class="comment">            2. pthread_detach不会阻塞，调用它后，线程运行结束后会自动释放资源。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取</span></span><br><span class="line">    <span class="type">int</span> tid = *((<span class="type">int</span> *)threadid);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hi, 我是线程 ID:[&quot;</span> &lt;&lt; tid &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印实例地址</span></span><br><span class="line">    SingleInstance::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 5 <span class="comment">// 线程个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[NUM_THREADS] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> indexes[NUM_THREADS] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 用数组来保存i的值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main() : 开始 ... &quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_THREADS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;main() : 创建线程:[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">indexes[i] = i; <span class="comment">//先保存i的值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 传入的时候必须强制转换为void* 类型，即无类型指针</span></span><br><span class="line">        ret = <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, PrintHello, (<span class="type">void</span> *)&amp;(indexes[i]));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            int pthread_create(pthread_t * tidp,const pthread_attr_t * attr,void * (*start_rtn)(void*),void *arg);</span></span><br><span class="line"><span class="comment">            各个参数说明：</span></span><br><span class="line"><span class="comment">                第一个参数为指向线程标识符的指针。</span></span><br><span class="line"><span class="comment">                第二个参数用来设置线程属性。</span></span><br><span class="line"><span class="comment">                第三个参数是线程运行函数的起始地址。</span></span><br><span class="line"><span class="comment">                最后一个参数是运行函数的参数。</span></span><br><span class="line"><span class="comment">            编译链接参数：</span></span><br><span class="line"><span class="comment">                -lpthread</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            返回值：</span></span><br><span class="line"><span class="comment">                若线程创建成功，则返回0。若线程创建失败，则返回出错编号，并且*thread中的内容是未定义的。</span></span><br><span class="line"><span class="comment">                返回成功时，由tidp指向的内存单元被设置为新创建线程的线程ID。attr参数用于指定各种不同的线程属性。新创建的线程从start_rtn函数的地址开始运行，该函数只有一个万能指针参数arg，如果需要向start_rtn函数传递的参数不止一个，那么需要把这些参数放到一个结构中，然后把这个结构的地址作为arg的参数传入。</span></span><br><span class="line"><span class="comment">                linux下用C语言开发多线程程序，Linux系统下的多线程遵循POSIX线程接口，称为pthread。</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            注意事项：</span></span><br><span class="line"><span class="comment">                因为pthread并非Linux系统的默认库，而是POSIX线程库。在Linux中将其作为一个库来使用，因此加上 -lpthread（或-pthread）以显式链接该库。函数在执行错误时的错误信息将作为返回值返回，并不修改系统全局变量errno，当然也无法使用perror()打印错误信息。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Error:无法创建线程,&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动释放单实例的资源</span></span><br><span class="line">    SingleInstance::<span class="built_in">DeleteInstance</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main() : 结束! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="在多线程情况下的饿汉模式和懒汉模式"><a href="#在多线程情况下的饿汉模式和懒汉模式" class="headerlink" title="在多线程情况下的饿汉模式和懒汉模式"></a>在多线程情况下的饿汉模式和懒汉模式</h2><p>饿汉单例模式的线程安全特性<br>饿汉单例模式中，单例对象定义成了一个static静态对象，它是在程序启动时，main函数运行之前就初始化好的，因此不存在线程安全问题，可以放心的在多线程环境中使用。</p><p>懒汉单例模式的线程安全特性<br>getInstance是个不可重入函数，也就它在多线程环境中执行，会出现问题。因此需要考虑加锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////  加锁的懒汉式实现  //////////////////</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleInstance</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单实例对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> SingleInstance *&amp;<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放单实例，进程退出时调用</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DeleteInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印实例地址</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 将其构造和析构成为私有的, 禁止外部构造和析构</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>();</span><br><span class="line">    ~<span class="built_in">SingleInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将其拷贝构造和赋值构造成为私有函数, 禁止外部拷贝和赋值</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>(<span class="type">const</span> SingleInstance &amp;signal);</span><br><span class="line">    SingleInstance &amp;<span class="keyword">operator</span>=(<span class="type">const</span> SingleInstance &amp;signal);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 唯一单实例对象指针</span></span><br><span class="line">    <span class="type">static</span> SingleInstance *m_SingleInstance;</span><br><span class="line">    <span class="type">static</span> std::mutex m_Mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化静态成员变量</span></span><br><span class="line">SingleInstance *SingleInstance::m_SingleInstance = <span class="literal">NULL</span>;</span><br><span class="line">std::mutex SingleInstance::m_Mutex;</span><br><span class="line"></span><br><span class="line"><span class="function">SingleInstance *&amp;<span class="title">SingleInstance::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  这里使用了两个if判断语句的技术称为双检锁；好处是，只有判断指针为空的时候才加锁，</span></span><br><span class="line">    <span class="comment">//  避免每次调用GetInstance的方法都加锁，锁的开销毕竟还是有点大的。</span></span><br><span class="line">    <span class="keyword">if</span> (m_SingleInstance == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_Mutex)</span></span>; <span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">if</span> (m_SingleInstance == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_SingleInstance = <span class="built_in">new</span> (std::nothrow) SingleInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_SingleInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SingleInstance::DeleteInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_Mutex)</span></span>; <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">if</span> (m_SingleInstance)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_SingleInstance;</span><br><span class="line">        m_SingleInstance = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SingleInstance::Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我的实例内存地址是:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingleInstance::<span class="built_in">SingleInstance</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingleInstance::~<span class="built_in">SingleInstance</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中,我们对懒汉模式的单例对象创建使用了双重检测(DCLP)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_SingleInstance == <span class="literal">NULL</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_Mutex)</span></span>; <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">if</span> (m_SingleInstance == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_SingleInstance = <span class="built_in">new</span> (std::nothrow) SingleInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很多人会疑惑为什么要用两个if语句? 一个if不行吗?</p><p>我们可以模拟一下一个if的情况:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_SingleInstance == <span class="literal">NULL</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_Mutex)</span></span>; <span class="comment">// 加锁</span></span><br><span class="line">    m_SingleInstance = <span class="built_in">new</span> (std::nothrow) SingleInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在模拟之前,我们先要明确一个问题: m_SingleInstance &#x3D; new (std::nothrow) SingleInstance;的操作是否为原子操作?</p><p>答案是:否,m_SingleInstance &#x3D; new (std::nothrow) SingleInstance;的操作可以拆分成三步:</p><ul><li>分配对象的内存空间(memory &#x3D; allocate())。</li><li>初始化对象(ctorInstance(memory))。</li><li>将m_SingleInstance指向分配的内存(m_SingleInstance &#x3D; memory)。<br>PS:第二步和第三步在不同编译器中执行顺序可能不一样(1,2,3或者1,3,2)即:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = <span class="built_in">allocate</span>();</span><br><span class="line"><span class="built_in">ctorInstance</span>(memory);</span><br><span class="line">m_SingleInstance = memory;</span><br></pre></td></tr></table></figure>或者:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = <span class="built_in">allocate</span>();</span><br><span class="line">m_SingleInstance = memory;</span><br><span class="line"><span class="built_in">ctorInstance</span>(memory);</span><br></pre></td></tr></table></figure></li></ul><p>假设我们现在有两个线程,此时第一个线程进入到if语句中加锁,并执行以上三个步骤来进行单例对象的创建操作,但是该线程只执行到m_SingleInstance &#x3D; new (std::nothrow) SingleInstance的前两个步骤,此时m_SingleInstance还没指向分配的内存,那么此时m_SingleInstance的值仍然为NULL,此时第二个线程刚好满足 if (m_SingleInstance &#x3D;&#x3D; NULL)<br>这个条件,进入了线程等待状态,直到第一个线程执行完m_SingleInstance &#x3D; new (std::nothrow) SingleInstance;操作后解锁,第二个线程又进来new了一个对象,这时候就出问题了.因此这才需要双重检测(DCLP)操作.</p><p>那么聪明的娃们可能又会说,我可以把加锁操作放在if外面,即:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SingleInstance *&amp;<span class="title">SingleInstance::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_Mutex)</span></span>; <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">if</span> (m_SingleInstance == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        m_SingleInstance = <span class="built_in">new</span> (std::nothrow) SingleInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_SingleInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样确实不会出现多实例创建的问题,但是又出现了一个效率问题,加锁操作是需要耗费时间的,而改成这样的话,我们每次调用GetInstance()接口的时候都进行了加锁操作,而理论上我们加锁的牡丹是为了只创建一个对象实例,这样效率大大降低了.因此这才需要用到双重检测</p><h2 id="内部静态变量的懒汉单例（C-11-线程安全）"><a href="#内部静态变量的懒汉单例（C-11-线程安全）" class="headerlink" title="内部静态变量的懒汉单例（C++11 线程安全）"></a>内部静态变量的懒汉单例（C++11 线程安全）</h2><p>利用静态变量是只会初始化一次的来设计一个内部静态变量的懒汉单例（C++11 线程安全）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////  内部静态变量的懒汉实现  //////////////////</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单实例对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Single &amp;<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印实例地址</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 禁止外部构造</span></span><br><span class="line">    <span class="built_in">Single</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止外部析构</span></span><br><span class="line">    ~<span class="built_in">Single</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止外部复制构造</span></span><br><span class="line">    <span class="built_in">Single</span>(<span class="type">const</span> Single &amp;signal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止外部赋值操作</span></span><br><span class="line">    Single &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Single &amp;signal);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Single &amp;<span class="title">Single::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部静态特性的方式实现单实例</span></span><br><span class="line">    <span class="type">static</span> Single signal;</span><br><span class="line">    <span class="keyword">return</span> signal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Single::Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我的实例内存地址是:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Single::<span class="built_in">Single</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Single::~<span class="built_in">Single</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-std&#x3D;c++0x编译是使用了C++11的特性，在C++11内部静态变量的方式里是线程安全的，只创建了一次实例，这个方式非常推荐，实现的代码最少！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习笔记之原型模式</title>
      <link href="/2023/05/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>原型模式是所有创建型模式中最特殊的一个，它的一大特点就是具体的创建过程，是由对象本身提供，这样我们在很多的场景下可以很方便的快速构建新的对象。但是在实际的工作中,对于原型模式使用其实并不多见，而原型模式的一大特定就是用Clone方法来实现深拷贝.</p><p>因此原型模式的适用场景所具备的条件如下:</p><ul><li>创建新对象成本较大(通过原型模式,可以利用已有的对象来快速克隆出新的对象)。</li><li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用的内存较小的时候，也可以使用原型模式配合备忘录模式来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好。</li><li>需要避免使用<font color = red>&gt;分层次</font>的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</li></ul><p>优点：</p><ul><li>如果创建新的对象比较复杂，可以利用原型模式简化对象的创建过程，同时也能够提高效率。</li><li>简化对象的创建，无需理会创建过程。</li><li>可以在程序运行时（对象属性发生了变化）获得一份内容相同的实例，他们之间不会相互干扰。</li></ul><p>缺点：</p><ul><li>在实现深拷贝时可能需要比较复杂的代码。</li><li>需要为每一个类配备一个克隆方法，而且该克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”。</li></ul><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p>这里,我们举例说明一下.假设我们现在要设计一个ai算法对外接口,整体而言就三个接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">AIAlgorithmsType</span></span><br><span class="line">&#123;</span><br><span class="line">    NONE,</span><br><span class="line">    Nakedeye3D,</span><br><span class="line">    NakedeyeVR</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CreatAIAlgorithms</span><span class="params">(<span class="keyword">enum</span> AIAlgorithmsType type,<span class="type">wchar_t</span>* path)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SetAIAlgorithmsInputData</span><span class="params">(<span class="type">void</span>* InputData,<span class="type">int</span> width,<span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">GetAIAlgorithmsResult</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>对于应用层来说,当前有一帧视频帧数据需要进行处理,那么只需要设置AIAlgorithmsType的类型就可以调用对应的ai算法,来得到对应是处理结果(path是算法库所在的路径,现在默认所有的算法库都放在这个路径下),此时应用层的需求构建出一条ai算法链路,将一帧视频帧数据作为第一个ai算法的输入,并将第一高ai算法输出的结果作为第二个ai算法的输入,以此类推,构建出一条ai算法特效的链路出来,同时GetAIAlgorithmsResult接口的输入参数UseAIAlgorithms来控制是否调用该算法进行特效处理.</p><p>对于这样的需求,我们一般会想到创建一个类,然后有多少算法就创建多少class,再将数据送进去处理得到每个算法的处理结果,如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AIAlgorithms</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">AIAlgorithms</span>()&#123;&#125;</span><br><span class="line"> ~<span class="built_in">AIAlgorithms</span>()&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CreatAIAlgorithms</span><span class="params">(<span class="keyword">enum</span> AIAlgorithmsType type,<span class="type">wchar_t</span>* path)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetAIAlgorithmsInputData</span><span class="params">(<span class="type">void</span>* InputData,<span class="type">int</span> width,<span class="type">int</span> height)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">GetAIAlgorithmsResult</span><span class="params">(<span class="type">bool</span> UseAIAlgorithms)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一张黑色的视频帧(rgba全为0),并构建Nakedeye3D+NakedeyeVR的链路,将该帧数据先作为Nakedeye3D的输入参数,并将得到的结果作为NakedeyeVR的输入参数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* InputData = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">char</span> [width*height*<span class="number">4</span>]();</span><br><span class="line">    AIAlgorithms Nakedeye3DAIAlgorithms;</span><br><span class="line">    Nakedeye3DAIAlgorithms.<span class="built_in">CreatAIAlgorithms</span>(Nakedeye3D,path);</span><br><span class="line">    Nakedeye3DAIAlgorithms.<span class="built_in">SetAIAlgorithmsInputData</span>((<span class="type">void</span>*)InputData, width, height);</span><br><span class="line">    <span class="type">void</span> *pNakedeye3DAIAlgorithmsResult =  Nakedeye3DAIAlgorithms.<span class="built_in">GetAIAlgorithmsResult</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    AIAlgorithms NakedeyeVRAIAlgorithms;</span><br><span class="line">    NakedeyeVRAIAlgorithms.<span class="built_in">CreatAIAlgorithms</span>(NakedeyeVR,path);</span><br><span class="line">    NakedeyeVRAIAlgorithms.<span class="built_in">SetAIAlgorithmsInputData</span>(pNakedeye3DAIAlgorithmsResult, width, height);</span><br><span class="line">    <span class="type">void</span> *pNakedeyeVRAIAlgorithmsResult =  NakedeyeVRAIAlgorithms.<span class="built_in">GetAIAlgorithmsResult</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果写成这样的话,你会发现每次在链路中新增一个新的算法,都需要重新一一个个设置参数,并且后面如果算法接口修改了输入参数的话,又得对每个实例对象一个个改,整个工作量非常大,而实际上对象的状态变化很小,他们之间的区别就只是设置的AIAlgorithmsType和InputData的时候不同罢了,完全没必要每次设计这么多参数,因此我们这时候就可以用到原型模式,来进行对象的快速copy创建.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AIAlgorithmsPrototype</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AIAlgorithmsPrototype</span>()=<span class="keyword">default</span>;<span class="comment">//禁止默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">AIAlgorithmsPrototype</span>(<span class="keyword">enum</span> AIAlgorithmsType type,<span class="type">wchar_t</span>* path,<span class="type">void</span>* InputData,<span class="type">int</span> width,<span class="type">int</span> height,<span class="type">bool</span> UseAIAlgorithms)</span><br><span class="line">        :m_emType&#123;type&#125;</span><br><span class="line">        ,m_pResourcePath&#123;path&#125;</span><br><span class="line">        ,m_pInputData&#123;InputData&#125;</span><br><span class="line">        ,m_width&#123;width&#125;</span><br><span class="line">        ,m_height&#123;height&#125;</span><br><span class="line">        ,<span class="built_in">m_UseAIAlgorithms</span>(UseAIAlgorithms)</span><br><span class="line">        ,<span class="built_in">m_pOutputData</span>(<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AIAlgorithmsPrototype</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> *<span class="title">GetAIAlgorithmsResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pOutputData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> AIAlgorithmsPrototype* <span class="title">Clone</span><span class="params">()</span> </span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    AIAlgorithmsType m_emType);<span class="comment">//算法类型</span></span><br><span class="line">    <span class="type">wchar_t</span>* m_pResourcePath;  <span class="comment">//算法库所在路径</span></span><br><span class="line">    <span class="type">void</span>* m_pInputData; <span class="comment">//输入的rgba帧数据所在内存地址</span></span><br><span class="line">    <span class="type">int</span> m_width;<span class="comment">//帧的宽度</span></span><br><span class="line">    <span class="type">int</span> m_height;<span class="comment">//帧的高度</span></span><br><span class="line">    <span class="type">bool</span> m_UseAIAlgorithms;<span class="comment">//是否使用该ai算法</span></span><br><span class="line">    <span class="type">void</span>* m_pOutputData; <span class="comment">//输出的rgba帧数据所在内存地址</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AIAlgorithmsPlugins</span> : <span class="keyword">public</span> AIAlgorithmsPrototype</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line"><span class="built_in">AIAlgorithmsPlugins</span>()=<span class="keyword">default</span>;<span class="comment">//禁止默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">AIAlgorithmsPlugins</span>(<span class="keyword">enum</span> AIAlgorithmsType type, <span class="type">wchar_t</span>* path, <span class="type">void</span>* InputData,<span class="type">int</span> width,<span class="type">int</span> height, <span class="type">bool</span> UseAIAlgorithms)  <span class="comment">//构造函数  </span></span><br><span class="line">&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前创建的算法为:&quot;</span> &lt;&lt; type &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">CreatAIAlgorithms</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//根据算法名称和算法库路径加载对应的算法</span></span><br><span class="line">        <span class="type">bool</span> ret = AlgorithmsPlugin::<span class="built_in">LoadAlgorithmsLibrary</span>(m_emType, m_pResourcePath);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error:BAlgorithmsPlugin::LoadAlgorithmsLibrary %d Fail !!!\n&quot;</span>,m_emType);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="type">bool</span> ret = AlgorithmsPlugin::<span class="built_in">Process</span>(m_pInputData, m_width,m_height,m_pOutputData);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error:AlgorithmsPlugin::Process Fail !!!\n&quot;</span>);</span><br><span class="line">            m_pOutputData = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetAIAlgorithmsType</span><span class="params">(<span class="keyword">enum</span> AIAlgorithmsType type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_emType = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetAIAlgorithmsInputData</span><span class="params">(<span class="type">void</span>* InputData)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pInputData = InputData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AIAlgorithmsPlugins</span>(<span class="type">const</span> AIAlgorithmsPlugins &amp;rhs) <span class="comment">//拷贝构造函数  </span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//不需要修改的类成员变量</span></span><br><span class="line">        m_pResourcePath = rhs.m_pResourcePath;</span><br><span class="line">        m_width = rhs.m_width;</span><br><span class="line">        m_height = rhs.m_height;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要修改的类成员变量</span></span><br><span class="line">        m_emType = AIAlgorithmsType::NONE;</span><br><span class="line">        m_pInputData = <span class="literal">NULL</span>;</span><br><span class="line">        m_UseAIAlgorithms = <span class="literal">true</span>;</span><br><span class="line">        m_pOutputData = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">                </span><br><span class="line">AIAlgorithmsPlugins&amp; <span class="keyword">operator</span>=(<span class="type">const</span> AIAlgorithmsPlugins&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不需要修改的类成员变量</span></span><br><span class="line">        m_pResourcePath = rhs.m_pResourcePath;</span><br><span class="line">        m_width = rhs.m_width;</span><br><span class="line">        m_height = rhs.m_height;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要修改的类成员变量</span></span><br><span class="line">        m_emType = AIAlgorithmsType::NONE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(m_pInputData !=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_pInputData;</span><br><span class="line">            m_pInputData = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_UseAIAlgorithms = <span class="literal">true</span>;</span><br><span class="line">        m_pOutputData = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">AIAlgorithmsPlugins* <span class="title">Clone</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AIAlgorithmsPlugins</span>(<span class="keyword">this</span>-&gt;m_emType, <span class="keyword">this</span>-&gt;m_pResourcePath,</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_pInputData, <span class="keyword">this</span>-&gt;m_width, <span class="keyword">this</span>-&gt;m_height, <span class="keyword">this</span>-&gt;m_UseAIAlgorithms);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> ~<span class="built_in">AIAlgorithmsPlugins</span>()</span><br><span class="line"> &#123;</span><br><span class="line"><span class="keyword">if</span>(m_pInputData !=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_pInputData;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m_pOutputData !=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_pOutputData;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="type">int</span> width = <span class="number">1920</span>;</span><br><span class="line">    <span class="type">int</span> height = <span class="number">1080</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* InputData = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">char</span> [width*height*<span class="number">4</span>]();</span><br><span class="line"></span><br><span class="line">AIAlgorithmsPlugins *pNakedeye3DAIAlgorithms = <span class="keyword">new</span> <span class="built_in">AIAlgorithmsPlugins</span>(Nakedeye3D, path, InputData, width, height,<span class="literal">true</span>);</span><br><span class="line">    <span class="type">void</span> *pNakedeye3DAIAlgorithmsResult = pNakedeye3DAIAlgorithms-&gt;<span class="built_in">GetAIAlgorithmsResult</span>();</span><br><span class="line"> </span><br><span class="line">AIAlgorithmsPlugins *pNakedeyeVRAIAlgorithms = pNakedeye3DAIAlgorithms-&gt;<span class="built_in">Clone</span>();</span><br><span class="line">    pNakedeyeVRAIAlgorithms-&gt;<span class="built_in">SetAIAlgorithmsType</span>(NakedeyeVR)</span><br><span class="line">    pNakedeyeVRAIAlgorithms-&gt;<span class="built_in">SetAIAlgorithmsInputData</span>(pNakedeye3DAIAlgorithmsResult);</span><br><span class="line"><span class="type">void</span> *pNakedeyeVRAIAlgorithmsResult = pNakedeyeVRAIAlgorithms-&gt;<span class="built_in">GetAIAlgorithmsResult</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pNakedeye3DAIAlgorithms;</span><br><span class="line">pNakedeye3DAIAlgorithms = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有同学可能会说，直接调用拷贝构造函数是不是就可以了，何必在外层封装一层 Clone？实际上，这是有本质区别的。敲黑板，重点来了！</p><p>原型模式实现的是一个Clone 接口，注意是接口，也就是基于多态的 Clone 虚函数。也就是说原型模式能够通过基类指针来复制派生类对象。拷贝构造函数完不成这样的任务。在继承场景下，Clone 函数可以定义为虚函数。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习笔记之建造者模式</title>
      <link href="/2023/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>建造者模式是将一个复杂对象的构建过程隐藏起来,应用层不关心建造过程细节.只需要指定需要建造的类型就可以得到该类型对应的产品实例;</p><p>举个例子:比如有两个生成笔记本电脑的车间,一个生成的是macbook,一个生成的是华硕电脑.此时我作为一个用户,下单了一个订单,购买一台配置为:cpu: i9 内存 16G 固态硬盘 1T的macbook电脑,此时就适合用建造者模式.</p><p>如果你不用建造者模式,而是正常通过折叠构造函数模式（telescoping constructor pattern ）设计一个class,那么在对应的构造函数中就会出现可选参数(华硕的电脑还要选择GPU的型号: 1650Ti - 4060),此时你设计的类的构造珊瑚就就变成这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProductionComputer</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductionComputer</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">ProductionComputer</span>(<span class="keyword">enum</span> emCPUType cpu, <span class="type">int</span> Memory, <span class="type">int</span> SSD);<span class="comment">//macbook</span></span><br><span class="line">    <span class="built_in">ProductionComputer</span>(<span class="keyword">enum</span> emCPUType cpu, <span class="type">int</span> Memory, <span class="type">int</span> SSD,<span class="keyword">enum</span> emGPUType gpu);<span class="comment">//华硕</span></span><br><span class="line">   </span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样设计的话,只要笔记本电脑的品牌够多,那么相对应的构造函数也会有好几个,那么我们在使用及阅读的时候就会很不方便。你可以想象一下，当你要调用一个类的构造函数时，你首先要决定使用哪一个，然后里面又是一堆参数，如果这些参数的类型很多又都一样，你还要搞清楚这些参数的含义，很容易就传混了。。。那酸爽谁用谁知道。</p><p>当然还有另外一种Javabean模式,就是构造函数不传参,而是搞一堆类成员函数来set参数,比如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProductionComputer</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductionComputer</span>();</span><br><span class="line">    <span class="built_in">SetCPU</span>(<span class="keyword">enum</span> emCPUType cpu);</span><br><span class="line">    <span class="built_in">SetMemory</span>(<span class="type">int</span> Memory);</span><br><span class="line">    <span class="built_in">SetSSD</span>(<span class="type">int</span> SSD);</span><br><span class="line">    <span class="built_in">SetGPU</span>(<span class="keyword">enum</span> emGPUType gpu);</span><br><span class="line">   </span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方式在构建过程中,类中的属性是分步设置的，对象的状态容易发生变化，造成错误。</p><p>因此,建造者模式适用于一个具有较多的零件的复杂产品的创建过程.</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>建造者模式适用场景 :</p><ul><li>对象有非常多属性;</li><li>想把复杂对象的创建和使用分离,不想让应用层关心建造过程细节;</li><li>创造一个对象需要很多步骤;</li></ul><p>如何实现:</p><ul><li>在Computer中创建一个静态内部类 Builder，然后将Computer 中的参数都复制到Builder类中。</li><li>在Computer中创建一个private的构造函数，参数为Builder类型</li><li>在Builder中创建一个public的构造函数，参数为Computer中必填的那些参数，cpu 和ram。</li><li>在Builder中创建设置函数，对Computer中那些可选参数进行赋值，返回值为Builder类型的实例</li><li>在Builder中创建一个build()方法，在其中构建Computer的实例并返回</li></ul><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点:</p><ul><li>创建和使用分离</li><li>可扩展性好,解耦度较高<br>缺点:</li><li>产品内部发生变化,建造者也要相应修改;</li><li>产生多余的Builder对象</li></ul><h1 id="举例实操"><a href="#举例实操" class="headerlink" title="举例实操"></a>举例实操</h1><p>举例:现在有2个用于处理rgba数据的AI算法,每个算法的处理效果和模型均不相同,并且所需要的输入参数也存在一定的差异,但是这些算法对外暴露的接口均一样.即:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">AIAlgorithmsType</span></span><br><span class="line">&#123;</span><br><span class="line">    NONE,</span><br><span class="line">    Nakedeye3D,</span><br><span class="line">    NakedeyeVR</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Nakedeye3D:</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CreatAIAlgorithms</span><span class="params">(<span class="keyword">enum</span> AIAlgorithmsType type,<span class="type">wchar_t</span>* path)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SetAIAlgorithmsInputData</span><span class="params">(<span class="type">void</span>* InputData,<span class="type">int</span> width,<span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">GetAIAlgorithmsResult</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NakedeyeVR:</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">NakedeyeVRSplitScreenMode</span></span><br><span class="line">&#123;   </span><br><span class="line">    UpAndDownMode,</span><br><span class="line">    LeftAndRightMode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CreatAIAlgorithms</span><span class="params">(<span class="keyword">enum</span> AIAlgorithmsType type,<span class="type">wchar_t</span>* path)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SetAIAlgorithmsInputData</span><span class="params">(<span class="type">void</span>* InputData,<span class="type">int</span> width,<span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SetVRSplitScreenMode</span><span class="params">(<span class="keyword">enum</span> NakedeyeVRSplitScreenMode mode)</span></span>;<span class="comment">//NakedeyeVR需要多设置这个参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">GetAIAlgorithmsResult</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时,我们如果采用正常的实现方式的话,如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AIAlgorithms</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AIAlgorithms</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Nakedeye3D</span></span><br><span class="line">    <span class="built_in">AIAlgorithms</span>(<span class="keyword">enum</span> AIAlgorithmsType type,<span class="type">wchar_t</span>* path,<span class="type">void</span>* InputData,<span class="type">int</span> width,<span class="type">int</span> height)</span><br><span class="line">    :m_emType&#123;type&#125;</span><br><span class="line">    ,m_pResourcePath&#123;path&#125;</span><br><span class="line">    ,m_pInputData&#123;InputData&#125;</span><br><span class="line">    ,m_width&#123;width&#125;</span><br><span class="line">    ,m_height&#123;height&#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//NakedeyeVR</span></span><br><span class="line">    <span class="built_in">AIAlgorithms</span>(<span class="keyword">enum</span> AIAlgorithmsType type,<span class="type">wchar_t</span>* path,<span class="type">void</span>* InputData,<span class="type">int</span> width,<span class="type">int</span> height,<span class="keyword">enum</span> NakedeyeVRSplitScreenMode mode)</span><br><span class="line">    :m_emType&#123;type&#125;</span><br><span class="line">    ,m_pResourcePath&#123;path&#125;</span><br><span class="line">    ,m_pInputData&#123;InputData&#125;</span><br><span class="line">    ,m_width&#123;width&#125;</span><br><span class="line">    ,m_height&#123;height&#125;</span><br><span class="line">    ,<span class="built_in">m_emMode</span>(mode)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    AIAlgorithmsType m_emType);<span class="comment">//算法类型</span></span><br><span class="line">    <span class="type">wchar_t</span>* m_pResourcePath;  <span class="comment">//算法库所在路径</span></span><br><span class="line">    <span class="type">void</span>* m_pInputData; <span class="comment">//输入的rgba帧数据所在内存地址</span></span><br><span class="line">    <span class="type">int</span> m_width;<span class="comment">//帧的宽度</span></span><br><span class="line">    <span class="type">int</span> m_height;<span class="comment">//帧的高度</span></span><br><span class="line"></span><br><span class="line">    NakedeyeVRSplitScreenMode m_emMode;<span class="comment">//NakedeyeVR需要的参数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AIAlgorithmsBuilder</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">AIAlgorithms <span class="title">BuildNakedeye3DAIAlgorithms</span><span class="params">(<span class="type">wchar_t</span>* path,<span class="type">void</span>* InputData,<span class="type">int</span> width,<span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AIAlgorithms</span>(Nakedeye3D,path,InputData,width,height);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function">AIAlgorithms <span class="title">BuildNakedeyeVRAIAlgorithms</span><span class="params">(<span class="type">wchar_t</span>* path,<span class="type">void</span>* InputData,<span class="type">int</span> width,<span class="type">int</span> height, <span class="keyword">enum</span> NakedeyeVRSplitScreenMode mode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AIAlgorithms</span>(NakedeyeVR,path,InputData,width,height,mode);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用时:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AIAlgorithmsBuilder builder;</span><br><span class="line">    <span class="keyword">auto</span> Nakedeye3DAIAlgorithms=builder.<span class="built_in">BuildNakedeye3DAIAlgorithms</span>(path,InputData,width,height);</span><br><span class="line">    <span class="keyword">auto</span> NakedeyeVRAIAlgorithms=builder.<span class="built_in">BuildNakedeye3DAIAlgorithms</span>(path,InputData,width,height,mode);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写代码是没问题的，只是如果我们现在想引进一个新的算法，就不得不去修改AIAlgorithmsBuilder类,并且假如这个算法还需要其他输入参数的话,你还得为AIAlgorithms增加一个构造函数，简直麻烦到爆炸.</p><p>so, 建造者模式应运而生,采用面向接口编程的方式，从AIAlgorithmsBuilder抽象出接口BuilderInterface</p><p>BuilderInterface中包含了所有的算法都需要具备的几个接口.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AIAlgorithms</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AIAlgorithms</span>()</span><br><span class="line">        :m_emType&#123;NONE&#125;</span><br><span class="line">        ,m_pResourcePath&#123;<span class="literal">NULL</span>&#125;</span><br><span class="line">        ,m_pInputData&#123;<span class="literal">NULL</span>&#125;</span><br><span class="line">        ,m_width&#123;<span class="number">0</span>&#125;</span><br><span class="line">        ,m_height&#123;<span class="number">0</span>&#125;</span><br><span class="line">        ,<span class="built_in">m_pOutputData</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetAIAlgorithmsInitParam</span><span class="params">(<span class="keyword">enum</span> AIAlgorithmsType type, <span class="type">wchar_t</span>* pResourcePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_emType = type;</span><br><span class="line">        m_pResourcePath = pResourcePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetAIAlgorithmsInputDataParam</span><span class="params">(<span class="type">void</span>* pInputData, <span class="type">unsigned</span> <span class="type">int</span> width, <span class="type">unsigned</span> <span class="type">int</span> height)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pInputData = pInputData;</span><br><span class="line">        m_width = width;</span><br><span class="line">        m_height = height;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetVRSplitScreenMode</span><span class="params">(<span class="keyword">enum</span> NakedeyeVRSplitScreenMode mode)</span><span class="comment">//NakedeyeVR需要多设置这个参数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_emMode = mode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">enum</span> AIAlgorithmsType <span class="title">GetAIAlgorithmsType</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_emType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">wchar_t</span>* <span class="title">GetAIAlgorithmsResourcePath</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pResourcePath;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetWidth</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_width;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetOutputData</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pOutputData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">enum</span> NakedeyeVRSplitScreenMode <span class="title">GetVRSplitScreenMode</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_emMode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    AIAlgorithmsType m_emType);<span class="comment">//算法类型</span></span><br><span class="line">    <span class="type">wchar_t</span>* m_pResourcePath;  <span class="comment">//算法库所在路径</span></span><br><span class="line">    <span class="type">void</span>* m_pInputData; <span class="comment">//输入的rgba帧数据所在内存地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_width;<span class="comment">//帧的宽度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_height;<span class="comment">//帧的高度</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* m_pOutputData; <span class="comment">//(算法处理过的输出结果)输出的rgba帧数据所在内存地址</span></span><br><span class="line"></span><br><span class="line">    NakedeyeVRSplitScreenMode m_emMode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuilderInterface</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">CreatAIAlgorithms</span><span class="params">(<span class="type">wchar_t</span>* pResourcePath)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">SetAIAlgorithmsInputData</span><span class="params">(<span class="type">void</span>* InputData,<span class="type">unsigned</span> <span class="type">int</span> width,<span class="type">unsigned</span> <span class="type">int</span> height)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通虚函数，对应在基类中定义一个缺省的实现 (default implementation)，表示继承的是基类成员函数的接口和缺省的实现，由派生类自行选择是否重写该函数。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">SetNakedeyeVRSplitScreenMode</span><span class="params">(<span class="keyword">enum</span> NakedeyeVRSplitScreenMode mode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> *<span class="title">GetAIAlgorithmsResult</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//普通虚函数，对应在基类中定义一个缺省的实现 (default implementation)，表示继承的是基类成员函数的接口和缺省的实现，由派生类自行选择是否重写该函数。</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">BuilderInterface</span>()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现各自的子类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Nakedeye3DBuilder</span>:<span class="keyword">public</span> BuilderInterface&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Nakedeye3DBuilder</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_pAIAlgorithms = <span class="keyword">new</span> <span class="built_in">AIAlgorithms</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">CreatAIAlgorithms</span><span class="params">(<span class="type">wchar_t</span>* pResourcePath)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pAIAlgorithms-&gt;<span class="built_in">SetAIAlgorithmsInitParam</span>(Nakedeye3D, pResourcePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据算法名称和算法库路径加载对应的算法</span></span><br><span class="line">        <span class="type">bool</span> ret = AlgorithmsPlugin::<span class="built_in">LoadAlgorithmsLibrary</span>(m_emType, m_pResourcePath);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error:BuilderInterface::CreatAIAlgorithms LoadAlgorithmsLibrary %d Fail !!!\n&quot;</span>,m_emType);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetAIAlgorithmsInputData</span><span class="params">(<span class="type">void</span>* InputData,<span class="type">unsigned</span> <span class="type">int</span> width,<span class="type">unsigned</span> <span class="type">int</span> height)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pAIAlgorithms-&gt;<span class="built_in">SetAIAlgorithmsInputDataParam</span>(InputData, width,height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">GetAIAlgorithmsResult</span><span class="params">()</span> <span class="keyword">override</span></span>;<span class="comment">//overide作用:在派生类中提醒自己要重写这个同参数函数,不写则报错（函数参数、返回类型必须相同）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AIAlgorithms* m_pAIAlgorithms;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Nakedeye3DBuilder::GetAIAlgorithmsResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_pOutputData = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">char</span>[m_width*m_height*<span class="number">4</span>]();</span><br><span class="line">    <span class="type">bool</span> ret = AlgorithmsPlugin::<span class="built_in">Process</span>(m_pInputData, m_width,m_height,m_pOutputData);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error:Nakedeye3DBuilder::GetAIAlgorithmsResult Process Fail !!!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">delete</span>[] m_pOutputData;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_pOutputData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NakedeyeVRBuilder</span>:<span class="keyword">public</span> BuilderInterface&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NakedeyeVRBuilder</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_pAIAlgorithms = <span class="keyword">new</span> <span class="built_in">AIAlgorithms</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">CreatAIAlgorithms</span><span class="params">( <span class="type">wchar_t</span>* pResourcePath)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pAIAlgorithms-&gt;<span class="built_in">SetAIAlgorithmsInitParam</span>(NakedeyeVR, pResourcePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据算法名称和算法库路径加载对应的算法</span></span><br><span class="line">        <span class="type">bool</span> ret = AlgorithmsPlugin::<span class="built_in">LoadAlgorithmsLibrary</span>(m_emType, m_pResourcePath);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error:BuilderInterface::CreatAIAlgorithms LoadAlgorithmsLibrary %d Fail !!!\n&quot;</span>,m_emType);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetAIAlgorithmsInputData</span><span class="params">(<span class="type">void</span>* InputData,<span class="type">unsigned</span> <span class="type">int</span> width,<span class="type">unsigned</span> <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pAIAlgorithms-&gt;<span class="built_in">SetAIAlgorithmsInputDataParam</span>(InputData, width,height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SetNakedeyeVRSplitScreenMode</span><span class="params">(<span class="keyword">enum</span> NakedeyeVRSplitScreenMode mode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pAIAlgorithms-&gt;<span class="built_in">SetVRSplitScreenMode</span>(mode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">GetAIAlgorithmsResult</span><span class="params">()</span><span class="keyword">override</span></span>;<span class="comment">//overide作用:在派生类中提醒自己要重写这个同参数函数,不写则报错（函数参数、返回类型必须相同）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AIAlgorithms* m_pAIAlgorithms;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">NakedeyeVRBuilder::GetAIAlgorithmsResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_pOutputData = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">char</span>[m_width*m_height*<span class="number">4</span>]();</span><br><span class="line">    <span class="type">bool</span> ret = AlgorithmsPlugin::<span class="built_in">Process</span>(m_pInputData, m_width,m_height,m_pOutputData);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error:NakedeyeVRBuilder::GetAIAlgorithmsResult Process Fail !!!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">delete</span>[] m_pOutputData;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_pOutputData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指挥者Director</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Director</span>(BuilderInterface* builder)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pBuilder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetAIAlgorithmsResult</span><span class="params">(<span class="type">wchar_t</span>* path, <span class="type">void</span>* InputData,<span class="type">unsigned</span> <span class="type">int</span> width,<span class="type">unsigned</span> <span class="type">int</span> height,<span class="keyword">enum</span> NakedeyeVRSplitScreenMode mode = UpAndDownMode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">m_pBuilder-&gt;<span class="built_in">CreatAIAlgorithms</span>(path);</span><br><span class="line">m_pBuilder-&gt;<span class="built_in">SetAIAlgorithmsInputData</span>(InputData,width,height);</span><br><span class="line">        m_pBuilder-&gt;<span class="built_in">SetNakedeyeVRSplitScreenMode</span>(model)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetAIAlgorithmsResult</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">BuilderInterface *m_pBuilder;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//建造Nakedeye3D</span></span><br><span class="line"><span class="function">Director <span class="title">directorBuildNakedeye3D</span><span class="params">(<span class="keyword">new</span> Nakedeye3DBuilder)</span></span>;</span><br><span class="line"><span class="type">void</span>* pNakedeye3DOutputData = directorBuildNakedeye3D.<span class="built_in">GetAIAlgorithmsResult</span>(path,InputData,width,height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建造NakedeyeVR</span></span><br><span class="line"><span class="function">Director <span class="title">directorBuildNakedeyeVR</span><span class="params">(<span class="keyword">new</span> NakedeyeVRBuilder)</span></span>;</span><br><span class="line"><span class="type">void</span>* pNakedeyeVROutputData = directorBuildNakedeyeVR.<span class="built_in">GetAIAlgorithmsResult</span>(path,InputData,width,height,mode);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习笔记之工厂模式</title>
      <link href="/2023/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="工厂模式的介绍"><a href="#工厂模式的介绍" class="headerlink" title="工厂模式的介绍"></a>工厂模式的介绍</h1><p>工厂模式的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在工厂模式中，我们在创建对象时<font color =red>不会对客户端暴露创建逻辑</font>，并且是通过使用<font color =red>一个共同的接口</font>来指向新创建的对象。<br>简单来说，使用了C++多态的特性，将存在继承关系的类，通过一个工厂类创建对应的子类（派生类）对象。在项目复杂的情况下，可以便于子类对象的创建。</p><p>工厂模式的实现方式可分别简单工厂模式、工厂方法模式、抽象工厂模式，每个实现方式都存在优和劣。</p><p>由于作者是一名音视频开发工程师,因此就以音视频文件举个例子:</p><h2 id="简单工厂模式（Simple-Factory）"><a href="#简单工厂模式（Simple-Factory）" class="headerlink" title="简单工厂模式（Simple Factory）"></a>简单工厂模式（Simple Factory）</h2><p>具体的情形：<br>一个音视频文件可以包含一个或者多个视频流,音频流和字幕流.<br>现在我们要设计一个接口让应用层调用,这个接口的作用就是用于生成一条流(可以是视频流也可以是音频流或者字幕流).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//流的抽象类（基类）,接口函数为Log()，用于打印日志信息</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stream</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Stream</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Log</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下为具体流的的类，分别是视频、音频和字幕的流，它们都继承于Stream抽象类。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//视频流</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoStream</span> : <span class="keyword">public</span> Stream</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建一条视频流&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 音频流</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioStream</span> : <span class="keyword">public</span> Stream</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建一条音频流&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字幕流</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubtitleStream</span> : <span class="keyword">public</span> Stream</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建一条字幕流&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>StreamFactory为工厂类，类里实现根据流的类型创建对应流对象的CreatStream(STREAM_TYPE type)函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">STREAM_TYPE</span></span><br><span class="line">&#123;</span><br><span class="line">    VIDEO,</span><br><span class="line">    AUDIO,</span><br><span class="line">    SUBTITLE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂类:流的生产厂 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StreamFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 根据流的类型创建对应的流对象</span></span><br><span class="line">    <span class="function">Stream *<span class="title">CreateStream</span><span class="params">(STREAM_TYPE type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> VIDEO:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">VideoStream</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AUDIO:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AudioStream</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SUBTITLE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SubtitleStream</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>main函数，先是构造了工厂对象，后创建指定类型的具体流对象，创建了流的对象便可直接日志信息。因为采用的是<code>new</code>的方式创建了对象，用完了要通过<code>delete</code> 释放资源资源哦！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构造工厂对象</span></span><br><span class="line">    StreamFactory streamFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从流工厂对象创建一条视频流</span></span><br><span class="line">    Stream *pVideoStream = streamFactory.<span class="built_in">CreateStream</span>(VIDEO);</span><br><span class="line">    <span class="keyword">if</span> (pVideoStream != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//日志打印:创建一条视频流</span></span><br><span class="line">        pVideoStream-&gt;<span class="built_in">Log</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> pVideoStream;</span><br><span class="line">        pVideoStream = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从流工厂对象创建一条音频流</span></span><br><span class="line">    Stream *pAudioStream = streamFactory.<span class="built_in">CreateStream</span>(AUDIO);</span><br><span class="line">    <span class="keyword">if</span> (pAudioStream != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//日志打印:创建一条音频流</span></span><br><span class="line">        pAudioStream-&gt;<span class="built_in">Log</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> pAudioStream;</span><br><span class="line">        pAudioStream = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从流工厂对象创建一条字幕流</span></span><br><span class="line">    Stream *pSubtitleStream = streamFactory.<span class="built_in">CreateStream</span>(SUBTITLE);</span><br><span class="line">    <span class="keyword">if</span> (pSubtitleStream != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//日志打印:创建一条字幕流</span></span><br><span class="line">        pSubtitleStream-&gt;<span class="built_in">Log</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> pSubtitleStream;</span><br><span class="line">        pSubtitleStream = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建一条视频流</span><br><span class="line">创建一条音频流</span><br><span class="line">创建一条字幕流</span><br></pre></td></tr></table></figure><p>通过上述的样例代码,我们很容易发现<br>简单工厂模式的结构由三个部分组成：</p><ul><li>工厂类(StreamFactory)：工厂模式的核心类，会定义一个用于创建指定的具体实例对象的接口。</li><li>抽象流类(Stream)：是具体流类(VideoStream&#x2F;AudioStream&#x2F;SubtitleStream)继承的父类或实现的接口。</li><li>具体流类(VideoStream&#x2F;AudioStream&#x2F;SubtitleStream)：工厂类所创建的对象就是此具体流的实例。</li></ul><p>简单工厂模式的特点：<br>工厂类封装了创建具体流对象的函数。</p><p>简单工厂模式有个很大的缺陷:<br>扩展性非常差，每次我们新增不同种类的流的时候，都需要去修改工厂类(StreamFactory)。</p><p>综上所述:</p><p>简单工厂模式包含三个角色：工厂角色负责实现创建所有实例的内部逻辑；抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</p><p>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</p><p>简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。</p><p>简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。</p><h2 id="工厂方法模式（Factory-Method）"><a href="#工厂方法模式（Factory-Method）" class="headerlink" title="工厂方法模式（Factory Method）"></a>工厂方法模式（Factory Method）</h2><p>在简单工厂模式中工厂类的定义为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂类:流的生产厂 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StreamFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 根据流的类型创建对应的流对象</span></span><br><span class="line">    <span class="function">Stream *<span class="title">CreateStream</span><span class="params">(STREAM_TYPE type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> VIDEO:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">VideoStream</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AUDIO:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AudioStream</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SUBTITLE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SubtitleStream</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以发现在工厂类负责创建的对象比较少的情况下,用简单工厂模式即可,但是如果STREAM_TYPE的类型有很多的话,每次我们新增不同种类的流的时候，都需要去修改工厂类(StreamFactory),而由于工厂类集中了所有种类的流的创建逻辑，一旦不能正常工作，整个系统都要受到影响。</p><p>因此对于有需要不同种类的产品类的时候,我们就需要采用工厂方法模式（Factory Method）,将简单工程模式中的工厂类的定义的定义剥离出来,形成抽象的工厂类,和具体工厂类.</p><p>此时:抽象工厂类(StreamFactory)，提供了创建具体流的纯虚函数。</p><p>具体工厂类(VideoProducer、AudioProducer、SUBTITLEProducer)，继承持续工厂类，实现对应具体种类的流对象的创建。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象工厂类(StreamFactory)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StreamFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Stream *<span class="title">CreateStream</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">StreamFactory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视频流生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoProducer</span> : <span class="keyword">public</span> StreamFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Stream *<span class="title">CreateStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">VideoStream</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 音频流生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioProducer</span> : <span class="keyword">public</span> StreamFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Stream *<span class="title">CreateStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AudioStream</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字幕流生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubtitleProducer</span> : <span class="keyword">public</span> StreamFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Stream *<span class="title">CreateStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SubtitleStream</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>main函数针对每种类型的流，构造了每种类型的生产线，再由每个生产线创建出对应种类的流。需注意的是具体工厂对象和具体产品流对象，用完了需要通过delete释放资源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ================ 生产视频流的流程 ==================== //</span></span><br><span class="line">    <span class="comment">// 工厂开设视频流生产线</span></span><br><span class="line">    StreamFactory *videoProducer = <span class="keyword">new</span> <span class="built_in">VideoProducer</span>();</span><br><span class="line">    <span class="comment">// 视频流生产线产出一条视频流</span></span><br><span class="line">    Stream *videoStream = videoProducer-&gt;<span class="built_in">CreateStream</span>();</span><br><span class="line">    <span class="comment">// 打印该条视频流的日志信息</span></span><br><span class="line">    videoStream-&gt;<span class="built_in">Log</span>();</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> videoStream;</span><br><span class="line">    <span class="keyword">delete</span> videoProducer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================ 生产音频流的流程 ==================== //</span></span><br><span class="line">    <span class="comment">// 工厂开设音频流生产线</span></span><br><span class="line">    StreamFactory *audioProducer = <span class="keyword">new</span> <span class="built_in">AudioProducer</span>();</span><br><span class="line">    <span class="comment">// 音频流生产线产出一条音频流</span></span><br><span class="line">    Stream *audioStream = audioProducer-&gt;<span class="built_in">CreateStream</span>();</span><br><span class="line">    <span class="comment">// 打印该条音频流的日志信息</span></span><br><span class="line">    audioStream-&gt;<span class="built_in">Log</span>();</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> audioStream;</span><br><span class="line">    <span class="keyword">delete</span> audioProducer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================ 生产字幕流的流程 ==================== //</span></span><br><span class="line">    <span class="comment">// 工厂开设字幕流生产线</span></span><br><span class="line">    StreamFactory *subtitleProducer = <span class="keyword">new</span> <span class="built_in">SubtitleProducer</span>();</span><br><span class="line">    <span class="comment">// 字幕流生产线产出一条字幕流</span></span><br><span class="line">    Stream *subtitleStream = subtitleProducer-&gt;<span class="built_in">CreateStream</span>();</span><br><span class="line">    <span class="comment">// 打印该条字幕流的日志信息</span></span><br><span class="line">    subtitleStream-&gt;<span class="built_in">Log</span>();</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> subtitleStream;</span><br><span class="line">    <span class="keyword">delete</span> subtitleProducer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建一条视频流</span><br><span class="line">创建一条音频流</span><br><span class="line">创建一条字幕流</span><br></pre></td></tr></table></figure><p>工厂方法模式的结构组成：</p><ul><li><p>抽象工厂类：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现。</p></li><li><p>具体工厂类：继承于抽象工厂，实现创建对应具体产品对象的方式。</p></li><li><p>抽象产品类：它是具体产品继承的父类（基类）。</p></li><li><p>具体产品类：具体工厂所创建的对象，就是此类。</p></li></ul><p>工厂方法模式的特点：</p><ul><li>工厂方法模式抽象出了工厂类，提供创建具体产品的接口，交由子类去实现。</li><li>工厂方法模式的应用并不只是为了封装具体产品对象的创建，而是要把具体产品对象的创建放到具体工厂类实现。</li></ul><p>工厂方法模式的缺陷：</p><ul><li>每新增一个产品，就需要增加一个对应的产品的具体工厂类。相比简单工厂模式而言，工厂方法模式需要更多的类定义。</li><li>一条生产线只能一个产品。</li></ul><h2 id="抽象工厂模式（Abstract-Factory）"><a href="#抽象工厂模式（Abstract-Factory）" class="headerlink" title="抽象工厂模式（Abstract Factory）"></a>抽象工厂模式（Abstract Factory）</h2><p>对于一个StreamFactory,我们除了能创建出对应种类的流以外,还需要能创建出一个用于存放流信息的对象,这里就需要用到抽象工厂模式（Abstract Factory）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//流的抽象类（基类）,接口函数为Log()，用于打印日志信息</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stream</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Stream</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Log</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//流信息的抽象类（基类）,接口函数为GetStreamInfo()，用于获得流信息</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StreamInformation</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">StreamInformation</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Log</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下为具体流的的类，分别是视频、音频和字幕的流</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//视频流</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoStream</span> : <span class="keyword">public</span> Stream</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建一条视频流&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoStreamInformation</span> : <span class="keyword">public</span> StreamInformation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建一个存放当前视频流信息的结构体对象&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 音频流</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioStream</span> : <span class="keyword">public</span> Stream</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建一条音频流&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioStreamInformation</span> : <span class="keyword">public</span> StreamInformation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建一个存放当前音频流信息的结构体对象&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字幕流</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubtitleStream</span> : <span class="keyword">public</span> Stream</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建一条字幕流&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubtitleStreamInformation</span> : <span class="keyword">public</span> StreamInformation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建一个存放当前字幕流信息的结构体对象&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象工厂类(StreamFactory)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StreamFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Stream *<span class="title">CreateStream</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> StreamInformation *<span class="title">CreateStreamInformation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">StreamFactory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视频流生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoProducer</span> : <span class="keyword">public</span> StreamFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Stream *<span class="title">CreateStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">VideoStream</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">StreamInformation *<span class="title">CreateStreamInformation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">VideoStreamInformation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 音频流生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioProducer</span> : <span class="keyword">public</span> StreamFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Stream *<span class="title">CreateStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AudioStream</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">StreamInformation *<span class="title">CreateStreamInformation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AudioStreamInformation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字幕流生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubtitleProducer</span> : <span class="keyword">public</span> StreamFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Stream *<span class="title">CreateStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SubtitleStream</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">StreamInformation *<span class="title">CreateStreamInformation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SubtitleStreamInformation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ================ 生产视频流的流程 ==================== //</span></span><br><span class="line">    <span class="comment">// 开设视频流生产线</span></span><br><span class="line">    StreamFactory *videoProducer = <span class="keyword">new</span> <span class="built_in">VideoProducer</span>();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 生产线产出视频流</span></span><br><span class="line">    Stream *videoStream = videoProducer-&gt;<span class="built_in">CreateStream</span>();</span><br><span class="line"><span class="comment">// 生产线产出一个存放视频流信息的结构体</span></span><br><span class="line">    StreamInformation *videoStreamInformation = videoStream-&gt;<span class="built_in">CreateStreamInformation</span>();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 打印:&quot;创建一条视频流&quot;</span></span><br><span class="line">    videoStream-&gt;<span class="built_in">Log</span>();</span><br><span class="line"><span class="comment">// 打印:&quot;创建一个存放当前字幕流信息的结构体对象&quot;</span></span><br><span class="line">    videoStreamInformation-&gt;<span class="built_in">Log</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> videoStream;</span><br><span class="line"><span class="keyword">delete</span> videoStreamInformation;</span><br><span class="line">    <span class="keyword">delete</span> videoProducer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...............//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建一条视频流</span><br><span class="line">创建一个存放当前字幕流信息的结构体对象</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="扩展-模板工厂"><a href="#扩展-模板工厂" class="headerlink" title="扩展(模板工厂)"></a>扩展(模板工厂)</h2><p>以上三种工厂模式，在新增流的种类时，都存在一定的缺陷。</p><p>简单工厂模式:需要去修改工厂类，这违背了开闭法则。<br>工厂方式模式和抽象工厂模式，都需要增加一个对应的产品的具体工厂类，这就会增大了代码的编写量。<br>那么有什么好的方法，在新增流种类的时候，即不用修改工厂类，也不用新增具体的工厂类？<br>这就需要用到模板工厂:</p><ul><li>AbstractStreamFactory为抽象模板工厂类，其中模板参数：AbstractProduct_t为抽象类(如StreamInformation、Stream)</li><li>ConcreteStreamFactory为具体模板工厂类，其中模板参数：AbstractProduct_t抽象类（如StreamInformation、Stream），ConcreteProduct_t具体类(如VideoStream、VideoStreamInformation、AudioStream、AudioStreamInformation、SubtitleStream、SubtitleStreamInformation)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象模板工厂类</span></span><br><span class="line"><span class="comment">// 模板参数：AbstractProduct_t 产品抽象类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">AbstractProduct_t</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractStreamFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProduct_t *<span class="title">CreateProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractStreamFactory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体模板工厂类</span></span><br><span class="line"><span class="comment">// 模板参数：AbstractProduct_t 产品抽象类，ConcreteProduct_t 产品具体类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">AbstractProduct_t</span>, <span class="keyword">class</span> <span class="title class_">ConcreteProduct_t</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStreamFactory</span> : <span class="keyword">public</span> AbstractStreamFactory&lt;AbstractProduct_t&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">AbstractProduct_t *<span class="title">CreateProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProduct_t</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构造视频流的工厂对象</span></span><br><span class="line">    ConcreteStreamFactory&lt;Stream, VideoStream&gt; videoStreamFactory;</span><br><span class="line">    <span class="comment">//创建视频流对象</span></span><br><span class="line">    Stream *pVideoStream = videoStreamFactory.<span class="built_in">CreateProduct</span>();</span><br><span class="line">    <span class="comment">//打印:&quot;创建一条视频流&quot;</span></span><br><span class="line">    pVideoStream-&gt;<span class="built_in">Log</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造字幕流信息的工厂对象</span></span><br><span class="line">    ConcreteStreamFactory&lt;StreamInformation, SubtitleStreamInformation&gt; subtitleStreamInformationFactory;</span><br><span class="line">    <span class="comment">//创建字幕流的信息存储对象</span></span><br><span class="line">    StreamInformation *pSubtitleStreamInformation = subtitleStreamInformationFactory.<span class="built_in">CreateProduct</span>();</span><br><span class="line">    <span class="comment">//打印:&quot;创建一个存放当前字幕流信息的结构体对象&quot;</span></span><br><span class="line">    pSubtitleStreamInformation-&gt;<span class="built_in">Log</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> pSubtitleStreamInformation;</span><br><span class="line">    pSubtitleStreamInformation = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pVideoStream;</span><br><span class="line">    pVideoStream = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">创建一条视频流</span><br><span class="line">创建一个存放当前字幕流信息的结构体对象</span><br></pre></td></tr></table></figure><p>前面的模板工厂虽然在新增流的种类的时候，不需要新增具体的工厂类，但是缺少一个可以统一随时随地获取指定的流对象的类。</p><p>还有改进的空间，我们可以把产品注册的对象用std::map的方式保存，通过key-valve的方式可以轻松简单的获取对应的产品对象实例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类，产品注册模板接口类</span></span><br><span class="line"><span class="comment">// 模板参数 ProductType_t 表示的类是产品抽象类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ProductType_t</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IProductRegistrar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 获取产品对象抽象接口</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> ProductType_t *<span class="title">CreateProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="comment">// 禁止外部构造和虚构, 子类的&quot;内部&quot;的其他函数可以调用</span></span><br><span class="line">   <span class="built_in">IProductRegistrar</span>() &#123;&#125;</span><br><span class="line">   <span class="keyword">virtual</span> ~<span class="built_in">IProductRegistrar</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="comment">// 禁止外部拷贝和赋值操作</span></span><br><span class="line">   <span class="built_in">IProductRegistrar</span>(<span class="type">const</span> IProductRegistrar &amp;);</span><br><span class="line">   <span class="type">const</span> IProductRegistrar &amp;<span class="keyword">operator</span>=(<span class="type">const</span> IProductRegistrar &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂模板类，用于获取和注册产品对象</span></span><br><span class="line"><span class="comment">// 模板参数 ProductType_t 表示的类是产品抽象类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ProductType_t</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 获取工厂单例，工厂的实例是唯一的</span></span><br><span class="line">   <span class="function"><span class="type">static</span> ProductFactory&lt;ProductType_t&gt; &amp;<span class="title">Instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="type">static</span> ProductFactory&lt;ProductType_t&gt; instance;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 产品注册</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">RegisterProduct</span><span class="params">(IProductRegistrar&lt;ProductType_t&gt; *registrar, std::string name)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      m_ProductRegistry[name] = registrar;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 根据名字name，获取对应具体的产品对象</span></span><br><span class="line">   <span class="function">ProductType_t *<span class="title">GetProduct</span><span class="params">(std::string name)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="comment">// 从map找到已经注册过的产品，并返回产品对象</span></span><br><span class="line">      <span class="keyword">if</span> (m_ProductRegistry.<span class="built_in">find</span>(name) != m_ProductRegistry.<span class="built_in">end</span>())</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">return</span> m_ProductRegistry[name]-&gt;<span class="built_in">CreateProduct</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 未注册的产品，则报错未找到</span></span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;No product found for &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="comment">// 禁止外部构造和虚构</span></span><br><span class="line">   <span class="built_in">ProductFactory</span>() &#123;&#125;</span><br><span class="line">   ~<span class="built_in">ProductFactory</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 禁止外部拷贝和赋值操作</span></span><br><span class="line">   <span class="built_in">ProductFactory</span>(<span class="type">const</span> ProductFactory &amp;);</span><br><span class="line">   <span class="type">const</span> ProductFactory &amp;<span class="keyword">operator</span>=(<span class="type">const</span> ProductFactory &amp;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 保存注册过的产品，key:产品名字 , value:产品类型</span></span><br><span class="line">   std::map&lt;std::string, IProductRegistrar&lt;ProductType_t&gt; *&gt; m_ProductRegistry;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品注册模板类，用于创建具体产品和从工厂里注册产品</span></span><br><span class="line"><span class="comment">// 模板参数 ProductType_t 表示的类是产品抽象类（基类），ProductImpl_t 表示的类是具体产品（产品种类的子类）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ProductType_t</span>, <span class="keyword">class</span> <span class="title class_">ProductImpl_t</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductRegistrar</span> : <span class="keyword">public</span> IProductRegistrar&lt;ProductType_t&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 构造函数，用于注册产品到工厂，只能显示调用</span></span><br><span class="line">   <span class="function"><span class="keyword">explicit</span> <span class="title">ProductRegistrar</span><span class="params">(std::string name)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="comment">// 通过工厂单例把产品注册到工厂</span></span><br><span class="line">      ProductFactory&lt;ProductType_t&gt;::<span class="built_in">Instance</span>().<span class="built_in">RegisterProduct</span>(<span class="keyword">this</span>, name);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建具体产品对象指针</span></span><br><span class="line">   <span class="function">ProductType_t *<span class="title">CreateProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductImpl_t</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// ========================== 生产视频流的过程 ===========================//</span></span><br><span class="line">   <span class="comment">// 注册产品种类为Stream（基类），产品为VideoStream（子类）到工厂，产品名为vidStream</span></span><br><span class="line">   <span class="function">ProductRegistrar&lt;Stream, VideoStream&gt; <span class="title">videoStream</span><span class="params">(<span class="string">&quot;vidStream&quot;</span>)</span></span>;</span><br><span class="line">   <span class="comment">// 从工厂获取产品种类为Stream，名称为vidStream的产品对象</span></span><br><span class="line">   Stream *pVideoStream = ProductFactory&lt;Stream&gt;::<span class="built_in">Instance</span>().<span class="built_in">GetProduct</span>(<span class="string">&quot;vidStream&quot;</span>);</span><br><span class="line">   <span class="comment">//打印:&quot;创建一条视频流&quot;</span></span><br><span class="line">   pVideoStream-&gt;<span class="built_in">Log</span>();</span><br><span class="line">   <span class="comment">// 释放资源</span></span><br><span class="line">   <span class="keyword">if</span> (pVideoStream)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">delete</span> pVideoStream;</span><br><span class="line">      pVideoStream = <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ========================== 生产字幕流的信息存储对象的过程 ===========================//</span></span><br><span class="line">   <span class="comment">// 注册产品种类为StreamInformation（基类），产品为SubtitleStreamInformation（子类）到工厂，产品名为SubInfo</span></span><br><span class="line">   <span class="function">ProductRegistrar&lt;StreamInformation, SubtitleStreamInformation&gt; <span class="title">adidasShoes</span><span class="params">(<span class="string">&quot;SubInfo&quot;</span>)</span></span>;</span><br><span class="line">   <span class="comment">// 从工厂获取产品种类为StreamInformation，名称为SubInfo的产品对象</span></span><br><span class="line">   StreamInformation *pSubtitleStreamInformation = ProductFactory&lt;StreamInformation&gt;::<span class="built_in">Instance</span>().<span class="built_in">GetProduct</span>(<span class="string">&quot;SubInfo&quot;</span>);</span><br><span class="line">   <span class="comment">//打印:&quot;创建一个存放当前字幕流信息的结构体对象&quot;</span></span><br><span class="line">   pSubtitleStreamInformation-&gt;<span class="built_in">Show</span>();</span><br><span class="line">   <span class="comment">// 释放资源</span></span><br><span class="line">   <span class="keyword">if</span> (pSubtitleStreamInformation)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">delete</span> pSubtitleStreamInformation;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结<br>将工厂方法模式改良成模板工厂，虽然可以解决产品新增时，不需要新增具体工厂类，但是缺少一个可以随时随地获取产品对象的方式，说明还有改进的空间。</p><p>将模板工厂改良成产品注册模板类+单例工厂模板类，产品注册模板类用于注册不同类型的产品，单例工厂模板类用于获取指定已注册的产品对象。这种方式，可以把工厂模式中产品的注册和获取的主要功能很好的抽象成两个类，并且使用单例模式使得工厂类可以随时随地获取已注册的产品对象。</p><p>所以产品注册模板类+单例工厂模板类的工厂模式，达到了开闭法则，并且扩展性高和封装度高。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习笔记</title>
      <link href="/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h1><p>设计模式分为以下三种类型:</p><ul><li>创建型</li><li>结构型</li><li>行为型</li></ul><p>其中:</p><h2 id="创建型设计模式包括"><a href="#创建型设计模式包括" class="headerlink" title="创建型设计模式包括:"></a>创建型设计模式包括:</h2><ul><li>简单工厂模式（Simple Factory）</li><li>工厂方法模式（Factory Method）</li><li>抽象工厂模式（Abstract Factory）</li><li>建造者模式</li><li>原型模式（Prototype）</li><li>单例模式（Singleton）</li></ul><h2 id="结构型设计模式包括"><a href="#结构型设计模式包括" class="headerlink" title="结构型设计模式包括:"></a>结构型设计模式包括:</h2><ul><li>适配器模式（Adapter）</li><li>桥梁模式（Bridge）</li><li>组合模式（Composite）</li><li>装饰模式（Decorator）</li><li>门面模式（Facade）</li><li>享元模式（Flyweight）</li><li>代理模式（Proxy）</li></ul><h2 id="行为型设计模式包括"><a href="#行为型设计模式包括" class="headerlink" title="行为型设计模式包括:"></a>行为型设计模式包括:</h2><ul><li>责任链模式（Chain Of Responsibilities）</li><li>命令行模式（Command）</li><li>迭代器模式（Iterator）</li><li>中介者模式（Mediator）</li><li>备忘录模式（Memento）</li><li>观察者模式（Observer）</li><li>访问者模式（Visitor）</li><li>策略模式（Strategy）</li><li>状态模式（State）</li><li>模板方法模式（Template Method）</li></ul><p>由于市面上关于设计模式的教程基本上都是用java语言编写的教学样例,因此我打算以C++语言编写样例来学习设计模式,这样也方便后续在工作中用到的话直接拿来修改使用.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编译Linux版本OpenCV的具体步骤</title>
      <link href="/2023/04/19/Ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91Linux%E7%89%88%E6%9C%ACOpenCV%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/"/>
      <url>/2023/04/19/Ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91Linux%E7%89%88%E6%9C%ACOpenCV%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步：更新apt-get"><a href="#第一步：更新apt-get" class="headerlink" title="第一步：更新apt-get"></a>第一步：更新apt-get</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h2 id="第二步：下载源代码"><a href="#第二步：下载源代码" class="headerlink" title="第二步：下载源代码"></a>第二步：下载源代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/opencv/opencv.git</span><br><span class="line">git clone https://github.com/opencv/opencv_contrib.git</span><br></pre></td></tr></table></figure><p>如果clone速度很糟糕的话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#原地址</span><br><span class="line">git clone https://github.com/opencv/opencv.git</span><br><span class="line">#改为</span><br><span class="line">git clone https://github.com.cnpmjs.org/opencv/opencv.git</span><br><span class="line">#或者</span><br><span class="line">git clone https://hub.fastgit.org/opencv/opencv.git</span><br><span class="line">#或者</span><br><span class="line">git clone https://gitclone.com/github.com/opencv/opencv.git</span><br></pre></td></tr></table></figure><p>其中：下载OpenCV_contrib的原因是：<br> OpenCV3.0以上的版本，把一些不稳定的函数放到了第三方库OpenCV_contrib中（比如sift,surf等），为了应用这些功能，我们需要通过CMake把OpenCV_contrib中的功能重新加入到OpenCV中。</p><p>等待下载完源代码后，在opencv文件夹中新建两个文件夹build和install<br><img src="/./picture/Ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91Linux%E7%89%88%E6%9C%ACOpenCV%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/1.png"><br>接着将opencv_contrib文件夹复制到opencv文件夹中<br><img src="/./picture/Ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91Linux%E7%89%88%E6%9C%ACOpenCV%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/2.png"></p><h2 id="第三部：安装官方给的opencv依赖包"><a href="#第三部：安装官方给的opencv依赖包" class="headerlink" title="第三部：安装官方给的opencv依赖包"></a>第三部：安装官方给的opencv依赖包</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</span><br><span class="line">sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</span><br></pre></td></tr></table></figure><p>如果出现以下报错，不需要理会：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">没有可用的软件包 python-dev，但是它被其它的软件包引用了。</span><br><span class="line">这可能意味着这个缺失的软件包可能已被废弃，</span><br><span class="line">或者只能在其他发布源中找到</span><br><span class="line">然而下列软件包会取代它：</span><br><span class="line">  python2-dev:i386 python2:i386 python2-dev python2 python-dev-is-python3</span><br><span class="line"></span><br><span class="line">E: 软件包 python-dev 没有可安装候选</span><br><span class="line">E: 无法定位软件包 python-numpy</span><br><span class="line">E: 无法定位软件包 libjasper-dev</span><br><span class="line">E: 无法定位软件包 libdc1394-22-dev</span><br></pre></td></tr></table></figure><h2 id="第四步：下载一下Cmake的GUI软件"><a href="#第四步：下载一下Cmake的GUI软件" class="headerlink" title="第四步：下载一下Cmake的GUI软件"></a>第四步：下载一下Cmake的GUI软件</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install cmake-qt-gui</span><br></pre></td></tr></table></figure><p> 等待下载完成后打开它opencv安装的路径<br> <img src="/./picture/Ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91Linux%E7%89%88%E6%9C%ACOpenCV%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/3.png"></p><p> 勾选Grouped，接着点击左下方的Configure按钮，选择Unix Makefiles，选择Use default native compilers（默认），然后点击Finish<br>  <img src="/./picture/Ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91Linux%E7%89%88%E6%9C%ACOpenCV%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/4.png"></p><h2 id="第五步：修改Cmake配置信息"><a href="#第五步：修改Cmake配置信息" class="headerlink" title="第五步：修改Cmake配置信息"></a>第五步：修改Cmake配置信息</h2><p>在CMAKE_BUILD_TYPE 值处输入RELEASE<br>  <img src="/./picture/Ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91Linux%E7%89%88%E6%9C%ACOpenCV%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/5.png"></p><p>在CMAKE_INSTALL_PREFIX值处输入之前创建的install文件夹路径<br>  <img src="/./picture/Ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91Linux%E7%89%88%E6%9C%ACOpenCV%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/6.png"></p><p>在OPENCV_EXTRA_MODULES_PATH处，添加opencv_contrib文件夹下的modules文件夹的路径<br> <img src="/./picture/Ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91Linux%E7%89%88%E6%9C%ACOpenCV%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/7.png"><br>注：OPENCV_EXTRA_MODULES_PATH 是用来指定要编译的扩展模块，其中包括OpenCV_contrib模块。</p><p>接着勾选OPENCV_GENERATE_PKGCONFIG</p><p>最后点击Generate生成配置文件</p><h2 id="第六步：编译源代码"><a href="#第六步：编译源代码" class="headerlink" title="第六步：编译源代码"></a>第六步：编译源代码</h2><p>接着，进入到opencv的build目录下打开终端，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>如果想让编译的速度快一点可以查看一下电脑配置，通过make的-j命令（加速Linux程序编译），比如我的电脑可以开到20</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j 20</span><br></pre></td></tr></table></figure><p>等待make运行结束后，再输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="第六步：配置环境变量"><a href="#第六步：配置环境变量" class="headerlink" title="第六步：配置环境变量"></a>第六步：配置环境变量</h2><p>在命令行窗口输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/ld.so.conf.d/opencv.conf</span><br></pre></td></tr></table></figure><p>将以下内容添加进去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/ws/桌面/Git_OpenCV/opencv/install</span><br></pre></td></tr></table></figure><p><img src="/./picture/Ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91Linux%E7%89%88%E6%9C%ACOpenCV%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/8.png"></p><p>接着输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p>我们在这个文件夹中可以看到这个.pc文件：<br><img src="/./picture/Ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91Linux%E7%89%88%E6%9C%ACOpenCV%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/10.png"></p><p>于是我们在命令行窗口再输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/bash.bashrc</span><br></pre></td></tr></table></figure><p>在文件最后面添加下面这两行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/home/ws/桌面/Git_OpenCV/opencv/install/lib/pkgconfig </span><br><span class="line">export PKG_CONFIG_PATH </span><br></pre></td></tr></table></figure><p><img src="/./picture/Ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91Linux%E7%89%88%E6%9C%ACOpenCV%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/9.png"></p><h2 id="第六步：测试"><a href="#第六步：测试" class="headerlink" title="第六步：测试"></a>第六步：测试</h2><p>最后，在任意位置打开终端运行下面这个命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --cflags --libs opencv4 </span><br></pre></td></tr></table></figure><p>就会出现下面信息：<br><img src="/./picture/Ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91Linux%E7%89%88%E6%9C%ACOpenCV%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/11.png"></p><p>此时就代表着我们之前配置的都成功了</p><p>现在我们可以跑个例子看一下<br>现在任意位置新建一个文件夹，起名叫test，然后在文件夹里面创建一个cpp文件，起名叫test.cpp，并输入以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">Rect rect;</span><br><span class="line">Point pt1;</span><br><span class="line">Point pt2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat img=<span class="built_in">imread</span>(<span class="string">&quot;1.png&quot;</span>);</span><br><span class="line">    rect.x= <span class="number">50</span>;</span><br><span class="line">    rect.y= <span class="number">50</span>;</span><br><span class="line">    rect.width= <span class="number">100</span>;</span><br><span class="line">    rect.height= <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">rectangle</span>(img,rect,<span class="built_in">Scalar</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>);<span class="comment">//用rect画矩形</span></span><br><span class="line"></span><br><span class="line">    pt1.x= <span class="number">100</span>;</span><br><span class="line">    pt1.y= <span class="number">100</span>;</span><br><span class="line">    pt2.x= <span class="number">200</span>;</span><br><span class="line">    pt2.y= <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">rectangle</span>(img,pt1,pt2,<span class="built_in">Scalar</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>);<span class="comment">//用两个点来画矩形</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;image&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;image&quot;</span>,img);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>同时去网上找张png格式照片，或者直接用系统自带的截图工具截一张图，命名为1.png放在test文件夹里面。</p><p>接着，我们用CMake编译该代码。<br>首先在test文件夹添加一个CMakeLists.txt文件，内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">project( test )  </span><br><span class="line">find_package( OpenCV REQUIRED )  </span><br><span class="line">add_executable( test test )  </span><br><span class="line">target_link_libraries( test $&#123;OpenCV_LIBS&#125; )  </span><br></pre></td></tr></table></figure><p>然后在test文件夹中打开命令行窗口，输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake .</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>其中cmake .表示在当期目录下执行cmake操作</p><p>最后点击生成的test可执行文件：<br><img src="/./picture/Ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91Linux%E7%89%88%E6%9C%ACOpenCV%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/12.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>m4a格式介绍</title>
      <link href="/2023/03/23/m4a%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/03/23/m4a%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是一-m4a-文件？"><a href="#什么是一-m4a-文件？" class="headerlink" title="什么是一.m4a 文件？"></a>什么是一.m4a 文件？</h1><p>M4A是一种用于压缩MPEG-4编码文件的扩展名。MPEG-4官方扩展名是MP4格式，它包含了音频文件及视频文件。而MP4文件中标准的音频格式无疑就是M4A了。其实M4A格式以前并不知名，直到2007年苹果公司首次用M4A与AAC、ALAC等作为iTunes及iPod歌曲收录格式，它才逐渐使用广泛起来。。M4A 一词缩写为 MPEG 4 音频。这些音频文件通常具有 .m4a 文件扩展名。对于未受保护的内容尤其如此。它可以存储各种类型的音频内容，例如有声读物、歌曲和播客。M4A 通常被认为是比 MP3 更高级的格式，而 MP3 通常不是为音频而设计的。它只是 MPEG 1 或 2 视频文件中的音频层。</p><h2 id="M4A文件功能一览"><a href="#M4A文件功能一览" class="headerlink" title="M4A文件功能一览:"></a>M4A文件功能一览:</h2><ul><li>M4A格式是不受版权保护的。一般受保护的文件多数是MP4格式。</li><li>M4A音频文件在压缩前可以解码回原始质量。</li><li>多数iTunes商店中的M4A歌曲需要付费，但是偶尔也会有特价或者赠送活动。</li><li>iTunes商店也提供除M4A外其他格式的音乐。</li><li>可以通过将M4A音乐的扩展名改为M4R后，将其设置为iPhone铃声。</li><li>它为您最大化的提供无损音质及最小化地占用您的存储空间。</li></ul><h2 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h2><ul><li>优: 虽然M4A是一种压缩后的格式，但是音频的质量是没有损耗的。另外，M4A文件是不受数字版权管理保护的，所以您可以灵活地对其进行再次编辑及传输。</li><li>劣: M4A格式可以在iTunes、iPod及其他苹果设备中完美读取。但是与MP3格式相比，它与其他品牌产品的兼容性稍逊许多。</li></ul><p><font color =red>注：M4A 格式由 FairPlay 数字版权管理加密，通过 iTunes Store 出售时使用 .m4p 扩展名。Apple iPhone 使用 MPEG-4 音频作为铃声，但这些音频文件使用 .m4r 扩展名。</font></p><h1 id="M4A与MP3区别"><a href="#M4A与MP3区别" class="headerlink" title="M4A与MP3区别"></a>M4A与MP3区别</h1><ul><li>M4A 和MP3都是纯音频文件格式。</li><li>M4A：以相同比特率编码时，在质量和大小方面优于 MP3。</li><li>.m4a 文件扩展名非常常见，因为它们已被 Apple 用于 iTunes Music Store。</li><li>M4A 是使用 MPEG-4 技术压缩的音频文件，它基本上与“MPEG-4音频层”相关联，扩展名为.m4a的文件是MPEG-4电影的音频层。它旨在超越 MP3 并成为音频压缩的新标准。它在许多方面都非常接近 MP3，但引入它以在相同甚至更小的文件大小中具有更好的质量。</li><li>M4A 格式最早由 Apple 引入。格式类型也实现为 Apple 无损编码器 (ALE)。因此，目前M4A无法获得MP3主流的成功，因为音频格式还不能普遍播放。它在某种程度上仅限于 MacOS、iPod 和其他 Apple 产品。</li><li>Mp3：最著名的数字音频格式。它也是现场最早的压缩格式之一，并在音乐爱好者中非常流行。它的主流成功是如此之快，以至于该文件类型能够被普遍播放，几乎可以用任何硬件或软件播放。一般来说，M4A会产生更好的音质，但很多人会认为，无论是真是假，声音差异是无法区分的，将MP3文件转换为M4A文件是浪费时间。最终，转换只会让你失去原来的音质。</li></ul><h1 id="M4A-文件格式规范"><a href="#M4A-文件格式规范" class="headerlink" title="M4A 文件格式规范"></a>M4A 文件格式规范</h1><p>M4A 文件由连续的块组成。每个块有 8 个字节的头，并细分为：</p><ul><li>4 字节块大小（大端，高字节优先）</li><li>4 字节块类型：“ftyp”、“mdat”、“moov”、“pnot”、“udta”、“uuid”、“moof”、“free”、“skip”、“ jP2”、”wide”、”load”、”ctab”、”imap”、”matt”、”kmat”、”clip”、”crgn”、”sync”、”chap”、”tmcd”、”scpt” ，“ssrc”，“PICT”。</li></ul><p>第一个块的类型为“ftype”，并且在偏移量 8 处有一个子类型。子类型定义的 M4A 必须是“M4A_”，对于 M4B 子类型必须是“M4B_”，对于 M4P 子类型必须是“M4P_”。</p><p>迭代块，直到检测到未知类型的块，它将组成 M4A（MPEG-4 音频）文件。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg常用命令</title>
      <link href="/2023/02/27/FFmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/02/27/FFmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="filter-complex拼接多个视频，各个视频同时播放"><a href="#filter-complex拼接多个视频，各个视频同时播放" class="headerlink" title="filter_complex拼接多个视频，各个视频同时播放"></a>filter_complex拼接多个视频，各个视频同时播放</h1><h2 id="拼接两个视频"><a href="#拼接两个视频" class="headerlink" title="拼接两个视频"></a>拼接两个视频</h2><p>1.横向拼接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out1.mp4 -i out2.mp4 -filter_complex <span class="string">&quot;[0:v]pad=iw*2:ih*1[a];[a][1:v]overlay=w&quot;</span> out.mp4</span><br><span class="line"><span class="comment">//pad是将合成的视频宽高，这里iw代表第一个视频的宽，iw*2代表合成后的视频宽度加倍，ih为第一个视频的高，合成的两个视频最好分辨率一致。overlay是覆盖，[a][1:v]overlay=w，后面代表是覆盖位置w:0</span></span><br></pre></td></tr></table></figure><p>2.竖屏拼接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out1.mp4 -i out2.mp4 -filter_complex <span class="string">&quot;[0:v]pad=iw:ih*2[a];[a][1:v]overlay=0:h&quot;</span> out.mp4</span><br></pre></td></tr></table></figure><h2 id="三个视频拼接"><a href="#三个视频拼接" class="headerlink" title="三个视频拼接"></a>三个视频拼接</h2><p>1.横向拼接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out1.mp4 -i out2.mp4 -i out3.mp4 -filter_complex <span class="string">&quot;[0:v]pad=iw*3:ih*1[a];[a][1:v]overlay=w[b];[b][2:v]overlay=2.0*w&quot;</span> out.mp4 </span><br></pre></td></tr></table></figure><p>2.竖向拼接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out1.mp4 -i out2.mp4 -i out3.mp4 -filter_complex <span class="string">&quot;[0:v]pad=iw:ih*3[a];[a][1:v]overlay=0:h[b];[b][2:v]overlay=0:2.0*h&quot;</span> out.mp4</span><br></pre></td></tr></table></figure><h2 id="四个视频2x2方式排列"><a href="#四个视频2x2方式排列" class="headerlink" title="四个视频2x2方式排列"></a>四个视频2x2方式排列</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out1.mp4 -i out2.mp4 -i out3.mp4 -i out4.mp4 -filter_complex <span class="string">&quot;[0:v]pad=iw*2:ih*2[a];[a][1:v]overlay=w[b];[b][2:v]overlay=0:h[c];[c][3:v]overlay=w:h&quot;</span> out.mp4</span><br></pre></td></tr></table></figure><p>一、mp4转nv12<br>&#x2F;&#x2F;将mp4转成nv12(yuv420)</p><h1 id="ffmpeg-i-input-mp4-an-pix-fmt-nv12-s-1920x1080-output-yuv"><a href="#ffmpeg-i-input-mp4-an-pix-fmt-nv12-s-1920x1080-output-yuv" class="headerlink" title="ffmpeg -i input.mp4 -an -pix_fmt nv12 -s 1920x1080 output.yuv"></a>ffmpeg -i input.mp4 -an -pix_fmt nv12 -s 1920x1080 output.yuv</h1><p>&#x2F;&#x2F;播放nv12</p><h1 id="ffplay-video-size-1920x1080-pixel-format-nv12-output-yuv"><a href="#ffplay-video-size-1920x1080-pixel-format-nv12-output-yuv" class="headerlink" title="ffplay -video_size 1920x1080 -pixel_format nv12 output.yuv"></a>ffplay -video_size 1920x1080 -pixel_format nv12 output.yuv</h1><p>二、yuv与yuv相互转换<br>1.nv12转nv21</p><h1 id="ffmpeg-pix-fmt-nv12-s-1920x1080-i-nv12-yuv-pix-fmt-nv21-nv21-yuv"><a href="#ffmpeg-pix-fmt-nv12-s-1920x1080-i-nv12-yuv-pix-fmt-nv21-nv21-yuv" class="headerlink" title="ffmpeg -pix_fmt nv12 -s 1920x1080 -i nv12.yuv -pix_fmt nv21 nv21.yuv"></a>ffmpeg -pix_fmt nv12 -s 1920x1080 -i nv12.yuv -pix_fmt nv21 nv21.yuv</h1><p>&#x2F;&#x2F;播放nv21</p><h1 id="ffplay-video-size-1920x1080-pixel-format-nv21-nv21-yuv"><a href="#ffplay-video-size-1920x1080-pixel-format-nv21-nv21-yuv" class="headerlink" title="ffplay -video_size 1920x1080 -pixel_format nv21 nv21.yuv"></a>ffplay -video_size 1920x1080 -pixel_format nv21 nv21.yuv</h1><p>2.nv12转YUV420P(I420)</p><h1 id="ffmpeg-pix-fmt-nv12-s-1920x1080-i-nv12-1-yuv-pix-fmt-yuv420p-I420-1-yuv"><a href="#ffmpeg-pix-fmt-nv12-s-1920x1080-i-nv12-1-yuv-pix-fmt-yuv420p-I420-1-yuv" class="headerlink" title="ffmpeg -pix_fmt nv12 -s 1920x1080 -i nv12_1.yuv -pix_fmt yuv420p I420_1.yuv"></a>ffmpeg -pix_fmt nv12 -s 1920x1080 -i nv12_1.yuv -pix_fmt yuv420p I420_1.yuv</h1><p>&#x2F;&#x2F;播放YUV420P(I420)</p><h1 id="ffplay-video-size-1920x1080-pixel-format-yuv420p-I420-1-yuv"><a href="#ffplay-video-size-1920x1080-pixel-format-yuv420p-I420-1-yuv" class="headerlink" title="ffplay -video_size 1920x1080 -pixel_format yuv420p I420_1.yuv"></a>ffplay -video_size 1920x1080 -pixel_format yuv420p I420_1.yuv</h1><p>3.nv12 1920x180转nv12 640x480截取</p><h1 id="ffmpeg-pix-fmt-nv12-s-1920x1080-i-nv12-1-yuv-s-640x480-pix-fmt-nv12-640x480-yuv"><a href="#ffmpeg-pix-fmt-nv12-s-1920x1080-i-nv12-1-yuv-s-640x480-pix-fmt-nv12-640x480-yuv" class="headerlink" title="ffmpeg -pix_fmt nv12 -s 1920x1080 -i nv12_1.yuv -s 640x480 -pix_fmt nv12 640x480.yuv"></a>ffmpeg -pix_fmt nv12 -s 1920x1080 -i nv12_1.yuv -s 640x480 -pix_fmt nv12 640x480.yuv</h1><p>4.从nv12中提取y、u、v分量</p><h1 id="ffmpeg-s-1920x1080-pix-fmt-nv12-i-nv12-1-yuv-filter-complex-‘extractplanes-x3D-y-u-v-y-u-v-’-map-‘-y-’-y-yuv-map-‘-u-’-u-yuv-map-‘-v-’-v-yuv"><a href="#ffmpeg-s-1920x1080-pix-fmt-nv12-i-nv12-1-yuv-filter-complex-‘extractplanes-x3D-y-u-v-y-u-v-’-map-‘-y-’-y-yuv-map-‘-u-’-u-yuv-map-‘-v-’-v-yuv" class="headerlink" title="ffmpeg -s 1920x1080 -pix_fmt nv12 -i nv12_1.yuv -filter_complex ‘extractplanes&#x3D;y+u+v[y][u][v]’ -map ‘[y]’ y.yuv -map ‘[u]’ u.yuv -map ‘[v]’ v.yuv"></a>ffmpeg -s 1920x1080 -pix_fmt nv12 -i nv12_1.yuv -filter_complex ‘extractplanes&#x3D;y+u+v[y][u][v]’ -map ‘[y]’ y.yuv -map ‘[u]’ u.yuv -map ‘[v]’ v.yuv</h1><p>输出y(1920x1080)、u(960x540)、v(960x540)分量分辨率，用于播放使用：<br>&lt;1&gt;.Output #0, rawvideo, to ‘y.yuv’:<br>  rawvideo (Y800 &#x2F; 0x30303859), gray, 1920x1080, q&#x3D;2-31, 414720 kb&#x2F;s, 25 fps, 25 tbn, 25 tbc</p><p>&lt;2&gt;.Output #1, rawvideo, to ‘u.yuv’:<br>  rawvideo (Y800 &#x2F; 0x30303859), gray, 960x540, q&#x3D;2-31, 103680 kb&#x2F;s, 25 fps, 25 tbn, 25 tbc</p><p>&lt;3&gt;.Output #2, rawvideo, to ‘v.yuv’:<br>   rawvideo (Y800 &#x2F; 0x30303859), gray, 960x540, q&#x3D;2-31, 103680 kb&#x2F;s, 25 fps, 25 tbn, 25 tbc</p><p>&#x2F;&#x2F;播放y分量</p><h1 id="ffplay-pix-fmt-gray-s-1920x1080-y-yuv"><a href="#ffplay-pix-fmt-gray-s-1920x1080-y-yuv" class="headerlink" title="ffplay -pix_fmt gray -s 1920x1080 y.yuv"></a>ffplay -pix_fmt gray -s 1920x1080 y.yuv</h1><p>&#x2F;&#x2F;播放u分量</p><h1 id="ffplay-pix-fmt-gray-s-960x540-u-yuv"><a href="#ffplay-pix-fmt-gray-s-960x540-u-yuv" class="headerlink" title="ffplay -pix_fmt gray -s 960x540 u.yuv"></a>ffplay -pix_fmt gray -s 960x540 u.yuv</h1><p>&#x2F;&#x2F;播放v分量</p><h1 id="ffplay-pix-fmt-gray-s-960x540-v-yuv"><a href="#ffplay-pix-fmt-gray-s-960x540-v-yuv" class="headerlink" title="ffplay -pix_fmt gray -s 960x540 v.yuv"></a>ffplay -pix_fmt gray -s 960x540 v.yuv</h1><p>5.提取yuv中的y、u、v分量播放</p><h1 id="ffplay-s-1280x720-pix-fmt-nv12-vf-extractplanes-x3D-’y’-out-yuv"><a href="#ffplay-s-1280x720-pix-fmt-nv12-vf-extractplanes-x3D-’y’-out-yuv" class="headerlink" title="ffplay -s 1280x720 -pix_fmt nv12 -vf extractplanes&#x3D;’y’ out.yuv"></a>ffplay -s 1280x720 -pix_fmt nv12 -vf extractplanes&#x3D;’y’ out.yuv</h1><h1 id="ffplay-s-1280x720-pix-fmt-nv12-vf-extractplanes-x3D-’u’-out-yuv"><a href="#ffplay-s-1280x720-pix-fmt-nv12-vf-extractplanes-x3D-’u’-out-yuv" class="headerlink" title="ffplay -s 1280x720 -pix_fmt nv12 -vf extractplanes&#x3D;’u’ out.yuv"></a>ffplay -s 1280x720 -pix_fmt nv12 -vf extractplanes&#x3D;’u’ out.yuv</h1><h1 id="ffplay-s-1280x720-pix-fmt-nv12-vf-extractplanes-x3D-’v’-out-yuv"><a href="#ffplay-s-1280x720-pix-fmt-nv12-vf-extractplanes-x3D-’v’-out-yuv" class="headerlink" title="ffplay -s 1280x720 -pix_fmt nv12 -vf extractplanes&#x3D;’v’ out.yuv"></a>ffplay -s 1280x720 -pix_fmt nv12 -vf extractplanes&#x3D;’v’ out.yuv</h1><p>三、从yuv数据中提取N帧视频<br>&lt;1&gt;.从NV12中提取30帧yuv数据</p><h1 id="ffmpeg-s-1920x1080-pix-fmt-nv12-i-nv12-yuv-c-v-rawvideo-filter-v-select-x3D-”gt-n-1-”-vframes-30-out30-yuv"><a href="#ffmpeg-s-1920x1080-pix-fmt-nv12-i-nv12-yuv-c-v-rawvideo-filter-v-select-x3D-”gt-n-1-”-vframes-30-out30-yuv" class="headerlink" title="ffmpeg -s 1920x1080 -pix_fmt nv12 -i nv12.yuv -c:v rawvideo -filter:v select&#x3D;”gt(n, -1)” -vframes 30 out30.yuv"></a>ffmpeg -s 1920x1080 -pix_fmt nv12 -i nv12.yuv -c:v rawvideo -filter:v select&#x3D;”gt(n, -1)” -vframes 30 out30.yuv</h1><h1 id="ffplay-video-size-1920x1080-pixel-format-nv12-out30-yuv"><a href="#ffplay-video-size-1920x1080-pixel-format-nv12-out30-yuv" class="headerlink" title="ffplay -video_size 1920x1080 -pixel_format nv12 out30.yuv"></a>ffplay -video_size 1920x1080 -pixel_format nv12 out30.yuv</h1><p>&lt;2&gt;.从NV12中提取1帧yuv数据</p><h1 id="ffmpeg-s-1920x1080-pix-fmt-nv12-i-nv12-yuv-c-v-rawvideo-filter-v-select-x3D-”gt-n-1-”-vframes-1-out-01-yuv"><a href="#ffmpeg-s-1920x1080-pix-fmt-nv12-i-nv12-yuv-c-v-rawvideo-filter-v-select-x3D-”gt-n-1-”-vframes-1-out-01-yuv" class="headerlink" title="ffmpeg -s 1920x1080 -pix_fmt nv12 -i nv12.yuv -c:v rawvideo -filter:v select&#x3D;”gt(n, -1)” -vframes 1 out_01.yuv"></a>ffmpeg -s 1920x1080 -pix_fmt nv12 -i nv12.yuv -c:v rawvideo -filter:v select&#x3D;”gt(n, -1)” -vframes 1 out_01.yuv</h1><h1 id="ffplay-video-size-1920x1080-pixel-format-nv12-out-01-yuv"><a href="#ffplay-video-size-1920x1080-pixel-format-nv12-out-01-yuv" class="headerlink" title="ffplay -video_size 1920x1080 -pixel_format nv12 out_01.yuv"></a>ffplay -video_size 1920x1080 -pixel_format nv12 out_01.yuv</h1><p>输入为webm文件:<br>.&#x2F;ffmpeg  -c:v libvpx -i .&#x2F;input.webm   -vcodec vp8 -auto-alt-ref 0 -vf scale&#x3D;”trunc(iw&#x2F;2&#x2F;2)*2:trunc(ih&#x2F;2&#x2F;2)*2” -acodec copy .&#x2F;output.webm<br>如果失败：尝试用vp9解码：<br>.&#x2F;ffmpeg  -c:v libvpx-vp9 -i .&#x2F;input.webm   -vcodec vp8 -auto-alt-ref 0 -vf scale&#x3D;”trunc(iw&#x2F;2&#x2F;2)*2:trunc(ih&#x2F;2&#x2F;2)*2” -acodec copy .&#x2F;output.webm<br>如果还是失败：<br>.&#x2F;ffmpeg -i .&#x2F;input.webm   -vcodec vp8 -auto-alt-ref 0 -vf scale&#x3D;”trunc(iw&#x2F;2&#x2F;2)*2:trunc(ih&#x2F;2&#x2F;2)*2” -acodec copy .&#x2F;output.webm</p><p>输入为mp4视频：<br>.&#x2F;ffmpeg -i .&#x2F;input.mp4 -vcodec libx264 -crf 28 -coder 1 -refs 5 -me_method umh -subq 9 -me_range 32 -trellis 2 -chromaoffset -2 -bf 2 -b_strategy 1 -g 100 -i_qfactor 1.3 -b_qfactor 1.4 -x264opts bframes&#x3D;5:b-adapt&#x3D;2:ref&#x3D;5 -vf scale&#x3D;”trunc(iw&#x2F;2&#x2F;2)*2:trunc(ih&#x2F;2&#x2F;2)*2” -acodec copy .&#x2F;outputmp4</p><p>输入为flv文件：<br>.&#x2F;ffmpeg -i .&#x2F;xxx.flv -vcodec vp8 -auto-alt-ref 0 -vf scale&#x3D;”trunc(iw&#x2F;2&#x2F;2)*2:trunc(ih&#x2F;2&#x2F;2)*2” -acodec copy .&#x2F;output.webm  转完后再把output.webm手动改成output.flv</p><p>1个视频流 + 1个音频流 合成一段视频：<br>-i F:\ffmpegx64\output.mp4 -i C:\Users\ws\Downloads\沙一汀EL+-+脱离.mp3 -map 0:v:0 -map 1:a:0 -c:v copy -c:a copy 112.mp4</p><p>从1个视频中抽取出 视频流  和 音频流：<br>ffmpeg -i 112.mp4 -c:v copy -an output_video.mp4 -c:a libmp3lame -q:a 4 output_audio.mp3</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg中时间基与时间戳的详解</title>
      <link href="/2023/02/18/FFmpeg%E4%B8%AD%E6%97%B6%E9%97%B4%E5%9F%BA%E4%B8%8E%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/02/18/FFmpeg%E4%B8%AD%E6%97%B6%E9%97%B4%E5%9F%BA%E4%B8%8E%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>首先在讲解时间基之前，需要大家了解以下两个知识点：</p><ul><li>Ｉ帧，P帧，B帧指的是什么？</li><li>什么是GOP？</li><li>什么是PTS和DTS?</li></ul><h2 id="I帧，P帧，B帧指的是什么？"><a href="#I帧，P帧，B帧指的是什么？" class="headerlink" title="Ｉ帧，P帧，B帧指的是什么？"></a>Ｉ帧，P帧，B帧指的是什么？</h2><p>Ｉ帧一般也叫关键帧，属于帧内编码帧，特点是包含了一张图像的完整信息，这些信息不包含运动矢量，因此在解码的时候不需要去参考其他的帧来进行解码操作；同时我们平时使用播放器进行seek操作的时，为了保证图片的完整显示，其实是不是seek到指定的这个时间点位置的，而是seek到该时间点附近的I帧上，这样就能有效的避免seek的点为B帧或P帧所造成的当前画面花屏残缺的现象（至于是寻找该Seek帧还是之后的I帧，这就取决于你在调用FFmpeg的av_seek_frame函数的第三个参数所设置的策略了，一般设置为AVSEEK_FLAG_BACKWARD），切换视频轨道同样也是这个道理．</p><p>由于I帧具备不需要参考其他帧进行解码的这一特点．因此I帧越多就越能有效的阻止误差的累积和扩散。<br>在闭合式GOP中，每个GOP的第一个帧一定是I帧，且当前GOP的数据不会参考前后GOP的数据。</p><p>P帧：一般也叫向前预测编码帧，属于帧间编码帧，特点是并未完整的包含一帧画面的所有信息，而是利用之前的I帧或P帧进行预测编码</p><p>B帧：也叫双向预测编码图像帧，属于帧间编码帧，特点是并未完整的包含一帧画面的所有信息，而是利用之前和之后的I帧或P帧进行双向预测编码。B帧不可以作为参考帧（也就是说B帧不能被其他I&#x2F;P&#x2F;B帧所参考，只能是B帧去参考其他I&#x2F;P帧）。<br>同时B帧比I帧或者帧具有更高的压缩率，但需要更多的缓冲时间以及更高的CPU占用率，因此B帧适合本地存储以及视频点播，而不适用对实时性要求较高的直播系统。</p><p>举例：<br>采集顺序：IBBPBBIPBP<br>解码顺序：IPBBIBBPBP</p><h2 id="什么是GOP？"><a href="#什么是GOP？" class="headerlink" title="什么是GOP？"></a>什么是GOP？</h2><p>在视频编码序列中，GOP即Group of picture（图像组），指两个I帧之间的距离，Reference（参考周期）指两个P帧之间的距离。</p><p>一个I帧所占用的字节数大于一个P帧，一个P帧所占用的字节数大于一个B帧。所以在码率不变的前提下，GOP值越大，P、B帧的数量会越多，平均每个I、P、B帧所占用的字节数就越多，也就更容易获取较好的图像质量；Reference越大，B帧的数量越多，同理也更容易获得较好的图像质量。</p><p>需要说明的是，通过提高GOP值来提高图像质量是有限度的，在遇到场景切换的情况时，H.264编码器会自动强制插入一个I帧，此时实际的GOP值被缩短了。另一方面，在一个GOP中，P、B帧是由I帧预测得到的，当I帧的图像质量比较差时，会影响到一个GOP中后续P、B帧的图像质量，直到下一个GOP开始才有可能得以恢复，所以GOP值也不宜设置过大。</p><p>同时，由于P、B帧的复杂度大于I帧，所以过多的P、B帧会影响编码效率，使编码效率降低。另外，过长的GOP还会影响Seek操作的响应速度，由于P、B帧是由前面的I或P帧预测得到的，所以Seek操作需要直接定位，解码某一个P或B帧时，需要先解码得到本GOP内的I帧及之前的N个预测帧才可以，GOP值越长，需要解码的预测帧就越多，seek响应的时间也越长。</p><h2 id="什么是PTS和DTS"><a href="#什么是PTS和DTS" class="headerlink" title="什么是PTS和DTS?"></a>什么是PTS和DTS?</h2><p>DTS(Decoding Time Stamp, 解码时间戳)，表示压缩帧的解码时间。<br>PTS(Presentation Time Stamp, 显示时间戳)，表示将压缩帧解码后得到的原始帧后，在我们的屏幕设备上的显示时间。</p><p>需要注意的是：音频中DTS和PTS是相同的。视频中由于B帧需要参考其他的I&#x2F;P帧进行双向预测编码，因此含B帧的视频解码顺序与显示顺序不同，即DTS与PTS不同（不含B帧的视频，其DTS和PTS是相同的）。</p><h1 id="FFmpeg-中的时间基与时间戳"><a href="#FFmpeg-中的时间基与时间戳" class="headerlink" title="FFmpeg 中的时间基与时间戳"></a>FFmpeg 中的时间基与时间戳</h1><h2 id="时间基与时间戳的概念"><a href="#时间基与时间戳的概念" class="headerlink" title="时间基与时间戳的概念"></a>时间基与时间戳的概念</h2><p>在FFmpeg中，时间基(time_base)是时间戳(timestamp)的单位，实际的时间(以秒等为单位)＝时间戳*时间基。</p><p>例如，一帧视频的dts&#x3D;40,pts&#x3D;160,time_base&#x3D;1&#x2F;1000s．</p><p>那么：</p><pre><code>该帧视频的解码时间＝dts*time_base=40/1000s=0.04s该帧视频的显示时间＝pts*time_base=160/1000s=0.16s</code></pre><p>FFmpeg中时间戳(pts&#x2F;dts)的类型是int64_t类型（范围：-9223372036854775808~9223372036854775807），<br>time_base相当于是一个时钟脉冲或者说是单片机里的晶振周期，而dts&#x2F;pts则是时钟脉冲（晶振周期）的计数。</p><h3 id="三种时间基-tbr、tbn-和-tbc"><a href="#三种时间基-tbr、tbn-和-tbc" class="headerlink" title="三种时间基 tbr、tbn 和 tbc"></a>三种时间基 tbr、tbn 和 tbc</h3><p>不同的封装格式具有不同的时间基。在 FFmpeg 处理音视频过程中的不同阶段，也会采用不同的时间基。<br>FFmepg 中有三种时间基，命令行中 tbr、tbn 和 tbc 的打印值就是这三种时间基的倒数：<br>tbn：对应容器中的时间基。值是 AVStream.time_base 的倒数<br>tbc：对应编解码器中的时间基。值是 AVCodecContext.time_base 的倒数<br>tbr：从视频流中猜算得到，可能是帧率或场率(帧率的 2 倍)</p><h3 id="内部时间基-AV-TIME-BASE"><a href="#内部时间基-AV-TIME-BASE" class="headerlink" title="内部时间基 AV_TIME_BASE"></a>内部时间基 AV_TIME_BASE</h3><p>除以上三种时间基外，FFmpeg还有一个内部时间基AV_TIME_BASE(以及分数形式的AV_TIME_BASE_Q)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Internal time base represented as integer</span><br><span class="line">#define AV_TIME_BASE            1000000</span><br><span class="line"></span><br><span class="line">// Internal time base represented as fractional value</span><br><span class="line">#define AV_TIME_BASE_Q          (AVRational)&#123;1, AV_TIME_BASE&#125;</span><br></pre></td></tr></table></figure><p>注：AV_TIME_BASE和AV_TIME_BASE_Q:用于 FFmpeg 内部函数处理，使用此时间基计算得到时间值表示的是微秒（1s&#x3D;1000ms&#x3D;1000000us）。</p><h3 id="时间值形式转换"><a href="#时间值形式转换" class="headerlink" title="时间值形式转换"></a>时间值形式转换</h3><p>av_q2d()将时间从AVRational形式转换为double形式。AVRational是分数类型，double是双精度浮点数类型，转换的结果单位是秒。转换前后的值基于同一时间基，仅仅是数值的表现形式不同而已。</p><p>av_q2d()实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert an AVRational to a `double`.</span></span><br><span class="line"><span class="comment"> * @param a AVRational to convert</span></span><br><span class="line"><span class="comment"> * @return `a` in floating-point form</span></span><br><span class="line"><span class="comment"> * @see av_d2q()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">double</span> <span class="title function_">av_q2d</span><span class="params">(AVRational a)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.num / (<span class="type">double</span>) a.den;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>av_q2d()使用方法如下：</p><p>AVStream stream;<br>AVPacket packet;<br>packet 播放时刻值：timestamp(单位秒) &#x3D; packet.pts × av_q2d(stream.time_base);<br>packet 播放时长值：duration(单位秒) &#x3D; packet.duration × av_q2d(stream.time_base);</p><h3 id="时间基转换函数"><a href="#时间基转换函数" class="headerlink" title="时间基转换函数"></a>时间基转换函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rescale a 64-bit integer by 2 rational numbers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The operation is mathematically equivalent to `a × bq / cq`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is equivalent to av_rescale_q_rnd() with #AV_ROUND_NEAR_INF.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see av_rescale(), av_rescale_rnd(), av_rescale_q_rnd()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int64_t</span> <span class="title function_">av_rescale_q</span><span class="params">(<span class="type">int64_t</span> a, AVRational bq, AVRational cq)</span> av_const;</span><br></pre></td></tr></table></figure><p>av_rescale_q()用于不同时间基的转换，用于将时间值从一种时间基转换为另一种时间基。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert valid timing fields (timestamps / durations) in a packet from one</span></span><br><span class="line"><span class="comment"> * timebase to another. Timestamps with unknown values (AV_NOPTS_VALUE) will be</span></span><br><span class="line"><span class="comment"> * ignored.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param pkt packet on which the conversion will be performed</span></span><br><span class="line"><span class="comment"> * @param tb_src source timebase, in which the timing fields in pkt are</span></span><br><span class="line"><span class="comment"> *               expressed</span></span><br><span class="line"><span class="comment"> * @param tb_dst destination timebase, to which the timing fields will be</span></span><br><span class="line"><span class="comment"> *               converted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">av_packet_rescale_ts</span><span class="params">(AVPacket *pkt, AVRational tb_src, AVRational tb_dst)</span>;</span><br></pre></td></tr></table></figure><p>av_packet_rescale_ts()用于将AVPacket中各种时间值从一种时间基转换为另一种时间基。</p><h2 id="转封装过程中的时间基转换"><a href="#转封装过程中的时间基转换" class="headerlink" title="转封装过程中的时间基转换"></a>转封装过程中的时间基转换</h2><p>容器中的时间基(AVStream.time_base中的tbn)定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVStream</span> &#123;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This is the fundamental unit of time (in seconds) in terms</span></span><br><span class="line"><span class="comment">     * of which frame timestamps are represented.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * decoding: set by libavformat</span></span><br><span class="line"><span class="comment">     * encoding: May be set by the caller before avformat_write_header() to</span></span><br><span class="line"><span class="comment">     *           provide a hint to the muxer about the desired timebase. In</span></span><br><span class="line"><span class="comment">     *           avformat_write_header(), the muxer will overwrite this field</span></span><br><span class="line"><span class="comment">     *           with the timebase that will actually be used for the timestamps</span></span><br><span class="line"><span class="comment">     *           written into the file (which may or may not be related to the</span></span><br><span class="line"><span class="comment">     *           user-provided one, depending on the format).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVRational time_base;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AVStream.time_base是AVPacket中pts和dts的时间单位．<br>输入流与输出流中的time_base按如下方式确定：</p><ul><li>对于输入流：打开输入文件后，调用 avformat_find_stream_info()可获取到每个流中的 time_base</li><li>对于输出流：打开输出文件后，调用 avformat_write_header()可根据输出文件封装格式确定每个流的 time_base 并写入输出文件中</li></ul><p>不同封装格式具有不同的时间基，在转封装(将一种封装格式转换为另一种封装格式)过程中，时间基转换相关代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">av_read_frame(ifmt_ctx, &amp;pkt);// 从输入文件中读取 packet</span><br><span class="line">pkt.pts = av_rescale_q_rnd(pkt.pts, in_stream-&gt;time_base, out_stream-&gt;time_base, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX);</span><br><span class="line"></span><br><span class="line">pkt.dts = av_rescale_q_rnd(pkt.dts, in_stream-&gt;time_base, out_stream-&gt;time_base, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX);</span><br><span class="line"></span><br><span class="line">pkt.duration = av_rescale_q(pkt.duration, in_stream-&gt;time_base, out_stream-&gt;time_base);</span><br></pre></td></tr></table></figure><p>下面的代码具有和上面代码相同的效果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">av_read_frame(ifmt_ctx, &amp;pkt);<span class="comment">// 从输入文件中读取 packet</span></span><br><span class="line">av_packet_rescale_ts(&amp;pkt, in_stream-&gt;time_base, out_stream-&gt;time_base);<span class="comment">// 将packet中的各时间值从输入流封装格式时间基转换到输出流封装格式时间基</span></span><br></pre></td></tr></table></figure><p>这里流里的时间基in_stream-&gt;time_base和out_stream-&gt;time_base，是容器中的时间基，也就是上面说的tbn。</p><h2 id="转码过程中的时间基转换"><a href="#转码过程中的时间基转换" class="headerlink" title="转码过程中的时间基转换"></a>转码过程中的时间基转换</h2><p>编解码器中的时间基(AVCodecContext.time_base，3.2 节中的 tbc)定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVCodecContext</span> &#123;</span></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This is the fundamental unit of time (in seconds) in terms</span></span><br><span class="line"><span class="comment">     * of which frame timestamps are represented. For fixed-fps content,</span></span><br><span class="line"><span class="comment">     * timebase should be 1/framerate and timestamp increments should be</span></span><br><span class="line"><span class="comment">     * identically 1.</span></span><br><span class="line"><span class="comment">     * This often, but not always is the inverse of the frame rate or field rate</span></span><br><span class="line"><span class="comment">     * for video. 1/time_base is not the average frame rate if the frame rate is not</span></span><br><span class="line"><span class="comment">     * constant.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Like containers, elementary streams also can store timestamps, 1/time_base</span></span><br><span class="line"><span class="comment">     * is the unit in which these timestamps are specified.</span></span><br><span class="line"><span class="comment">     * As example of such codec time base see ISO/IEC 14496-2:2001(E)</span></span><br><span class="line"><span class="comment">     * vop_time_increment_resolution and fixed_vop_rate</span></span><br><span class="line"><span class="comment">     * (fixed_vop_rate == 0 implies that it is different from the framerate)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - encoding: MUST be set by user.</span></span><br><span class="line"><span class="comment">     * - decoding: the use of this field for decoding is deprecated.</span></span><br><span class="line"><span class="comment">     *             Use framerate instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVRational time_base;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述注释指出，AVCodecContext.time_base 是帧率(视频帧)的倒数，每帧时间戳递增 1，那么 tbc 就等于帧率。编码过程中，应由用户设置好此参数。解码过程中，此参数已过时，建议直接使用帧率倒数用作时间基。</p><p>这里有一个问题：按照此处注释说明，帧率为 25 的视频流，tbc 理应为 25，但实际值却为 50，不知作何解释？是否 tbc 已经过时，不具参考意义？</p><p>根据注释中的建议，实际使用时，在视频解码过程中，我们不使用 AVCodecContext.time_base，而用帧率倒数作时间基，在视频编码过程中，我们将 AVCodecContext.time_base 设置为帧率的倒数。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg解码H264</title>
      <link href="/2023/02/14/FFmpeg%E8%A7%A3%E7%A0%81H264/"/>
      <url>/2023/02/14/FFmpeg%E8%A7%A3%E7%A0%81H264/</url>
      
        <content type="html"><![CDATA[<h1 id="FFmpeg的H264解码"><a href="#FFmpeg的H264解码" class="headerlink" title="FFmpeg的H264解码"></a>FFmpeg的H264解码</h1><p>步骤一：添加头文件<br>libavcodec&#x2F;avcodec.h</p><p>常用数据结构</p><ul><li>AVCodec 编码器结构体</li><li>AVCodecContext 编码器上下文</li><li>AVFrame 解码后的帧</li></ul><p>AVCodec编码器结构体：记录编码器类型，比如：是音频解码器还是视频解码器，是H264还是H265等等。</p><p>AVCodecContext 编码器上下文：被当成参数进行传递，起到串联作用。</p><p>结构内存的分配与释放</p><p>av_frame_alloc&#x2F;av_frame_free()</p><p>avcodec_alloc_context3()&#x2F;avcodec_free_context()</p><p>解码步骤：</p><ul><li>查找解码器（avcodec_find_decoder）</li><li>打开解码器（avcodec_open2）</li><li>解码（alcove_decode_video2）</li></ul><h1 id="FFmpeg的H264编码"><a href="#FFmpeg的H264编码" class="headerlink" title="FFmpeg的H264编码"></a>FFmpeg的H264编码</h1><p>编码步骤：</p><ul><li>查找编码器（avcodec_find_encoder_by_name）</li><li>设置编码参数，并打开编码器（avcodec_open2）</li><li>编码（avcodec_encode_video2）</li></ul><p>实际是调用h264的第三方库：libh264或libopemh264，FFmpeg只是在上面做了一层封装，方便我们去调用这些库</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/opt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/imgutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename, *codec_name;</span><br><span class="line">    <span class="type">const</span> AVcodec *codec;</span><br><span class="line">    AVCodecContext *c = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret,got_output;</span><br><span class="line">    FILE *f;</span><br><span class="line">    AVFrame *frame;</span><br><span class="line">    AVPacket pkt;</span><br><span class="line">    <span class="type">uint8_t</span> encode[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0xb7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Usage: %s &lt;output file&gt; &lt;code name&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    filename =argv[<span class="number">1</span>];</span><br><span class="line">    codec_name =argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">avcodec_register_all</span>();<span class="comment">//将所有编解码的库和API注册</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* find the mpeg1video encoder */</span></span><br><span class="line">    codec = <span class="built_in">avcodec_find_encoder_by_name</span>(codec_name);<span class="comment">//拿到具体的编解码器</span></span><br><span class="line">    <span class="keyword">if</span>(!codec)&#123;</span><br><span class="line">        <span class="built_in">fprint</span>(stderr, <span class="string">&quot;Codec not found\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c = <span class="built_in">avcodec_alloc_context3</span>(codec);<span class="comment">//拿到上下文</span></span><br><span class="line">    <span class="keyword">if</span>(!c)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Could not allocate video codec context&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置相关参数</span></span><br><span class="line">    <span class="comment">/* put sample parameters */</span></span><br><span class="line">    c-&gt;bit_rate = <span class="number">40000</span>;</span><br><span class="line">    <span class="comment">/* resolution must be a multiple of two */</span></span><br><span class="line">    c-&gt;width = <span class="number">352</span>;</span><br><span class="line">    c-&gt;height = <span class="number">280</span>;</span><br><span class="line">    <span class="comment">/* frames per second */</span></span><br><span class="line">    c-&gt;time_base = (AVRational)&#123;<span class="number">1</span>,<span class="number">25</span>&#125;;<span class="comment">//设置时间基，设置一秒有25帧；时间基是跟着帧率变化的</span></span><br><span class="line">    c-&gt;framerate = (AVRational)&#123;<span class="number">25</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* emit one intra frame every ten frames</span></span><br><span class="line"><span class="comment">     * check frame pict_type before passing frame</span></span><br><span class="line"><span class="comment">     * to encoder, if frame-&gt;pict_type is AV_PICTURE_TYPE_I</span></span><br><span class="line"><span class="comment">     * then gop_size is ignored and the out put of encoder</span></span><br><span class="line"><span class="comment">     * will always be I frame irrespective to gop_size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    c-&gt;gop_size = <span class="number">10</span>;<span class="comment">//每10帧中产生1个关键帧，即每个gop大小设置为10，gop_size越小，I帧就越多，数据就越大，码率就越大</span></span><br><span class="line">    c-&gt;max_b_frames = <span class="number">1</span>;<span class="comment">//B帧数量，对于实时性要求越高的场景，为了保证解码的速度，B帧就要越少，如果对压缩率要求高，那该值就要越大</span></span><br><span class="line">    c-&gt;pix_fmt = AV_PIX_FMT_YUV420P;<span class="comment">//设置编码数据的YUV格式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(codec-&gt;id == AV_CODEC_IO_H264)</span><br><span class="line">    <span class="built_in">av_opt_set</span>(c-&gt;priv_data, <span class="string">&quot;preset&quot;</span>, <span class="string">&quot;slow&quot;</span>. <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* open it */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avcodec_open2</span>(c, codec ,<span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Could not open codec\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f = <span class="built_in">fopen</span>(filename, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Could not open %s\n&quot;</span>, filename);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">    <span class="keyword">if</span>(!frame)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;Could not allocate video frame\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    frame-&gt;format = c-&gt;pix_fmt;</span><br><span class="line">    frame-&gt;width  = c-&gt;width;</span><br><span class="line">    frame-&gt;height = c-&gt;height;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_frame_get_buffer</span>(frame, <span class="number">32</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Could not a allocate the video frame data\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* encode 1 second of video */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">av_init_packet</span>(&amp;pkt);</span><br><span class="line">        pkt.data = <span class="literal">NULL</span>;<span class="comment">//packet data will be allocated by the encoder</span></span><br><span class="line">        pkt.size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* make sure the frame data is eritable */</span></span><br><span class="line">        ret = <span class="built_in">av_frame_make_writable</span>(frame);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* prepare a dummy image */</span></span><br><span class="line">        <span class="comment">/* Y */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y=<span class="number">0</span>; u &lt; c-&gt;height; y++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x= <span class="number">0</span>; x&lt; c-&gt;width; x++) &#123;</span><br><span class="line">                frame-&gt;data[<span class="number">0</span>][y * frame-&gt;linesize[<span class="number">0</span>] + x =x +y +i *<span class="number">3</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Cb and Cr */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y =<span class="number">0</span>;y &lt; c-&gt;height/<span class="number">2</span>; y++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x=<span class="number">0</span>; x &lt; c-&gt;width/<span class="number">2</span>; x++)&#123;</span><br><span class="line">                frame-&gt;data[<span class="number">1</span>][y * frame-&gt;linesize[<span class="number">1</span>] + x] = <span class="number">128</span> + y +i * <span class="number">2</span>;</span><br><span class="line">                frame-&gt;data[<span class="number">2</span>][y * frame-&gt;linesize[<span class="number">2</span>] + x] = <span class="number">94</span> + x +i * <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        frame-&gt;pts = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* encode the image */</span></span><br><span class="line">        ret = <span class="built_in">avcodec_encode_video2</span>(c, &amp;pkt, frame, &amp;got_output);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error encoding frame\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (got_output) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Write frame %3d (size=%5d)\n&quot;</span>, i, pkt.size);</span><br><span class="line">            <span class="built_in">fwrite</span>(pkt.data, <span class="number">1</span>, pkt.size, f);<span class="comment">//将数据写到文件中去</span></span><br><span class="line">            <span class="built_in">av_paket_unref</span>(&amp;pkt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get the delayed frames */</span></span><br><span class="line">    <span class="keyword">for</span> (got_output = <span class="number">1</span>; got_output; i++) &#123;</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">avcodec_encode_video2</span>(c, &amp;pkt, <span class="literal">NULL</span>, &amp;got_output);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error encoding frame\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IDR和I帧的区别</title>
      <link href="/2023/02/10/IDR%E5%92%8CI%E5%B8%A7%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/02/10/IDR%E5%92%8CI%E5%B8%A7%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>IDR（Instantaneous Decoding Refresh）–即时解码刷新。</p><p>I和IDR帧都是使用帧内预测的。它们都是同一个东西而已,在编码和解码中为了方便，要首个I帧和其他I帧区别开，所以才把第一个首个I帧叫IDR，这样就方便控制编码和解码流程。IDR帧的作用是立刻刷新,使错误不致传播,从IDR帧开始,重新算一个新的序列开始编码。而I帧不具有随机访问的能力，这个功能是由IDR承担。IDR会导致DPB（DecodedPictureBuffer 参考帧列表——这是关键所在）清空，而I不会。IDR图像一定是I图像，但I图像不一定是IDR图像。一个序列中可以有很多的I图像，I图像之后的图像可以引用I图像之间的图像做运动参考。一个序列中可以有很多的I图像，I图像之后的图象可以引用I图像之间的图像做运动参考。<br>对于IDR帧来说，在IDR帧之后的所有帧都不能引用任何IDR帧之前的帧的内容，与此相反，对于普通的I-帧来说，位于其之后的B-和P-帧可以引用位于普通I-帧之前的I-帧。从随机存取的视频流中，播放器永远可以从一个IDR帧播放，因为在它之后没有任何帧引用之前的帧。但是，不能在一个没有IDR帧的视频中从任意点开始播放，因为后面的帧总是会引用前面的帧。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>h264协议详解</title>
      <link href="/2023/02/10/h264%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/02/10/h264%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="h264背景"><a href="#h264背景" class="headerlink" title="h264背景"></a>h264背景</h1><p>h264是ITU-T和ISO&#x2F;IEC这两个组织一起制定的标准。最新的H.264标准则被纳入MPEG-4的第10部分，所以h264又称MPEG4 Part 10 AVC</p><h1 id="h264结构"><a href="#h264结构" class="headerlink" title="h264结构"></a>h264结构</h1><p>H264从功能上可以划分为2层：</p><ul><li>VCL（Video Coding Layer），视频编码层，H264编码&#x2F;压缩的核心，主要负责将视频数据编码&#x2F;压缩，再切分。</li><li>NAL（Network Abstraction Layer），网络抽象层，这里的网络指的是计算机网络而不是神经网络，负责将VCL的数据组织打包。</li></ul><h2 id="网络抽象层：NAL"><a href="#网络抽象层：NAL" class="headerlink" title="网络抽象层：NAL"></a>网络抽象层：NAL</h2><p>NAL的主成单元是NALU</p><h3 id="NALU"><a href="#NALU" class="headerlink" title="NALU"></a>NALU</h3><p>NALU分为头和神态两个部分组成：</p><ul><li>头：一般存储标志信息，譬如NALU的类型。<font color =red>注意：NAL会打包VCL数据，但是这并不意味着所有的NALU负载的都是VCL，也有一些NALU仅仅存储了和编解码信息相关的数据；</font></li><li>身体：存储了真正的数据。但实际上，这块也会相对比较复杂，H264的一个目的是“网络友好性”，说白了就是能够很好地适配各种传输格式。所以根据实际采用数据传输流格式，也会对这部分数据格式再进行处理。</li></ul><h4 id="NALU-Header"><a href="#NALU-Header" class="headerlink" title="NALU Header"></a>NALU Header</h4><p>NALU Header:只占1个字节，即8位。具体结构如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| forbidden_zero_bit | nal_ref_idc | nal_unit_type |</span><br><span class="line">`--------------------+-------------+---------------`</span><br><span class="line">|        1 bit       |    2 bit    |    5 bit      |</span><br></pre></td></tr></table></figure><h5 id="参数详解："><a href="#参数详解：" class="headerlink" title="参数详解："></a>参数详解：</h5><ul><li>forbidden_zero_bit:禁止位，有时也叫:forbidden_bit。在网络传输中发生错误时，会被置为1，告诉接收方丢掉该单元；否则为0。</li><li>nal_ref_idc:指示当前NALU的优先级，或者说重要性，数值越大表明越重要。笔者从文章Introduction to H.264: NAL Unit摘录下文：</li><li>nal_unit_type:表示NALU的类型。</li></ul><pre><code>对于forbidden_zero_bit参数这里就衍生出了两个问题：                1.网络传输发生错误时，由谁来对这个位进行置1处理？                2.置1后被对方接收了，由谁来丢弃？解码器吗？```快乐</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ShiftMediaProject的编译教程</title>
      <link href="/2023/01/20/ShiftMediaProject%E7%9A%84%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/"/>
      <url>/2023/01/20/ShiftMediaProject%E7%9A%84%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>ShiftMediaProject是Matthew 维护的非官方项目，我们可以看出在<a href="https://github.com/ShiftMediaProject">ShiftMediaProject</a>下面有很多子项目，包括 FFmpeg，x264，SDL 等等。虽然 FFmpeg 跟 x264 本身就支持 MSVC 的方式编译，他们的 configure 跟 makefile 脚本都可以使用 msvc 的编译器的。但是那始终是命令行工具，不太方便。所以 Matthew 把这些编译脚本，移植成了 Visual Studio 原生的解决方案（solution）。这样点几个按钮就可以编译了，而且可以断点调试源码，查看数据。VS 的版本众多，目前 vs2013以上的版本都可以使用 ShiftMediaProject（ffmpeg 的编译要求编译器对 C99 标准的支持。VS 中默认只有 VS2013 以及更新的版本对 C99 标准提供了支持，所以只能使用 VS2013 之后的版本，如果要使用更前版本，那么就得自己在 VS 先添加 C99 标准的支持）。</p><h1 id="下载源代码"><a href="#下载源代码" class="headerlink" title="下载源代码"></a>下载源代码</h1><p>首先创建一个文件夹，命名为ShiftMediaProject，接着进入该文件夹后，新建两个文件夹，一个命名为source，另一个命名为msvc。</p><p>进入source文件夹后，进入命令行模式，在该文件夹路径下输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ShiftMediaProject/FFmpeg.git</span><br></pre></td></tr></table></figure><p>等待克隆完成后,我们通过浏览器进入<a href="https://github.com/ShiftMediaProject/FFmpeg.git">ShiftMediaProject</a>，可以看出Tags中现在已经更新到5.2r109469。在这里你可以根据Tags来进行对应版本的切换。</p><p>现在，我们进入到source\FFmpeg\SMP中，可以看到所有的 VS 项目相关的文件，都在 SMP 文件夹下，仔细查看该目录下的 readme 文件内容，按里面的说明进行。</p><p>可以看出在readme文件中说了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bzlib    iconv    zlib    lzma    libxml2    sdl2    libmp3lame    libvorbis    libspeex    libopus    libilbc    libtheora    libx264    libx265    libxvid    libvpx    libgme    libmodplug    libsoxr    libfreetype    fontconfig    libfribidi    libass    gnutls    libgcrypt    libssh    libcdio    libcdio_paranoia  libbluray    opengl    ffnvcodec   libmfx</span><br><span class="line">```    </span><br><span class="line">这些都是我们需要下载的依赖项目，上面大部分的依赖项目都被放在了ShiftMediaProject的 git 仓库 了，这些都可以手动下载，当然强烈建议还是使用 FFmpeg\SMP\project_get_dependencies.bat 批处理自动clone下载，这个脚本不仅仅可在第一次用于clone项目（及其本身依赖的其他git项目），还可以在后面任何时候执行，用来自动更新各自最新的版本</span><br><span class="line"></span><br><span class="line">所以，双击执行 “project_get_dependencies.bat” 批处理，等待一段 较长的时间 的下载，即可完成大部分依赖库的下载。但是按照国内的网络直接运行FFmpeg/SMP下的脚本project_get_dependencies.bat，通过这种方式是很难成功的，我这边挂了vpn也不行。所以只能一个个下依赖库。管理员启动Git CMD输入：</span><br></pre></td></tr></table></figure><p>git clone <a href="https://github.com/ShiftMediaProject/bzip2.git">https://github.com/ShiftMediaProject/bzip2.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/fontconfig.git">https://github.com/ShiftMediaProject/fontconfig.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/freetype2.git">https://github.com/ShiftMediaProject/freetype2.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/fribidi.git">https://github.com/ShiftMediaProject/fribidi.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/game-music-emu.git">https://github.com/ShiftMediaProject/game-music-emu.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/gmp.git">https://github.com/ShiftMediaProject/gmp.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/gnutls.git">https://github.com/ShiftMediaProject/gnutls.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/harfbuzz.git">https://github.com/ShiftMediaProject/harfbuzz.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/lame.git">https://github.com/ShiftMediaProject/lame.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/libass.git">https://github.com/ShiftMediaProject/libass.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/libbluray.git">https://github.com/ShiftMediaProject/libbluray.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/libcdio.git">https://github.com/ShiftMediaProject/libcdio.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/libcdio-paranoia.git">https://github.com/ShiftMediaProject/libcdio-paranoia.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/libgcrypt.git">https://github.com/ShiftMediaProject/libgcrypt.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/libgpg-error.git">https://github.com/ShiftMediaProject/libgpg-error.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/libiconv.git">https://github.com/ShiftMediaProject/libiconv.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/libilbc.git">https://github.com/ShiftMediaProject/libilbc.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/liblzma.git">https://github.com/ShiftMediaProject/liblzma.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/libssh.git">https://github.com/ShiftMediaProject/libssh.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/libvpx.git">https://github.com/ShiftMediaProject/libvpx.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/libxml2.git">https://github.com/ShiftMediaProject/libxml2.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/mfx_dispatch.git">https://github.com/ShiftMediaProject/mfx_dispatch.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/modplug.git">https://github.com/ShiftMediaProject/modplug.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/nettle.git">https://github.com/ShiftMediaProject/nettle.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/ogg.git">https://github.com/ShiftMediaProject/ogg.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/opus.git">https://github.com/ShiftMediaProject/opus.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/sdl.git">https://github.com/ShiftMediaProject/sdl.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/soxr.git">https://github.com/ShiftMediaProject/soxr.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/speex.git">https://github.com/ShiftMediaProject/speex.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/theora.git">https://github.com/ShiftMediaProject/theora.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/vorbis.git">https://github.com/ShiftMediaProject/vorbis.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/x264.git">https://github.com/ShiftMediaProject/x264.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/x265.git">https://github.com/ShiftMediaProject/x265.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/xvid.git">https://github.com/ShiftMediaProject/xvid.git</a><br>git clone <a href="https://github.com/ShiftMediaProject/zlib.git">https://github.com/ShiftMediaProject/zlib.git</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">下载过程中如果有报错，我们可以参考博文：[《OpenSSL SSL_read: Connection was reset, errno 10054》](https://blog.csdn.net/qq_29493173/article/details/114534057)和</span><br><span class="line">[《Failed to connect to github.com port 443: Timed out》](https://blog.csdn.net/yy339452689/article/details/104040279)解决。</span><br><span class="line"></span><br><span class="line">此时，我们的整个文件结构就变成以下这样：</span><br></pre></td></tr></table></figure><ul><li>msvc (OutputDir)　　　　　　　　　　　　　 　　(该项目默认的 VS 编译输出的目录)</li><li>source　　　　　　　　　　　　　　　　　 　　　　(这个是需要的上一级目录，待会下载的依赖项目有很多，十几二十来个依赖项目都会下载到这里)<br>　　- FFmpeg 　　　　　　　　　　　　　　　　　　　(这个是 clone 到本地的项目目录)<br>　　- ..Any other libraries source code..    (其他的十几二十个依赖的项目)</li></ul><pre><code>确保上面提到的所有依赖都下载完成后，我们才运行脚本project_get_dependencies.bat，去下载其它依赖文件。# 下载安装VSNASM和VSYASM[下载VSNASM](https://github.com/ShiftMediaProject/VSNASM/releases)[下载VSYASM](https://github.com/ShiftMediaProject/VSYASM/releases)下载后解压，分别执行install_script.bat即可。</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Qt5各平台的安装教程</title>
      <link href="/2023/01/19/Qt5%E5%90%84%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2023/01/19/Qt5%E5%90%84%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>对于一名音视频开发人员，掌握一项桌面端软件或移动端APP的开发技能，是一件很有必要的事情。而由于音视频开发者基本采用的是C++语言，并且FFmpeg&#x2F;WebRTC等第三方库跨平台的特性，使得绝大多数人员都选择Qt来进行用户图形界面的开发。</p><p>因此，本文将介绍如何在Windows、macOS、Linux平台进行Qt的安装。</p><p>现阶段Qt已经升级到了Qt6版本，但是为了兼容Windows10以下的机器，我们还是选择Qt5进行安装，当然如果你采用的是ARM架构的Mac电脑（也就是M1&#x2F;M2芯片的mac），那么你就需要采用Qt6，否则可以一律采用Qt5。当然，如果你公司项目坑爹的采用的是Qt4，并且你还想用高版本的Visual Studio进行调试。。。。那么你可以看下我之前写的这篇<a href="https://qiangwu666.github.io/2020/05/14/VS2013%E7%BC%96%E8%AF%9164%E4%BD%8DQT4.8.6%E6%BA%90%E4%BB%A3%E7%A0%81%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E7%89%88%EF%BC%89/">文章</a></p><p>至于Qt5的具体版本选择，则需要根据该版本是否LTS（Long Term Support）来进行选择。LTS（Long Term Support） 版本通常支持三年，目前还在支持的有 5.12、5.15，但 5.15 只有商业版本提供 LTS 服务。因此，在这里我们采用的是Qt5.12.12版本进行安装。</p><p>首先是登陆Qt官网下载对应的<a href="https://download.qt.io/archive/qt/5.12/5.12.12/">Qt安装包</a>，当然如果你需要对Qt进行裁剪或者修改源代码的话，可以直接下载<a href="https://download.qt.io/archive/qt/5.12/5.12.12/single/">Qt源代码</a>进行编译，这边由于我们涉及到的Qt较为基础，因此，直接用他官方提供的安装包进行安装就行了。</p><p><img src="/./picutre/Qt5%E5%90%84%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/QT%E5%AE%98%E6%96%B9%E5%AE%89%E8%A3%85%E5%8C%85%E4%B8%8B%E8%BD%BD%E7%95%8C%E9%9D%A2.png"></p><p>其中：</p><p>submodules：Qt 各个子模块源码包</p><p>single：Qt 完整的源码包</p><p>qt-opensource-windows-x86-5.12.12.exe：Windows 安装包</p><p>qt-opensource-mac-x64-5.12.12.dmg：Mac 安装包</p><p>qt-opensource-linux-x64-5.12.12.run：Linux 安装包</p><p><img src="/./picutre/Qt5%E5%90%84%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/QT%E5%AE%98%E6%96%B9%E6%BA%90%E4%BB%A3%E7%A0%81%E4%B8%8B%E8%BD%BD%E7%95%8C%E9%9D%A2.png"><br>其中：</p><p>qt-everywhere-src-5.12.12.zip和qt-everywhere-src-5.12.12.tar.xz是不同压缩方式；</p><p>在Windows端下载qt-everywhere-src-5.12.12.zip；</p><p>Mac和Linux端下载qt-everywhere-src-5.12.12.tar.xz</p><h1 id="Windows平台的安装"><a href="#Windows平台的安装" class="headerlink" title="Windows平台的安装"></a>Windows平台的安装</h1><p><a href="https://zhuanlan.zhihu.com/p/385486784">https://zhuanlan.zhihu.com/p/385486784</a></p><h1 id="macOS平台的安装"><a href="#macOS平台的安装" class="headerlink" title="macOS平台的安装"></a>macOS平台的安装</h1><h1 id="Linux平台的安装"><a href="#Linux平台的安装" class="headerlink" title="Linux平台的安装"></a>Linux平台的安装</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于NvDec+CUDA+OpenGL+NvEnc的全流程GPU加速方案</title>
      <link href="/2023/01/19/%E5%9F%BA%E4%BA%8ENvDec+CUDA+OpenGL+NvEnc%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8BGPU%E5%8A%A0%E9%80%9F%E6%96%B9%E6%A1%88/"/>
      <url>/2023/01/19/%E5%9F%BA%E4%BA%8ENvDec+CUDA+OpenGL+NvEnc%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8BGPU%E5%8A%A0%E9%80%9F%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="0-介绍："><a href="#0-介绍：" class="headerlink" title="0 介绍："></a>0 介绍：</h1><p>在编解码领域中，对音视频文件进行解码编码主要有两种方式：</p><ul><li>软件解码编码</li><li>硬件解码编码</li></ul><p>软件解码编码实际上就是直接用CPU进行解码编码，硬件解码编码则是采用GPU进行解码编码．<br>两种方式的区别在于：GPU解码编码的效率高于CPU解码编码，但是CPU解码编码的质量确高于GPU解码编码．</p><p>当处理较大数据量的时候，往往会用GPU进行运算，比如OpenGL或者CUDA。在实际的操作中，往往CUDA实现并行计算会比OpenGL更加方便，而OpenGL在进行后期渲染更具有优势。由于CUDA中的运算结果存储在GPU中，如果将数据download到CPU，然后再将CPU中的数据上传到GPU，使用OpenGL进行渲染，中间的GPU与CPU的交互会很耗时，毕竟使用GPU的目的就是为了加速，这样的数据传输会降低效率。</p><p>所以我们在进行编解码时，在某些注重时间效率的场景下，如何提高解码渲染编码的速度，就绕开CPU，直接通过CUDA和OpenGL进行GPU全流程加速（硬件解码－＞硬件渲染－＞硬件编码），则成了我们的一个研究重点．</p><p>而作为GPU第一大厂的Nvidia，则刚好有一套方案满足我们的需求．<br>CUDA是Nvidia推出的一个通用GPU计算平台，对于提升并行任务的效率非常有帮助。CUDA支持与OpenGL和D3D等图形API的互操作。NVIDIA还提供了一些示例来展示它的工作原理，包括设备到主机复制和零复制（仅限设备到设备）。显然，从设备复制到主机并再次上传进行渲染会影响性能。但是所有零拷贝示例都依赖于CUDA内核将NV12转换为RGB。结果是我们必须使用nvcc编译器来构建代码，并且我们的构建环境会很复杂（CUDA7 支持在线编译器），有时是不可能的（我使用CUDA驱动程序API在任何构建环境中为所有平台构建支持CUDA的代码）。</p><p>是否有任何解决方案可以仅使用图形API实现零拷贝？回答是肯定的。</p><p>由于D3D只支持Win系统，因此接下来我们将以FFmpeg+CUDA+NvDec+OpenGL+NvEnc的方式，来演示GPU全流程</p><p>PS:<br>NVDEC(硬件加速的视频解码):NVIDIA GPU 包含基于硬件的解码器 (NVDEC)，可为几种热门的编解码器提供基于硬件的全加速视频解码。由于解码工作流完全卸载至 NVDEC，图形引擎和 CPU 可以有更多的时间执行其他操作。NVDEC 比实时解码速度更快，非常适合用于转码应用以及视频播放应用。借助 NVDECODE API，软件开发者能够配置此专用硬件视频解码器。此专用加速器支持在 Windows 和 Linux 平台上对以下视频编解码器进行硬件加速解码：MPEG-2、VC-1、H.264 (AVCHD)、H.265 (HEVC)、VP8、VP9 和 AV1。</p><p>NVENC(硬件加速的视频编码):从 Kepler 这一代开始，NVIDIA GPU 包含基于硬件的编码器（简称为 NVENC），可提供基于硬件的全加速视频编码，且独立于图形性能。由于计算复杂的编码工作流完全卸载至 NVENC，图形引擎和 CPU 可以有更多的时间执行其他操作。例如，在游戏录制和直播过程中（如使用 Open Broadcaster Software (OBS) 在 Twitch.tv 上直播），编码工作流完全卸载至 NVENC，从而使图形引擎带宽可全部用于游戏渲染。借助 NVENC，我们可以：</p><ul><li>在不使用 CPU 的情况下以高质量和超低延迟对游戏和应用进行编码和串流</li><li>针对存档、OTT 串流、网络视频进行高质量编码</li><li>以超低功耗对每个流进行编码（瓦特&#x2F;流）</li></ul><p>现在我们通过FFmpeg来介绍基于OpenGL的Nvida硬件解码和编码功能，从而实现一套全流程GPU的加速方案</p><h1 id="1-前期准备："><a href="#1-前期准备：" class="headerlink" title="1 前期准备："></a>1 前期准备：</h1><p>先阅读完Nvida的这个<a href="https://docs.nvidia.com/video-technologies/video-codec-sdk/ffmpeg-with-nvidia-gpu/index.html">文档</a></p><p>接着进行编译工作</p><h2 id="1-1-安装CUDA-Toolkit"><a href="#1-1-安装CUDA-Toolkit" class="headerlink" title="1.1 安装CUDA Toolkit"></a>1.1 安装CUDA Toolkit</h2><p><a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux&target_arch=x86_64&Distribution=Ubuntu&target_version=20.04">下载CUDA Toolkit</a><br>PS:这个是Ubuntu20.04版本的，其他版本请对应下载</p><h2 id="1-1-Nvida驱动程序"><a href="#1-1-Nvida驱动程序" class="headerlink" title="1.1 Nvida驱动程序"></a>1.1 Nvida驱动程序</h2><p><a href="https://www.nvidia.com/Download/index.aspx?lang=en-us">下载对应的Nvida驱动程序</a></p><p><a href="https://wujianqiangcode.github.io/Linux%E4%B8%8BNvidia%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4">安装Nvidia驱动教程</a></p><h2 id="1-2-验证"><a href="#1-2-验证" class="headerlink" title="1.2 验证"></a>1.2 验证</h2><p>接下来来就是验证环节：</p><h3 id="1-2-1-验证cuda是否能正常使用"><a href="#1-2-1-验证cuda是否能正常使用" class="headerlink" title="1.2.1 验证cuda是否能正常使用"></a>1.2.1 验证cuda是否能正常使用</h3><p>下载CUDA演示样例验证是否成功安装：</p><p>首先在命令行窗口输入一下命令查看cuda版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>例如显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ws@wujianqiang-ubuntu-18:~$ nvidia-smi</span><br><span class="line">Thu Jan 12 13:43:47 2023       </span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 520.61.05    Driver Version: 520.61.05    CUDA Version: 11.8     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                               |                      |               MIG M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  NVIDIA GeForce ...  On   | 00000000:65:00.0  On |                  N/A |</span><br><span class="line">|  0%   55C    P8    15W / 200W |   1250MiB /  8192MiB |      2%      Default |</span><br><span class="line">|                               |                      |                  N/A |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">                                                                               </span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                                  |</span><br><span class="line">|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |</span><br><span class="line">|        ID   ID                                                   Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">|    0   N/A  N/A      1294      G   /usr/lib/xorg/Xorg                 24MiB |</span><br><span class="line">|    0   N/A  N/A      1401      G   /usr/bin/gnome-shell               82MiB |</span><br><span class="line">|    0   N/A  N/A      1823      G   /usr/lib/xorg/Xorg                573MiB |</span><br><span class="line">|    0   N/A  N/A      1953      G   /usr/bin/gnome-shell              129MiB |</span><br><span class="line">|    0   N/A  N/A      2341      G   ...AAAAAAAAA= --shared-files       60MiB |</span><br><span class="line">|    0   N/A  N/A      2743      G   ...RendererForSitePerProcess      181MiB |</span><br><span class="line">|    0   N/A  N/A      9243      C   ...ffice/program/soffice.bin      128MiB |</span><br><span class="line">|    0   N/A  N/A     22138      G   ...377498332981217288,131072       61MiB |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>则代表cuda的版本是11.8,因此我们要将cuda-samples切换到对应版本进行编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b v11.8 https://github.com/NVIDIA/cuda-samples.git</span><br></pre></td></tr></table></figure><p>注：如果make后提示找不到glut的话，输入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install libgl1-mesa-dev</span><br><span class="line">sudo apt-get install libglu1-mesa-dev</span><br><span class="line">sudo apt-get install libglut-dev</span><br></pre></td></tr></table></figure><p>出现：E: 无法定位软件包 libglut-dev，执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install freeglut3-dev</span><br></pre></td></tr></table></figure><p>如果成功显示该画面就说明CUDA Toolkit安装成功：<br><img src="/./picture/%E5%9F%BA%E4%BA%8ENvDec+CUDA+OpenGL+NvEnc%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8BGPU%E5%8A%A0%E9%80%9F%E6%96%B9%E6%A1%88/CUDA%E6%BC%94%E7%A4%BA%E6%A0%B7%E4%BE%8B%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5.png"></p><h3 id="1-2-2-验证NvDec和NvEnc是否能正常使用"><a href="#1-2-2-验证NvDec和NvEnc是否能正常使用" class="headerlink" title="1.2.2 验证NvDec和NvEnc是否能正常使用"></a>1.2.2 验证NvDec和NvEnc是否能正常使用</h3><p><a href="https://developer.nvidia.com/nvidia-video-codec-sdk/download">下载Nvida的Video_Codec_SDK</a></p><p>接着可以用cmake工具构建一下Video_Codec_SDK里面的Samples，如果能成功构建，那么就代表Nvidia的NvDec和NvEnc都安装成功了。<br><img src="/./picture/%E5%9F%BA%E4%BA%8ENvDec+CUDA+OpenGL+NvEnc%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8BGPU%E5%8A%A0%E9%80%9F%E6%96%B9%E6%A1%88/%E9%AA%8C%E8%AF%81CUDA%20Toolkit%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png"></p><p>PS:如果想学习Nvidia提供的Video_Codec_SDK中的样例，请查看这篇(文章)[]</p><h2 id="1-3-安装FFmpeg和对应的nv-codec-headers"><a href="#1-3-安装FFmpeg和对应的nv-codec-headers" class="headerlink" title="1.3 安装FFmpeg和对应的nv-codec-headers"></a>1.3 安装FFmpeg和对应的nv-codec-headers</h2><p>由于我们进行解码操作使用还需要对音视频文件进行Demux操作，分离出视频流出来进行NvDec的硬件解码，因此，我们还需要使用第三方软件(如FFMPEG)进行Demux操作，所以我们还要下载一下FFmpeg进行编译</p><p>接着下载FFmpeg以及与Nvidia编解码器API接口所需的FFmpeg版本的标头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone -b release/xx  https://git.ffmpeg.org/ffmpeg.git</span><br><span class="line">git clone -b sdk/xx https://github.com/FFmpeg/nv-codec-headers.git</span><br></pre></td></tr></table></figure><h1 id="2-具体解码流程步骤"><a href="#2-具体解码流程步骤" class="headerlink" title="2 具体解码流程步骤"></a>2 具体解码流程步骤</h1><p>首先我们根据Nvidia官方的<a href="https://docs.nvidia.com/video-technologies/video-codec-sdk/nvdec-video-decoder-api-prog-guide/index.html">NVDEC API</a>指南进行学习．</p><p>其硬件解码流程，具体过程如下所示：</p><ul><li>初始化设置</li><li>创建CUDA上下文</li><li>查询硬件解码器解码能力</li><li>创建解码器实例</li><li>使用第三方软件(如FFMPEG)进行Demux</li><li>使用NVDECODE API提供的解析器或第三方解析器（如FFmpeg）解析视频比特流</li><li>使用NVDECODE API启动解码</li><li>获取解码后的YUV进行进一步处理</li><li>查询解码帧状态</li><li>根据解码状态，使用解码后的输出进行进一步的处理(如渲染、后处理等)<br>  如果应用程序需要显示输出：<br>- a、将解码后的YUV转化为RGB格式<br>- b、将RGB映射到DirectX或OpenGL纹理<br>- c、将纹理绘制到屏幕上</li><li>在译码过程完成后销毁解码器实例</li><li>销毁CUDA上下文</li></ul><h2 id="2-1-初始化设置"><a href="#2-1-初始化设置" class="headerlink" title="2.1 初始化设置"></a>2.1 初始化设置</h2><p>首先进行初始化，需要初始化的地方有三个：</p><ul><li>加载对应头文件和动态库</li><li>CUDA初始化</li><li>解码器初始化</li></ul><h3 id="2-1-1-加载对应头文件和动态库"><a href="#2-1-1-加载对应头文件和动态库" class="headerlink" title="2.1.1 加载对应头文件和动态库"></a>2.1.1 加载对应头文件和动态库</h3><p>根据官方的操作指南提示：所有 NVDECODE API 都暴露在两个头文件中：cuviddec.h和 nvcuvid.h. 这两个文件可以在Nvidia提供的Video_Codec_SDK包中的Interface文件夹中找到。NVIDIA的Video_Codec_SDK中的示例静态加载库（作为 Windows SDK 包的一部分提供）函数并包括cuviddec.h和 nvcuvid.h在源文件中。Windows DLLnvcuvid.dll 包含在适用于 Windows 的 NVIDIA 显示驱动程序中。Linux 库 libnvcuvid.so包含在用于 Linux 的 NVIDIA 显示驱动程序中。</p><p>我们在工程中一般是通过动态库的方式进行加载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cuviddec.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nvcuvid.h&quot;</span></span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line"><span class="type">void</span>* hrnvcuda = <span class="built_in">LoadLibrary</span>(<span class="string">L&quot;NVCUDA.DLL&quot;</span>);</span><br><span class="line"><span class="type">void</span>* hrnvcuvid = <span class="built_in">LoadLibrary</span>(<span class="string">L&quot;NVCUVID.DLL&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__    </span></span><br><span class="line">    <span class="type">void</span>* hrnvcuda = <span class="built_in">dlopen</span>(<span class="string">&quot;libcuda.so&quot;</span>,RTLD_LAZY );</span><br><span class="line">    <span class="type">void</span>* hrnvcuvid = <span class="built_in">dlopen</span>(<span class="string">&quot;libnvcuvid.so&quot;</span>,RTLD_LAZY );</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>    </span></span><br></pre></td></tr></table></figure><h3 id="2-1-2-CUDA初始化"><a href="#2-1-2-CUDA初始化" class="headerlink" title="2.1.2 CUDA初始化"></a>2.1.2 CUDA初始化</h3><p>在cuda的api中，采用的是cuda.h中的cuInit进行初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CUresult CUDAAPI <span class="title">cuInit</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Flags)</span></span>;</span><br></pre></td></tr></table></figure><p>这里的flags目前必须给0，对于cuda的所有函数，必须先调用cuInit，否则其他API都会返CUDA_ERROR_NOT_INITIALIZED．<br>但是我们在实际的生成开发环境中，只调用cuInit进行初始化是远远不够的，因此在我们下载的nv-codec-headers的include文件夹的dynlink_cuda.h文件中对这个函数进行了一层封装：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cuInit</span>(<span class="type">unsigned</span> <span class="type">int</span> Flags, <span class="type">int</span> cudaVersion, <span class="type">void</span> *pHandleDriver,<span class="type">int</span> dxtype);</span><br></pre></td></tr></table></figure><p>该封装的函数除了调用cuInit进行初始化以外，还做了两件事：</p><ul><li>调用cuDriverGetVersion函数得到此时设备的cuda驱动版本信息，从而针对性的进行对应版本的相关函数的加载</li><li>通过设定的宏和输入参数类型，来确定是加载cuGraphicsGLRegisterImage等cuda和OpenGL交互的接口还是cuda和哪个版本的DX交互的接口</li></ul><p><font color =red>注：没有对应的cuDestroy，不需要释放，程序销毁自动释放；</font></p><h4 id="相关参数的具体含义："><a href="#相关参数的具体含义：" class="headerlink" title="相关参数的具体含义："></a>相关参数的具体含义：</h4><h5 id="Flags："><a href="#Flags：" class="headerlink" title="Flags："></a>Flags：</h5><p>目前，Flags参数必须为 0。如果尚未调用cuInit()，则驱动程序 API 中的任何函数都将返回CUDA_ERROR_NOT_INITIALIZED。</p><h5 id="cudaVersion：："><a href="#cudaVersion：：" class="headerlink" title="cudaVersion：："></a>cudaVersion：：</h5><p>这个值直接设计成0就行，我们用不到v2接口,所以也不需要指定cudaVersion来针对性进行_v2相关接口的加载，只需要加载默认的接口就可以了</p><h5 id="pHandleDriver："><a href="#pHandleDriver：" class="headerlink" title="pHandleDriver："></a>pHandleDriver：</h5><p>CUDADRIVER cudadriver &#x3D; 0;<br>将cudadriver作为参数传递进去，函数内部会将cuda驱动的句柄值赋值给cudadriver（这个值对我们实际应用时，一般用不到，因此无需特别在意）</p><h5 id="dxtype："><a href="#dxtype：" class="headerlink" title="dxtype："></a>dxtype：</h5><p>该参数只在Win下调用DX的时候使用，如果用OpenGL的话，该参数无实际含义,只需记得打开INIT_CUDA_GL这个宏即可。</p><p>注意需要根据使用的DX类型和宏的开关与否进行参数设置。</p><p>可设置dxtype结构体为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">D3DX_SUPPORT_TYPE</span></span><br><span class="line">&#123;</span><br><span class="line">    SUPPORT_D3D9EX,</span><br><span class="line">    SUPPORT_D3D10,</span><br><span class="line">    SUPPORT_D3D11,</span><br><span class="line">    SUPPORT_UNKOWN,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过宏和dxtype来针对性的进行初始化设置的具体代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> INIT_CUDA_GL</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cuInitGL</span>(<span class="number">0</span>, __CUDA_API_VERSION, CudaDrvLib) != CUDA_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> CUDA_ERROR_INVALID_DEVICE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> INIT_CUDA_D3D9</span></span><br><span class="line"><span class="keyword">if</span> (dxtype == <span class="number">0</span> &amp;&amp;  <span class="built_in">cuInitD3D9</span>(<span class="number">0</span>, __CUDA_API_VERSION, CudaDrvLib) != CUDA_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> CUDA_ERROR_INVALID_DEVICE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> INIT_CUDA_D3D10</span></span><br><span class="line"><span class="keyword">if</span> (dxtype == <span class="number">1</span> &amp;&amp; <span class="built_in">cuInitD3D10</span>(<span class="number">0</span>, __CUDA_API_VERSION, CudaDrvLib) != CUDA_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> CUDA_ERROR_INVALID_DEVICE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> INIT_CUDA_D3D11</span></span><br><span class="line"><span class="keyword">if</span> (dxtype == <span class="number">2</span> &amp;&amp; <span class="built_in">cuInitD3D11</span>(<span class="number">0</span>, __CUDA_API_VERSION, CudaDrvLib) != CUDA_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> CUDA_ERROR_INVALID_DEVICE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="2-1-3-解码器初始化"><a href="#2-1-3-解码器初始化" class="headerlink" title="2.1.3 解码器初始化"></a>2.1.3 解码器初始化</h3><p>同样的，我们对NvDec解码器也得进行初始化操作．我们调用的还是之前下载的nv-codec-headers的include文件夹中的dynlink_nvcuvid.h文件里的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CUresult  CUDAAPI <span class="title">cuvidInit</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Flags)</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以看下dynlink_nvcuvid.cpp中这个函数的源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CUresult CUDAAPI <span class="title">cuvidInit</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLLDRIVER DriverLib;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CHECKED_CALL</span>(<span class="built_in">LOAD_LIBRARY</span>(&amp;DriverLib));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fetch all function pointers</span></span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCreateVideoSource);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCreateVideoSourceW);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidDestroyVideoSource);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidSetVideoSourceState);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidGetVideoSourceState);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidGetSourceVideoFormat);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidGetSourceAudioFormat);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCreateVideoParser);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidParseVideoData);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidDestroyVideoParser);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCreateDecoder);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidDestroyDecoder);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidDecodePicture);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(WIN64) || defined(_WIN64) || defined(__x86_64) || defined(AMD64) || defined(_M_AMD64)</span></span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidMapVideoFrame64);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidUnmapVideoFrame64);</span><br><span class="line">    cuvidMapVideoFrame #  = cuvidMapVideoFrame64;</span><br><span class="line">    cuvidUnmapVideoFrame = cuvidUnmapVideoFrame64;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidMapVideoFrame);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidUnmapVideoFrame);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    GET_PROC(cuvidGetVideoFrameSurface);</span></span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCtxLockCreate);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCtxLockDestroy);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCtxLock);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCtxUnlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CUDA_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出其实就做了一件事情，就是加载对应的函数接口．其中输入参数Flags默认设置为0就行了</p><h2 id="2-2-创建CUDA上下文"><a href="#2-2-创建CUDA上下文" class="headerlink" title="2.2 创建CUDA上下文"></a>2.2 创建CUDA上下文</h2><p>通过2.1的步骤，我们已经将该加载的h文件和动态库文件都加载了，对应的接口函数我们也都加载完成了，接下来就是对cuda进行创建了，而在创建cuda之前，我们需要对电脑的硬件进行检测，我们得知道是哪个型号的gpu后，才能进行CUDA上下文的创建．</p><h3 id="2-2-1-显卡设备信息的获取以及显卡的选择"><a href="#2-2-1-显卡设备信息的获取以及显卡的选择" class="headerlink" title="2.2.1 显卡设备信息的获取以及显卡的选择"></a>2.2.1 显卡设备信息的获取以及显卡的选择</h3><p>首先我们要知道设备有多少张显卡，通过cuDeviceGetCount(int *count)函数，得到设备的显卡数量。<br>具体API定义如下(nv-codec-headers的include文件夹中的dynlink_cuda.h文件里)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuDeviceGetCount</span><span class="params">(<span class="type">int</span> *count)</span></span>;</span><br><span class="line">tcuDeviceGetCount                     *cuDeviceGetCount;</span><br></pre></td></tr></table></figure><p>接着我们需要得到这些显卡的具体信息。</p><p>此时就用到cuDeviceGet和cuDeviceGetName函数；<br>其中cuDeviceGet通过for循环输入1～count来得到每张显卡设备的设备句柄：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcuDeviceGet                          *cuDeviceGet;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuDeviceGet</span><span class="params">(CUdevice *device, <span class="type">int</span> ordinal)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="相关参数的具体含义：-1"><a href="#相关参数的具体含义：-1" class="headerlink" title="相关参数的具体含义："></a>相关参数的具体含义：</h4><h5 id="device："><a href="#device：" class="headerlink" title="device："></a>device：</h5><p>设备句柄</p><h5 id="ordinal："><a href="#ordinal：" class="headerlink" title="ordinal："></a>ordinal：</h5><p>设备id号</p><p>cuDeviceGetName通过输入设备句柄得到每张显卡的名称</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuDeviceGetName</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> len, CUdevice dev)</span></span>;</span><br><span class="line">tcuDeviceGetName                      *cuDeviceGetName;</span><br></pre></td></tr></table></figure><p>相关参数信息：</p><h5 id="dev："><a href="#dev：" class="headerlink" title="dev："></a>dev：</h5><p>设备句柄</p><h5 id="len："><a href="#len：" class="headerlink" title="len："></a>len：</h5><p>默认输入为256</p><p>然后调用helper_cuda_drvapi.h文件中的checkCudaCapabilitiesDRV函数，来进行CUDA GPU SM功能的常规检查</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">checkCudaCapabilitiesDRV</span>(<span class="type">int</span> major_version, <span class="type">int</span> minor_version, <span class="type">int</span> devID)</span><br></pre></td></tr></table></figure><p>Streaming Multiprocessor (SM)的具体含义参考这篇<a href="https://blog.csdn.net/asasasaababab/article/details/80447254">文章</a></p><p><font color = red>注：major_version和minor_version默认输入为1，若想了解checkCudaCapabilitiesDRV函数的具体实现，详见helper_cuda_drvapi.h文件。</font></p><p>最后调用cuDeviceGetAttribute来返回返回有关设备的信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuDeviceGetAttribute</span><span class="params">(<span class="type">int</span> *pi, CUdevice_attribute attrib, CUdevice dev)</span></span>;</span><br><span class="line">tcuDeviceGetAttribute           *cuDeviceGetAttribute;</span><br></pre></td></tr></table></figure><h4 id="相关参数的具体含义：-2"><a href="#相关参数的具体含义：-2" class="headerlink" title="相关参数的具体含义："></a>相关参数的具体含义：</h4><h5 id="pi"><a href="#pi" class="headerlink" title="pi:"></a>pi:</h5><p>返回设备属性值</p><h5 id="attrib"><a href="#attrib" class="headerlink" title="attrib:"></a>attrib:</h5><p>要查询的设备属性，详见dynlink_cuda_cuda.h文件的CUdevice_attribute_enum结构体内容</p><h5 id="dev"><a href="#dev" class="headerlink" title="dev:"></a>dev:</h5><p>设备句柄</p><hr><p>这里有个使用技巧，通过checkCUDADecodecErrors来接收各个API接口返回的CUresult值，从而查看是否成功调用各API接口。<br>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">checkCUDADecodecErrors</span>(<span class="built_in">cuDeviceGetAttribute</span>(xx,xx,xx)))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><hr><p>此时经过上面步骤后，我们已经成功获取到了每一张Nvida显卡设备的相关信息，紧接着我们就需要从中挑选出性能最好的一张来使用。</p><p>我们可以通过<a href="https://github.com/NVIDIA/cuda-samples/blob/master/Common/helper_cuda_drvapi.h">helper_cuda_drvapi.h文件</a>的gpuGetMaxGflopsGLDeviceIdDRV函数，来挑选出最好的一张显卡。当我们调用<br>gpuGetMaxGflopsGLDeviceIdDRV()函数时，返回的值是最佳显卡的id值，此时我们再调用cuDeviceGet函数，将id值作为输入参数，即可得到该张显卡的设备句柄。</p><p>接着我们调用cuDeviceComputeCapability函数查看一下这张最佳显卡的算力情况，以及通过cuDeviceTotalMem返回设备上的内存总量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuDeviceComputeCapability</span><span class="params">(<span class="type">int</span> *major, <span class="type">int</span> *minor, CUdevice dev)</span></span>;</span><br><span class="line">tcuDeviceComputeCapability            *cuDeviceComputeCapability;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __CUDA_API_VERSION &gt;= 3020</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuDeviceTotalMem</span><span class="params">(<span class="type">size_t</span> *bytes, CUdevice dev)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuDeviceTotalMem</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *bytes, CUdevice dev)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">tcuDeviceTotalMem                     *cuDeviceTotalMem;</span><br></pre></td></tr></table></figure><h4 id="相关参数的具体设置："><a href="#相关参数的具体设置：" class="headerlink" title="相关参数的具体设置："></a>相关参数的具体设置：</h4><h5 id="major、minor：："><a href="#major、minor：：" class="headerlink" title="major、minor：："></a>major、minor：：</h5><p>在major和minor中返回定义设备dev计算能力的主要和次要修订号</p><h5 id="dev：-1"><a href="#dev：-1" class="headerlink" title="dev："></a>dev：</h5><p>设备句柄</p><h3 id="2-2-2-创建CUDA上下文"><a href="#2-2-2-创建CUDA上下文" class="headerlink" title="2.2.2 创建CUDA上下文"></a>2.2.2 创建CUDA上下文</h3><p>当我们完成上面步骤后，我们就可以创建CUDA上下文咯！</p><p>在低CUDA版本我们需要将这张显卡与OpenGL的互操作性创建CUDA上下文，此时调用cuGLCtxCreate函数进行最终的CUDA上下文的创建</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult CUDAAPI <span class="title">tcuGLCtxCreate</span><span class="params">(CUcontext *pCtx, <span class="type">unsigned</span> <span class="type">int</span> Flags, CUdevice device)</span></span>;</span><br><span class="line">tcuGLCtxCreate                        *cuGLCtxCreate;</span><br></pre></td></tr></table></figure><h4 id="相关参数的具体设置：-1"><a href="#相关参数的具体设置：-1" class="headerlink" title="相关参数的具体设置："></a>相关参数的具体设置：</h4><h5 id="pCtx："><a href="#pCtx：" class="headerlink" title="pCtx："></a>pCtx：</h5><p>返回所创建的CUDA上下文</p><h5 id="Flags：-1"><a href="#Flags：-1" class="headerlink" title="Flags："></a>Flags：</h5><p>CUDA 上下文创建选项，默认输入：CU_CTX_SCHED_BLOCKING_SYNC</p><h5 id="CUdevice："><a href="#CUdevice：" class="headerlink" title="CUdevice："></a>CUdevice：</h5><p>创建的上下文的设备句柄</p><p>在Nvidia的cuda<a href="https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1g931f6d260d7db412b37497cb4b2fdf5d">操作文档</a>中也有写到：</p><h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="Deprecated"></a>Deprecated</h4><p>This function is deprecated as of Cuda 3.0.</p><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>Maps the buffer object specified by buffer into the address space of the current CUDA context and returns in *dptr and *size the base pointer and size of the resulting mapping.</p><p>There must be a valid OpenGL context bound to the current thread when this function is called. This must be the same context, or a member of the same shareGroup, as the context that was bound when the buffer was registered.</p><p>All streams in the current CUDA context are synchronized with the current GL context.</p><h4 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h4><p>Note that this function may also return error codes from previous, asynchronous launches.</p><p>因此在CUDA版本大于5的时候，我们就不需要专门去调用这个接口了，而是直接采用cuCtxCreate接口进行上下文创建：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuCtxCreate</span><span class="params">(CUcontext *pctx, <span class="type">unsigned</span> <span class="type">int</span> flags, CUdevice dev)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> tcuCtxCreate                    *cuCtxCreate;</span><br></pre></td></tr></table></figure><h4 id="相关参数的具体设置：-2"><a href="#相关参数的具体设置：-2" class="headerlink" title="相关参数的具体设置："></a>相关参数的具体设置：</h4><h5 id="pCtx：-1"><a href="#pCtx：-1" class="headerlink" title="pCtx："></a>pCtx：</h5><p>返回所创建的CUDA上下文</p><h5 id="Flags：-2"><a href="#Flags：-2" class="headerlink" title="Flags："></a>Flags：</h5><p>CUDA 上下文创建选项，默认输入：CU_CTX_SCHED_BLOCKING_SYNC</p><h5 id="CUdevice：-1"><a href="#CUdevice：-1" class="headerlink" title="CUdevice："></a>CUdevice：</h5><p>创建的上下文的设备句柄，也就是我们之前通过gpuGetMaxGflopsGLDeviceIdDRV拿到的最好设备的id号后，再将该id号作为输入参数设置到cuDeviceGet函数中得到的对应的dev值</p><h3 id="2-2-3-验证CUDA上下文是否成功创建以及当前上下文可用的内存总量是否充足"><a href="#2-2-3-验证CUDA上下文是否成功创建以及当前上下文可用的内存总量是否充足" class="headerlink" title="2.2.3 验证CUDA上下文是否成功创建以及当前上下文可用的内存总量是否充足"></a>2.2.3 验证CUDA上下文是否成功创建以及当前上下文可用的内存总量是否充足</h3><p>按道理，此时我们已经完成了CUDA上下文的创建，但是为了保险起见，我们还需要验证一下</p><p>接着从当前CPU线程中弹出当前CUDA上下文，看一下是否已经成功创建了，如果成功的话，我们再将其push进去。</p><p>cuCtxPushCurrent():将给定的上下文ctx推送到CPU线程的当前上下文堆栈中。指定的上下文成为CPU线程的当前上下文，因此所有对当前上下文进行操作的CUDA函数都会受到影响。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuCtxPopCurrent</span><span class="params">(CUcontext *pctx)</span></span>;</span><br><span class="line">tcuCtxPopCurrent                      *cuCtxPopCurrent;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuCtxPushCurrent</span><span class="params">(CUcontext ctx)</span></span>;</span><br><span class="line">tcuCtxPushCurrent                     *cuCtxPushCurrent;</span><br></pre></td></tr></table></figure><p>然后我们通过cuMemGetInfo函数得到可用内存和总内存（以字节为单位）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult CUDAAPI <span class="title">tcuMemGetInfo</span><span class="params">(<span class="type">size_t</span> *free, <span class="type">size_t</span> *total)</span></span>;</span><br><span class="line">tcuMemGetInfo                         *cuMemGetInfo;</span><br></pre></td></tr></table></figure><p>在total中返回当前上下文可用的内存总量。在free中返回设备上根据操作系统空闲的内存量。不保证 CUDA 能够分配操作系统报告为空闲的所有内存。在多原则的情况下，返回的空闲估计容易出现竞争条件，在估计和报告空闲内存之间由不同进程或同一进程中的不同线程完成的新分配&#x2F;释放，将导致偏差报告的可用值和实际可用内存。</p><p>Tegra 上的集成 GPU 与 CPU 和 SoC 的其他组件共享内存。API 返回的可用值和总值不包括某些平台上操作系统维护的 SWAP 内存空间。当 GPU 或 CPU 分配或访问内存时，操作系统可能会将一些内存页面移动到交换区域。请参阅 Tegra 应用说明，了解如何计算 Tegra 上的总内存和可用内存。</p><p>当满足可用内存不小于300<em>1024</em>1024，总内存不小于512 <em>1024</em>1024时，我们认为此时是足够用的（这边可以用if语句来判断，满足则返回true，不满足则返回false）。</p><p>此时为了为了方便多线程实现，我们调用dynlink_nvcuvid.h中的cuvidCtxLockCreate函数来进行上下文的锁定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult CUDAAPI <span class="title">tcuvidCtxLockCreate</span><span class="params">(CUvideoctxlock *pLock, CUcontext ctx)</span></span>;</span><br><span class="line">tcuvidCtxLockCreate                   *cuvidCtxLockCreate;</span><br></pre></td></tr></table></figure><h2 id="2-3-查询硬件解码器解码能力"><a href="#2-3-查询硬件解码器解码能力" class="headerlink" title="2.3 查询硬件解码器解码能力"></a>2.3 查询硬件解码器解码能力</h2><p>不同的GPU包含不同的能力. 因此，为了确保你的应用能在所有的GPU硬件上运行，很有必要查询硬件能力(当然你也可以调过这个流程，反正解不了就崩嘛，没啥区别)，然后根据所需的能力是否满足进行合适的操作</p><p>可以参考NVIDIA的Video_Codec_SDK中的NvDecoder.cpp中的HandleVideoSequence函数内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">CUVIDDECODECAPS decodecaps;</span><br><span class="line"><span class="built_in">memset</span>(&amp;decodecaps, <span class="number">0</span>, <span class="built_in">sizeof</span>(decodecaps));</span><br><span class="line"></span><br><span class="line">decodecaps.eCodecType = pVideoFormat-&gt;codec;</span><br><span class="line">decodecaps.eChromaFormat = pVideoFormat-&gt;chroma_format;</span><br><span class="line">decodecaps.nBitDepthMinus8 = pVideoFormat-&gt;bit_depth_luma_minus8;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPushCurrent</span>(m_cuContext)); <span class="comment">//启用context</span></span><br><span class="line"><span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidGetDecoderCaps</span>(&amp;decodecaps));</span><br><span class="line"><span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!decodecaps.bIsSupported)&#123;</span><br><span class="line">    <span class="built_in">NVDEC_THROW_ERROR</span>(<span class="string">&quot;Codec not supported on this GPU&quot;</span>, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">    <span class="keyword">return</span> nDecodeSurface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pVideoFormat-&gt;coded_width &gt; decodecaps.nMaxWidth) ||</span><br><span class="line">    (pVideoFormat-&gt;coded_height &gt; decodecaps.nMaxHeight))&#123;</span><br><span class="line"></span><br><span class="line">    std::ostringstream errorString;</span><br><span class="line">    errorString &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;Resolution          : &quot;</span> &lt;&lt; pVideoFormat-&gt;coded_width &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; pVideoFormat-&gt;coded_height &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;Max Supported (wxh) : &quot;</span> &lt;&lt; decodecaps.nMaxWidth &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; decodecaps.nMaxHeight &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;Resolution not supported on this GPU&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::string cErr = errorString.<span class="built_in">str</span>();</span><br><span class="line">    <span class="built_in">NVDEC_THROW_ERROR</span>(cErr, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">    <span class="keyword">return</span> nDecodeSurface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pVideoFormat-&gt;coded_width&gt;&gt;<span class="number">4</span>)*(pVideoFormat-&gt;coded_height&gt;&gt;<span class="number">4</span>) &gt; decodecaps.nMaxMBCount)&#123;</span><br><span class="line"></span><br><span class="line">    std::ostringstream errorString;</span><br><span class="line">    errorString &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;MBCount             : &quot;</span> &lt;&lt; (pVideoFormat-&gt;coded_width &gt;&gt; <span class="number">4</span>)*(pVideoFormat-&gt;coded_height &gt;&gt; <span class="number">4</span>) &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;Max Supported mbcnt : &quot;</span> &lt;&lt; decodecaps.nMaxMBCount &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;MBCount not supported on this GPU&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::string cErr = errorString.<span class="built_in">str</span>();</span><br><span class="line">    <span class="built_in">NVDEC_THROW_ERROR</span>(cErr, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">    <span class="keyword">return</span> nDecodeSurface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_nWidth &amp;&amp; m_nLumaHeight &amp;&amp; m_nChromaHeight) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cuvidCreateDecoder() has been called before, and now there&#x27;s possible config change</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ReconfigureDecoder</span>(pVideoFormat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// eCodec has been set in the constructor (for parser). Here it&#x27;s set again for potential correction</span></span><br><span class="line">m_eCodec = pVideoFormat-&gt;codec;</span><br><span class="line">m_eChromaFormat = pVideoFormat-&gt;chroma_format;</span><br><span class="line">m_nBitDepthMinus8 = pVideoFormat-&gt;bit_depth_luma_minus8;</span><br><span class="line">m_nBPP = m_nBitDepthMinus8 &gt; <span class="number">0</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the output surface format same as chroma format</span></span><br><span class="line"><span class="keyword">if</span> (m_eChromaFormat == cudaVideoChromaFormat_420 || cudaVideoChromaFormat_Monochrome)</span><br><span class="line">    m_eOutputFormat = pVideoFormat-&gt;bit_depth_luma_minus8 ? cudaVideoSurfaceFormat_P016 : cudaVideoSurfaceFormat_NV12;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_eChromaFormat == cudaVideoChromaFormat_444)</span><br><span class="line">    m_eOutputFormat = pVideoFormat-&gt;bit_depth_luma_minus8 ? cudaVideoSurfaceFormat_YUV444_16Bit : cudaVideoSurfaceFormat_YUV444;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_eChromaFormat == cudaVideoChromaFormat_422)</span><br><span class="line">    m_eOutputFormat = cudaVideoSurfaceFormat_NV12;  <span class="comment">// no 4:2:2 output format supported yet so make 420 default</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if output format supported. If not, check falback options</span></span><br><span class="line"><span class="keyword">if</span> (!(decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; m_eOutputFormat)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_NV12))</span><br><span class="line">        m_eOutputFormat = cudaVideoSurfaceFormat_NV12;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_P016))</span><br><span class="line">        m_eOutputFormat = cudaVideoSurfaceFormat_P016;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_YUV444))</span><br><span class="line">        m_eOutputFormat = cudaVideoSurfaceFormat_YUV444;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_YUV444_16Bit))</span><br><span class="line">        m_eOutputFormat = cudaVideoSurfaceFormat_YUV444_16Bit;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">NVDEC_THROW_ERROR</span>(<span class="string">&quot;No supported output format found&quot;</span>, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">&#125;</span><br><span class="line">m_videoFormat = *pVideoFormat;</span><br></pre></td></tr></table></figure><h2 id="2-4-创建解码器实例"><a href="#2-4-创建解码器实例" class="headerlink" title="2.4 创建解码器实例"></a>2.4 创建解码器实例</h2><p>分为两个部分：</p><ul><li>CUVIDDECODECREATEINFO信息的获取</li><li>创建视频解码器</li></ul><h3 id="2-4-1-CUVIDDECODECREATEINFO信息的获取"><a href="#2-4-1-CUVIDDECODECREATEINFO信息的获取" class="headerlink" title="2.4.1 CUVIDDECODECREATEINFO信息的获取"></a>2.4.1 CUVIDDECODECREATEINFO信息的获取</h3><p>首先我们需要进行CUVIDDECODECREATEINFO信息的填充。CUVIDDECODECREATEINFO结构如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* \struct CUVIDDECODECREATEINFO</span></span><br><span class="line"><span class="comment">* Struct used in create decoder</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CUVIDDECODECREATEINFO</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulWidth;              <span class="comment">/**&lt; Coded Sequence Width */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulHeight;             <span class="comment">/**&lt; Coded Sequence Height */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulNumDecodeSurfaces;  <span class="comment">/**&lt; Maximum number of internal decode surfaces */</span></span><br><span class="line">    cudaVideoCodec CodecType;           <span class="comment">/**&lt; cudaVideoCodec_XXX */</span></span><br><span class="line">    cudaVideoChromaFormat ChromaFormat; <span class="comment">/**&lt; cudaVideoChromaFormat_XXX (only 4:2:0 is currently supported) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulCreationFlags;      <span class="comment">/**&lt; Decoder creation flags (cudaVideoCreateFlags_XXX解析器的创建;         /**&lt; Reserved for future use - set to zero */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * area of the frame thcuvidCreateDecoderat should be displayed</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">short</span> left;</span><br><span class="line">        <span class="type">short</span> top;</span><br><span class="line">        <span class="type">short</span> right;</span><br><span class="line">        <span class="type">short</span> bottom;</span><br><span class="line">    &#125; display_area;</span><br><span class="line">    cudaVideoSurfaceFormat OutputFormat;       <span class="comment">/**&lt; cudaVideoSurfaceFormat_XXX */</span></span><br><span class="line">    cudaVideoDeinterlaceMode DeinterlaceMode;  <span class="comment">/**&lt; cudaVideoDeinterlaceMode_XXX */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulTargetWidth;               <span class="comment">/**&lt; Post-processed Output Width (Should be aligned to 2) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulTargetHeight;              <span class="comment">/**&lt; Post-processed Output Height (Should be aligbed to 2) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulNumOutputSurfaces;         <span class="comment">/**&lt; Maximum number of output surfaces simultaneously mapped */</span></span><br><span class="line">    CUvideoctxlock vidLock;                    <span class="comment">/**&lt; If non-NULL, context lock used for synchronizing ownership of the cuda context */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * target rectangle in the output frame (for aspect ratio conversion)</span></span><br><span class="line"><span class="comment">    * if a null rectangle is specified, &#123;0,0,ulTargetWidth,ulTargetHeight&#125; will be used</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">short</span> left;</span><br><span class="line">        <span class="type">short</span> top;</span><br><span class="line">        <span class="type">short</span> right;</span><br><span class="line">        <span class="type">short</span> bottom;</span><br><span class="line">    &#125; target_rect;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> Reserved2[<span class="number">5</span>];                <span class="comment">/**&lt; Reserved for future use - set to zero */</span></span><br><span class="line">&#125; CUVIDDECODECREATEINFO;</span><br></pre></td></tr></table></figure><h4 id="相关参数具体设置："><a href="#相关参数具体设置：" class="headerlink" title="相关参数具体设置："></a>相关参数具体设置：</h4><h5 id="ulWidth、ulHeight："><a href="#ulWidth、ulHeight：" class="headerlink" title="ulWidth、ulHeight："></a>ulWidth、ulHeight：</h5><p>通过解码得到的视频流信息来获取，与视频文件的宽高保持一致</p><h5 id="ulNumDecodeSurfaces："><a href="#ulNumDecodeSurfaces：" class="headerlink" title="ulNumDecodeSurfaces："></a>ulNumDecodeSurfaces：</h5><p>默认值为：MAX_FRAME_COUNT（这是驱动程序将在内部分配用于存储解码帧的表面数。使用更高的数字可确保更好的流水线，但会增加 GPU 内存消耗。为了正确操作，最小值定义在 CUVIDEOFORMAT::min_num_decode_surfaces并且可以从 Nvidia 解析器的第一个序列回调中获得。NVDEC 引擎将解码数据写入这些表面之一。NVDECODE API 的用户无法访问这些表面，但 映射阶段（包括解码器输出格式转换、缩放、裁剪等）使用这些表面作为输入表面。）</p><h5 id="CodecType："><a href="#CodecType：" class="headerlink" title="CodecType："></a>CodecType：</h5><p>CodecType需要根据文件的FourCC来进行确认。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* \enum cudaVideoCodec</span></span><br><span class="line"><span class="comment">* Video Codec Enums</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">cudaVideoCodec_enum</span> &#123;</span><br><span class="line">    cudaVideoCodec_MPEG1=<span class="number">0</span>,                 <span class="comment">/**&lt;  MPEG1   */</span></span><br><span class="line">    cudaVideoCodec_MPEG2, <span class="number">4</span>                  <span class="comment">/**&lt;  HEVC   */</span></span><br><span class="line">    cudaVideoCodec_VP8,                     <span class="comment">/**&lt;  VP8   */</span></span><br><span class="line">    cudaVideoCodec_VP9,                     <span class="comment">/**&lt;  VP9   */</span></span><br><span class="line">    cudaVideoCodec_NumCodecs,               <span class="comment">/**&lt;  Max COdecs   */</span></span><br><span class="line">    <span class="comment">// Uncompressed YUV</span></span><br><span class="line">    cudaVideoCodec_YUV420 = ((<span class="string">&#x27;I&#x27;</span>&lt;&lt;<span class="number">24</span>)|(<span class="string">&#x27;Y&#x27;</span>&lt;&lt;<span class="number">16</span>)|(<span class="string">&#x27;U&#x27;</span>&lt;&lt;<span class="number">8</span>)|(<span class="string">&#x27;V&#x27;</span>)),   <span class="comment">/**&lt; Y,U,V (4:2:0)  */</span></span><br><span class="line">    cudaVideoCodec_YV12   = ((<span class="string">&#x27;Y&#x27;</span>&lt;&lt;<span class="number">24</span>)|(<span class="string">&#x27;V&#x27;</span>&lt;&lt;<span class="number">16</span>)|(<span class="string">&#x27;1&#x27;</span>&lt;&lt;<span class="number">8</span>)|(<span class="string">&#x27;2&#x27;</span>)),   <span class="comment">/**&lt; Y,V,U (4:2:0)  */</span></span><br><span class="line">    cudaVideoCodec_NV12   = ((<span class="string">&#x27;N&#x27;</span>&lt;&lt;<span class="number">24</span>)|(<span class="string">&#x27;V&#x27;</span>&lt;&lt;<span class="number">16</span>)|(<span class="string">&#x27;1&#x27;</span>&lt;&lt;<span class="number">8</span>)|(<span class="string">&#x27;2&#x27;</span>)),   <span class="comment">/**&lt; Y,UV  (4:2:0)  */</span></span><br><span class="line">    cudaVideoCodec_YUYV   = ((<span class="string">&#x27;Y&#x27;</span>&lt;&lt;<span class="number">24</span>)|(<span class="string">&#x27;U&#x27;</span>&lt;&lt;<span class="number">16</span>)|(<span class="string">&#x27;Y&#x27;</span>&lt;&lt;<span class="number">8</span>)|(<span class="string">&#x27;V&#x27;</span>)),   <span class="comment">/**&lt; YUYV/YUY2 (4:2:2)  */</span></span><br><span class="line">    cudaVideoCodec_UYVY   = ((<span class="string">&#x27;U&#x27;</span>&lt;&lt;<span class="number">24</span>)|(<span class="string">&#x27;Y&#x27;</span>&lt;&lt;<span class="number">16</span>)|(<span class="string">&#x27;V&#x27;</span>&lt;&lt;<span class="number">8</span>)|(<span class="string">&#x27;Y&#x27;</span>))    <span class="comment">/**&lt; UYVY (4:2:2)  */</span></span><br><span class="line">&#125; cudaVideoCodec;</span><br></pre></td></tr></table></figure><p>我们一般只需要通过FourCC来区分Cuda支持的这四种解码类型：</p><ul><li>H264（FourCC:’462H’、’462T’、’462X’、’ CVA’、’1CVA’、’1cva’）</li><li>H265（FourCC:’2VPM’）</li><li>MPEG2（FourCC:’CVEH’）</li><li>VP9（FourCC:’ 9PV’）</li></ul><p>其余的根据实际应用场景也可以进行适当的增加。</p><h5 id="ChromaFormat："><a href="#ChromaFormat：" class="headerlink" title="ChromaFormat："></a>ChromaFormat：</h5><p>默认设置为：cudaVideoChromaFormat_420</p><h5 id="ulCreationFlags："><a href="#ulCreationFlags：" class="headerlink" title="ulCreationFlags："></a>ulCreationFlags：</h5><p>默认设置为：cudaVideoCreate_PreferCUVID</p><p>接下来是CUVIDDECODECREATEINFO内一些输出格式的相关参数设置</p><h5 id="OutputFormat："><a href="#OutputFormat：" class="headerlink" title="OutputFormat："></a>OutputFormat：</h5><p>默认设置为：cudaVideoSurfaceFoCreatOpenGLTextruermat_NV12</p><h5 id="DeinterlaceMode："><a href="#DeinterlaceMode：" class="headerlink" title="DeinterlaceMode："></a>DeinterlaceMode：</h5><p>默认设置为：cudaVideoDeinterlaceMode_Weave</p><h5 id="bitDepthMinus8："><a href="#bitDepthMinus8：" class="headerlink" title="bitDepthMinus8："></a>bitDepthMinus8：</h5><p>该参数需要根据文件的bitdepth来进行设置。<br>如果不小30,设置为2,否则设置为0</p><h5 id="ulTargetWidth，ulTargetHeight："><a href="#ulTargetWidth，ulTargetHeight：" class="headerlink" title="ulTargetWidth，ulTargetHeight："></a>ulTargetWidth，ulTargetHeight：</h5><p>ulTargetWidth，ulTargetHeight与ulWidth、ulHeight的值一致<br>即：ulTargetWidth &#x3D; ulWidth；ulTargetWidth &#x3D; ulHeight；</p><h5 id="ulNumOutputSurfaces："><a href="#ulNumOutputSurfaces：" class="headerlink" title="ulNumOutputSurfaces："></a>ulNumOutputSurfaces：</h5><p>默认为2（这是用户将同时映射到解码表面以进行进一步处理 的输出表面的最大数量cuvidMapVideoFrame()。这些表面具有经过后处理的解码输出以供用户使用。驱动程序在内部分配相应数量的表面。用户将有权访问输出表面。请参阅准备解码帧以进行进一步处理以了解map的定义。）</p><h5 id="vidLock："><a href="#vidLock：" class="headerlink" title="vidLock："></a>vidLock：</h5><p>该参数值为之前调用cuvidCtxLockCreate函数得到的pLock</p><h4 id="target-rect"><a href="#target-rect" class="headerlink" title="target_rect:"></a>target_rect:</h4><p>arget_rect.left &#x3D; 0;<br>target_rect.top &#x3D; 0;<br>target_rect.right &#x3D; ulWidth;<br>target_rect.bottom &#x3D; ulHeight;</p><p><a href="https://www.ffmpeg.org/doxygen/3.3/structCUVIDDECODECREATEINFO.html">CUVIDDECODECREATEINFO 结构参考</a></p><h3 id="2-4-2-创建视频解码器"><a href="#2-4-2-创建视频解码器" class="headerlink" title="2.4.2 创建视频解码器"></a>2.4.2 创建视频解码器</h3><p>然后调用cuvidCreateDecoder进行解码器的创建</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult CUDAAPI <span class="title">tcuvidCreateDecoder</span><span class="params">(CUvideodecoder *phDecoder, CUVIDDECODECREATEINFO *pdci)</span></span>;</span><br><span class="line">tcuvidCreateDecoder                   *cuvidCreateDecoder;</span><br></pre></td></tr></table></figure><h2 id="2-5-使用第三方软件-如FFMPEG-进行Demux"><a href="#2-5-使用第三方软件-如FFMPEG-进行Demux" class="headerlink" title="2.5 使用第三方软件(如FFMPEG)进行Demux"></a>2.5 使用第三方软件(如FFMPEG)进行Demux</h2><p>分为以下几个步骤：</p><ul><li>获取MediaInfo信息</li><li>创建解复用器</li><li>拿到额外数据信息</li><li>根据FourCC创建对应的硬件解码器</li><li>将其Seek到初始位置0<br>在Nvidia官方的<a href="https://docs.nvidia.com/video-technologies/video-codec-sdk/nvdec-video-decoder-api-prog-guide/index.html">NVDEC API</a>指南中，它采用的是cuvidCreateVideoParser()来创建解析器，而在我们实际的工程开发过程中，我们一般都是采用FFMPEG来进行音视频文件的Demux．<br>因此在解复用器这一块，我们以调用FFmpeg的API为准．<br>而调用FFmpeg进行Demux的基本流程可以参考NVIDIA的Video_Codec_SDK示例AppDecGL中FFmpegDemuxer类的创建:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Demux 解析,获得每一帧码流的数据存在pVideo中,nVideoBytes为数据的字节数</span></span><br><span class="line"><span class="comment">//Demux将pVideo存储的地址值改变为pkt.data，即改变了pVideo指向的地址！！！</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Demux</span><span class="params">(<span class="type">uint8_t</span> **ppVideo, <span class="type">int</span> *pnVideoBytes, <span class="type">int64_t</span> *pts = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!fmtc) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *pnVideoBytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pkt.data) &#123;</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(&amp;pkt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> e = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = <span class="built_in">av_read_frame</span>(fmtc, &amp;pkt)) &gt;= <span class="number">0</span> &amp;&amp; pkt.stream_index != iVideoStream) &#123;</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(&amp;pkt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bMp4H264 || bMp4HEVC) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pktFiltered.data) &#123;</span><br><span class="line">                <span class="built_in">av_packet_unref</span>(&amp;pktFiltered);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ck</span>(<span class="built_in">av_bsf_send_packet</span>(bsfc, &amp;pkt));</span><br><span class="line">            <span class="built_in">ck</span>(<span class="built_in">av_bsf_receive_packet</span>(bsfc, &amp;pktFiltered));</span><br><span class="line">            *ppVideo = pktFiltered.data;</span><br><span class="line">            *pnVideoBytes = pktFiltered.size;</span><br><span class="line">            <span class="keyword">if</span> (pts)</span><br><span class="line">                *pts = (<span class="type">int64_t</span>) (pktFiltered.pts * userTimeScale * timeBase);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bMp4MPEG4 &amp;&amp; (frameCount == <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> extraDataSize = fmtc-&gt;streams[iVideoStream]-&gt;codecpar-&gt;extradata_size;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (extraDataSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// extradata contains start codes 00 00 01. Subtract its size</span></span><br><span class="line">                    pDataWithHeader = (<span class="type">uint8_t</span> *)<span class="built_in">av_malloc</span>(extraDataSize + pkt.size - <span class="number">3</span>*<span class="built_in">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!pDataWithHeader) &#123;</span><br><span class="line">                        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;FFmpeg error: &quot;</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; __LINE__;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">memcpy</span>(pDataWithHeader, fmtc-&gt;streams[iVideoStream]-&gt;codecpar-&gt;extradata, extraDataSize);</span><br><span class="line">                    <span class="built_in">memcpy</span>(pDataWithHeader+extraDataSize, pkt.data+<span class="number">3</span>, pkt.size - <span class="number">3</span>*<span class="built_in">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line"></span><br><span class="line">                    *ppVideo = pDataWithHeader;</span><br><span class="line">                    *pnVideoBytes = extraDataSize + pkt.size - <span class="number">3</span>*<span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *ppVideo = pkt.data;</span><br><span class="line">                *pnVideoBytes = pkt.size;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pts)</span><br><span class="line">                *pts = (<span class="type">int64_t</span>)(pkt.pts * userTimeScale * timeBase);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        frameCount++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ReadPacket</span><span class="params">(<span class="type">void</span> *opaque, <span class="type">uint8_t</span> *pBuf, <span class="type">int</span> nBuf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((DataProvider *)opaque)-&gt;<span class="built_in">GetData</span>(pBuf, nBuf);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-6-使用NVDECODE-API提供的解析器或第三方解析器（如FFmpeg）解析视频比特流"><a href="#2-6-使用NVDECODE-API提供的解析器或第三方解析器（如FFmpeg）解析视频比特流" class="headerlink" title="2.6 使用NVDECODE API提供的解析器或第三方解析器（如FFmpeg）解析视频比特流"></a>2.6 使用NVDECODE API提供的解析器或第三方解析器（如FFmpeg）解析视频比特流</h2><p>在这里直接采用的是NVDECODE API提供的解析器来解析视频比特流．</p><p>分为以下几个部分：</p><ul><li>CUVIDPARSERPARAMS信息的获取</li><li>相关回调函数的设计</li><li>解析器的创建</li><li>从解复用器提取数据包进行解码</li></ul><h3 id="2-6-1-CUVIDPARSERPARAMS信息的获取"><a href="#2-6-1-CUVIDPARSERPARAMS信息的获取" class="headerlink" title="2.6.1 CUVIDPARSERPARAMS信息的获取"></a>2.6.1 CUVIDPARSERPARAMS信息的获取</h3><p>首先创建一个CUVIDPARSERPARAMS类型的变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dynlink_nvcuvid.h文件中定义</span></span><br><span class="line"><span class="comment">/***********************************************************************************************************************/</span></span><br><span class="line"><span class="comment">//! Parser callbacks</span></span><br><span class="line"><span class="comment">//! The parser will call these synchronously from within cuvidParseVideoData(), whenever there is sequence change or a picture</span></span><br><span class="line"><span class="comment">//! is ready to be decoded and/or displayed. First argument in functions is &quot;void *pUserData&quot; member of structure CUVIDSOURCEPARAMS</span></span><br><span class="line"><span class="comment">//! Return values from these callbacks are interpreted as below. If the callbacks return failure, it will be propagated by</span></span><br><span class="line"><span class="comment">//! cuvidParseVideoData() to the application.</span></span><br><span class="line"><span class="comment">//! Parser picks default operating point as 0 and outputAllLayers flag as 0 if PFNVIDOPPOINTCALLBACK is not set or return value is</span></span><br><span class="line"><span class="comment">//! -1 or invalid operating point.</span></span><br><span class="line"><span class="comment">//! PFNVIDSEQUENCECALLBACK : 0: fail, 1: succeeded, &gt; 1: override dpb size of parser (set by CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces</span></span><br><span class="line"><span class="comment">//! while creating parser)</span></span><br><span class="line"><span class="comment">//! PFNVIDDECODECALLBACK   : 0: fail, &gt;=1: succeeded</span></span><br><span class="line"><span class="comment">//! PFNVIDDISPLAYCALLBACK  : 0: fail, &gt;=1: succeeded</span></span><br><span class="line"><span class="comment">//! PFNVIDOPPOINTCALLBACK  : &lt;0: fail, &gt;=0: succeeded (bit 0-9: OperatingPoint, bit 10-10: outputAllLayers, bit 11-30: reserved)</span></span><br><span class="line"><span class="comment">//! PFNVIDSEIMSGCALLBACK   : 0: fail, &gt;=1: succeeded</span></span><br><span class="line"><span class="comment">/***********************************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(CUDAAPI *PFNVIDSEQUENCECALLBACK)</span><span class="params">(<span class="type">void</span> *, CUVIDEOFORMAT *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(CUDAAPI *PFNVIDDECODECALLBACK)</span><span class="params">(<span class="type">void</span> *, CUVIDPICPARAMS *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(CUDAAPI *PFNVIDDISPLAYCALLBACK)</span><span class="params">(<span class="type">void</span> *, CUVIDPARSERDISPINFO *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(CUDAAPI *PFNVIDOPPOINTCALLBACK)</span><span class="params">(<span class="type">void</span> *, CUVIDOPERATINGPOINTINFO*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(CUDAAPI *PFNVIDSEIMSGCALLBACK)</span> <span class="params">(<span class="type">void</span> *, CUVIDSEIMESSAGEINFO *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CUVIDPARSERPARAMS</span></span><br><span class="line">&#123;</span><br><span class="line">    cudaVideoCodec CodecType;                   <span class="comment">/**&lt; IN: cudaVideoCodec_XXX                                                  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ulMaxNumDecodeSurfaces;        <span class="comment">/**&lt; IN: Max # of decode surfaces (parser will cycle through these)          */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ulClockRate;                   <span class="comment">/**&lt; IN: Timestamp units in Hz (0=default=10000000Hz)                        */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ulErrorThreshold;              <span class="comment">/**&lt; IN: % Error threshold (0-100) for calling pfnDecodePicture (100=always</span></span><br><span class="line"><span class="comment">                                                     IN: call pfnDecodePicture even if picture bitstream is fully corrupted) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ulMaxDisplayDelay;             <span class="comment">/**&lt; IN: Max display queue delay (improves pipelining of decode with display)</span></span><br><span class="line"><span class="comment">                                                         0=no delay (recommended values: 2..4)                               */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bAnnexb : <span class="number">1</span>;                   <span class="comment">/**&lt; IN: AV1 annexB stream                                                   */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uReserved : <span class="number">31</span>;                <span class="comment">/**&lt; Reserved for future use - set to zero                                   */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uReserved1[<span class="number">4</span>];                 <span class="comment">/**&lt; IN: Reserved for future use - set to 0                                  */</span></span><br><span class="line">    <span class="type">void</span> *pUserData;                            <span class="comment">/**&lt; IN: User data for callbacks                                             */</span></span><br><span class="line">    PFNVIDSEQUENCECALLBACK pfnSequenceCallback; <span class="comment">/**&lt; IN: Called before decoding frames and/or whenever there is a fmt change */</span></span><br><span class="line">    PFNVIDDECODECALLBACK pfnDecodePicture;      <span class="comment">/**&lt; IN: Called when a picture is ready to be decoded (decode order)         */</span></span><br><span class="line">    PFNVIDDISPLAYCALLBACK pfnDisplayPicture;    <span class="comment">/**&lt; IN: Called whenever a picture is ready to be displayed (display order)  */</span></span><br><span class="line">    PFNVIDOPPOINTCALLBACK pfnGetOperatingPoint; <span class="comment">/**&lt; IN: Called from AV1 sequence header to get operating point of a AV1</span></span><br><span class="line"><span class="comment">                                                         scalable bitstream                                                  */</span></span><br><span class="line">    PFNVIDSEIMSGCALLBACK pfnGetSEIMsg;          <span class="comment">/**&lt; IN: Called when all SEI messages are parsed for particular frame        */</span></span><br><span class="line">    <span class="type">void</span> *pvReserved2[<span class="number">5</span>];                       <span class="comment">/**&lt; Reserved for future use - set to NULL                                   */</span></span><br><span class="line">    CUVIDEOFORMATEX *pExtVideoInfo;             <span class="comment">/**&lt; IN: [Optional] sequence header data from system layer                   */</span></span><br><span class="line">&#125; CUVIDPARSERPARAMS;</span><br></pre></td></tr></table></figure><h4 id="相关参数具体设置：-1"><a href="#相关参数具体设置：-1" class="headerlink" title="相关参数具体设置："></a>相关参数具体设置：</h4><h5 id="CodecType"><a href="#CodecType" class="headerlink" title="CodecType"></a>CodecType</h5><p>与前面的CUVIDDECODECREATEINFO中的CodecType保持一致（必须来自枚举 cudaVideoCodec, 指示内容的编解码器类型，如 H.264、HEVC、VP9 等）</p><h5 id="ulMaxNumDecodeSurfaces"><a href="#ulMaxNumDecodeSurfaces" class="headerlink" title="ulMaxNumDecodeSurfaces"></a>ulMaxNumDecodeSurfaces</h5><p>与前面的CUVIDDECODECREATEINFO中的ulNumDecodeSurfaces保持一致（这是解析器的 DPB（解码图片缓冲区）中的表面数。该值在解析器初始化时可能是未知的，可以将其设置为虚拟数字（如 1）以创建解析器对象。应用程序必须注册回调pfn序列回调与驱动程序一起使用，当解析器遇到第一个序列头或序列中的任何更改时，解析器将调用它。此回调报告解析器的 DPB 正确解码所需的最小表面数 CUVIDEOFORMAT::min_num_decode_surfaces. 如果想要更新，序列回调可能会将此值返回给解析器 CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces. 然后解析器覆盖CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces与序列回调返回的值，如果序列回调的返回值大于 1（见说明pfn序列回调以下）。因此，为了优化内存分配，解码器对象的创建应该推迟到CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces是已知的，因此可以使用所需数量的缓冲区创建解码器对象，这样 CUVIDDECODECREATEINFO::ulNumDecodeSurfaces&#x3D; CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces）</p><h5 id="ulClockRate："><a href="#ulClockRate：" class="headerlink" title="ulClockRate："></a>ulClockRate：</h5><p>默认为0</p><h5 id="ulErrorThreshold"><a href="#ulErrorThreshold" class="headerlink" title="ulErrorThreshold"></a>ulErrorThreshold</h5><p>默认为0</p><h5 id="ulMaxDisplayDelay"><a href="#ulMaxDisplayDelay" class="headerlink" title="ulMaxDisplayDelay"></a>ulMaxDisplayDelay</h5><p>最大显示回调延迟。0 &#x3D; 无延迟，一设置0或者1,稳妥点也可以设置为2</p><h5 id="uReserved1-5"><a href="#uReserved1-5" class="headerlink" title="uReserved1[5]"></a>uReserved1[5]</h5><p>默认全为0(0&#x3D;default&#x3D;10000000Hz)</p><h5 id="pUserData"><a href="#pUserData" class="headerlink" title="pUserData"></a>pUserData</h5><p>回调函数</p><h5 id="pfnSequenceCallback"><a href="#pfnSequenceCallback" class="headerlink" title="pfnSequenceCallback"></a>pfnSequenceCallback</h5><p>pfnSequenceCallback是parser解析到序列及图像参数信息时的回调函数，其传入的参数是parser解析好的视频参数，可以用于初始化解码器或重置解码器。<br>应用程序必须注册一个函数来处理任何序列更改。解析器为初始序列头或遇到视频格式更改时触发此回调。序列回调的返回值由驱动程序解释如下：</p><ul><li>0：失败</li><li>1：成功，但驱动程序不应覆盖 CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces</li><li>&gt;1：成功，驱动程序应该覆盖 CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces有了这个返回值</li></ul><h5 id="pfnDecodePicture"><a href="#pfnDecodePicture" class="headerlink" title="pfnDecodePicture"></a>pfnDecodePicture</h5><p>pfnDecodePicture是parser解析到视频编码数据后的回调函数，其传入的参数parser处理好待解码的视频编码数据，需要在该函数中调用decoder的接口进行解码操作。<br>当一帧的比特流数据准备就绪时，解析器触发此回调。在场图片的情况下，每个显示调用可能有两个解码调用，因为两个场构成一个帧。此回调的返回值解释为：</p><ul><li>0：失败</li><li>≥1：成功</li></ul><h5 id="pfnDisplayPicture"><a href="#pfnDisplayPicture" class="headerlink" title="pfnDisplayPicture"></a>pfnDisplayPicture</h5><p>pfnDisplayPicture是parser对解码后的数据处理的回调函数，可以在该回调中对已解码的数据进行获取（从显存到系统内存）并处理。<br>当显示顺序中的帧准备就绪时，解析器触发此回调。此回调的返回值解释为：</p><ul><li>0：失败</li><li>≥1：成功</li></ul><h5 id="pvReserved2"><a href="#pvReserved2" class="headerlink" title="pvReserved2"></a>pvReserved2</h5><p>默认为0</p><h5 id="pExtVideoInfo"><a href="#pExtVideoInfo" class="headerlink" title="pExtVideoInfo"></a>pExtVideoInfo</h5><p>默认为NULL</p><h5 id="pfnGetOperatingPoint（只针对avi）"><a href="#pfnGetOperatingPoint（只针对avi）" class="headerlink" title="pfnGetOperatingPoint（只针对avi）"></a>pfnGetOperatingPoint（只针对avi）</h5><h5 id="pfnGetSEIMsg-一般用不到"><a href="#pfnGetSEIMsg-一般用不到" class="headerlink" title="pfnGetSEIMsg(一般用不到)"></a>pfnGetSEIMsg(一般用不到)</h5><p>当一帧所有未注册的用户 SEI 消息或元数据 OBU 被解析时，解析器按解码顺序触发此回调。目前此回调支持 H264、HEVC 和 AV1 编解码器。此回调的返回值解释为：</p><ul><li>0：失败</li><li>≥1：成功</li></ul><h3 id="2-6-2-相关回调函数的设计"><a href="#2-6-2-相关回调函数的设计" class="headerlink" title="2.6.2 相关回调函数的设计"></a>2.6.2 相关回调函数的设计</h3><p>上面三个回调函数的设置的非常重要的，如果不清楚回调函数需要实现的具体内容，可以参考NVIDIA的Video_Codec_SDK中的NvDecoder.cpp的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">NvDecoder::<span class="built_in">NvDecoder</span>(CUcontext cuContext, <span class="type">bool</span> bUseDeviceFrame, cudaVideoCodec eCodec, <span class="type">bool</span> bLowLatency, </span><br><span class="line">    <span class="type">bool</span> bDeviceFramePitched, <span class="type">const</span> Rect *pCropRect, <span class="type">const</span> Dim *pResizeDim, <span class="type">int</span> maxWidth, <span class="type">int</span> maxHeight, <span class="type">unsigned</span> <span class="type">int</span> clkRate,</span><br><span class="line">    <span class="type">bool</span> force_zero_latency) :</span><br><span class="line">    <span class="built_in">m_cuContext</span>(cuContext), <span class="built_in">m_bUseDeviceFrame</span>(bUseDeviceFrame), <span class="built_in">m_eCodec</span>(eCodec), <span class="built_in">m_bDeviceFramePitched</span>(bDeviceFramePitched),</span><br><span class="line">    <span class="built_in">m_nMaxWidth</span> (maxWidth), <span class="built_in">m_nMaxHeight</span>(maxHeight), <span class="built_in">m_bForce_zero_latency</span>(force_zero_latency)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pCropRect) m_cropRect = *pCropRect;</span><br><span class="line">    <span class="keyword">if</span> (pResizeDim) m_resizeDim = *pResizeDim;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidCtxLockCreate</span>(&amp;m_ctxLock, cuContext));</span><br><span class="line"></span><br><span class="line">    decoderSessionID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CUVIDPARSERPARAMS：该接口用来创建VideoParser</span></span><br><span class="line">    <span class="comment">//主要参数是设置三个回调函数，实现对解析出来的数据的处理</span></span><br><span class="line">    CUVIDPARSERPARAMS videoParserParameters = &#123;&#125;;<span class="comment">//结构体</span></span><br><span class="line">    videoParserParameters.CodecType = eCodec; <span class="comment">//解码视频类型，如H264</span></span><br><span class="line">    videoParserParameters.ulMaxNumDecodeSurfaces = <span class="number">1</span>;<span class="comment">//解码表面的最大数量（解析器将循环遍历这些表面）</span></span><br><span class="line">    videoParserParameters.ulClockRate = clkRate;<span class="comment">//1000</span></span><br><span class="line">    videoParserParameters.ulMaxDisplayDelay = bLowLatency ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    videoParserParameters.pUserData = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//三个回调函数</span></span><br><span class="line">    videoParserParameters.pfnSequenceCallback = HandleVideoSequenceProc;<span class="comment">//解码序列时调用</span></span><br><span class="line">    videoParserParameters.pfnDecodePicture = HandlePictureDecodeProc;<span class="comment">//准备开始解码时调用</span></span><br><span class="line">    videoParserParameters.pfnDisplayPicture = m_bForce_zero_latency ? <span class="literal">NULL</span> : HandlePictureDisplayProc;<span class="comment">//解码出数据调用</span></span><br><span class="line"></span><br><span class="line">    videoParserParameters.pfnGetOperatingPoint = HandleOperatingPointProc;<span class="comment">//这个是新增的回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Create video parser object and initialize</span></span><br><span class="line">    <span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidCreateVideoParser</span>(&amp;m_hParser, &amp;videoParserParameters));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们通过NVIDIA的Video_Codec_SDK中的NvDecoder.cpp来着重讲解一下这几个回调函数应该怎么样去设计！！！</p><h4 id="2-6-2-1-pfnSequenceCallback回调函数的设计"><a href="#2-6-2-1-pfnSequenceCallback回调函数的设计" class="headerlink" title="2.6.2.1 pfnSequenceCallback回调函数的设计"></a>2.6.2.1 pfnSequenceCallback回调函数的设计</h4><p>这个回调函数是在解码序列时才会被调用．</p><p>整个HandleVideoSequence函数其实主要分为几个步骤：</p><ul><li>相关结构体参数的数据填充</li><li>调用cuvidGetDecoderCaps接口来查询解码帧的状态</li><li>调用cuvidCreateDecoder接口来创建视频解码器</li></ul><p><font color = red >而这两个步骤，其实就是我们在前面2.4章节所说的，所以只要把2.4章节的步骤操作封装成一个函数，然后赋值给pfnSequenceCallback回调函数就可以了！！！</font></p><p>具体可以参考例程中的HandleVideoSequence函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return value from HandleVideoSequence() are interpreted as   :</span></span><br><span class="line"><span class="comment">*  0: fail, 1: succeeded, &gt; 1: override dpb size of parser (set by CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces while creating parser)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NvDecoder::HandleVideoSequence</span><span class="params">(CUVIDEOFORMAT *pVideoFormat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    START_TIMER</span><br><span class="line">    m_videoInfo.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    m_videoInfo.<span class="built_in">clear</span>();</span><br><span class="line">    m_videoInfo &lt;&lt; <span class="string">&quot;Video Input Information&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tCodec        : &quot;</span> &lt;&lt; <span class="built_in">GetVideoCodecString</span>(pVideoFormat-&gt;codec) &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tFrame rate   : &quot;</span> &lt;&lt; pVideoFormat-&gt;frame_rate.numerator &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; pVideoFormat-&gt;frame_rate.denominator</span><br><span class="line">            &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; <span class="number">1.0</span> * pVideoFormat-&gt;frame_rate.numerator / pVideoFormat-&gt;frame_rate.denominator &lt;&lt; <span class="string">&quot; fps&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tSequence     : &quot;</span> &lt;&lt; (pVideoFormat-&gt;progressive_sequence ? <span class="string">&quot;Progressive&quot;</span> : <span class="string">&quot;Interlaced&quot;</span>) &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tCoded size   : [&quot;</span> &lt;&lt; pVideoFormat-&gt;coded_width &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pVideoFormat-&gt;coded_height &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tDisplay area : [&quot;</span> &lt;&lt; pVideoFormat-&gt;display_area.left &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pVideoFormat-&gt;display_area.top &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">            &lt;&lt; pVideoFormat-&gt;display_area.right &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pVideoFormat-&gt;display_area.bottom &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tChroma       : &quot;</span> &lt;&lt; <span class="built_in">GetVideoChromaFormatString</span>(pVideoFormat-&gt;chroma_format) &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tBit depth    : &quot;</span> &lt;&lt; pVideoFormat-&gt;bit_depth_luma_minus8 + <span class="number">8</span></span><br><span class="line">    ;</span><br><span class="line">    m_videoInfo &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nDecodeSurface = pVideoFormat-&gt;min_num_decode_surfaces;</span><br><span class="line"></span><br><span class="line">    CUVIDDECODECAPS decodecaps;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;decodecaps, <span class="number">0</span>, <span class="built_in">sizeof</span>(decodecaps));</span><br><span class="line"></span><br><span class="line">    decodecaps.eCodecType = pVideoFormat-&gt;codec;</span><br><span class="line">    decodecaps.eChromaFormat = pVideoFormat-&gt;chroma_format;</span><br><span class="line">    decodecaps.nBitDepthMinus8 = pVideoFormat-&gt;bit_depth_luma_minus8;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPushCurrent</span>(m_cuContext)); <span class="comment">//启用context</span></span><br><span class="line">    <span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidGetDecoderCaps</span>(&amp;decodecaps));</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!decodecaps.bIsSupported)&#123;</span><br><span class="line">        <span class="built_in">NVDEC_THROW_ERROR</span>(<span class="string">&quot;Codec not supported on this GPU&quot;</span>, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">        <span class="keyword">return</span> nDecodeSurface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pVideoFormat-&gt;coded_width &gt; decodecaps.nMaxWidth) ||</span><br><span class="line">        (pVideoFormat-&gt;coded_height &gt; decodecaps.nMaxHeight))&#123;</span><br><span class="line"></span><br><span class="line">        std::ostringstream errorString;</span><br><span class="line">        errorString &lt;&lt; std::endl</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;Resolution          : &quot;</span> &lt;&lt; pVideoFormat-&gt;coded_width &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; pVideoFormat-&gt;coded_height &lt;&lt; std::endl</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;Max Supported (wxh) : &quot;</span> &lt;&lt; decodecaps.nMaxWidth &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; decodecaps.nMaxHeight &lt;&lt; std::endl</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;Resolution not supported on this GPU&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> std::string cErr = errorString.<span class="built_in">str</span>();</span><br><span class="line">        <span class="built_in">NVDEC_THROW_ERROR</span>(cErr, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">        <span class="keyword">return</span> nDecodeSurface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pVideoFormat-&gt;coded_width&gt;&gt;<span class="number">4</span>)*(pVideoFormat-&gt;coded_height&gt;&gt;<span class="number">4</span>) &gt; decodecaps.nMaxMBCount)&#123;</span><br><span class="line"></span><br><span class="line">        std::ostringstream errorString;</span><br><span class="line">        errorString &lt;&lt; std::endl</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;MBCount             : &quot;</span> &lt;&lt; (pVideoFormat-&gt;coded_width &gt;&gt; <span class="number">4</span>)*(pVideoFormat-&gt;coded_height &gt;&gt; <span class="number">4</span>) &lt;&lt; std::endl</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;Max Supported mbcnt : &quot;</span> &lt;&lt; decodecaps.nMaxMBCount &lt;&lt; std::endl</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;MBCount not supported on this GPU&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> std::string cErr = errorString.<span class="built_in">str</span>();</span><br><span class="line">        <span class="built_in">NVDEC_THROW_ERROR</span>(cErr, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">        <span class="keyword">return</span> nDecodeSurface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_nWidth &amp;&amp; m_nLumaHeight &amp;&amp; m_nChromaHeight) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cuvidCreateDecoder() has been called before, and now there&#x27;s possible config change</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ReconfigureDecoder</span>(pVideoFormat);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// eCodec has been set in the constructor (for parser). Here it&#x27;s set again for potential correction</span></span><br><span class="line">    m_eCodec = pVideoFormat-&gt;codec;</span><br><span class="line">    m_eChromaFormat = pVideoFormat-&gt;chroma_format;</span><br><span class="line">    m_nBitDepthMinus8 = pVideoFormat-&gt;bit_depth_luma_minus8;</span><br><span class="line">    m_nBPP = m_nBitDepthMinus8 &gt; <span class="number">0</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the output surface format same as chroma format</span></span><br><span class="line">    <span class="keyword">if</span> (m_eChromaFormat == cudaVideoChromaFormat_420 || cudaVideoChromaFormat_Monochrome)</span><br><span class="line">        m_eOutputFormat = pVideoFormat-&gt;bit_depth_luma_minus8 ? cudaVideoSurfaceFormat_P016 : cudaVideoSurfaceFormat_NV12;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_eChromaFormat == cudaVideoChromaFormat_444)</span><br><span class="line">        m_eOutputFormat = pVideoFormat-&gt;bit_depth_luma_minus8 ? cudaVideoSurfaceFormat_YUV444_16Bit : cudaVideoSurfaceFormat_YUV444;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_eChromaFormat == cudaVideoChromaFormat_422)</span><br><span class="line">        m_eOutputFormat = cudaVideoSurfaceFormat_NV12;  <span class="comment">// no 4:2:2 output format supported yet so make 420 default</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if output format supported. If not, check falback options</span></span><br><span class="line">    <span class="keyword">if</span> (!(decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; m_eOutputFormat)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_NV12))</span><br><span class="line">            m_eOutputFormat = cudaVideoSurfaceFormat_NV12;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_P016))</span><br><span class="line">            m_eOutputFormat = cudaVideoSurfaceFormat_P016;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_YUV444))</span><br><span class="line">            m_eOutputFormat = cudaVideoSurfaceFormat_YUV444;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_YUV444_16Bit))</span><br><span class="line">            m_eOutputFormat = cudaVideoSurfaceFormat_YUV444_16Bit;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">NVDEC_THROW_ERROR</span>(<span class="string">&quot;No supported output format found&quot;</span>, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">    &#125;</span><br><span class="line">    m_videoFormat = *pVideoFormat;</span><br><span class="line"></span><br><span class="line">    CUVIDDECODECREATEINFO videoDecodeCreateInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    videoDecodeCreateInfo.CodecType = pVideoFormat-&gt;codec;</span><br><span class="line">    videoDecodeCreateInfo.ChromaFormat = pVideoFormat-&gt;chroma_format;</span><br><span class="line">    videoDecodeCreateInfo.OutputFormat = m_eOutputFormat;</span><br><span class="line">    videoDecodeCreateInfo.bitDepthMinus8 = pVideoFormat-&gt;bit_depth_luma_minus8;</span><br><span class="line">    <span class="keyword">if</span> (pVideoFormat-&gt;progressive_sequence)</span><br><span class="line">        videoDecodeCreateInfo.DeinterlaceMode = cudaVideoDeinterlaceMode_Weave;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        videoDecodeCreateInfo.DeinterlaceMode = cudaVideoDeinterlaceMode_Adaptive;</span><br><span class="line">    videoDecodeCreateInfo.ulNumOutputSurfaces = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// With PreferCUVID, JPEG is still decoded by CUDA while video is decoded by NVDEC hardware</span></span><br><span class="line">    videoDecodeCreateInfo.ulCreationFlags = cudaVideoCreate_PreferCUVID;</span><br><span class="line">    videoDecodeCreateInfo.ulNumDecodeSurfaces = nDecodeSurface;</span><br><span class="line">    videoDecodeCreateInfo.vidLock = m_ctxLock;</span><br><span class="line">    videoDecodeCreateInfo.ulWidth = pVideoFormat-&gt;coded_width;</span><br><span class="line">    videoDecodeCreateInfo.ulHeight = pVideoFormat-&gt;coded_height;</span><br><span class="line">    <span class="comment">// AV1 has max width/height of sequence in sequence header</span></span><br><span class="line">    <span class="keyword">if</span> (pVideoFormat-&gt;codec == cudaVideoCodec_AV1 &amp;&amp; pVideoFormat-&gt;seqhdr_data_length &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// dont overwrite if it is already set from cmdline or reconfig.txt</span></span><br><span class="line">        <span class="keyword">if</span> (!(m_nMaxWidth &gt; pVideoFormat-&gt;coded_width || m_nMaxHeight &gt; pVideoFormat-&gt;coded_height))</span><br><span class="line">        &#123;</span><br><span class="line">            CUVIDEOFORMATEX *vidFormatEx = (CUVIDEOFORMATEX *)pVideoFormat;</span><br><span class="line">            m_nMaxWidth = vidFormatEx-&gt;av1.max_width;</span><br><span class="line">            m_nMaxHeight = vidFormatEx-&gt;av1.max_height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_nMaxWidth &lt; (<span class="type">int</span>)pVideoFormat-&gt;coded_width)</span><br><span class="line">        m_nMaxWidth = pVideoFormat-&gt;coded_width;</span><br><span class="line">    <span class="keyword">if</span> (m_nMaxHeight &lt; (<span class="type">int</span>)pVideoFormat-&gt;coded_height)</span><br><span class="line">        m_nMaxHeight = pVideoFormat-&gt;coded_height;</span><br><span class="line">    videoDecodeCreateInfo.ulMaxWidth = m_nMaxWidth;</span><br><span class="line">    videoDecodeCreateInfo.ulMaxHeight = m_nMaxHeight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(m_cropRect.r &amp;&amp; m_cropRect.b) &amp;&amp; !(m_resizeDim.w &amp;&amp; m_resizeDim.h)) &#123;</span><br><span class="line">        m_nWidth = pVideoFormat-&gt;display_area.right - pVideoFormat-&gt;display_area.left;</span><br><span class="line">        m_nLumaHeight = pVideoFormat-&gt;display_area.bottom - pVideoFormat-&gt;display_area.top;</span><br><span class="line">        videoDecodeCreateInfo.ulTargetWidth = pVideoFormat-&gt;coded_width;</span><br><span class="line">        videoDecodeCreateInfo.ulTargetHeight = pVideoFormat-&gt;coded_height;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_resizeDim.w &amp;&amp; m_resizeDim.h) &#123;</span><br><span class="line">            videoDecodeCreateInfo.display_area.left = pVideoFormat-&gt;display_area.left;</span><br><span class="line">            videoDecodeCreateInfo.display_area.top = pVideoFormat-&gt;display_area.top;</span><br><span class="line">            videoDecodeCreateInfo.display_area.right = pVideoFormat-&gt;display_area.right;</span><br><span class="line">            videoDecodeCreateInfo.display_area.bottom = pVideoFormat-&gt;display_area.bottom;</span><br><span class="line">            m_nWidth = m_resizeDim.w;</span><br><span class="line">            m_nLumaHeight = m_resizeDim.h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_cropRect.r &amp;&amp; m_cropRect.b) &#123;</span><br><span class="line">            videoDecodeCreateInfo.display_area.left = m_cropRect.l;</span><br><span class="line">            videoDecodeCreateInfo.display_area.top = m_cropRect.t;</span><br><span class="line">            videoDecodeCreateInfo.display_area.right = m_cropRect.r;</span><br><span class="line">            videoDecodeCreateInfo.display_area.bottom = m_cropRect.b;</span><br><span class="line">            m_nWidth = m_cropRect.r - m_cropRect.l;</span><br><span class="line">            m_nLumaHeight = m_cropRect.b - m_cropRect.t;</span><br><span class="line">        &#125;</span><br><span class="line">        videoDecodeCreateInfo.ulTargetWidth = m_nWidth;</span><br><span class="line">        videoDecodeCreateInfo.ulTargetHeight = m_nLumaHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_nChromaHeight = (<span class="type">int</span>)(<span class="built_in">ceil</span>(m_nLumaHeight * <span class="built_in">GetChromaHeightFactor</span>(m_eOutputFormat)));</span><br><span class="line">    m_nNumChromaPlanes = <span class="built_in">GetChromaPlaneCount</span>(m_eOutputFormat);</span><br><span class="line">    m_nSurfaceHeight = videoDecodeCreateInfo.ulTargetHeight;</span><br><span class="line">    m_nSurfaceWidth = videoDecodeCreateInfo.ulTargetWidth;</span><br><span class="line">    m_displayRect.b = videoDecodeCreateInfo.display_area.bottom;</span><br><span class="line">    m_displayRect.t = videoDecodeCreateInfo.display_area.top;</span><br><span class="line">    m_displayRect.l = videoDecodeCreateInfo.display_area.left;</span><br><span class="line">    m_displayRect.r = videoDecodeCreateInfo.display_area.right;</span><br><span class="line"></span><br><span class="line">    m_videoInfo &lt;&lt; <span class="string">&quot;Video Decoding Params:&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tNum Surfaces : &quot;</span> &lt;&lt; videoDecodeCreateInfo.ulNumDecodeSurfaces &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tCrop         : [&quot;</span> &lt;&lt; videoDecodeCreateInfo.display_area.left &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; videoDecodeCreateInfo.display_area.top &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">        &lt;&lt; videoDecodeCreateInfo.display_area.right &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; videoDecodeCreateInfo.display_area.bottom &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tResize       : &quot;</span> &lt;&lt; videoDecodeCreateInfo.ulTargetWidth &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; videoDecodeCreateInfo.ulTargetHeight &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tDeinterlace  : &quot;</span> &lt;&lt; std::vector&lt;<span class="type">const</span> <span class="type">char</span> *&gt;&#123;<span class="string">&quot;Weave&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adaptive&quot;</span>&#125;[videoDecodeCreateInfo.DeinterlaceMode]</span><br><span class="line">    ;</span><br><span class="line">    m_videoInfo &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPushCurrent</span>(m_cuContext));</span><br><span class="line">    <span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidCreateDecoder</span>(&amp;m_hDecoder, &amp;videoDecodeCreateInfo));</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="built_in">STOP_TIMER</span>(<span class="string">&quot;Session Initialization Time: &quot;</span>);</span><br><span class="line">    NvDecoder::<span class="built_in">addDecoderSessionOverHead</span>(<span class="built_in">getDecoderSessionID</span>(), elapsedTime);</span><br><span class="line">    <span class="keyword">return</span> nDecodeSurface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-2-2-pfnDecodePicture回调函数的设计"><a href="#2-6-2-2-pfnDecodePicture回调函数的设计" class="headerlink" title="2.6.2.2 pfnDecodePicture回调函数的设计"></a>2.6.2.2 pfnDecodePicture回调函数的设计</h4><p>这个回调函数是在准备开始解码时才会被调用<br>整个HandleVideoSequence函数其实主要就是调用cuvidDecodePicture接口</p><p>在2.6.2.1章节中我们调用了cuvidCreateDecoder接口来创建视频解码器，而这个接口将会返回phDecoder这个句柄，而接下来我们就要将phDecoder作为hDecoder输入参数设置到cuvidDecodePicture接口中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************************************************/</span></span><br><span class="line"><span class="comment">//! \fn CUresult CUDAAPI cuvidCreateDecoder(CUvideodecoder *phDecoder, CUVIDDECODECREATEINFO *pdci)</span></span><br><span class="line"><span class="comment">//! Create the decoder object based on pdci. A handle to the created decoder is returned</span></span><br><span class="line"><span class="comment">/*****************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> CUresult CUDAAPI <span class="title">cuvidCreateDecoder</span><span class="params">(CUvideodecoder *phDecoder, CUVIDDECODECREATEINFO *pdci)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************************************************************/</span></span><br><span class="line"><span class="comment">//! \fn CUresult CUDAAPI cuvidDecodePicture(CUvideodecoder hDecoder, CUVIDPICPARAMS *pPicParams)</span></span><br><span class="line"><span class="comment">//! Decode a single picture (field or frame)</span></span><br><span class="line"><span class="comment">//! Kicks off HW decoding </span></span><br><span class="line"><span class="comment">/*****************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> CUresult CUDAAPI <span class="title">cuvidDecodePicture</span><span class="params">(CUvideodecoder hDecoder, CUVIDPICPARAMS *pPicParams)</span></span>;</span><br></pre></td></tr></table></figure><p>除了这个参数以外，我们还需要将CUVIDPICPARAMS结构体作为第二个参数直接设置进去</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return value from HandlePictureDecode() are interpreted as:</span></span><br><span class="line"><span class="comment">*  0: fail, &gt;=1: succeeded</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NvDecoder::HandlePictureDecode</span><span class="params">(CUVIDPICPARAMS *pPicParams)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_hDecoder)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NVDEC_THROW_ERROR</span>(<span class="string">&quot;Decoder not initialized.&quot;</span>, CUDA_ERROR_NOT_INITIALIZED);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_nPicNumInDecodeOrder[pPicParams-&gt;CurrPicIdx] = m_nDecodePicCnt++;</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPushCurrent</span>(m_cuContext));</span><br><span class="line">    <span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidDecodePicture</span>(m_hDecoder, pPicParams));</span><br><span class="line">    <span class="keyword">if</span> (m_bForce_zero_latency &amp;&amp; ((!pPicParams-&gt;field_pic_flag) || (pPicParams-&gt;second_field)))</span><br><span class="line">    &#123;</span><br><span class="line">        CUVIDPARSERDISPINFO dispInfo;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;dispInfo, <span class="number">0</span>, <span class="built_in">sizeof</span>(dispInfo));</span><br><span class="line">        dispInfo.picture_index = pPicParams-&gt;CurrPicIdx;</span><br><span class="line">        dispInfo.progressive_frame = !pPicParams-&gt;field_pic_flag;</span><br><span class="line">        dispInfo.top_field_first = pPicParams-&gt;bottom_field_flag ^ <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">HandlePictureDisplay</span>(&amp;dispInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-2-3-pfnDisplayPicture回调函数的设计"><a href="#2-6-2-3-pfnDisplayPicture回调函数的设计" class="headerlink" title="2.6.2.3 pfnDisplayPicture回调函数的设计"></a>2.6.2.3 pfnDisplayPicture回调函数的设计</h4><p>这个回调函数是在解码出数据时才会被调用</p><p>整个HandlePictureDisplay函数其实主要就做了以下几件事情：</p><ul><li>CUVIDPROCPARAMS结构体参数的数据填充</li><li>cuCtxPushCurrent</li><li>调用cuvidMapVideoFrame接口，获取到设备内存中指定的YUV数据地址</li><li>分配空间</li><li>NV12TORGB</li><li>cuCtxPopCurrent</li><li>cuvidUnmapVideoFrame</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Return value from HandlePictureDisplay() are interpreted as:</span></span><br><span class="line"><span class="comment">*  0: fail, &gt;=1: succeeded</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//目的是找到解码后数据在显存中的位置以及指针的指向，因此重点看了HandlePictureDisplay函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NvDecoder::HandlePictureDisplay</span><span class="params">(CUVIDPARSERDISPINFO *pDispInfo)</span> </span>&#123;</span><br><span class="line">    CUVIDPROCPARAMS videoProcessingParameters = &#123;&#125;;</span><br><span class="line">    videoProcessingParameters.progressive_frame = pDispInfo-&gt;progressive_frame;</span><br><span class="line">    videoProcessingParameters.second_field = pDispInfo-&gt;repeat_first_field + <span class="number">1</span>;</span><br><span class="line">    videoProcessingParameters.top_field_first = pDispInfo-&gt;top_field_first;</span><br><span class="line">    videoProcessingParameters.unpaired_field = pDispInfo-&gt;repeat_first_field &lt; <span class="number">0</span>;</span><br><span class="line">    videoProcessingParameters.output_stream = m_cuvidStream;</span><br><span class="line"></span><br><span class="line">    CUdeviceptr dpSrcFrame = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nSrcPitch = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPushCurrent</span>(m_cuContext));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cuvidMapVideoFrame:返回cuda设备指针和视频帧的Pitch，获取到设备内存中指定的YUV数据地址</span></span><br><span class="line">    <span class="comment">// MapVideoFrame: 拿到解码后数据在显存的指针 --&gt; dpSrcFrame</span></span><br><span class="line">    <span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidMapVideoFrame</span>(m_hDecoder, pDispInfo-&gt;picture_index, &amp;dpSrcFrame,</span><br><span class="line">        &amp;nSrcPitch, &amp;videoProcessingParameters));</span><br><span class="line"></span><br><span class="line">    CUVIDGETDECODESTATUS DecodeStatus;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;DecodeStatus, <span class="number">0</span>, <span class="built_in">sizeof</span>(DecodeStatus));</span><br><span class="line">    CUresult result = <span class="built_in">cuvidGetDecodeStatus</span>(m_hDecoder, pDispInfo-&gt;picture_index, &amp;DecodeStatus);</span><br><span class="line">    <span class="keyword">if</span> (result == CUDA_SUCCESS &amp;&amp; (DecodeStatus.decodeStatus == cuvidDecodeStatus_Error || DecodeStatus.decodeStatus == cuvidDecodeStatus_Error_Concealed))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Decode Error occurred for picture %d\n&quot;</span>, m_nPicNumInDecodeOrder[pDispInfo-&gt;picture_index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> *pDecodedFrame = <span class="literal">nullptr</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// lock_guard 自动解锁 当控件离开lock_guard创建对象的范围时，lock_guard被破坏并释放互斥体</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mtxVPFrame)</span></span>;</span><br><span class="line">        <span class="comment">// 解出一帧 m_nDecodedFrame+1,且若不够空间了,则开辟空间</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">unsigned</span>)++m_nDecodedFrame &gt; m_vpFrame.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Not enough frames in stock</span></span><br><span class="line">            m_nFrameAlloc++;</span><br><span class="line">            <span class="type">uint8_t</span> *pFrame = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (m_bUseDeviceFrame)<span class="comment">//初始化解码器的时候设置的,是否使用显卡内存,是得解码出来的数据不转到CPU内存</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (m_bDeviceFramePitched)<span class="comment">//分配显存空间，并返回指向该空间的指针pFrame</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuMemAllocPitch</span>((CUdeviceptr *)&amp;pFrame, &amp;m_nDeviceFramePitch, <span class="built_in">GetWidth</span>() * m_nBPP, m_nLumaHeight + (m_nChromaHeight * m_nNumChromaPlanes), <span class="number">16</span>));</span><br><span class="line">                cuvidCreateVideoParser&#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//CPU内存</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuMemAlloc</span>((CUdeviceptr *)&amp;pFrame, <span class="built_in">GetFrameSize</span>()));<span class="comment">// 开辟空间</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pFrame = <span class="keyword">new</span> <span class="type">uint8_t</span>[<span class="built_in">GetFrameSize</span>()];</span><br><span class="line">            &#125;</span><br><span class="line">            m_vpFrame.<span class="built_in">push_back</span>(pFrame);<span class="comment">//压进堆栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        pDecodedFrame = m_vpFrame[m_nDecodedFrame - <span class="number">1</span>];<span class="comment">// 取堆栈最后一个帧数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy luma plane</span></span><br><span class="line">    CUDA_MEMCPY2D m = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    m.srcMemoryType = CU_MEMORYTYPE_DEVICE;</span><br><span class="line">    m.srcDevice = dpSrcFrame;<span class="comment">//解码后数据在显存的指针</span></span><br><span class="line">    m.srcPitch = nSrcPitch;</span><br><span class="line">    m.dstMemoryType = m_bUseDeviceFrame ? CU_MEMORYTYPE_DEVICE : CU_MEMORYTYPE_HOST;</span><br><span class="line">    m.dstDevice = (CUdeviceptr)(m.dstHost = pDecodedFrame);</span><br><span class="line">    m.dstPitch = m_nDeviceFramePitch ? m_nDeviceFramePitch : <span class="built_in">GetWidth</span>() * m_nBPP;</span><br><span class="line">    m.WidthInBytes = <span class="built_in">GetWidth</span>() * m_nBPP;</span><br><span class="line">    m.Height = m_nLumaHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码完成,NV12格式 pDecodedFrame</span></span><br><span class="line">    <span class="comment">// NV12TORGB</span></span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuMemcpy2DAsync</span>(&amp;m, m_cuvidStream));<span class="comment">//复制二维数组的内存。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy chroma plane</span></span><br><span class="line">    <span class="comment">// NVDEC output has luma height aligned by 2. Adjust chroma offset by aligning height</span></span><br><span class="line">    m.srcDevice = (CUdeviceptr)((<span class="type">uint8_t</span> *)dpSrcFrame + m.srcPitch * ((m_nSurfaceHeight + <span class="number">1</span>) &amp; ~<span class="number">1</span>));</span><br><span class="line">    m.dstDevice = (CUdeviceptr)(m.dstHost = pDecodedFrame + m.dstPitch * m_nLumaHeight);</span><br><span class="line">    m.Height = m_nChromaHeight;</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuMemcpy2DAsync</span>(&amp;m, m_cuvidStream));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_nNumChromaPlanes == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m.srcDevice = (CUdeviceptr)((<span class="type">uint8_t</span> *)dpSrcFrame + m.srcPitch * ((m_nSurfaceHeight + <span class="number">1</span>) &amp; ~<span class="number">1</span>) * <span class="number">2</span>);</span><br><span class="line">        m.dstDevice = (CUdeviceptr)(m.dstHost = pDecodedFrame + m.dstPitch * m_nLumaHeight * <span class="number">2</span>);</span><br><span class="line">        m.Height = m_nChromaHeight;</span><br><span class="line">        <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuMemcpy2DAsync</span>(&amp;m, m_cuvidStream));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuStreamSynchronize</span>(m_cuvidStream));</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>));<span class="comment">// 拷贝结束,取消上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">int</span>)m_vTimestamp.<span class="built_in">size</span>() &lt; m_nDecodedFrame) &#123;</span><br><span class="line">        m_vTimestamp.<span class="built_in">resize</span>(m_vpFrame.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    m_vTimestamp[m_nDecodedFrame - <span class="number">1</span>] = pDispInfo-&gt;timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取消映射先前映射的视频帧</span></span><br><span class="line">    <span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidUnmapVideoFrame</span>(m_hDecoder, dpSrcFrame));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-2-4-pfnGetOperatingPoint回调函数的设计"><a href="#2-6-2-4-pfnGetOperatingPoint回调函数的设计" class="headerlink" title="2.6.2.4 pfnGetOperatingPoint回调函数的设计"></a>2.6.2.4 pfnGetOperatingPoint回调函数的设计</h4><h4 id="2-6-2-5-pfnGetSEIMsg回调函数的设计"><a href="#2-6-2-5-pfnGetSEIMsg回调函数的设计" class="headerlink" title="2.6.2.5 pfnGetSEIMsg回调函数的设计"></a>2.6.2.5 pfnGetSEIMsg回调函数的设计</h4><h3 id="2-6-3-解析器的创建"><a href="#2-6-3-解析器的创建" class="headerlink" title="2.6.3 解析器的创建"></a>2.6.3 解析器的创建</h3><p>当我们把CUVIDPARSERPARAMS结构体填充完成后，就可以调用cuvidCreateVideoParser函数，将CUVIDPARSERPARAMS作为输入参数，进行解析器的创建。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult CUDAAPI <span class="title">tcuvidCreateVideoParser</span><span class="params">(CUvideoparser *pObj, CUVIDPARSERPARAMS *pParams)</span></span>;</span><br><span class="line">tcuvidCreateVideoParser               *cuvidCreateVideoParser;</span><br></pre></td></tr></table></figure><p>Video_Codec_SDK样例中NvDecoder文件:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CUVIDPARSERPARAMS：该接口用来创建VideoParser</span></span><br><span class="line"><span class="comment">//主要参数是设置三个回调函数，实现对解析出来的数据的处理</span></span><br><span class="line">CUVIDPARSERPARAMS videoParserParameters = &#123;&#125;;<span class="comment">//结构体</span></span><br><span class="line">videoParserParameters.CodecType = eCodec; <span class="comment">//解码视频类型，如H264</span></span><br><span class="line">videoParserParameters.ulMaxNumDecodeSurfaces = <span class="number">1</span>;<span class="comment">//解码表面的最大数量（解析器将循环遍历这些表面）</span></span><br><span class="line">videoParserParameters.ulClockRate = clkRate;</span><br><span class="line">videoParserParameters.ulMaxDisplayDelay = bLowLatency ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">videoParserParameters.pUserData = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三个回调函数</span></span><br><span class="line">videoParserParameters.pfnSequenceCallback = HandleVideoSequenceProc;<span class="comment">//解码序列时调用</span></span><br><span class="line">videoParserParameters.pfnDecodePicture = HandlePictureDecodeProc;<span class="comment">//准备开始解码时调用</span></span><br><span class="line">videoParserParameters.pfnDisplayPicture = m_bForce_zero_latency ? <span class="literal">NULL</span> : HandlePictureDisplayProc;<span class="comment">//解码出数据调用</span></span><br><span class="line">videoParserParameters.pfnGetOperatingPoint = HandleOperatingPointProc;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create video parser object and initialize</span></span><br><span class="line"><span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidCreateVideoParser</span>(&amp;m_hParser, &amp;videoParserParameters));</span><br></pre></td></tr></table></figure><h3 id="2-6-4-从解复用器提取数据包进行解码"><a href="#2-6-4-从解复用器提取数据包进行解码" class="headerlink" title="2.6.4 从解复用器提取数据包进行解码"></a>2.6.4 从解复用器提取数据包进行解码</h3><p>解析器创建完成后，我们就可以开始真正的进行解码咯，而解码就需要通过调用cuvidParseVideoData从解复用器提取数据包：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult CUDAAPI <span class="title">tcuvidParseVideoData</span><span class="params">(CUvideoparser obj, CUVIDSOURCEDATAPACKET *pPacket)</span></span>;</span><br><span class="line">tcuvidParseVideoData                  *cuvidParseVideoData;</span><br></pre></td></tr></table></figure><p>首先定义一个CUVIDSOURCEDATAPACKET结构体类型的变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CUVIDSOURCEDATAPACKET</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;            <span class="comment">/**&lt; Combination of CUVID_PKT_XXX flags */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> payload_size;     <span class="comment">/**&lt; number of bytes in the payload (may be zero if EOS flag is set) */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *payload;   <span class="comment">/**&lt; Pointer to packet payload data (may be NULL if EOS flag is set) */</span></span><br><span class="line">    CUvideotimestamp timestamp;     <span class="comment">/**&lt; Presentation timestamp (10MHz clock), only valid if CUVID_PKT_TIMESTAMP flag is set */</span></span><br><span class="line">&#125; CUVIDSOURCEDATAPACKET;</span><br></pre></td></tr></table></figure><h4 id="相关参数具体设置：-2"><a href="#相关参数具体设置：-2" class="headerlink" title="相关参数具体设置："></a>相关参数具体设置：</h4><p>首先使用memset函数将结构体初始化（全置为0）</p><h5 id="flags："><a href="#flags：" class="headerlink" title="flags："></a>flags：</h5><p>默认为0</p><h5 id="payload-size"><a href="#payload-size" class="headerlink" title="payload_size"></a>payload_size</h5><p>payload_size等于之前CUVIDEOFORMATEX结构体中format.seqhdr_data_length的值</p><h5 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h5><p>payload等于之前CUVIDEOFORMATEX结构体中raw_seqhdr_data的值</p><h5 id="timestamp"><a href="#timestamp" class="headerlink" title="timestamp"></a>timestamp</h5><p>默认为0</p><p>通过上面的参数，我们可以知道还必须得到CUVIDEOFORMATEX结构体变量的信息<br>因此我们接着定义一个CUVIDEOFORMATEX结构体类型的变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包含原始序列头信息的视频格式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    CUVIDEOFORMAT format;<span class="comment">//Video format</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> raw_seqhdr_data[<span class="number">1024</span>];</span><br><span class="line">&#125; CUVIDEOFORMATEX;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="相关参数具体设置：-3"><a href="#相关参数具体设置：-3" class="headerlink" title="相关参数具体设置："></a>相关参数具体设置：</h4><p>首先使用memset函数将结构体初始化（全置为0）</p><h5 id="format："><a href="#format：" class="headerlink" title="format："></a>format：</h5><p>只需要设置format.seqhdr_data_length ，值等于额外数据的长度</p><h5 id="raw-seqhdr-data："><a href="#raw-seqhdr-data：" class="headerlink" title="raw_seqhdr_data："></a>raw_seqhdr_data：</h5><p>通过memcpy将额外数据copy到raw_seqhdr_data中，长度为seqhdr_data_length<br>即：memcpy(CuVideoFormatEx.raw_seqhdr_data, exdata, exdataLen);</p><p>接着我们通过调用cuvidParseVideoData从解复用器提取数据包，该接口是用来向parser塞数据，通过不断地塞h.264数据，parser会通过回调接口对解析出来的数据进行处理。</p><p>提取成功后，紧接着调用cuCtxPopCurrent函数，将给定的上下文ctx从当前CPU线程的上下文堆栈中弹出。</p><p>Video_Codec_SDK样例中NvDecoder文件:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//AVPacket转CUVIDSOURCEDATAPACKET，并交给cuvidParaseVideoData进行</span></span><br><span class="line">CUVIDSOURCEDATAPACKET packet = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">packet.payload = pData;<span class="comment">//指向数据包有效载荷数据的指针</span></span><br><span class="line">packet.payload_size = nSize;<span class="comment">//负载中的字节数</span></span><br><span class="line">packet.flags = nFlags | CUVID_PKT_TIMESTAMP;</span><br><span class="line">packet.timestamp = nTimestamp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否是stream的最后一个packet</span></span><br><span class="line"><span class="keyword">if</span> (!pData || nSize == <span class="number">0</span>) &#123;</span><br><span class="line">    packet.flags |= CUVID_PKT_ENDOFSTREAM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidParseVideoData</span>(m_hParser, &amp;packet));</span><br><span class="line">```    </span><br><span class="line">## <span class="number">2.7</span> 获取解码后的 YUV 以供进一步处理</span><br><span class="line">这一步骤是在pfnDisplayPicture指向的回调函数进行处理的，在前面的<span class="number">2.6</span><span class="number">.2</span><span class="number">.3</span>章节中，我们说了pfnDisplayPicture这个回调函数是在解码出数据时才会被调用</span><br><span class="line"></span><br><span class="line">而整个HandlePictureDisplay函数其实主要就做了以下几件事情：</span><br><span class="line">- CUVIDPROCPARAMS结构体参数的数据填充</span><br><span class="line">- cuCtxPushCurrent</span><br><span class="line">- 调用cuvidMapVideoFrame接口，获取到设备内存中指定的YUV数据地址</span><br><span class="line">- 分配空间</span><br><span class="line">- NV12TORGB</span><br><span class="line">- cuCtxPopCurrent</span><br><span class="line">- cuvidUnmapVideoFrame</span><br><span class="line"></span><br><span class="line">其中的：</span><br><span class="line">- 调用cuvidMapVideoFrame接口，获取到设备内存中指定的YUV数据地址</span><br><span class="line">- 分配空间</span><br><span class="line">- NV12TORGB</span><br><span class="line">就是获取解码后的 YUV 的相关处理步骤</span><br><span class="line"></span><br><span class="line">## <span class="number">2.8</span> 查询解码帧的状态</span><br><span class="line">通过应用程序接口<span class="built_in">cuvidGetDecoderCaps</span>()查询底层硬件视频解码器的功能。</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line"><span class="comment">/**********************************************************************************************************************/</span></span><br><span class="line"><span class="comment">//! \fn CUresult CUDAAPI cuvidGetDecoderCaps(CUVIDDECODECAPS *pdc)</span></span><br><span class="line"><span class="comment">//! Queries decode capabilities of NVDEC-HW based on CodecType, ChromaFormat and BitDepthMinus8 parameters.</span></span><br><span class="line"><span class="comment">//! 1. Application fills IN parameters CodecType, ChromaFormat and BitDepthMinus8 of CUVIDDECODECAPS structure</span></span><br><span class="line"><span class="comment">//! 2. On calling cuvidGetDecoderCaps, driver fills OUT parameters if the IN parameters are supported</span></span><br><span class="line"><span class="comment">//!    If IN parameters passed to the driver are not supported by NVDEC-HW, then all OUT params are set to 0.</span></span><br><span class="line"><span class="comment">//! E.g. on Geforce GTX 960:</span></span><br><span class="line"><span class="comment">//!   App fills - eCodecType = cudaVideoCodec_H264; eChromaFormat = cudaVideoChromaFormat_420; nBitDepthMinus8 = 0;</span></span><br><span class="line"><span class="comment">//!   Given IN parameters are supported, hence driver fills: bIsSupported = 1; nMinWidth   = 48; nMinHeight  = 16; </span></span><br><span class="line"><span class="comment">//!   nMaxWidth = 4096; nMaxHeight = 4096; nMaxMBCount = 65536;</span></span><br><span class="line"><span class="comment">//! CodedWidth*CodedHeight/256 must be less than or equal to nMaxMBCount</span></span><br><span class="line"><span class="comment">/**********************************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> CUresult CUDAAPI <span class="title">cuvidGetDecoderCaps</span><span class="params">(CUVIDDECODECAPS *pdc)</span></span>;</span><br></pre></td></tr></table></figure><p>具体调用方式可以参考2.6.2.1章节pfnSequenceCallback回调函数的设计</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CUVIDDECODECAPS decodecaps;</span><br><span class="line"><span class="built_in">memset</span>(&amp;decodecaps, <span class="number">0</span>, <span class="built_in">sizeof</span>(decodecaps));</span><br><span class="line"></span><br><span class="line">decodecaps.eCodecType = pVideoFormat-&gt;codec;</span><br><span class="line">decodecaps.eChromaFormat = pVideoFormat-&gt;chroma_format;</span><br><span class="line">decodecaps.nBitDepthMinus8 = pVideoFormat-&gt;bit_depth_luma_minus8;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPushCurrent</span>(m_cuContext)); <span class="comment">//启用context</span></span><br><span class="line"><span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidGetDecoderCaps</span>(&amp;decodecaps));</span><br><span class="line"><span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure><hr><p>此时关于硬件解码的部分我们已经基本上完成了，接下来就是如何使用OpenGL与CUDA进行交互操作了．</p><hr><h2 id="2-9-根据解码状态，使用解码后的输出进行进一步的处理-如渲染、后处理等"><a href="#2-9-根据解码状态，使用解码后的输出进行进一步的处理-如渲染、后处理等" class="headerlink" title="2.9 根据解码状态，使用解码后的输出进行进一步的处理(如渲染、后处理等)"></a>2.9 根据解码状态，使用解码后的输出进行进一步的处理(如渲染、后处理等)</h2><p>我们知道从解码器解码出来的数据格式是NV12，而我们如果想对该数据进行进一步的处理(如渲染、后处理等)的话，NV12数据无论是进行OpenGL的播放渲染还是进行相关特效处理（大部分OpenGL的filter都是对RGBA数据进行处理的）都不太适合，因此，我们拿到NV12数据后还需要进行一个步骤：将数据转换成容易处理的格式，也就是RGBA或者BGRA格式（每个像素用32比特位表示，占4个字节 ，R，G，B,A分量分别用8个bit表示）．</p><p>而如何将解码后的NV12数据转化为RGBA格式呢？</p><p>此时有两种方案:</p><ul><li>将解码后的NV12数据通过cuda的Kernel Functions转成了BGRA等格式</li><li>让OpeGL或者DX将获取到的NV12数据，通过使用特定shader实现RGB到YUV的图像格式</li></ul><p>这两者的区别就在于我们是让CUDA进行格式转换，还是通过OpenGL进行格式转换？</p><p>现在摆在我们面前的是：</p><p>我们的目的是：实现NvDec硬件解码-&gt;OpenGL渲染和filter处理-&gt;NvDec硬件编码的全流程GPU加速方案</p><p>NvDec解码后的数据是存放在GPU上的NV12数据，我们在渲染和filter功能实现上需要通过OpenGL来实现</p><p>因此我们需要OpenGL能够直接操作NvDec解码后在GPU上的地址数据，这一点就需要借助CUDA来实现，NVidia的CUDA提供了和OpenGL以及各版本DX的交互接口，这使得，通过OpenGL直接对NvDec解码后的数据进行操作成为了可能．详见NVidia相关<a href="https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__OPENGL.html">官方文档</a></p><h3 id="2-9-1-为什么要采用OpenGL与CUDA互操作的方式"><a href="#2-9-1-为什么要采用OpenGL与CUDA互操作的方式" class="headerlink" title="2.9.1 为什么要采用OpenGL与CUDA互操作的方式"></a>2.9.1 为什么要采用OpenGL与CUDA互操作的方式</h3><p>其实传统的渲染方式一般是：</p><ul><li>将硬解码得到的NV12数据拷贝回CPU内存，</li><li>然后再将NV12格式转成YUV420格式，</li><li>进而再调用OpenGL渲染。</li></ul><p>缺点：GPU到CPU的数据拷贝在时间上花销过大，NV12格式转成YUV420格式计算花销大，因此造成解码渲染耗时较大，容易出现卡顿现象。</p><p>因此我们其实是有以下两个方案：<br>方案一：</p><ul><li>使用CUDA与OpenGL互操作，无需将数据传入CPU，将硬解码取得的NV12数据直接通过CUDA的Kernel Functions转成RGBA或BGRA。</li><li>然后再利用内存映射的方法，让OpeGL直接进行渲染和相关特效处理。<br>方案二：</li><li>使用CUDA与OpenGL互操作，无需将数据传入CPU，利用内存映射的方法，将CUDA与OpenGL进行绑定</li><li>让OpeGL将获取到的NV12数据，通过使用shader进行格式转换，最后再进行渲染。</li></ul><p>这两个方案的区别在于是让CUDA的核函数进行NV12-&gt;RGB的转换，还是通过OpenGL的shader进行NV12-&gt;RGB的转换．</p><p>而如果我们采用第二种方案的话，比较麻烦的问题在于，我们需要两条OpenGL纹理(一条存放Y数据，一体存放UV数据)来跟CUDA进行互操作．这样的操作太过于麻烦，且容易出错，因此我们一般还是参考例程的代码，统一采用的是第一种方案．当然，如果你想了解一下第二种方案的实现，可以参考这篇<a href="">博客</a></p><h3 id="2-9-2-CUDA与OpenGL互操作"><a href="#2-9-2-CUDA与OpenGL互操作" class="headerlink" title="2.9.2 CUDA与OpenGL互操作"></a>2.9.2 CUDA与OpenGL互操作</h3><p>OpenGL与CUDA互操作可以分成两种方法:</p><p>方法一：<br>OpenGL将Buffer对象注册到CUDA中去，供CUDA读写操作，然后再在OpenGL中使用。一般这种情况下注册的是<font color = red>VBO和PBO</font>，VBO一般用于存储顶点坐标、索引等数据；PBO则一般用于存储图像数据，因此称作Pixel Buffer Object。</p><p>方法二：<br>OpenGL将<font color =red>Texture</font>注册到CUDA中去，经CUDA处理后得到纹理内容，然后在OpenGL中渲染出来。</p><p>二者的操作流程一致：</p><ul><li>在OpenGL里面初始化Buffer Object</li><li>在CUDA中注册OpenGL中的Buffer Object</li><li>CUDA锁定资源，获取操作资源的指针，在<font color =red>CUDA核函数</font>中进行数据处理</li><li>CUDA释放资源，在OpenGL中使用Buffer Object进行渲染和显示</li></ul><p>接下来，我们将分别讲述一下这两种方法的实现步骤</p><h4 id="2-9-2-1-方法一-VBO-VAO-："><a href="#2-9-2-1-方法一-VBO-VAO-：" class="headerlink" title="2.9.2.1 方法一(VBO+VAO)："></a>2.9.2.1 方法一(VBO+VAO)：</h4><h5 id="2-9-2-1-1-VBO-VAO基础概念介绍"><a href="#2-9-2-1-1-VBO-VAO基础概念介绍" class="headerlink" title="2.9.2.1.1 VBO+VAO基础概念介绍"></a>2.9.2.1.1 VBO+VAO基础概念介绍</h5><p>VBO:顶点缓冲对象VBO<font color =red>是在显卡存储空间中开辟出的一块内存缓存区，用于存储顶点的各类属性信息，如顶点坐标，顶点法向量，顶点颜色数据等</font>。在渲染时，可以直接从VBO中取出顶点的各类属性数据，由于VBO在显存而不是在内存中，不需要从CPU传输数据，处理效率更高。<br>所以可以理解为VBO就是显存中的一个存储区域，可以保持大量的顶点属性信息。并且可以开辟很多个VBO，每个VBO在OpenGL中有它的唯一标识ID，这个ID对应着具体的VBO的显存地址，通过这个ID可以对特定的VBO内的数据进行存取操作。</p><p>VAO:是一个保存了所有顶点数据属性的状态结合，它存储了顶点数据的格式以及顶点数据所需的VBO对象的引用。<br>VAO本身并没有存储顶点的相关属性数据，这些信息是存储在VBO中的，<font color =red>VAO相当于是对很多个VBO的引用，把一些VBO组合在一起作为一个对象统一管理</font>。</p><p>EBO:索引缓冲对象EBO相当于OpenGL中的顶点数组的概念，，<font color =red>是为了解决同一个顶点多次重复调用的问题</font>，可以减少内存空间浪费，提高执行效率。当需要使用重复的顶点时，通过顶点的位置索引来调用顶点，而不是对重复的顶点信息重复记录，重复调用。<font color =red>EBO中存储的内容就是顶点位置的索引indices，EBO跟VBO类似，也是在显存中的一块内存缓冲器，只不过EBO保存的是顶点的索引</font>。</p><p>综上所述：<br>VBO存放的是顶点信息（坐标，颜色，法向量．．．．）；VAO是对多个VBO的管理器，也就是相当于VBO的集合，EBO也就是VBO中顶点信息中的坐标的索引集合</p><p>我们用C++语言来表达就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    Coordinates xyz;</span><br><span class="line">    Color color;</span><br><span class="line">    NormalVectors normal_vectors;</span><br><span class="line">    .....</span><br><span class="line">&#125;VBO;</span><br><span class="line">VBO* pVAO =<span class="keyword">new</span> VBO[n]();</span><br><span class="line">Coordinates* pEBO = nwe Coordinates[n]();</span><br></pre></td></tr></table></figure><p>例程AppDecGL中对NV12转BGRA的CUDA操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Launch cuda kernels for colorspace conversion from raw video to raw image formats which OpenGL textures can work with</span></span><br><span class="line"><span class="keyword">if</span> (dec.<span class="built_in">GetBitDepth</span>() == <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dec.<span class="built_in">GetOutputFormat</span>() == cudaVideoSurfaceFormat_YUV444)</span><br><span class="line">        <span class="built_in">YUV444ToColor32</span>&lt;BGRA32&gt;(pFrame, dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// default assumed NV12</span></span><br><span class="line">        <span class="built_in">Nv12ToColor32</span>&lt;BGRA32&gt;(pFrame, dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dec.<span class="built_in">GetOutputFormat</span>() == cudaVideoSurfaceFormat_YUV444)</span><br><span class="line">        <span class="built_in">YUV444P16ToColor32</span>&lt;BGRA32&gt;(pFrame, <span class="number">2</span> * dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// default assumed P016</span></span><br><span class="line">        <span class="built_in">P016ToColor32</span>&lt;BGRA32&gt;(pFrame, <span class="number">2</span> * dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-9-2-1-2-代码实现（为了提高效率，同时操作两个VBO数据）"><a href="#2-9-2-1-2-代码实现（为了提高效率，同时操作两个VBO数据）" class="headerlink" title="2.9.2.1.2 代码实现（为了提高效率，同时操作两个VBO数据）"></a>2.9.2.1.2 代码实现（为了提高效率，同时操作两个VBO数据）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化Buffer Object</span></span><br><span class="line"><span class="comment">//vertex array object</span></span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;VAO);</span><br><span class="line"><span class="comment">//Create vertex buffer object</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">2</span>, <span class="keyword">this</span>-&gt;VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create Element Buffer Objects</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;EBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bind the Vertex Array Object first, then bind and set vertex buffer(s) and attribute pointer(s).</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="keyword">this</span>-&gt;VAO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定VBO后即在CUDA中注册Buffer Object</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="keyword">this</span>-&gt;VBO[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(*<span class="keyword">this</span>-&gt;malla)*<span class="keyword">this</span>-&gt;numPoints, <span class="keyword">this</span>-&gt;malla, GL_DYNAMIC_COPY);</span><br><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>(&amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>], <span class="keyword">this</span>-&gt;VBO[<span class="number">0</span>], cudaGraphicsRegisterFlagsNone);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="keyword">this</span>-&gt;VBO[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(*<span class="keyword">this</span>-&gt;malla)*<span class="keyword">this</span>-&gt;numPoints, <span class="keyword">this</span>-&gt;malla, GL_DYNAMIC_COPY);</span><br><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>(&amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">1</span>], <span class="keyword">this</span>-&gt;VBO[<span class="number">1</span>], cudaGraphicsRegisterFlagsNone);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在CUDA中映射资源，锁定资源</span></span><br><span class="line"><span class="built_in">cudaGraphicsMapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cudaGraphicsMapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">point *devicePoints1;</span><br><span class="line">point *devicePoints2;</span><br><span class="line"><span class="type">size_t</span> size = <span class="built_in">sizeof</span>(*<span class="keyword">this</span>-&gt;malla)*<span class="keyword">this</span>-&gt;numPoints;</span><br><span class="line"><span class="comment">// 获取操作资源的指针，以便在CUDA核函数中使用</span></span><br><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>((<span class="type">void</span> **)&amp;devicePoints1, &amp;size, <span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">cudaGraphicsResourceGetMappedPointer</span>((<span class="type">void</span> **)&amp;devicePoints2, &amp;size, <span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行CUDA的内核操作Nv12-&gt;BGRA操作．这边请参考例程</span></span><br><span class="line"><span class="built_in">Nv12ToColor32</span>&lt;BGRA32&gt;(pFrame, dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理完了即可解除资源锁定，OpenGL可以开始利用处理结果了。</span></span><br><span class="line"><span class="comment">// 注意在CUDA处理过程中，OpenGL如果访问这些锁定的资源会出错。</span></span><br><span class="line"><span class="built_in">cudaGraphicsUnmapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cudaGraphicsUnmapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">1</span>], <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>值得注意的是，由于这里绑定的是VBO，属于Buffer对象，因此调用的CUDA API是这两个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>();</span><br><span class="line"><span class="built_in">cudaGraphicsResourceGetMappedPointer</span>();</span><br></pre></td></tr></table></figure><h4 id="2-9-2-2-方法二-texture-："><a href="#2-9-2-2-方法二-texture-：" class="headerlink" title="2.9.2.2 方法二(texture)："></a>2.9.2.2 方法二(texture)：</h4><h5 id="2-9-2-2-2-代码实现（为了提高效率，同时操作两个Texture数据）"><a href="#2-9-2-2-2-代码实现（为了提高效率，同时操作两个Texture数据）" class="headerlink" title="2.9.2.2.2 代码实现（为了提高效率，同时操作两个Texture数据）"></a>2.9.2.2.2 代码实现（为了提高效率，同时操作两个Texture数据）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化两个Texture并绑定</span></span><br><span class="line">cudaGraphicsResource_t cudaResources[<span class="number">2</span>];</span><br><span class="line">GLuint textureID[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">glEnable</span>(GL_TEXTURE_2D);</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">2</span>, textureID);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在CUDA中注册这两个Texture</span></span><br><span class="line">cudaError_t err = <span class="built_in">cudaGraphicsGLRegisterImage</span>(&amp;cudaResources[<span class="number">0</span>], textureID[<span class="number">0</span>], GL_TEXTURE_2D, cudaGraphicsRegisterFlagsWriteDiscard);</span><br><span class="line"><span class="keyword">if</span> (err != cudaSuccess)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;cudaGraphicsGLRegisterImage: &quot;</span> &lt;&lt; err &lt;&lt; <span class="string">&quot;Line: &quot;</span> &lt;&lt; __LINE__;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">err = <span class="built_in">cudaGraphicsGLRegisterImage</span>(&amp;cudaResources[<span class="number">1</span>], textureID[<span class="number">1</span>], GL_TEXTURE_2D, cudaGraphicsRegisterFlagsWriteDiscard);</span><br><span class="line"><span class="keyword">if</span> (err != cudaSuccess)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;cudaGraphicsGLRegisterImage: &quot;</span> &lt;&lt; err &lt;&lt; <span class="string">&quot;Line: &quot;</span> &lt;&lt; __LINE__;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在CUDA中锁定资源，获得操作Texture的指针，这里是CudaArray*类型</span></span><br><span class="line">cudaError_t err = <span class="built_in">cudaGraphicsMapResources</span>(<span class="number">2</span>, cudaResource, <span class="number">0</span>);</span><br><span class="line">err = <span class="built_in">cudaGraphicsSubResourceGetMappedArray</span>(&amp;<span class="keyword">this</span>-&gt;cuArrayL, cudaResource[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">err = <span class="built_in">cudaGraphicsSubResourceGetMappedArray</span>(&amp;<span class="keyword">this</span>-&gt;cuArrayR, cudaResource[<span class="number">1</span>], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据拷贝至CudaArray。这里因为得到的是CudaArray，处理时不方便操作，于是先在设备内存中</span></span><br><span class="line"><span class="comment">// 分配缓冲区处理，处理完后再把结果存到CudaArray中，仅仅是GPU内存中的操作。</span></span><br><span class="line"><span class="built_in">cudaMemcpyToArray</span>(cuArrayL, <span class="number">0</span>, <span class="number">0</span>, pHostDataL, imgWidth*imgHeight * <span class="built_in">sizeof</span>(uchar4), cudaMemcpyDeviceToDevice);</span><br><span class="line"><span class="built_in">cudaMemcpyToArray</span>(cuArrayR, <span class="number">0</span>, <span class="number">0</span>, pHostDataR, imgWidth*imgHeight * <span class="built_in">sizeof</span>(uchar4), cudaMemcpyDeviceToDevice);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行CUDA的内核操作Nv12-&gt;BGRA操作．这边请参考例程</span></span><br><span class="line"><span class="built_in">Nv12ToColor32</span>&lt;BGRA32&gt;(pFrame, dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理完后即解除资源锁定，OpenGL可以利用得到的Texture对象进行纹理贴图操作了。</span></span><br><span class="line"><span class="built_in">cudaGraphicsUnmapResources</span>(<span class="number">1</span>, &amp;cudaResource[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cudaGraphicsUnmapResources</span>(<span class="number">1</span>, &amp;cudaResource[<span class="number">1</span>], <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>注意这里因为使用的是Texture对象，因此使用了不同的API：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cudaGraphicsGLRegisterImage</span>();</span><br><span class="line"><span class="built_in">cudaGraphicsSubResourceGetMappedArray</span>();</span><br></pre></td></tr></table></figure><p>由于NvDec解码出来的是Nv12数据，也就是一个个像素数据，因此显然我们是没办法采用VBO+VAO方式的，所以也只有第二种方法适合我们，</p><p>但是，我们查看例程会发现，NVidia提供的例程压根就没采用这两种方式，而是采用了PBO进行映射！！！</p><p>因此我们这里引入pbo概念：PBO一般用于存储图像数据，因此称作Pixel Buffer Object</p><p>而我们的例程中用到的也是这种方案（PBO＋Texture），其本质就是将NvDec解码后的数据的地址与PBO进行绑定，这样我们就能通过PBO来跟CUDA进行互操作，等到NvDec解码后的数据通过CUDA的的Kernel Functions转成了BGRA等格式后，我们再从PBO将数据读到纹理上，之后我们就可以通过对纹理id进行操作，来实现各种特效处理和渲染操作啦！</p><p>至于为啥我们不直接通过OpenGL的纹理和CUDA进行交互的原因就是PBO可以通过 DMA (Direct Memory Access) 快速地在显卡上传递像素数据，而不影响CPU的时钟周期（中断）。同时它还具备异步 DMA 传输的优势。说到底就是这样干效率会高一点！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在OpenGL中分配和图像相同大小的pbo和texture</span></span><br><span class="line">GLuint pbo[<span class="number">2</span>];</span><br><span class="line">GLuint textureID[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//双pbo模式</span></span><br><span class="line"><span class="built_in">glGenBuffersARB</span>(<span class="number">2</span>, pbo);</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">2</span>, textureID);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个pbo存放第一个texture</span></span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, pbo[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">glBufferDataARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, nTexWidth*nTexHeight*<span class="number">4</span>, <span class="literal">NULL</span>, GL_STREAM_DRAW_ARB);</span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA8, width, height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>(&amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>], <span class="keyword">this</span>-&gt;pbo[<span class="number">0</span>], cudaGraphicsRegisterFlagsNone);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个pbo存放第二个texture</span></span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, pbo[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">glBufferDataARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, nTexWidth*nTexHeight*<span class="number">4</span>, <span class="literal">NULL</span>, GL_STREAM_DRAW_ARB);</span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA8, width, height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>(&amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>], <span class="keyword">this</span>-&gt;pbo[<span class="number">1</span>], cudaGraphicsRegisterFlagsNone);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在CUDA中映射资源，锁定资源</span></span><br><span class="line"><span class="built_in">cudaGraphicsMapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cudaGraphicsMapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">point *devicePoints1;</span><br><span class="line">point *devicePoints2;</span><br><span class="line"><span class="type">size_t</span> size = <span class="built_in">sizeof</span>(*<span class="keyword">this</span>-&gt;malla)*<span class="keyword">this</span>-&gt;numPoints;</span><br><span class="line"><span class="comment">// 获取操作资源的指针，以便在CUDA核函数中使用</span></span><br><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>((<span class="type">void</span> **)&amp;devicePoints1, &amp;size, <span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">cudaGraphicsResourceGetMappedPointer</span>((<span class="type">void</span> **)&amp;devicePoints2, &amp;size, <span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行CUDA的内核操作Nv12-&gt;BGRA操作．这边请参考例程</span></span><br><span class="line"><span class="built_in">Nv12ToColor32</span>&lt;BGRA32&gt;(pFrame, dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理完了即可解除资源锁定，OpenGL可以开始利用处理结果了。</span></span><br><span class="line"><span class="comment">// 注意在CUDA处理过程中，OpenGL如果访问这些锁定的资源会出错。</span></span><br><span class="line"><span class="built_in">cudaGraphicsUnmapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cudaGraphicsUnmapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从OpenGL在CUDA映射的PBO中将数据读取到对应的OpenGL纹理上</span></span><br><span class="line"><span class="comment">// load texture from pbo</span></span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, pbo[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_TYPE, textureID[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">glTexSubImage2D</span>(GL_TEXTURE_TYPE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, width, height, GL_BGRA, GL_UNSIGNED_BYTE, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_TYPE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, pbo[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_TYPE, textureID[<span class="number">1</span>]));</span><br><span class="line"><span class="built_in">glTexSubImage2D</span>(GL_TEXTURE_TYPE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, width, height, GL_BGRA, GL_UNSIGNED_BYTE, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_TYPE, <span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>值得注意的是，由于这里绑定的是PBO，属于Buffer对象，而不是Texture对象（可以理解成用PBO对Texture对象进行了封装），因此调用的CUDA API是这两个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>();</span><br><span class="line"><span class="built_in">cudaGraphicsResourceGetMappedPointer</span>();</span><br></pre></td></tr></table></figure><p>在上述的代码中都有一段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行CUDA的内核操作Nv12-&gt;BGRA操作．这边请参考例程</span></span><br><span class="line"><span class="built_in">Nv12ToColor32</span>&lt;BGRA32&gt;(pFrame, dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br></pre></td></tr></table></figure><p>其实这段就是CUDA的内核的操作，通过启动 cuda 内核，用于从原始视频到 OpenGL 纹理可以使用的原始图像格式的色彩空间转换，而因为我这里有NV12ToARGB_drvapi.cu文件，因此我也可以通过执行这个文件的NV12ToARGB_drvapi函数来进行CUDA的内核操作（CUDA kernel for outputing the final ARGB output from NV12）；<br>当然你也可以像Nvidia给的例程中一样，通过NvCodecUtils.h这个文件的Nv12ToColor32接口来进行CUDA的内核操作，从而实现NV12-&gt;RGB32的转换．这个本质上是一样的，没啥区别．</p><p>当然为了我们后面进行OpenGL的渲染和特效处理，从上面的代码可以看出，我们在进行从OpenGL在CUDA映射的PBO中将数据读取到对应的OpenGL纹理上时，我们调用的glTexSubImage2D函数的第七个参数不是GL_RGBA而是GL_BGRA，知道为啥这样吗？<br>因为我们一开始创建纹理在调用glTexImage2D的时候，用的是GL_RGBA参数，而我们进行的CUDA的内核的操作是将Nv12转成了BGRA数据，也就是说现在我们PBO中存放的数据是BGRA排列的数据，而我们一般是习惯用RGBA数据来进行OpenGL操作的，所以如果我们调用glTexSubImage2D函数进行PBO到Texture的操作时，我们还是采用的GL_RGBA参数的话，那么此时Texture上的数据就是BGRA排列的数据了，但是我们如果偷偷的将glTexSubImage2D第七个参数从GL_RGBA改成GL_BGRA的话，那么B和R的数据将会被OpenGL自动进行调换，此时，我们OpenGL的Texture上对应的数据排列就是RGBARGBA了，这操作是不是很秀！</p><h1 id="３-中间渲染和filter链路的构建的具体流程步骤"><a href="#３-中间渲染和filter链路的构建的具体流程步骤" class="headerlink" title="３ 中间渲染和filter链路的构建的具体流程步骤"></a>３ 中间渲染和filter链路的构建的具体流程步骤</h1><h2 id="3-1-OpenGL的屏幕绘制和filter链路的构建"><a href="#3-1-OpenGL的屏幕绘制和filter链路的构建" class="headerlink" title="3.1 OpenGL的屏幕绘制和filter链路的构建"></a>3.1 OpenGL的屏幕绘制和filter链路的构建</h2><h2 id="3-2-OpenGL的filter链路的构建"><a href="#3-2-OpenGL的filter链路的构建" class="headerlink" title="3.2 OpenGL的filter链路的构建"></a>3.2 OpenGL的filter链路的构建</h2><h1 id="4-具体编码流程步骤"><a href="#4-具体编码流程步骤" class="headerlink" title="4 具体编码流程步骤"></a>4 具体编码流程步骤</h1><p>首先我们根据Nvidia官方的<a href="https://docs.nvidia.com/video-technologies/video-codec-sdk/nvenc-video-encoder-api-prog-guide/">NVENC API</a>指南进行学习．</p><p>通过上面的文档我们可以知道NVENC将YUV&#x2F;RGB作为输入并生成符合H.264&#x2F;HEVC&#x2F;AV1标准的视频比特流。<br>而我们则是要通过使用 NVIDIA Video Codec SDK 中提供的 NVENCODE API来实现硬件编码功能．<br>NVENCODE API 函数、结构和其他参数被公开在NVIDIA Video Codec SDK 中提供的nvEncodeAPI.h中，因此我们在进行编码操作时，就需要将该文件include进去，同时还需要加载对应的动态库（Windows上调用的是nvEncodeAPI.dll；linux上调用的是libnvidia-encode.so）．头文件和动态库导入的大致流程如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nvEncodeAPI.h&quot;</span></span></span><br><span class="line">...... </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line"><span class="type">static</span> <span class="type">wchar_t</span> __NVEncodeLibName32[] = <span class="string">L&quot;nvEncodeAPI.dll&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">wchar_t</span> __NVEncodeLibName64[] = <span class="string">L&quot;nvEncodeAPI64.dll&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined __linux__</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> __NVEncodeLibName[] = <span class="string">&quot;libnvidia-encode.so&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">...... </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> BOOL <span class="title">Is64Bit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">sizeof</span>(<span class="type">void</span> *)!=<span class="built_in">sizeof</span>(DWORD));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...... </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Is64Bit</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        m_hinstLib = <span class="built_in">LoadLibrary</span>(__NVEncodeLibName64);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_hinstLib = <span class="built_in">LoadLibrary</span>(__NVEncodeLibName32);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    m_hinstLib = <span class="built_in">dlopen</span>(__NVEncodeLibName, RTLD_LAZY);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>其硬件编码流程，具体过程如下所示：</p><ul><li>初始化编码器</li><li>设置所需的编码参数</li><li>分配输入&#x2F;输出缓冲区</li><li>将帧复制到输入缓冲区并从输出缓冲区读取比特流。这可以同步（Windows 和 Linux）或异步（仅限 Windows 7 及更高版本）完成。</li><li>清理&#x2F;释放所有分配的输入&#x2F;输出缓冲区</li><li>关闭编码会话</li></ul><h2 id="4-1-初始化编码器"><a href="#4-1-初始化编码器" class="headerlink" title="4.1 初始化编码器"></a>4.1 初始化编码器</h2><p>接下来的讲解，我们将基于在<a href="https://community.adobe.com/t5/adobe-media-encoder-discussions/nvidia-gpu-accelerated-h264-encoder-plugin-ready-for-public-testing/td-p/5213367">Adobe Support Community</a>网站上一位名叫Guest的作者在2013年提供的<a href="https://github.com/jetkiwi/NVENC_export">NVENC_export</a>作为参考来进行适当修改，来实现我们的功能．</p><p>当我们加载完nvEncodeAPI对应的库文件后，第一步就是调用NvEncodeAPICreateInstance．这个接口会将动态库中的函数加载到对应的函数指针中，这样我们在后续的操作中才能调用NVENCODE中的其他API接口．</p><p>具体的参考代码在NVENC_export&#x2F;Samples&#x2F;nvEncode2&#x2F;src文件夹中的CNVEncoder.cpp文件中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    NVENCSTATUS nvStatus;</span><br><span class="line">    MYPROC nvEncodeAPICreateInstance; <span class="comment">// function pointer to create instance in nvEncodeAPI</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Is64Bit</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        m_hinstLib = <span class="built_in">LoadLibrary</span>(<span class="built_in">TEXT</span>(__NVEncodeLibName64));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_hinstLib = <span class="built_in">LoadLibrary</span>(<span class="built_in">TEXT</span>(__NVEncodeLibName32));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    m_hinstLib = <span class="built_in">dlopen</span>(__NVEncodeLibName, RTLD_LAZY);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_hinstLib != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line">        nvEncodeAPICreateInstance = (MYPROC) <span class="built_in">GetProcAddress</span>(m_hinstLib, <span class="string">&quot;NvEncodeAPICreateInstance&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        nvEncodeAPICreateInstance = (MYPROC) <span class="built_in">dlsym</span>(m_hinstLib, <span class="string">&quot;NvEncodeAPICreateInstance&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != nvEncodeAPICreateInstance) </span><br><span class="line">        &#123;</span><br><span class="line">            m_pEncodeAPI = <span class="keyword">new</span> NV_ENCODE_API_FUNCTION_LIST;</span><br><span class="line">            <span class="keyword">if</span> (m_pEncodeAPI)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(m_pEncodeAPI, <span class="number">0</span>, <span class="built_in">sizeof</span>(NV_ENCODE_API_FUNCTION_LIST));</span><br><span class="line">                m_pEncodeAPI-&gt;version = NV_ENCODE_API_FUNCTION_LIST_VER;</span><br><span class="line">                nvStatus = <span class="built_in">nvEncodeAPICreateInstance</span>(m_pEncodeAPI);</span><br><span class="line">                m_bEncodeAPIFound = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_bEncodeAPIFound = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">PRINTERR</span>((<span class="string">&quot;CNvEncoder::CNvEncoder() failed to find NvEncodeAPICreateInstance&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在上面代码中，我们拿到m_pEncodeAPI后(也就是执行完nvStatus &#x3D; nvEncodeAPICreateInstance(m_pEncodeAPI)语句后)，为了确保拿到的m_pEncodeAPI可以调用到我们后续需要的nvEncodeAPI接口，其实我们可以在加个if语句进行判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!m_pEncodeAPI-&gt;nvEncCreateBitstreamBuffer || !m_pEncodeAPI-&gt;nvEncOpenEncodeSession || !m_pEncodeAPI-&gt;nvEncGetEncodeGUIDCount || !m_pEncodeAPI-&gt;nvEncGetEncodeProfileGUIDCount ||</span><br><span class="line">!m_pEncodeAPI-&gt;nvEncGetEncodeProfileGUIDs || !m_pEncodeAPI-&gt;nvEncGetEncodeGUIDs || !m_pEncodeAPI-&gt;nvEncGetInputFormatCount || !m_pEncodeAPI-&gt;nvEncGetInputFormats ||</span><br><span class="line">!m_pEncodeAPI-&gt;nvEncGetEncodeCaps || !m_pEncodeAPI-&gt;nvEncGetEncodePresetCount || !m_pEncodeAPI-&gt;nvEncGetEncodePresetGUIDs || !m_pEncodeAPI-&gt;nvEncGetEncodePresetConfig ||</span><br><span class="line">!m_pEncodeAPI-&gt;nvEncInitializeEncoder || !m_pEncodeAPI-&gt;nvEncCreateInputBuffer || !m_pEncodeAPI-&gt;nvEncDestroyInputBuffer || !m_pEncodeAPI-&gt;nvEncCreateBitstreamBuffer ||</span><br><span class="line">!m_pEncodeAPI-&gt;nvEncDestroyBitstreamBuffer || !m_pEncodeAPI-&gt;nvEncEncodePicture || !m_pEncodeAPI-&gt;nvEncLockBitstream || !m_pEncodeAPI-&gt;nvEncUnlockBitstream ||</span><br><span class="line">!m_pEncodeAPI-&gt;nvEncLockInputBuffer || !m_pEncodeAPI-&gt;nvEncUnlockInputBuffer || !m_pEncodeAPI-&gt;nvEncGetEncodeStats || !m_pEncodeAPI-&gt;nvEncGetSequenceParams ||</span><br><span class="line">!m_pEncodeAPI-&gt;nvEncRegisterAsyncEvent || !m_pEncodeAPI-&gt;nvEncUnregisterAsyncEvent || !m_pEncodeAPI-&gt;nvEncMapInputResource || !m_pEncodeAPI-&gt;nvEncUnmapInputResource ||</span><br><span class="line">!m_pEncodeAPI-&gt;nvEncDestroyEncoder || !m_pEncodeAPI-&gt;nvEncInvalidateRefFrames || !m_pEncodeAPI-&gt;nvEncOpenEncodeSessionEx || !m_pEncodeAPI-&gt;nvEncRegisterResource ||</span><br><span class="line">!m_pEncodeAPI-&gt;nvEncUnregisterResource || !m_pEncodeAPI-&gt;nvEncReconfigureEncoder)</span><br><span class="line">                        &#123;</span><br><span class="line">                            m_bEncodeAPIFound = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            m_bEncodeAPIFound = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure><p>此时，如果m_bEncodeAPIFound为true就代表着我们已经成功的加载了我们后续需要的所有nvEncodeAPI接口（｡♥‿♥｡）</p><h2 id="4-2-设置所需的编码参数"><a href="#4-2-设置所需的编码参数" class="headerlink" title="4.2 设置所需的编码参数"></a>4.2 设置所需的编码参数</h2><p>至此，我们已经成功完成了编码器的初始化，接下来就需要对编码器的参数进行设置了．<br>具体步骤如下：</p><ul><li>获取编码会话句柄</li><li>选择编码器GUID</li><li>获取编码器信息</li><li>选择编码器预设配置</li><li>选择编码器配置文件</li><li>获取支持的输入格式列表</li></ul><h3 id="4-2-1-获取编码会话句柄"><a href="#4-2-1-获取编码会话句柄" class="headerlink" title="4.2.1 获取编码会话句柄"></a>4.2.1 获取编码会话句柄</h3><p>当我们成功加载 NVENC 接口后，还必须要调用NvEncOpenEncodeSessionEx打开编码会话。此函数返回一个编码会话句柄，该句柄必须用于当前会话中对 API 函数的所有后续调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NVENCSTATUS</span> <span class="params">(NVENCAPI* PNVENCOPENENCODESESSIONEX)</span>       <span class="params">(NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS *openSessionExParams, </span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">PNVENCOPENENCODESESSIONEX       nvEncOpenEncodeSessionEx;    </span></span></span><br></pre></td></tr></table></figure><p>在NVENC_export&#x2F;Samples&#x2F;nvEncode2&#x2F;src文件夹中的CNVEncoder.cpp文件中的CNvEncoder::OpenEncodeSession函数中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">    HRESULT hr = S_OK;</span><br><span class="line">    <span class="comment">//NVENCSTATUS nvStatus = NV_ENC_SUCCESS;</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;m_stEncoderInput, &amp;encodeConfig, <span class="built_in">sizeof</span>(m_stEncoderInput));</span><br><span class="line">    m_fOutput = m_stEncoderInput.fOutput;</span><br><span class="line">    <span class="type">bool</span> bCodecFound = <span class="literal">false</span>;</span><br><span class="line">    NV_ENC_CAPS_PARAM stCapsParam = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS stEncodeSessionParams = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uArraysize = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">SET_VER</span>(stCapsParam, NV_ENC_CAPS_PARAM);</span><br><span class="line">    <span class="built_in">SET_VER</span>(stEncodeSessionParams, NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If another NVENC session is already open, close it (to avoid mem-leak)</span></span><br><span class="line"><span class="built_in">DestroyEncodeSession</span>();</span><br><span class="line"></span><br><span class="line">nvStatus = NV_ENC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (m_stEncoderInput.interfaceType)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line">        <span class="keyword">case</span> NV_ENC_DX9:</span><br><span class="line">            <span class="built_in">InitD3D9</span>(deviceID);</span><br><span class="line">            stEncodeSessionParams.device = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(m_pD3D9Device);</span><br><span class="line">            stEncodeSessionParams.deviceType = NV_ENC_DEVICE_TYPE_DIRECTX;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> NV_ENC_DX10:</span><br><span class="line">            <span class="built_in">InitD3D10</span>(deviceID);</span><br><span class="line">            stEncodeSessionParams.device = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(m_pD3D10Device);</span><br><span class="line">            stEncodeSessionParams.deviceType = NV_ENC_DEVICE_TYPE_DIRECTX;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> NV_ENC_DX11:</span><br><span class="line">            <span class="built_in">InitD3D11</span>(deviceID);</span><br><span class="line">            stEncodeSessionParams.device = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(m_pD3D11Device);</span><br><span class="line">            stEncodeSessionParams.deviceType = NV_ENC_DEVICE_TYPE_DIRECTX;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">case</span> NV_ENC_CUDA:</span><br><span class="line"><span class="keyword">if</span> ( !m_useExternalContext )</span><br><span class="line"><span class="built_in">InitCuda</span>(deviceID);</span><br><span class="line">            stEncodeSessionParams.device = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(m_cuContext);</span><br><span class="line">            stEncodeSessionParams.deviceType = NV_ENC_DEVICE_TYPE_CUDA;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">assert</span>(<span class="string">&quot;Encoder interface not supported&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="comment">// switch</span></span><br><span class="line"></span><br><span class="line">    nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncOpenEncodeSessionEx</span>( &amp;stEncodeSessionParams, &amp;m_hEncoder);</span><br><span class="line">    <span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">my_printf</span>(<span class="string">&quot;nvEncOpenEncodeSessionEx() returned with error %d\n&quot;</span>, nvStatus);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Note: GUID key may be invalid or incorrect.  Recommend to upgrade your drivers and obtain a new key\n&quot;</span>);</span><br><span class="line">        <span class="comment">//checkNVENCErrors(nvStatus);// prevent NVNEC-plugin from exiting prematurely</span></span><br><span class="line"><span class="keyword">return</span> E_FAIL;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以从上面的代码看出，由于Guest的作者在2013年提供的<a href="https://github.com/jetkiwi/NVENC_export">NVENC_export</a>只适用于Win端，因此在上面的switch判断中，我们还需要加上一段针对Linux端的判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line">        <span class="keyword">case</span> NV_ENC_OPENGL:</span><br><span class="line">            <span class="comment">//NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS::device must be NULL if type is NV_ENC_OPENGL</span></span><br><span class="line">            stEncodeSessionParams.device = <span class="literal">nullptr</span>;</span><br><span class="line">            stEncodeSessionParams.deviceType = NV_ENC_DEVICE_TYPE_OPENGL;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>对应的将修改成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_NvEncodeInterfaceType</span></span><br><span class="line">&#123;</span><br><span class="line">    NV_ENC_DX9=<span class="number">0</span>,</span><br><span class="line">    NV_ENC_DX11=<span class="number">1</span>,</span><br><span class="line">    NV_ENC_CUDA=<span class="number">2</span>, <span class="comment">// On Linux, CUDA is the only NVENC interface available</span></span><br><span class="line">    NV_ENC_DX10=<span class="number">3</span>,</span><br><span class="line">    NV_ENC_OPENGL=<span class="number">4</span>,</span><br><span class="line">&#125; NvEncodeInterfaceType;</span><br></pre></td></tr></table></figure><p>至于为什么将device参数设置为nullptr，其实在官方提供的<a href="https://docs.nvidia.com/video-technologies/video-codec-sdk/nvenc-video-encoder-api-prog-guide/">文档</a>里面是有说明的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">OpenGL</span><br><span class="line">    The client should create an OpenGL context and make it current (in order to associate the context with the thread/process that is making calls to NVENCODE API) to the thread calling into NVENCODE API. NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS::device must be NULL and NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS::deviceType must be set to NV_ENC_DEVICE_TYPE_OPENGL. Use of the OpenGL device type for encoding is supported only on Linux.</span><br><span class="line">```   </span><br><span class="line">### 4.2.2 选择编码器GUID</span><br><span class="line">大致的设置流程分为以下几个部分：</span><br><span class="line">- 调用NvEncGetEncodeGUIDCount从 NVIDIA 视频编码器接口获取支持的编码器 GUID 的数量。</span><br><span class="line">- 使用获取到的支持的编码器 GUID 的数量结果来分配一个足够大的缓冲区，来容纳支持的编码器 GUID</span><br><span class="line">- 调用NvEncGetEncodeGUIDs填充此列表。</span><br><span class="line"></span><br><span class="line">PS:一般来说调用nvEncGetEncodeGUIDCount接口后，m_dwEncodeGUIDCount返回的值应该为2，也就是支持H264和HEVC这两种编码方式，如果返回的值不是2，那就需要你自己去查一下你的显卡到底咋回事了；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">// Enumerate the codec support by the HW Encoder</span><br><span class="line">    nvStatus = m_pEncodeAPI-&gt;nvEncGetEncodeGUIDCount(m_hEncoder, &amp;m_dwEncodeGUIDCount);</span><br><span class="line">    if (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        my_printf(&quot;nvEncGetEncodeGUIDCount() returned with error %d\n&quot;, nvStatus);</span><br><span class="line">        checkNVENCErrors(nvStatus);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">delete_array( m_stEncodeGUIDArray );</span><br><span class="line">        m_stEncodeGUIDArray       = new GUID[m_dwEncodeGUIDCount];</span><br><span class="line">        memset(m_stEncodeGUIDArray, 0, sizeof(GUID) * m_dwEncodeGUIDCount);</span><br><span class="line">        uArraysize = 0;</span><br><span class="line">        nvStatus = m_pEncodeAPI-&gt;nvEncGetEncodeGUIDs(m_hEncoder, m_stEncodeGUIDArray, m_dwEncodeGUIDCount, &amp;uArraysize);</span><br><span class="line">        assert(uArraysize &lt;= m_dwEncodeGUIDCount);</span><br><span class="line">        if (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            my_printf(&quot;nvEncGetEncodeGUIDs() returned with error %d\n&quot;, nvStatus);</span><br><span class="line">            checkNVENCErrors(nvStatus);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            for (unsigned int i = 0; i &lt; uArraysize; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                // check if HW encoder supports the particular codec -</span><br><span class="line">                if (GetCodecType(m_stEncodeGUIDArray[i]) == (unsigned int)m_stEncoderInput.codec)</span><br><span class="line">                &#123;</span><br><span class="line">// Found the desired codec GUID - store it as &quot;m_stEncodeGUID&quot;</span><br><span class="line">                    bCodecFound = true;</span><br><span class="line">                    memcpy(&amp;m_stEncodeGUID, &amp;m_stEncodeGUIDArray[i], sizeof(GUID));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    if (bCodecFound == false)</span><br><span class="line">    &#123;</span><br><span class="line">// Hardware doesn&#x27;t support our requested codec-type &lt;m_stEncoderInput.codec&gt;</span><br><span class="line">        assert(0);</span><br><span class="line">        return E_FAIL;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-3-获取编码器信息"><a href="#4-2-3-获取编码器信息" class="headerlink" title="4.2.3 获取编码器信息"></a>4.2.3 获取编码器信息</h3><p>NVIDIA 编码器接口公开了四种不同的调整信息枚举（高质量、低延迟、超低延迟和无损）来满足不同的视频编码应用场景<br>对于每个调整信息，提供了从 P1（最高性能）到 P7（最低性能）的七个预设来控制性能&#x2F;质量权衡。使用这些预设将自动为所选调谐信息设置所有相关编码参数。这是 API 公开的粗略控制级别。如果需要，可以调整预设中的特定属性&#x2F;参数。</p><p>获取编码器信息和预设配置的大致的设置流程分为以下几个部分：</p><ul><li>调用NvEncGetEncodePresetCount获取支持的编码器 GUID 的数量。</li><li>使用这个计数来分配一个足够大的缓冲区来保存支持的预设GUID。</li><li>调用NvEncGetEncodePresetGUIDs填充此列表。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetPresetConfig():</span></span><br><span class="line"><span class="comment">//    Gets the requested NVENC preset and stores it in this.m_stPresetConfig </span></span><br><span class="line"><span class="comment">//    Note, if requested preset is &#x27;default&#x27; (0), then allow any preset to be returned.</span></span><br><span class="line"><span class="comment">//    (This is a workaround for Geforce WHQL driver 314.21, where nvEncGetEncodePresetGUIDs returns</span></span><br><span class="line"><span class="comment">//    DEFAULT_GUID as a supported preset, but nvEncGetEncodePresetConfig returns ERROR for the</span></span><br><span class="line"><span class="comment">//    same DEFAULT_GUID.)</span></span><br><span class="line"><span class="function">HRESULT <span class="title">CNvEncoder::GetPresetConfig</span><span class="params">(<span class="type">const</span> <span class="type">int</span> iPresetIdx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NVENCSTATUS nvStatus = NV_ENC_SUCCESS;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uPresetCount2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncGetEncodePresetCount</span>(m_hEncoder, m_stEncodeGUID, &amp;m_dwCodecPresetGUIDCount);</span><br><span class="line">    <span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line"><span class="keyword">return</span> E_FAIL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete_array</span>(m_stCodecPresetGUIDArray);</span><br><span class="line">    m_stCodecPresetGUIDArray = <span class="keyword">new</span> GUID[m_dwCodecPresetGUIDCount];</span><br><span class="line">    nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncGetEncodePresetGUIDs</span>(m_hEncoder, m_stEncodeGUID, m_stCodecPresetGUIDArray, m_dwCodecPresetGUIDCount, &amp;uPresetCount2);</span><br><span class="line">    <span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line"><span class="keyword">return</span> E_FAIL;</span><br><span class="line"></span><br><span class="line">nvStatus = NV_ENC_ERR_GENERIC;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; m_dwCodecPresetGUIDCount; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// hack: if ( iPresetIdx == 0 &quot;default&quot;), then return the first valid preset.</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">int</span>)i == iPresetIdx || (iPresetIdx == <span class="number">0</span>) )</span><br><span class="line">&#123;</span><br><span class="line">nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncGetEncodePresetConfig</span>(m_hEncoder, m_stEncodeGUID, m_stCodecPresetGUIDArray[i], &amp;m_stPresetConfig);</span><br><span class="line"><span class="keyword">if</span> (nvStatus == NV_ENC_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">m_stPresetIdx  = iPresetIdx;</span><br><span class="line">m_stPresetGUID = m_stCodecPresetGUIDArray[m_stPresetIdx];</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( iPresetIdx != <span class="number">0</span> )</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nvStatus == NV_ENC_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> E_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-4-选择编码器预设配置"><a href="#4-2-4-选择编码器预设配置" class="headerlink" title="4.2.4 选择编码器预设配置"></a>4.2.4 选择编码器预设配置</h3><p>以下是获取预设编码配置并可选择更改选择配置参数的步骤：</p><ul><li>调用NvEncGetEncodePresetConfigEx与选定的 encodeGUID，调整信息和预设GUID作为输入</li><li>可以通过以下方式检索所需的预设编码器配置 NV_ENC_PRESET_CONFIG::presetCfg.</li><li>如果需要，使用相应的配置 API 覆盖默认编码器参数。</li></ul><p>这个可以不选择设置，直接采用默认的就行了，正常来说默认参数就够用了．</p><h3 id="4-2-5-选择编码器配置文件"><a href="#4-2-5-选择编码器配置文件" class="headerlink" title="4.2.5 选择编码器配置文件"></a>4.2.5 选择编码器配置文件</h3><p>大致的设置流程分为以下几个部分：</p><ul><li>调用NvEncGetEncodeProfileGUIDCount从 NVIDIA 视频编码器接口获取支持的编码器 GUID 的数量。</li><li>使用此计数来分配足够大小的缓冲区以容纳支持的编码配置文件 GUID。</li><li>调用NvEncGetEncodeProfileGUIDs填充此列表。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Enumerate the profile(s) available for selected codec &lt;m_stEncodeGUID&gt;</span></span><br><span class="line">  nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncGetEncodeProfileGUIDCount</span>(m_hEncoder, m_stEncodeGUID, &amp;m_dwCodecProfileGUIDCount);</span><br><span class="line">  <span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">my_printf</span>( <span class="string">&quot;nvEncGetEncodeProfileGUIDCount() returned with error %d\n&quot;</span>, nvStatus);</span><br><span class="line">      <span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">delete_array</span>( m_stCodecProfileGUIDArray );</span><br><span class="line">      m_stCodecProfileGUIDArray = <span class="keyword">new</span> GUID[m_dwCodecProfileGUIDCount];</span><br><span class="line">      <span class="built_in">memset</span>(m_stCodecProfileGUIDArray, <span class="number">0</span>, <span class="built_in">sizeof</span>(GUID) * m_dwCodecProfileGUIDCount);</span><br><span class="line">      uArraysize = <span class="number">0</span>;</span><br><span class="line">      nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncGetEncodeProfileGUIDs</span>(m_hEncoder,  m_stEncodeGUID, m_stCodecProfileGUIDArray, m_dwCodecProfileGUIDCount, &amp;uArraysize);</span><br><span class="line">      <span class="built_in">assert</span>(uArraysize &lt;= m_dwCodecProfileGUIDCount);</span><br><span class="line">      <span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">my_printf</span>( <span class="string">&quot;nvEncGetEncodeProfileGUIDs() returned with error %d\n&quot;</span>, nvStatus);</span><br><span class="line">          <span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          bCodecFound = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; uArraysize; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">// check if this HW-codec supports the requested profile &lt;m_stEncoderInput.profile&gt;</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">GetCodecProfile</span>(m_stCodecProfileGUIDArray[i]) == m_stEncoderInput.profile)</span><br><span class="line">              &#123;</span><br><span class="line"><span class="comment">// Found the desired Profile - store it as &quot;m_stCodecProfileGUID&quot;</span></span><br><span class="line">                  bCodecFound = <span class="literal">true</span>;</span><br><span class="line">                  <span class="built_in">memcpy</span>(&amp;m_stCodecProfileGUID, &amp;m_stCodecProfileGUIDArray[i], <span class="built_in">sizeof</span>(GUID));</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bCodecFound == <span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="comment">// Codec doesn&#x27;t support our requested profile &lt;m_stEncoderInput.profile&gt;</span></span><br><span class="line">      <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> E_FAIL;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-2-6-获取支持的输入格式列表"><a href="#4-2-6-获取支持的输入格式列表" class="headerlink" title="4.2.6 获取支持的输入格式列表"></a>4.2.6 获取支持的输入格式列表</h3><p>NVENCODE API 接受几种不同格式的输入帧，例如特定格式的 YUV 和 RGB。</p><p>可以按如下方式检索支持的输入格式列表：</p><ul><li>调用NvEncGetInputFormatCount获取支持的输入格式的数量。</li><li>使用这个计数来分配一个缓冲区来保存支持的输入缓冲区格式列表（它们是类型的列表元素NV_ENC_BUFFER_FORMAT).</li><li>通过调用NvEncGetInputFormats检索支持的输入缓冲区格式.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// Enumerate the (framebuffer) InputFormats available for selected codec &lt;m_stEncodeGUID&gt;</span></span><br><span class="line">   nvStatus =  m_pEncodeAPI-&gt;<span class="built_in">nvEncGetInputFormatCount</span>(m_hEncoder, m_stEncodeGUID, &amp;m_dwInputFmtCount);</span><br><span class="line">   <span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">my_printf</span>(<span class="string">&quot;nvEncGetInputFormatCount() returned with error %d\n&quot;</span>, nvStatus);</span><br><span class="line">       <span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">delete_array</span>( m_pAvailableSurfaceFmts );</span><br><span class="line">       m_pAvailableSurfaceFmts = <span class="keyword">new</span> NV_ENC_BUFFER_FORMAT[m_dwInputFmtCount];</span><br><span class="line">       <span class="built_in">memset</span>(m_pAvailableSurfaceFmts, <span class="number">0</span>, <span class="built_in">sizeof</span>(NV_ENC_BUFFER_FORMAT) * m_dwInputFmtCount);</span><br><span class="line">       nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncGetInputFormats</span>(m_hEncoder, m_stEncodeGUID, m_pAvailableSurfaceFmts, m_dwInputFmtCount, &amp;uArraysize);</span><br><span class="line">       <span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">my_printf</span>(<span class="string">&quot;nvEncGetInputFormats() returned with error %d\n&quot;</span>, nvStatus);</span><br><span class="line">           <span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>  &#123;</span><br><span class="line">           <span class="type">bool</span> bFmtFound = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> bFound_420 = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> bFound_444 = <span class="literal">false</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> idx;</span><br><span class="line">           <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; m_dwInputFmtCount; idx++)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// check if this HW-codec supports the requested (framebuffer) InputFormat </span></span><br><span class="line">               bFound_420 = encodeConfig.chromaFormatIDC == cudaVideoChromaFormat_420 &amp;&amp;</span><br><span class="line">(m_pAvailableSurfaceFmts[idx] == NV_ENC_BUFFER_FORMAT_NV12);</span><br><span class="line"></span><br><span class="line">bFound_444 = encodeConfig.chromaFormatIDC == cudaVideoChromaFormat_444 &amp;&amp;</span><br><span class="line">     ## <span class="number">4.3</span> 分配输入/输出缓冲区                  (m_pAvailableSurfaceFmts[idx] == NV_ENC_BUFFER_FORMAT_YUV444);</span><br><span class="line"><span class="keyword">if</span> ( bFound_420 || bFound_444 )</span><br><span class="line">&#123;</span><br><span class="line">            m_dwInputFormat = m_pAvailableSurfaceFmts[idx];</span><br><span class="line">bFmtFound = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="keyword">if</span> ( !bFmtFound ) &#123;</span><br><span class="line"><span class="built_in">my_printf</span>(<span class="string">&quot;ERROR, Unable to locate a compatible chromaformatIDC\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">           <span class="built_in">assert</span>(bFmtFound == <span class="literal">true</span>);</span><br><span class="line">           <span class="built_in">assert</span>(uArraysize &lt;= m_dwInputFmtCount);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (encodeConfig.preset &gt; <span class="number">-1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       hr = <span class="built_in">GetPresetConfig</span>(encodeConfig.preset);</span><br><span class="line">       <span class="keyword">if</span> (hr == S_OK)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">memcpy</span>(&amp;m_stEncodeConfig, &amp;m_stPresetConfig.presetCfg, <span class="built_in">sizeof</span>(NV_ENC_CONFIG));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if this HW-codec supports the requested (framebuffer) InputFormat </span></span><br><span class="line"><span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (Premiere Pro only): setup which optimizations the format-repacker </span></span><br><span class="line"><span class="comment">//                      is allowed to use</span></span><br><span class="line">m_Repackyuv.<span class="built_in">set_cpu_allow_avx</span>(m_stEncoderInput.CPU_enableAVX);</span><br><span class="line">m_Repackyuv.<span class="built_in">set_cpu_allow_avx2</span>(m_stEncoderInput.CPU_enableAVX2);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-2-7-初始化硬件编码器会话"><a href="#4-2-7-初始化硬件编码器会话" class="headerlink" title="4.2.7 初始化硬件编码器会话"></a>4.2.7 初始化硬件编码器会话</h3><p>大致的设置流程分为以下几个部分：</p><ul><li>编码会话属性的配置</li><li>初始化硬件编码器会话</li></ul><h4 id="4-2-7-1-编码会话属性的配置"><a href="#4-2-7-1-编码会话属性的配置" class="headerlink" title="4.2.7.1 编码会话属性的配置"></a>4.2.7.1 编码会话属性的配置</h4><p>编码会话参数配置分为三部分：</p><ul><li>基本的编码会话参数</li><li>高级编码器级参数</li></ul><h5 id="4-2-7-1-1-基本的编码会话参数"><a href="#4-2-7-1-1-基本的编码会话参数" class="headerlink" title="4.2.7.1.1 基本的编码会话参数"></a>4.2.7.1.1 基本的编码会话参数</h5><p>输入格式、输出尺寸、显示纵横比、帧率、平均码率等常用参数在NV_ENC_INITIALIZE_PARAMS结构体。用户应使用此结构的实例作为输入 NvEnc初始化编码器.</p><p>必须填充以下成员 NV_ENC_INITIALIZE_PARAMS成功初始化编码会话的结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NV_ENC_INITALIZE_PARAMS::encodeGUID：必须选择合适的编解码器 GUID，如选择编码器GUID部分所述。</span><br><span class="line">NV_ENC_INITIALIZE_PARAMS::编码宽度：必须指定编码视频的所需宽度。</span><br><span class="line">NV_ENC_INITIALIZE_PARAMS::encodeHeight：必须指定编码视频的所需高度。</span><br><span class="line">NV_ENC_INITALIZE_PARAMS::reportSliceOffsets：可用于启用切片偏移的报告。此功能需要NV_ENC_INITALIZE_PARAMS::enableEncodeAsync设置为<span class="number">0</span>，并且不适用于Kepler GPU上基于MB和基于字节的切片。</span><br></pre></td></tr></table></figure><h5 id="4-2-7-1-2-高级编解码器级参数"><a href="#4-2-7-1-2-高级编解码器级参数" class="headerlink" title="4.2.7.1.2 高级编解码器级参数"></a>4.2.7.1.2 高级编解码器级参数</h5><p>参数NV_ENC_INITIALIZE_PARAMS::NV_ENC_CONFIG encodeConfig：处理编码比特流的参数，如 GOP 长度、编码器配置文件、速率控制模式等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_NV_ENC_CONFIG</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span>                        version;           </span><br><span class="line">    GUID                            profileGUID;       </span><br><span class="line">    <span class="type">uint32_t</span>                        gopLength;         </span><br><span class="line">    <span class="type">int32_t</span>                         frameIntervalP;    </span><br><span class="line">    <span class="type">uint32_t</span>                        monoChromeEncoding;</span><br><span class="line">    NV_ENC_PARAMS_FRAME_FIELD_MODE  frameFieldMode;    </span><br><span class="line">                                                                                                              </span><br><span class="line">    NV_ENC_MV_PRECISION             mvPrecision;       </span><br><span class="line">    NV_ENC_RC_PARAMS                rcParams;          </span><br><span class="line">    NV_ENC_CODEC_CONFIG             encodeCodecConfig; </span><br><span class="line">    <span class="type">uint32_t</span>                        reserved [<span class="number">278</span>];    </span><br><span class="line">    <span class="type">void</span>*                           reserved2[<span class="number">64</span>];     </span><br><span class="line">&#125; NV_ENC_CONFIG;</span><br></pre></td></tr></table></figure><p>结构中提供高级 H.264、HEVC 和 AV1 特定参数 NV_ENC_CONFIG_H264,NV_ENC_CONFIG_HEVC和NV_ENC_CONFIG_AV1分别。用户可以通过该结构传递特定于编解码器的参数 NV_ENC_CONFIG::encodeCodecConfig.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \struct _NV_ENC_CODEC_CONFIG</span></span><br><span class="line"><span class="comment"> * Codec-specific encoder configuration parameters to be set during initialization.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">_NV_ENC_CODEC_CONFIG</span></span><br><span class="line">&#123;</span><br><span class="line">    NV_ENC_CONFIG_H264        h264Config;                <span class="comment">/**&lt; [in]: Specifies the H.264-specific encoder configuration. */</span></span><br><span class="line">    NV_ENC_CONFIG_HEVC        hevcConfig;                <span class="comment">/**&lt; [in]: Specifies the HEVC-specific encoder configuration. */</span></span><br><span class="line">    NV_ENC_CONFIG_H264_MEONLY h264MeOnlyConfig;          <span class="comment">/**&lt; [in]: Specifies the H.264-specific ME only encoder configuration. */</span></span><br><span class="line">    NV_ENC_CONFIG_HEVC_MEONLY hevcMeOnlyConfig;          <span class="comment">/**&lt; [in]: Specifies the HEVC-specific ME only encoder configuration. */</span></span><br><span class="line">    <span class="type">uint32_t</span>                reserved[<span class="number">320</span>];               <span class="comment">/**&lt; [in]: Reserved and must be set to 0 */</span></span><br><span class="line">&#125; NV_ENC_CODEC_CONFIG;</span><br></pre></td></tr></table></figure><p>具体的参考代码在NVENC_export&#x2F;Samples&#x2F;nvEncode2&#x2F;src文件夹中的CNvEncoderH264.cpp文件中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">HRESULT <span class="title">CNvEncoderH264::InitializeEncoderCodec</span><span class="params">(<span class="type">void</span> * <span class="type">const</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NV_ENC_CONFIG_H264_VUI_PARAMETERS *pvui;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> x264_sei_uuid[<span class="number">16</span>] = <span class="comment">// X264&#x27;s unregistered_user SEI</span></span><br><span class="line">&#123;   <span class="comment">// random ID number generated according to ISO-11578</span></span><br><span class="line"><span class="number">0xdc</span>, <span class="number">0x45</span>, <span class="number">0xe9</span>, <span class="number">0xbd</span>, <span class="number">0xe6</span>, <span class="number">0xd9</span>, <span class="number">0x48</span>, <span class="number">0xb7</span>,</span><br><span class="line"><span class="number">0x96</span>, <span class="number">0x2c</span>, <span class="number">0xd8</span>, <span class="number">0x20</span>, <span class="number">0xd9</span>, <span class="number">0x23</span>, <span class="number">0xee</span>, <span class="number">0xef</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    HRESULT hr           = S_OK;</span><br><span class="line">    <span class="type">int</span> numFrames        = <span class="number">0</span>;</span><br><span class="line">    NVENCSTATUS nvStatus = NV_ENC_SUCCESS;</span><br><span class="line">    <span class="type">bool</span> bMVCEncoding    = m_stEncoderInput.profile == NV_ENC_H264_PROFILE_STEREO ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    m_bAsyncModeEncoding = ((m_stEncoderInput.syncMode==<span class="number">0</span>) ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">string            s; <span class="comment">// text-buffer</span></span><br><span class="line">ostringstream   oss; <span class="comment">// text-buffer to generate encoder-settings</span></span><br><span class="line"></span><br><span class="line">    m_uMaxHeight         = m_stEncoderInput.maxHeight;</span><br><span class="line">    m_uMaxWidth          = m_stEncoderInput.maxWidth;</span><br><span class="line">    m_dwFrameWidth       = m_stEncoderInput.width;</span><br><span class="line">    m_dwFrameHeight      = m_stEncoderInput.height;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;m_stInitEncParams, <span class="number">0</span>, <span class="built_in">sizeof</span>(NV_ENC_INITIALIZE_PARAMS));</span><br><span class="line">    <span class="built_in">SET_VER</span>(m_stInitEncParams, NV_ENC_INITIALIZE_PARAMS);</span><br><span class="line">    m_stInitEncParams.encodeConfig = &amp;m_stEncodeConfig;</span><br><span class="line">    <span class="built_in">SET_VER</span>(m_stEncodeConfig, NV_ENC_CONFIG);</span><br><span class="line"></span><br><span class="line">pvui = <span class="built_in">reinterpret_cast</span>&lt;NV_ENC_CONFIG_H264_VUI_PARAMETERS *&gt;(p);</span><br><span class="line"></span><br><span class="line">    m_stInitEncParams.darHeight           = m_stEncoderInput.darRatioY;</span><br><span class="line">    m_stInitEncParams.darWidth            = m_stEncoderInput.darRatioX;</span><br><span class="line"><span class="comment">//    m_stInitEncParams.encodeHeight        = m_uMaxHeight;</span></span><br><span class="line"><span class="comment">//    m_stInitEncParams.encodeWidth         = m_uMaxWidth;</span></span><br><span class="line">    m_stInitEncParams.encodeHeight        = m_dwFrameHeight;</span><br><span class="line">    m_stInitEncParams.encodeWidth         = m_dwFrameWidth;</span><br><span class="line">    </span><br><span class="line">    m_uCurHeight                          = m_stInitEncParams.encodeHeight;</span><br><span class="line">    m_uCurWidth                           = m_stInitEncParams.encodeWidth;</span><br><span class="line">    </span><br><span class="line">    m_stInitEncParams.maxEncodeHeight     = m_uMaxHeight;</span><br><span class="line">    m_stInitEncParams.maxEncodeWidth      = m_uMaxWidth;</span><br><span class="line"></span><br><span class="line">    m_stInitEncParams.frameRateNum        = m_stEncoderInput.frameRateNum;</span><br><span class="line">    m_stInitEncParams.frameRateDen        = m_stEncoderInput.frameRateDen;</span><br><span class="line">    <span class="comment">//Fix me add theading model</span></span><br><span class="line">    m_stInitEncParams.enableEncodeAsync   = m_bAsyncModeEncoding;</span><br><span class="line">    m_stInitEncParams.enablePTD           = !m_stEncoderInput.disable_ptd;</span><br><span class="line">    m_stInitEncParams.reportSliceOffsets  = m_stEncoderInput.report_slice_offsets;</span><br><span class="line">    m_stInitEncParams.enableSubFrameWrite = m_stEncoderInput.enableSubFrameWrite;</span><br><span class="line">    m_stInitEncParams.encodeGUID          = m_stEncodeGUID;</span><br><span class="line">    m_stInitEncParams.presetGUID          = m_stPresetGUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user_SEI: (1) Create 16-byte UUID header (this is x264&#x27;s uuid)</span></span><br><span class="line"><span class="keyword">for</span>( <span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(x264_sei_uuid)/<span class="built_in">sizeof</span>(x264_sei_uuid[<span class="number">0</span>]); ++i ) </span><br><span class="line">oss &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(x264_sei_uuid[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// user_SEI: (2) start putting NVENC&#x27;s encoder-settings</span></span><br><span class="line">    CUresult        cuResult = CUDA_SUCCESS;</span><br><span class="line">    CUdevice        cuDevice = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>            gpu_name[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">checkCudaErrors</span>(<span class="built_in">cuDeviceGet</span>(&amp;cuDevice, m_deviceID));</span><br><span class="line"><span class="built_in">checkCudaErrors</span>(<span class="built_in">cuDeviceGetName</span>(gpu_name, <span class="number">100</span>, cuDevice));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the Geforce driver-version using NVAPI -</span></span><br><span class="line"><span class="comment">//   NVENC functionality is a hardware+firmware implementation, so it is important</span></span><br><span class="line"><span class="comment">//   to report both the GPU-hardware and the Geforce driver revision.</span></span><br><span class="line">NvU32             NVidia_DriverVersion;</span><br><span class="line">NvAPI_ShortString szBuildBranchString;</span><br><span class="line">NvAPI_Status      nvs = <span class="built_in">NvAPI_SYS_GetDriverAndBranchVersion</span>( &amp;NVidia_DriverVersion, szBuildBranchString);</span><br><span class="line"></span><br><span class="line"><span class="comment">//oss &lt;&lt; &quot;x264 - core 141 - H.264/MPEG-4 AVC codec - Copyleft 2003-2012 - &quot; &lt;&lt; __DATE__ &quot;&#125;, NVENC API &quot; &lt;&lt; std::dec &lt;&lt; NVENCAPI_MAJOR_VERSION</span></span><br><span class="line">oss &lt;&lt; <span class="string">&quot;CNvEncoderH264[&quot;</span> &lt;&lt; __DATE__  &lt;&lt; <span class="string">&quot;, NVENC API &quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; NVENCAPI_MAJOR_VERSION &lt;&lt; <span class="string">&quot;.&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; NVENCAPI_MINOR_VERSION &lt;&lt; <span class="string">&quot;]&quot;</span></span><br><span class="line">&lt;&lt; gpu_name;</span><br><span class="line"><span class="keyword">if</span> ( nvs == NVAPI_OK )</span><br><span class="line">oss &lt;&lt; <span class="string">&quot; (driver &quot;</span> &lt;&lt; szBuildBranchString &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; std::dec </span><br><span class="line">&lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span>&gt;(NVidia_DriverVersion)  &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">oss &lt;&lt; <span class="string">&quot; (driver ???)&quot;</span>; <span class="comment">// unknown driver version</span></span><br><span class="line">oss&lt;&lt; <span class="string">&quot; - options: &quot;</span>;</span><br><span class="line"></span><br><span class="line">oss &lt;&lt; <span class="string">&quot; / PROFILE=&quot;</span> &lt;&lt; std::dec &lt;&lt; m_stEncoderInput.profile;</span><br><span class="line"><span class="comment">// NVENC PRESET - print the index-value instead of the actual GUID (which isn&#x27;t really informative)</span></span><br><span class="line">desc_nv_enc_preset_names.<span class="built_in">value2string</span>(m_stPresetIdx, s);</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;,PRESET=&quot;</span> &lt;&lt; std::dec &lt;&lt; m_stPresetIdx;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;)&quot;</span>; <span class="comment">// show ascii-name of the preset</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//速率控制</span></span><br><span class="line">    <span class="keyword">if</span> (m_stEncoderInput.disableCodecCfg == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;profileGUID                  = m_stCodecProfileGUID;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.averageBitRate      = m_stEncoderInput.avgBitRate;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.maxBitRate          = m_stEncoderInput.peakBitRate;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.constQP.qpIntra     = m_stEncoderInput.qpI;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.constQP.qpInterP    = m_stEncoderInput.qpP;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.constQP.qpInterB    = m_stEncoderInput.qpB;</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;rcParams.enableMinQP       = m_stEncoderInput.min_qp_ena;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.minQP.qpIntra     = m_stEncoderInput.min_qpI;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.minQP.qpInterP    = m_stEncoderInput.min_qpP;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.minQP.qpInterB    = m_stEncoderInput.min_qpB;</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;rcParams.enableMaxQP       = m_stEncoderInput.max_qp_ena;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.maxQP.qpIntra     = m_stEncoderInput.max_qpI;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.maxQP.qpInterP    = m_stEncoderInput.max_qpP;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.maxQP.qpInterB    = m_stEncoderInput.max_qpB;</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;rcParams.enableInitialRCQP    = m_stEncoderInput.initial_qp_ena;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.initialRCQP.qpIntra  = m_stEncoderInput.initial_qpI;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.initialRCQP.qpInterP = m_stEncoderInput.initial_qpP;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.initialRCQP.qpInterB = m_stEncoderInput.initial_qpB;</span><br><span class="line"></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.rateControlMode     = (NV_ENC_PARAMS_RC_MODE)m_stEncoderInput.rateControl;</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;rcParams.vbvBufferSize       =  m_stEncoderInput.vbvBufferSize;</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;rcParams.vbvInitialDelay     =  m_stEncoderInput.vbvInitialDelay;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// user_SEI: (3) more NVENC&#x27;s encoder-settings</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">oss 创建保存输入/输出数据所需的资源&lt;&lt; <span class="string">&quot; / rateMode=&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>( m_stInitEncParams.encodeConfig-&gt;rcParams.rateControlMode ) &#123;</span><br><span class="line"><span class="keyword">case</span> NV_ENC_PARAMS_RC_CONSTQP:        <span class="comment">/**&lt; Constant QP mode */</span></span><br><span class="line">oss &lt;&lt; <span class="string">&quot;CONSTQP(I:P:B)=&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.qpI &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.qpP &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.qpB;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> NV_ENC_PARAMS_RC_VBR:            <span class="comment">/**&lt; Variable bitrate mode */</span></span><br><span class="line">oss &lt;&lt; <span class="string">&quot;VBR(avg:max)=&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.avgBitRate &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.peakBitRate;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> NV_ENC_PARAMS_RC_CBR:            <span class="comment">/**&lt; Constant bitrate mode */</span></span><br><span class="line">oss &lt;&lt; <span class="string">&quot;CBR(avg)=&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.avgBitRate;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> NV_ENC_PARAMS_RC_VBR_MINQP:      <span class="comment">/**&lt; Variable bitrate mode with MinQP */</span></span><br><span class="line"><span class="comment">// ASSUME min_qp_ena is set!</span></span><br><span class="line">oss &lt;&lt; <span class="string">&quot;VBR_MINQP(avg:max)=&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.avgBitRate &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.peakBitRate;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> NV_ENC_PARAMS_RC_2_PASS_QUALITY: <span class="comment">/**&lt; Multi pass CBR encoding optimized for image quality and works only with low latency mode */</span></span><br><span class="line">oss &lt;&lt; <span class="string">&quot;2_PASS_QUALITY(avg)=&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.avgBitRate;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> NV_ENC_PARAMS_RC_2_PASS_FRAMESIZE_CAP: <span class="comment">/**&lt; Multi pass CBR encoding optimized for maintaining frame size and works only with low latency mode */</span></span><br><span class="line">oss &lt;&lt; <span class="string">&quot;2_PASS_FRAMESIZE_CAP(avg)=&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.avgBitRate;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> NV_ENC_PARAMS_RC_2_PASS_VBR: <span class="comment">/**&lt; Multi pass VBR encoding for higher quality */</span></span><br><span class="line">oss &lt;&lt; <span class="string">&quot;2_PASS_VBR(avg:max)=&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.avgBitRate &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.peakBitRate;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( m_stEncoderInput.initial_qp_ena ) &#123;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;,IniQP(I:P:B)=&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.initial_qpI &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.initial_qpP &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.initial_qpB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_stEncoderInput.min_qp_ena &amp;&amp; m_stEncoderInput.max_qp_ena) &#123;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;,Min*MaxQP(I:P:B)=&quot;</span> </span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.min_qpI &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.min_qpP &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.min_qpB &lt;&lt; <span class="string">&quot;*&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.max_qpI &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.max_qpP &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.max_qpB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_stEncoderInput.min_qp_ena) &#123;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;,MinQP(I:P:B)=&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.min_qpI &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.min_qpP &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.min_qpB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_stEncoderInput.max_qp_ena) &#123;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;,MaxQP(I:P:B)=&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.max_qpI &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.max_qpP &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.max_qpB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// report adaptive-quantization for everything, &#x27;cause I don&#x27;t know its effect</span></span><br><span class="line"><span class="keyword">if</span> (m_stInitEncParams.encodeConfig-&gt;rcParams.enableAQ )</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;,AQ&quot;</span>; <span class="comment">// adaptive quantization</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIG_RCPARAM_2_OSS2(var,name) \</span></span><br><span class="line"><span class="meta">oss <span class="string">&lt;&lt; &quot; / &quot; &lt;&lt; name &lt;&lt; &quot;=&quot; &lt;&lt; std::dec &lt;&lt; (unsigned) m_stInitEncParams.encodeConfig-&gt;</span>rcParams. ## var</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIG_RCPARAM_2_OSS( var ) ADD_ENCODECONFIG_RCPARAM_2_OSS2(var,#var) </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ADD_ENCODECONFIG_RCPARAM_2_OSS2</span>(vbvBufferSize,<span class="string">&quot;vbvBS&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIG_RCPARAM_2_OSS2</span>(vbvInitialDelay,<span class="string">&quot;vbvID&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// user_SEI: (3) more NVENC&#x27;s encoder-settings</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;frameIntervalP       = m_stEncoderInput.numBFrames + <span class="number">1</span>;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;gopLength            = (m_stEncoderInput.gopLength &gt; <span class="number">0</span>) ?  m_stEncoderInput.gopLength : <span class="number">30</span>;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;monoChromeEncoding   = m_stEncoderInput.monoChromeEncoding;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;frameFieldMode       = m_stEncoderInput.FieldEncoding ;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;mvPrecision          = m_stEncoderInput.mvPrecision;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIG_2_OSS2( var, name ) \</span></span><br><span class="line"><span class="meta">oss <span class="string">&lt;&lt; &quot; / &quot; &lt;&lt; name &lt;&lt; &quot;=&quot; &lt;&lt; std::dec &lt;&lt; (unsigned) m_stInitEncParams.encodeConfig-&gt;</span> ## var</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIG_2_OSS(var) ADD_ENCODECONFIG_2_OSS2(var,#var)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIG_2_OSS2_if_nz( var, name ) \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> ( m_stInitEncParams.encodeConfig-&gt; ## var ) \</span></span><br><span class="line"><span class="meta">oss <span class="string">&lt;&lt; &quot; / &quot; &lt;&lt; name &lt;&lt; &quot;=&quot; &lt;&lt; std::dec &lt;&lt; (unsigned) m_stInitEncParams.encodeConfig-&gt;</span> ## var</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIG_2_OSS_if_nz( var ) ADD_ENCODECONFIG_2_OSS2_if_nz(var,#var)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ADD_ENCODECONFIG_2_OSS2</span>(frameIntervalP,<span class="string">&quot;IntervalP&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( m_stEncoderInput.numBFrames )</span><br><span class="line">oss &lt;&lt; <span class="string">&quot; (BFrames=&quot;</span> &lt;&lt; std::dec &lt;&lt; m_stEncoderInput.numBFrames &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIG_2_OSS2</span>(gopLength,<span class="string">&quot;gop&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIG_2_OSS2_if_nz</span>(monoChromeEncoding,<span class="string">&quot;mono&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIG_2_OSS2</span>(frameFieldMode,<span class="string">&quot;frameMode&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIG_2_OSS2</span>(mvPrecision,<span class="string">&quot;mv&quot;</span>);</span><br><span class="line"></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.disableDeblockingFilterIDC = m_stEncoderInput.disableDeblock; <span class="comment">// alawys enable deblk filter for h264</span></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.adaptiveTransformMode      = (m_stEncoderInput.profile &gt;= NV_ENC_H264_PROFILE_HIGH) ? m_stEncoderInput.adaptive_transform_mode : NV_ENC_H264_ADAPTIVE_TRANSFORM_AUTOSELECT;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.fmoMode                    = m_stEncoderInput.enableFMO;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.bdirectMode                = m_stEncoderInput.numBFrames &gt; <span class="number">0</span> ? m_stEncoderInput.bdirectMode : NV_ENC_H264_BDIRECT_MODE_DISABLE;</span><br><span class="line"><span class="comment">//        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.bdirectMode                = m_stEncoderInput.numBFrames &gt; 0 ? NV_ENC_H264_BDIRECT_MODE_TEMPORAL : NV_ENC_H264_BDIRECT_MODE_DISABLE;</span></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.outputAUD                  = m_stEncoderInput.aud_enable;</span><br><span class="line"><span class="comment">//      m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.entropyCodingMode        = (m_stEncoderInput.profile &gt; NV_ENC_H264_PROFILE_BASELINE) ? m_stEncoderInput.vle_entropy_mode : NV_ENC_H264_ENTROPY_CODING_MODE_CAVLC;</span></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.idrPeriod                = m_stInitEncParams.encodeConfig-&gt;gopLength ;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.level                    = m_stEncoderInput.level;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.numTemporalLayers        = m_stEncoderInput.numlayers;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if (m_stEncoderInput.svcTemporal)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.enableTemporalSVC = 1;</span></span><br><span class="line"><span class="comment">            m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.h264Extension.svcTemporalConfig.basePriorityID           = 0;</span></span><br><span class="line"><span class="comment">            m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.h264Extension.svcTemporalConfig.numTemporalLayers = m_stEncoderInput.numlayers;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NVENC 4.0 API</span></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="comment">// From documentation, setting the chromaFromatIDC to 3 will select</span></span><br><span class="line"><span class="comment">// 4:4:4 chroma-format!</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Don&#x27;t need to specify &#x27;separate color planes&#x27;</span></span><br><span class="line"><span class="keyword">switch</span> (m_stEncoderInput.chromaFormatIDC) &#123;</span><br><span class="line"><span class="keyword">case</span> cudaVideoChromaFormat_444:</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.chromaFormatIDC = <span class="number">3</span>; <span class="comment">// YUV444</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// cudaVideoChromaFormat_420:</span></span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.chromaFormatIDC = <span class="number">1</span>; <span class="comment">// YUV420</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIGH264_2_OSS2(var,name) \</span></span><br><span class="line"><span class="meta">oss <span class="string">&lt;&lt; &quot; / &quot; &lt;&lt; name &lt;&lt; &quot;=&quot; &lt;&lt; std::dec &lt;&lt; (unsigned) m_stInitEncParams.encodeConfig-&gt;</span>encodeCodecConfig.h264Config. ## var</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIGH264_2_OSS( var ) ADD_ENCODECONFIGH264_2_OSS2(var,#var)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIGH264_2_OSS2_if_nz(var,name) \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> ( m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config. ## var ) \</span></span><br><span class="line"><span class="meta">oss <span class="string">&lt;&lt; &quot; / &quot; &lt;&lt; name &lt;&lt; &quot;=&quot; &lt;&lt; std::dec &lt;&lt; (unsigned) m_stInitEncParams.encodeConfig-&gt;</span>encodeCodecConfig.h264Config. ## var</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIGH264_2_OSS_if_nz(var,name) ADD_ENCODECONFIGH264_2_OSS2_if_nz(var,#var)</span></span><br><span class="line"></span><br><span class="line">desc_nv_enc_buffer_format_names.<span class="built_in">value2string</span>(</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.chromaFormatIDC, s</span><br><span class="line">);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2</span>(chromaFormatIDC,<span class="string">&quot;chroma&quot;</span>);</span><br><span class="line"><span class="comment">//oss &lt;&lt; &quot;(&quot; &lt;&lt; s &lt;&lt; &quot;)&quot;; // show ascii-name of the chromaFormatIDC</span></span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(separateColourPlaneFlag,<span class="string">&quot;sepCPF&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(disableDeblockingFilterIDC,<span class="string">&quot;disDF&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2</span>(adaptiveTransformMode,<span class="string">&quot;adaTM&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS_if_nz</span>(fmoMode,<span class="string">&quot;fmoMode&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS</span>(bdirectMode);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS_if_nz</span>(outputAUD,<span class="string">&quot;outputAUD&quot;</span>);</span><br><span class="line"><span class="comment">//ADD_ENCODECONFIGH264_2_OSS(entropyCodingMode);</span></span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS</span>(idrPeriod);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS</span>(level);</span><br><span class="line"><span class="comment">//ADD_ENCODECONFIGH264_2_OSS(numTemporalLayers);</span></span><br><span class="line"></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.outputBufferingPeriodSEI = m_stEncoderInput.output_sei_BufferPeriod;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.outputPictureTimingSEI   = m_stEncoderInput.output_sei_PictureTime;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.hierarchicalPFrames      = !! m_stEncoderInput.hierarchicalP;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.hierarchicalBFrames      = !! m_stEncoderInput.hierarchicalB;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.disableSPSPPS            = !! m_stEncoderInput.outBandSPSPPS;</span><br><span class="line"><span class="comment">//        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.outputFramePackingSEI    = m_stEncoderInput.stereo3dMode!= NV_ENC_STEREO_PACKING_MODE_NONE ? 1 : 0;</span></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.outputFramePackingSEI    = m_stEncoderInput.stereo3dEnable ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.stereoMode               = (NV_ENC_STEREO_PACKING_MODE)m_stEncoderInput.stereo3dMode;</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.enableStereoMVC          = m_stEncoderInput.stereo3dEnable;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.separateColourPlaneFlag  = m_stEncoderInput.separateColourPlaneFlag;<span class="comment">// set to 1 to enable 4:4:4 mode</span></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.entropyCodingMode        = (m_stEncoderInput.profile &gt; NV_ENC_H264_PROFILE_BASELINE) ? m_stEncoderInput.vle_entropy_mode : NV_ENC_H264_ENTROPY_CODING_MODE_CAVLC;</span><br><span class="line">        <span class="keyword">if</span> (m_stEncoderInput.max_ref_frames&gt;<span class="number">0</span>) </span><br><span class="line">             m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.maxNumRefFrames     = m_stEncoderInput.max_ref_frames;</span><br><span class="line">        <span class="keyword">if</span> ( pvui != <span class="literal">NULL</span> )</span><br><span class="line">            m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.h264VUIParameters = *pvui;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(outputBufferingPeriodSEI,<span class="string">&quot;outBPSEI&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(outputPictureTimingSEI,<span class="string">&quot;outPTSEI&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(hierarchicalPFrames,<span class="string">&quot;hierP&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(hierarchicalBFrames,<span class="string">&quot;hierB&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(disableSPSPPS,<span class="string">&quot;disSPSPPS&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(outputFramePackingSEI,<span class="string">&quot;outFPSEI&quot;</span>);</span><br><span class="line"><span class="comment">//ADD_ENCODECONFIGH264_2_OSS2_if_nz(enableStereoMVC,&quot;enableStereo&quot;);</span></span><br><span class="line"><span class="comment">//if ( m_stEncoderInput.stereo3dEnable )</span></span><br><span class="line"><span class="comment">//ADD_ENCODECONFIGH264_2_OSS2(stereoMode,&quot;stereoMode&quot;);</span></span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2</span>(entropyCodingMode,<span class="string">&quot;entCM&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2</span>(maxNumRefFrames,<span class="string">&quot;maxRef&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (m_stEncoderInput.enableLTR) &#123;</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2</span>(ltrNumFrames, <span class="string">&quot;ltrnf&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(ltrTrustMode, <span class="string">&quot;ltrtm&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.sliceMode = m_stEncoderInput.sliceMode;</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.sliceModeData = m_stEncoderInput.sliceModeData;</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2</span>(sliceMode, <span class="string">&quot;SM&quot;</span>);</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2</span>(sliceModeData, <span class="string">&quot;SMData&quot;</span>);</span><br><span class="line"></span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.enableLTR    = m_stEncoderInput.enableLTR;</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.ltrNumFrames = m_stEncoderInput.ltrNumFrames;</span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.ltrTrustMode = m_stEncoderInput.ltrTrustMode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NVENC API 3</span></span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.enableVFR = m_stEncoderInput.enableVFR ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(enableVFR,<span class="string">&quot;enaVFR&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// NVENC API 4</span></span><br><span class="line">m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.qpPrimeYZeroTransformBypassFlag = m_stEncoderInput.qpPrimeYZeroTransformBypassFlag;</span><br><span class="line"><span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(qpPrimeYZeroTransformBypassFlag,<span class="string">&quot;qpPrimeYZero&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ..........</span><br></pre></td></tr></table></figure><h4 id="4-2-7-2-初始化硬件编码器会话"><a href="#4-2-7-2-初始化硬件编码器会话" class="headerlink" title="4.2.7.2 初始化硬件编码器会话"></a>4.2.7.2 初始化硬件编码器会话</h4><p>当我们完成上面的参数设置后，就可以将前面设置的NV_ENC_INITIALIZE_PARAMS作为输入参数，调用nvEncInitializeEncoder，来完成编码器的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// Initialize the Encoder</span></span><br><span class="line">   nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncInitializeEncoder</span>(m_hEncoder, &amp;m_stInitEncParams);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nvStatus == NV_ENC_SUCCESS)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (m_stEncoderInput.outBandSPSPPS &gt; <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">           <span class="built_in">SET_VER</span>(m_spspps, NV_ENC_SEQUENCE_PARAM_PAYLOAD);</span><br><span class="line">           m_spspps.spsppsBuffer = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">char</span> [<span class="number">1024</span>];</span><br><span class="line">           m_spspps.inBufferSize = <span class="number">1024</span>;</span><br><span class="line">           m_spspps.outSPSPPSPayloadSize = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">int</span>[<span class="number">1</span>];</span><br><span class="line">           nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncGetSequenceParams</span>(m_hEncoder, &amp;m_spspps);</span><br><span class="line">           <span class="built_in">assert</span>(nvStatus == NV_ENC_SUCCESS);</span><br><span class="line">           <span class="keyword">if</span> (nvStatus == NV_ENC_SUCCESS)</span><br><span class="line">           &#123;</span><br><span class="line">               (*m_fwrite_callback)(m_spspps.spsppsBuffer, <span class="number">1</span>, *m_spspps.outSPSPPSPayloadSize, m_fOutput, m_privateData);</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt; outSPSPPS PayloadSize = %d, Payload=&quot;</span>, *m_spspps.outSPSPPSPayloadSize);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(*m_spspps.outSPSPPSPayloadSize) ; i++) </span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, ((<span class="type">unsigned</span> <span class="type">char</span> *)m_spspps.spsppsBuffer)[i]);</span><br><span class="line"></span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-分配输入-x2F-输出缓冲区"><a href="#4-3-分配输入-x2F-输出缓冲区" class="headerlink" title="4.3 分配输入&#x2F;输出缓冲区"></a>4.3 分配输入&#x2F;输出缓冲区</h2><p>当我们完成初始化编码会话后，此时应该分配缓冲区来保存输入&#x2F;输出数据。</p><p>而我们由于我们是在Linux端，通过OpenGL来给NvEnc数据，因此我们此时就那不通过直接调用NvEncCreateInputBuffer应用程序接口来分配输入缓冲区了．<br>具体解释，在官方文档中也有重点提到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Creating Resources Required to Hold Input/output Data</span><br><span class="line">Once the encode session is initialized, the client should allocate buffers to hold the input/output data.</span><br><span class="line"></span><br><span class="line">The client may choose to allocate input buffers through NVIDIA Video Encoder Interface by calling NvEncCreateInputBuffer API. In this case, the client is responsible for destroying the allocated input buffers before closing the encode session. It is also the client’s responsibility to fill the input buffer with valid input data according to the chosen input buffer format.</span><br><span class="line"></span><br><span class="line">The client should allocate buffers to hold the output encoded bit stream using the NvEncCreateBitstreamBuffer API. It is the client’s responsibility to destroy these buffers before closing the encode session.</span><br><span class="line"></span><br><span class="line">Alternatively, in scenarios where the client cannot or does not want to allocate input buffers through the NVIDIA Video Encoder Interface, it can use any externally allocated DirectX resource as an input buffer. However, the client must perform some simple processing to map these resources to resource handles that are recognized by the NVIDIA Video Encoder Interface before use. The translation procedure is explained in Section Input buffers allocated externally.</span><br><span class="line"></span><br><span class="line">If the client has used a CUDA device to initialize the encoder session and wishes to use input buffers NOT allocated through the NVIDIA Video Encoder Interface, the client is required to use buffers allocated using the cuMemAlloc family of APIs. NVIDIA Video Encoder Interface supports CUdeviceptr and CUarray input formats.</span><br><span class="line"></span><br><span class="line">If the client has used the OpenGL device type to initialize the encoder session and wishes to use input buffers NOT allocated through the NVIDIA Video Encoder Interface, the client is required to provide the textures allocated earlier.</span><br><span class="line"></span><br><span class="line">The client may generate textures using glGenTextures(), bind it to either the NV_ENC_INPUT_RESOURCE_OPENGL_TEX::GL_TEXTURE_RECTANGLE or NV_ENC_INPUT_RESOURCE_OPENGL_TEX::GL_TEXTURE_2D target, allocate storage for it using glTexImage2D() and copy data to it.</span><br><span class="line"></span><br><span class="line">Note that the OpenGL interface for NVENCODE API is only supported on Linux.</span><br><span class="line"></span><br><span class="line">If the client has used a DirectX 12 device to initialize encoder session, then client must allocate input and output buffers using ID3D12Device::CreateCommittedResource() API. The client must perform some simple processing to map these input and output resources to resource handles that are recognized by the NVIDIA Video Encoder Interface before use. The translation procedure is explained in Section Input output buffer allocation for DirectX 12.</span><br><span class="line"></span><br><span class="line">Note: The client should allocate at least (1 + NB) input and output buffers, where NB is the number of B frames between successive P frames.</span><br></pre></td></tr></table></figure><h3 id="4-3-1-外部分配的输入缓冲区"><a href="#4-3-1-外部分配的输入缓冲区" class="headerlink" title="4.3.1 外部分配的输入缓冲区"></a>4.3.1 外部分配的输入缓冲区</h3><p>要将外部分配的缓冲区传递给编码器，需要执行以下步骤：</p><ul><li>填充具有外部分配缓冲区的属性的NV_ENC_REGISTER_RESOURCE。</li><li>调用NvEncRegisterResource，将上述填充好的NV_ENC_REGISTER_RESOURCE属性注册。</li><li>NvEncRegisterResource返回一个已注册的资源句柄NV_ENC_REGISTER_RESOURCE::registeredResource。</li><li>使用上述的句柄调用NvEncMapInputResource。</li><li>NV_ENC_MAP_INPUT_RESOURCE::mappedResource映射的句柄将会生效。</li><li>用户应当使用这个映射的句柄(NV_ENC_MAP_INPUT_RESOURCE::mappedResource) 作为输入缓冲句柄参数(NV_ENC_PIC_PARAMS)。</li><li>用户使用完资源后NvEncUnmapInputResource必须被调用。</li><li>在销毁注册的资源之前，用户还必须调用NvEncUnregisterResource，传入NvEncRegisterResource返回的句柄。映射的资源句柄 (NV_ENC_MAP_INPUT_RESOURCE::mappedResource) 不应在 NVIDIA 视频编码器接口处于映射状态时用于任何其他目的。这种用法不受支持，可能会导致未定义的行为。</li></ul><p>我们需要思考一个问题，外部分配的输入缓冲区要多大？这就需要看一下NvEnc支持什么格式的数据进行编码了，通过文档我们可以看出编码支持YUV和RGB格式直接编码，那么我们就可以直接将OpenGL渲染和特效处理后的RGBA数据直接进行编码啦！！！（如果你想知道NV12的数据如何编码可以参考例程，后面我写的这些代码里面的NV_ENC_BUFFER_FORMAT_NV12_TYPE走的就是NV12的编码，但是是只有一条纹理(直接把NV12存到一条上，你也可以用两条，具体参考例程吧)）</p><h3 id="4-3-1-1-NV-ENC-REGISTER-RESOURCE的填充和注册"><a href="#4-3-1-1-NV-ENC-REGISTER-RESOURCE的填充和注册" class="headerlink" title="4.3.1.1 NV_ENC_REGISTER_RESOURCE的填充和注册"></a>4.3.1.1 NV_ENC_REGISTER_RESOURCE的填充和注册</h3><p>我们可以先看下NVENC_export&#x2F;Samples&#x2F;nvEncode2&#x2F;src文件夹中的CNvEncoderH264.cpp文件中对应的这段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配 IO 缓冲区 -</span></span><br><span class="line">        <span class="comment">// 注意，这里的表面必须分配给源视频的*编码高度*和*编码宽度*，</span></span><br><span class="line">        <span class="comment">// 而不是显示高度和宽度。如果我们使用显示高度和宽度，那么色度部分</span></span><br><span class="line">        <span class="comment">// 解码帧的偏移很可能不正确（导致颜色未对齐。）</span></span><br><span class="line">        <span class="comment">// 例子：</span></span><br><span class="line">        <span class="comment">// 源视频编码宽度 x 高度 = 1920 x 1088（编码尺寸 VC1/MPEG2/MPEG4/H264）</span></span><br><span class="line">        <span class="comment">// 源视频显示尺寸 = 1920 x 1080</span></span><br><span class="line">        <span class="comment">// ...AllocateIOBuffers( 1920, 1088, ...);</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"><span class="comment">// 在隔行编码模式下，编码器将输入作为一个整体帧（即一对场）接收，</span></span><br><span class="line"><span class="comment">// 所以仍然使用全高。</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dwPicHeight = m_uMaxHeight;</span><br><span class="line"><span class="type">int</span> numMBs = ((m_dwFrameWidth + <span class="number">15</span>)/<span class="number">16</span>) * ((dwPicHeight + <span class="number">15</span>)/<span class="number">16</span>);</span><br><span class="line"><span class="type">int</span> NumIOBuffers = m_stEncoderInput.numBFrames + <span class="number">4</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AllocateIOBuffers</span>(m_uMaxWidth, dwPicHeight, NumIOBuffers);</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>在AllocateIOBuffers函数中，我们可以看到由于NVENC_export在设计之初是只为使用在Win端的，因此它整个类型判断只有NV_ENC_CUDA和NV_ENC_DX9，缺少了Linux端的代码，因此我们需要多新增一个NV_ENC_OPENGL枚举变量，并添加改类型的代码，如下所示，可以看出在NV_ENC_OPENGL类型的if语句中，我们首先使用 glGenTextures() 生成纹理，并将其绑定到NV_ENC_INPUT_RESOURCE_OPENGL_TEX::GL_TEXTURE_2D 目标，接着使用 glTexImage2D() 为其分配存储空间．</p><p>PS:这边顺便也加了一段NV_ENC_DX11的代码，如果你用到NV_ENC_DX12,NV_ENC_DX10那就参考着这个改就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">CNvEncoder::AllocateIOBuffers</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> dwInputWidth, <span class="type">unsigned</span> <span class="type">int</span> dwInputHeight, <span class="type">unsigned</span> <span class="type">int</span> maxFrmCnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_dwMaxSurfCount = maxFrmCnt;</span><br><span class="line">    NVENCSTATUS status = NV_ENC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &gt; CNvEncoder::AllocateIOBuffers() = Size (%dx%d @ %d frames)\n&quot;</span>, dwInputWidth, dwInputHeight, maxFrmCnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; m_dwMaxSurfCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        m_stInputSurface[i].dwWidth  = dwInputWidth;</span><br><span class="line">        m_stInputSurface[i].dwHeight = dwInputHeight;</span><br><span class="line">        <span class="keyword">if</span> (m_stEncoderInput.useMappedResources)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_CUDA)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; &gt; CUDA+NVENC InterOp using %d buffers.\n&quot;</span>, m_dwMaxSurfCount);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Illustrate how to use a Cuda buffer not allocated using NvEncCreateInputBuffer as input to the encoder.</span></span><br><span class="line">                <span class="built_in">cuCtxPushCurrent</span>(m_cuContext);</span><br><span class="line">                CUcontext   cuContextCurr;</span><br><span class="line">                CUdeviceptr devPtrDevice;</span><br><span class="line">                CUresult    result = CUDA_SUCCESS;                          </span><br><span class="line"></span><br><span class="line"><span class="comment">// For each buffer, allocate a host-memory space and a device-memory space.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// (1) Allocate Cuda buffer. We will use this to hold the input YUV data.</span></span><br><span class="line"><span class="type">unsigned</span> row_count;</span><br><span class="line"><span class="keyword">if</span> ( m_stEncoderInput.chromaFormatIDC == cudaVideoChromaFormat_420 ) &#123;</span><br><span class="line">m_stInputSurface[i].bufferFmt = NV_ENC_BUFFER_FORMAT_NV12;</span><br><span class="line">row_count = dwInputHeight*<span class="number">3</span>/<span class="number">2</span>; <span class="comment">// enough rows for NV12 frame</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// YUV 4:4:4</span></span><br><span class="line">m_stInputSurface[i].bufferFmt = NV_ENC_BUFFER_FORMAT_YUV444;</span><br><span class="line">row_count = dwInputHeight*<span class="number">3</span>; <span class="comment">// enough rows for YUV444 frame</span></span><br><span class="line">&#125;</span><br><span class="line">                result = <span class="built_in">cuMemAllocPitch</span>(&amp;devPtrDevice, (<span class="type">size_t</span> *)&amp;m_stInputSurface[i].dwCuPitch, dwInputWidth, row_count, <span class="number">16</span>);</span><br><span class="line">                m_stInputSurface[i].pExtAlloc      = (<span class="type">void</span>*)devPtrDevice;</span><br><span class="line"><span class="built_in">cuMemsetD8</span>( devPtrDevice, <span class="number">128</span>, m_stInputSurface[i].dwCuPitch*row_count);<span class="comment">// clear the memory</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// (2) Allocate Cuda buffer in host memory. We will use this to load data onto the Cuda buffer we want to use as input.</span></span><br><span class="line">                result = <span class="built_in">cuMemAllocHost</span>((<span class="type">void</span>**)&amp;m_stInputSurface[i].pExtAllocHost, m_stInputSurface[i].dwCuPitch*row_count);</span><br><span class="line"></span><br><span class="line">                m_stInputSurface[i].type           = NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR;</span><br><span class="line"><span class="built_in">memset</span>( (<span class="type">void</span> *)m_stInputSurface[i].pExtAllocHost, <span class="number">128</span>, m_stInputSurface[i].dwCuPitch*row_count);<span class="comment">// clear the memory</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">cuCtxPopCurrent</span>(&amp;cuContextCurr);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(NV_WINDOWS)</span></span><br><span class="line">            <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_DX9)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; &gt; DirectX+NVENC InterOp using %d buffers.\n&quot;</span>, m_dwMaxSurfCount);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Illustrate how to use an externally allocated IDirect3DSurface9* as input to the encoder.</span></span><br><span class="line">                IDirect3DSurface9 *pSurf = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> dwFormat = <span class="built_in">MAKE_FOURCC</span>(<span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>);;</span><br><span class="line">                HRESULT hr = S_OK;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">IsNV12Format</span>(m_dwInputFormat))</span><br><span class="line">                &#123;</span><br><span class="line">                    dwFormat = <span class="built_in">MAKE_FOURCC</span>(<span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">IsYV12Format</span>(m_dwInputFormat))</span><br><span class="line">                &#123;</span><br><span class="line">                    dwFormat = <span class="built_in">MAKE_FOURCC</span>(<span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                hr = m_pD3D9Device-&gt;<span class="built_in">CreateOffscreenPlainSurface</span>(dwInputWidth, dwInputHeight, (D3DFORMAT)dwFormat, D3DPOOL_DEFAULT, (IDirect3DSurface9 **)&amp;m_stInputSurface[i].pExtAlloc, <span class="literal">NULL</span>);</span><br><span class="line">                m_stInputSurface[i].bufferFmt      = NV_ENC_BUFFER_FORMAT_NV12;</span><br><span class="line">                m_stInputSurface[i].type           = NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_DX11)</span><br><span class="line">&#123;</span><br><span class="line">ID3D11Texture2D *pInputTextures = <span class="literal">NULL</span>;</span><br><span class="line">D3D11_TEXTURE2D_DESC desc;</span><br><span class="line"><span class="built_in">ZeroMemory</span>(&amp;desc, <span class="built_in">sizeof</span>(D3D11_TEXTURE2D_DESC));</span><br><span class="line">desc.Width = m_stEncoderInput.width;</span><br><span class="line">desc.Height = m_stEncoderInput.height;</span><br><span class="line">desc.MipLevels = <span class="number">1</span>;</span><br><span class="line">desc.ArraySize = <span class="number">1</span>;</span><br><span class="line">desc.Format = <span class="built_in">DXGI_FORMAT</span>(<span class="number">103</span>);</span><br><span class="line">desc.SainputFramesmpleDesc.Count = <span class="number">1</span>;</span><br><span class="line">desc.Usage = D3D11_USAGE_DEFAULT;</span><br><span class="line">desc.BindFlags = D3D11_BIND_RENDER_TARGET;</span><br><span class="line">desc.CPUAccessFlags = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (m_pD3D11Device-&gt;<span class="built_in">CreateTexture2D</span>(&amp;desc, <span class="literal">NULL</span>, &amp;pInputTextures) != S_OK)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">m_stInputSurface[i].pExtAlloc = (<span class="type">void</span> *)pInputTextures;</span><br><span class="line">m_stInputSurface[i].type = NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX;</span><br><span class="line">m_stInputSurface[i].bufferFmt = NV_ENC_BUFFER_FORMAT_NV12_PL;</span><br><span class="line">m_stInputSurface[i].dwCuPitch = m_stEncoderInput.width;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_OPENGL)<span class="comment">//NVENCODE API 的 OpenGL 接口仅在 Linux 上受支持</span></span><br><span class="line">&#123;</span><br><span class="line">NV_ENC_INPUT_RESOURCE_OPENGL_TEX *pResource = <span class="keyword">new</span> NV_ENC_INPUT_RESOURCE_OPENGL_TEX;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> tex;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;tex);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, tex);</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NV_ENC_BUFFER_FORMAT_NV12_TYPE</span></span><br><span class="line">                <span class="comment">//因此存放的是NV12，所以分配空间m_stEncoderInput.width*m_stEncoderInput.height* 3 / 2就够了</span></span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_R8, m_stEncoderInput[<span class="number">0</span>].width, m_stEncoderInput[<span class="number">0</span>].height* <span class="number">3</span> / <span class="number">2</span>, <span class="number">0</span>, GL_RED, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, m_stEncoderInput[<span class="number">0</span>].width, m_stEncoderInput[<span class="number">0</span>].height, <span class="number">0</span>, GL_RED, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glIsTexture</span>(tex)== <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">WSLogEx</span>(<span class="string">L&quot;Failed to create opengltextures \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pResource-&gt;texture = tex;</span><br><span class="line">            pResource-&gt;target = GL_TEXTURE_2D;</span><br><span class="line"></span><br><span class="line">m_stInputSurface[i].pExtAlloc = pResource;</span><br><span class="line">m_stInputSurface[i].type = NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NV_ENC_BUFFER_FORMAT_NV12_TYPE</span></span><br><span class="line">m_stInputSurface[i].bufferFmt = NV_ENC_BUFFER_FORMAT_NV12_PL;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">m_stInputSurface[i].bufferFmt      = NV_ENC_BUFFER_FORMAT_ARGB;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">m_stInputSurface[i].dwCuPitch = m_stEncoderInput.width;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="comment">// Register the allocated buffer with NvEncodeAPI</span></span><br><span class="line">            NV_ENC_REGISTER_RESOURCE stRegisterRes;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;stRegisterRes, <span class="number">0</span>, <span class="built_in">sizeof</span>(NV_ENC_REGISTER_RESOURCE));</span><br><span class="line">            <span class="built_in">SET_VER</span>(stRegisterRes, NV_ENC_REGISTER_RESOURCE);</span><br><span class="line">            stRegisterRes.resourceType = m_stInputSurface[i].type;</span><br><span class="line">stRegisterRes.bufferFormat = m_stInputSurface[i].bufferFmt;</span><br><span class="line">            <span class="comment">// Pass the resource handle to be registered and mapped during registration.</span></span><br><span class="line">            <span class="comment">// Do not pass this handle while mapping</span></span><br><span class="line">            stRegisterRes.resourceToRegister       = m_stInputSurface[i].pExtAlloc;</span><br><span class="line">            stRegisterRes.width                    = m_stInputSurface[i].dwWidth;</span><br><span class="line">            stRegisterRes.height                   = m_stInputSurface[i].dwHeight;</span><br><span class="line">            stRegisterRes.pitch                    = m_stInputSurface[i].dwCuPitch;</span><br><span class="line">            </span><br><span class="line">            status = m_pEncodeAPI-&gt;<span class="built_in">nvEncRegisterResource</span>(m_hEncoder, &amp;stRegisterRes);</span><br><span class="line">            <span class="built_in">checkNVENCErrors</span>(status);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Use this registered handle to retrieve an encoder-understandable mapped resource handle, through NvEncMapInputResource.</span></span><br><span class="line">            <span class="comment">// The mapped handle can be directly used with NvEncEncodePicture.</span></span><br><span class="line">            m_stInputSurface[i].hRegisteredHandle = stRegisterRes.registeredResource;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">// Premiere Plugin: allocate non-mapped resources</span></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &gt; System Memory with %d buffers.\n&quot;</span>, m_dwMaxSurfCount);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Allocate input surface</span></span><br><span class="line">            NV_ENC_CREATE_INPUT_BUFFER stAllocInputSurface;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;stAllocInputSurface, <span class="number">0</span>, <span class="built_in">sizeof</span>(stAllocInputSurface));</span><br><span class="line">            <span class="built_in">SET_VER</span>(stAllocInputSurface, NV_ENC_CREATE_INPUT_BUFFER);</span><br><span class="line">            stAllocInputSurface.width              = (m_dwFrameWidth  + <span class="number">31</span>)&amp;~<span class="number">31</span>;<span class="comment">//dwFrameWidth;</span></span><br><span class="line">            stAllocInputSurface.height             = (m_dwFrameHeight + <span class="number">31</span>)&amp;~<span class="number">31</span>; <span class="comment">//dwFrameHeight;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line">            stAllocInputSurface.memoryHeap         = NV_ENC_MEMORY_HEAP_SYSMEM_CACHED;</span><br><span class="line">            stAllocInputSurface.bufferFmt          = NV_ENC_BUFFER_FORMAT_NV12;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            stAllocInputSurface.memoryHeap         = NV_ENC_MEMORY_HEAP_SYSMEM_UNCACHED;</span><br><span class="line">            stAllocInputSurface.bufferFmt          = m_dwInputFormat;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_stEncoderInput.chromaFormatIDC == cudaVideoChromaFormat_420)</span><br><span class="line">stAllocInputSurface.bufferFmt = NV_ENC_BUFFER_FORMAT_NV12;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">stAllocInputSurface.bufferFmt = NV_ENC_BUFFER_FORMAT_YUV444;</span><br><span class="line"></span><br><span class="line">            status = m_pEncodeAPI-&gt;<span class="built_in">nvEncCreateInputBuffer</span>(m_hEncoder, &amp;stAllocInputSurface);</span><br><span class="line">            <span class="built_in">checkNVENCErrors</span>(status);</span><br><span class="line"></span><br><span class="line">            m_stInputSurface[i].hInputSurface      = stAllocInputSurface.inputBuffer;</span><br><span class="line">            m_stInputSurface[i].bufferFmt          = stAllocInputSurface.bufferFmt;</span><br><span class="line">            m_stInputSurface[i].dwWidth            = (m_dwFrameWidth  + <span class="number">31</span>)&amp;~<span class="number">31</span>;</span><br><span class="line">            m_stInputSurface[i].dwHeight           = (m_dwFrameHeight + <span class="number">31</span>)&amp;~<span class="number">31</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_stInputSurfQueue.<span class="built_in">Add</span>(&amp;m_stInputSurface[i]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时，我们已经完成NV_ENC_REGISTER_RESOURCE的填充和注册，接下来就是通过NvEncRegisterResource返回的资源句柄NV_ENC_REGISTER_RESOURCE::registeredResource来进行句柄的映射操作，从而将OpenGL分配的外部输入缓冲区映射到NV_ENC中</p><h3 id="4-3-1-2-将OpenGL分配的外部输入缓冲区映射到NV-ENC中"><a href="#4-3-1-2-将OpenGL分配的外部输入缓冲区映射到NV-ENC中" class="headerlink" title="4.3.1.2 将OpenGL分配的外部输入缓冲区映射到NV_ENC中"></a>4.3.1.2 将OpenGL分配的外部输入缓冲区映射到NV_ENC中</h3><p>继续参考NVENC_export&#x2F;Samples&#x2F;nvEncode2&#x2F;src文件夹中的CNvEncoderH264.cpp文件中EncodeCudaMemFrame，可以看出也缺少了Linux端的代码，我们将他补完整．<br>PS:这边顺便也加了一段NV_ENC_DX11的代码，如果你用到NV_ENC_DX12,NV_ENC_DX10那就参考着这个改就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">CNvEncoderH264::EncodeCudaMemFrame</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">EncodeFrameConfig *pEncodeFrame, CUdeviceptr oDecodedFrame[<span class="number">3</span>], <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> oFrame_pitch, <span class="type">bool</span> bFlush )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NVENCSTATUS nvStatus = NV_ENC_SUCCESS;</span><br><span class="line">    HRESULT hr = S_OK;</span><br><span class="line">    NV_ENC_MAP_INPUT_RESOURCE mapRes = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bFlush)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">FlushEncoder</span>();</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pEncodeFrame)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> E_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EncodeInputSurfaceInfo  *pInput;</span><br><span class="line">    EncodeOutputBuffer      *pOutputBitstream;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_stInputSurfQueue.<span class="built_in">Remove</span>(pInput, INFINITE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_stOutputSurfQueue.<span class="built_in">Remove</span>(pOutputBitstream, INFINITE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lockedPitch = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// encode width and height</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwWidth =  m_uMaxWidth; <span class="comment">//m_stEncoderInput.width;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwHeight = m_uMaxHeight;<span class="comment">//m_stEncoderInput.height;</span></span><br><span class="line">    <span class="comment">// Align 32 as driver does the same</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwSurfWidth  = (dwWidth + <span class="number">0x1f</span>) &amp; ~<span class="number">0x1f</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwSurfHeight = (dwHeight + <span class="number">0x1f</span>) &amp; ~<span class="number">0x1f</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pLuma    = pEncodeFrame-&gt;yuv[<span class="number">0</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pChromaU = pEncodeFrame-&gt;yuv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pChromaV = pEncodeFrame-&gt;yuv[<span class="number">2</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pInputSurface = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pInputSurfaceCh = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">const</span>    <span class="type">bool</span> need_2d_memcpy = (oFrame_pitch % pInput-&gt;dwCuPitch) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CUDA or DX9 interop with NVENC</span></span><br><span class="line">    <span class="keyword">if</span> (m_stEncoderInput.useMappedResources)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Here we copy from Host to Device Memory (CUDA)</span></span><br><span class="line">        <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_CUDA)</span><br><span class="line">        &#123;</span><br><span class="line">            CUresult result;</span><br><span class="line">            <span class="built_in">cuCtxPushCurrent</span>(m_cuContext); <span class="comment">// Necessary to bind the </span></span><br><span class="line">            CUcontext cuContextCurr;</span><br><span class="line"><span class="comment">// YUV444     : we don&#x27;t actually support this correctly.  Copy only the luma (Y) plane</span></span><br><span class="line"><span class="comment">// NV12  (420): the #bytes to </span></span><br><span class="line"><span class="keyword">if</span> ( need_2d_memcpy ) &#123;</span><br><span class="line"><span class="comment">// The source-framebuffer and destination-framebuffer have different pitches.</span></span><br><span class="line"><span class="comment">// (This seems to only happen when decoding HEVC-video using the DXVA/hybrid decoder.)</span></span><br><span class="line"></span><br><span class="line">CUDA_MEMCPY2D cuda_memcpy2d;</span><br><span class="line"><span class="built_in">memset</span>( (<span class="type">void</span> *)&amp;cuda_memcpy2d, <span class="number">0</span>, <span class="built_in">sizeof</span>(cuda_memcpy2d) );<span class="comment">// clear cuda_memcpy2d</span></span><br><span class="line"></span><br><span class="line">cuda_memcpy2d.dstDevice   = (CUdeviceptr) pInput-&gt;pExtAlloc;</span><br><span class="line">cuda_memcpy2d.dstMemoryType = CU_MEMORYTYPE_DEVICE;</span><br><span class="line">cuda_memcpy2d.dstPitch    = pInput-&gt;dwCuPitch;</span><br><span class="line">cuda_memcpy2d.dstXInBytes = <span class="number">0</span>; <span class="comment">// pInput-&gt;dwWidth;</span></span><br><span class="line">cuda_memcpy2d.dstY = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ( m_stEncoderInput.chromaFormatIDC == cudaVideoChromaFormat_444 )</span><br><span class="line">cuda_memcpy2d.Height = pInput-&gt;dwHeight;           <span class="comment">// luma(Y) plane only</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cuda_memcpy2d.Height = (pInput-&gt;dwHeight * <span class="number">3</span>) &gt;&gt; <span class="number">1</span>;<span class="comment">// Y + UV plane</span></span><br><span class="line"><span class="comment">//cuda_memcpy2d.srcArray </span></span><br><span class="line">cuda_memcpy2d.srcDevice = oDecodedFrame[<span class="number">0</span>];</span><br><span class="line">cuda_memcpy2d.srcHost = <span class="literal">NULL</span>;</span><br><span class="line">cuda_memcpy2d.srcMemoryType = CU_MEMORYTYPE_DEVICE;</span><br><span class="line">cuda_memcpy2d.srcPitch = oFrame_pitch;</span><br><span class="line">cuda_memcpy2d.srcXInBytes = <span class="number">0</span>; <span class="comment">// pInput-&gt;dwWidth;</span></span><br><span class="line">cuda_memcpy2d.srcY = <span class="number">0</span>;</span><br><span class="line">cuda_memcpy2d.WidthInBytes = oFrame_pitch;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nCNvEncoderH264::EncodeCudaMemFrame(): cuMemcpy2D(src_pitch=%0u -&gt; dst_pitch=%0u)\n&quot;</span>,</span><br><span class="line">oFrame_pitch, cuda_memcpy2d.dstPitch</span><br><span class="line">);</span><br><span class="line">result = <span class="built_in">cuMemcpy2D</span>(&amp;cuda_memcpy2d);</span><br><span class="line"><span class="comment">//result = cuMemcpy2DUnaligned(&amp;cuda_memcpy2d);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// source framebuffer and dest framebuffer have matching pitch,</span></span><br><span class="line"><span class="comment">// we can use a simpler 1D-memcpy</span></span><br><span class="line"><span class="keyword">if</span> (m_stEncoderInput.chromaFormatIDC == cudaVideoChromaFormat_444)</span><br><span class="line">result = <span class="built_in">cuMemcpyDtoD</span>((CUdeviceptr)pInput-&gt;pExtAlloc, oDecodedFrame[<span class="number">0</span>], pInput-&gt;dwCuPitch*pInput-&gt;dwHeight * <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">result = <span class="built_in">cuMemcpyDtoD</span>((CUdeviceptr)pInput-&gt;pExtAlloc, oDecodedFrame[<span class="number">0</span>], (pInput-&gt;dwCuPitch*pInput-&gt;dwHeight*<span class="number">3</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="built_in">checkCudaErrors</span>(result);</span><br><span class="line">            <span class="built_in">cuCtxPopCurrent</span>(&amp;cuContextCurr);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> Grab a pointer GPU Device Memory (DX9) and then copy the result</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_DX9)</span><br><span class="line">       &#123;</span><br><span class="line">           IDirect3DSurface9 *pSurf = (IDirect3DSurface9 *)pInput-&gt;pExtAlloc;</span><br><span class="line">           pSurf-&gt;<span class="built_in">UnlockRect</span>();</span><br><span class="line">       &#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_DX11)</span><br><span class="line">&#123;</span><br><span class="line">ID3D11Texture2D *pInputTextures = (ID3D11Texture2D *)pInput-&gt;pExtAlloc;</span><br><span class="line">ID3D11DeviceContext *pImmediateContext = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (m_pD3D11Device)</span><br><span class="line">&#123;</span><br><span class="line">m_pD3D11Device-&gt;<span class="built_in">GetImmediateContext</span>(&amp;pImmediateContext);</span><br><span class="line"><span class="keyword">if</span> (NV_INPUT_ENC_FRAME_DX11 ==  pEncodeFrame-&gt;inputEncodeFrameDeviceType )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//使用 GPU 将源资源的全部内容复制到目标资源。</span></span><br><span class="line">ID3D11Texture2D *pSrcTextures = (ID3D11Texture2D*)pLuma;</span><br><span class="line">pImmediateContext-&gt;<span class="built_in">CopyResource</span>(pInputTextures,pSrcTextures);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (NV_INPUT_ENC_FRAME_CPU == pEncodeFrame-&gt;inputEncodeFrameDeviceType)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//upload</span></span><br><span class="line">HRESULT hr = S_OK;</span><br><span class="line"></span><br><span class="line">D3D11_TEXTURE2D_DESC dstDesc;</span><br><span class="line">D3D11_BOX d3d11box;</span><br><span class="line"></span><br><span class="line">pInputTextures-&gt;<span class="built_in">GetDesc</span>(&amp;dstDesc);</span><br><span class="line">d3d11box.front = <span class="number">0</span>; d3d11box.back = <span class="number">1</span>;</span><br><span class="line">d3d11box.left = <span class="number">0</span>; d3d11box.top = <span class="number">0</span>;</span><br><span class="line">d3d11box.right = dstDesc.Width;</span><br><span class="line">d3d11box.bottom = dstDesc.Height;</span><br><span class="line"><span class="keyword">if</span> (dstDesc.Format == (DXGI_FORMAT)<span class="number">103</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//CPU 将数据从内存复制到在不可映射内存中创建的子资源</span></span><br><span class="line">pImmediateContext-&gt;<span class="built_in">UpdateSubresource</span>(pInputTextures, <span class="number">0</span>, &amp;d3d11box, pInputSurface, dstDesc.Width, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pImmediateContext)</span><br><span class="line">                pImmediateContext-&gt;<span class="built_in">Release</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_OPENGL)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//GPU的copy</span></span><br><span class="line"><span class="keyword">if</span> (NV_INPUT_ENC_FRAME_OpenGL ==  pEncodeFrame-&gt;inputEncodeFrameDeviceType)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">NV_ENC_INPUT_RESOURCE_OPENGL_TEX *pResource = (NV_ENC_INPUT_RESOURCE_OPENGL_TEX *)pInput-&gt;pExtAlloc;</span><br><span class="line"><span class="keyword">if</span>((pResource-&gt;target != GL_TEXTURE_2D) || (<span class="built_in">glIsTexture</span>(pResource-&gt;texture) == <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GLuint fboBuffer = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;fboBuffer);<span class="comment">//声明一个帧缓冲区</span></span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, fboBuffer);<span class="comment">//绑定</span></span><br><span class="line"><span class="comment">//将纹理附加到帧缓冲区上</span></span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_READ_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class="line">GL_TEXTURE_2D,  *((GLuint*)pLuma), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT1,</span><br><span class="line">GL_TEXTURE_2D, pResource-&gt;texture, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">glReadBuffer</span>(GL_COLOR_ATTACHMENT0);</span><br><span class="line"><span class="built_in">glDrawBuffer</span>(GL_COLOR_ATTACHMENT1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//glBlitFramebuffer 一般用于帧缓冲区（颜色缓冲区）间高性能数据拷贝</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NV_ENC_BUFFER_FORMAT_NV12_TYPE</span></span><br><span class="line"><span class="built_in">glBlitFramebuffer</span>(<span class="number">0</span>, <span class="number">0</span>, pInput-&gt;dwWidth, pInput-&gt;dwHeight * <span class="number">3</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, pInput-&gt;dwWidth, pInput-&gt;dwHeight * <span class="number">3</span> / <span class="number">2</span>,</span><br><span class="line">GL_COLOR_BUFFER_BIT, GL_NEAREST);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="built_in">glBlitFramebuffer</span>(<span class="number">0</span>, <span class="number">0</span>, pInput-&gt;dwWidth, pInput-&gt;dwHeight, <span class="number">0</span>, <span class="number">0</span>, pInput-&gt;dwWidth, pInput-&gt;dwHeight,</span><br><span class="line">GL_COLOR_BUFFER_BIT, GL_NEAREST);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (NV_INPUT_ENC_FRAME_CPU == pEncodeFrame-&gt;inputEncodeFrameDeviceType)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//WIN32</span></span></span><br><span class="line">        <span class="built_in">SET_VER</span>(mapRes, NV_ENC_MAP_INPUT_RESOURCE);</span><br><span class="line">        mapRes.registeredResource  = pInput-&gt;hRegisteredHandle;</span><br><span class="line">        nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncMapInputResource</span>(m_hEncoder, &amp;mapRes);</span><br><span class="line">        pInput-&gt;hInputSurface = mapRes.mappedResource;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时，我们已经调用了NvEncMapInputResource接口，如果返回成功的话，说明NV_ENC_MAP_INPUT_RESOURCE::mappedResource映射的句柄此时已经生效了</p><h3 id="4-3-2-分配输出的比特流缓冲区"><a href="#4-3-2-分配输出的比特流缓冲区" class="headerlink" title="4.3.2 分配输出的比特流缓冲区"></a>4.3.2 分配输出的比特流缓冲区</h3><p>分配输出的比特流缓冲区需要调用NvEncCreateBitstreamBuffer来进行分配。此时我们回到下NVENC_export&#x2F;Samples&#x2F;nvEncode2&#x2F;src文件夹中的CNvEncoder.cpp文件中的AllocateIOBuffers函数．<br>可以看出分配输出的比特流缓冲区的具体操作分为以下几个步骤：</p><ul><li>填充NV_ENC_CREATE_BITSTREAM_BUFFER结构体</li><li>调用nvEncCreateBitstreamBuffer接口，分配输出比特流缓冲区</li><li>设置视频编码接口的操作模式</li></ul><p>但是这个代码是有问题的，问题在于之前Guest在编写NVENC_export时候，只关注于Win端，因此没有注意到在Linux端是没办法使用异步操作模式的，也就是不能调用nvEncRegisterAsyncEvent接口，文档解释如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Modes of Operation</span><br><span class="line">The NVIDIA Video Encoder Interface supports the following two modes of operation.</span><br><span class="line"></span><br><span class="line">Asynchronous Mode</span><br><span class="line">This mode of operation is used for asynchronous output buffer processing. For this mode, the client allocates an event object and associates the event with an allocated output buffer. This event object is passed to the NVIDIA Encoder Interface as part of the NvEncEncodePicture API. The client can wait on the event in a separate thread. When the event is signaled, the client calls the NVIDIA Video Encoder Interface to copy output bitstream produced by the encoder. Note that the encoder supports asynchronous mode of operation only for Windows 7 and above, with driver running in WDDM mode. In Linux and Windows with TCC mode (TCC mode is available on Tesla boards1), ONLY synchronous mode is supported (refer to Section Synchronous Mode)</span><br><span class="line"></span><br><span class="line">The client should set the flag NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync to 1 to indicate that it wants to operate in asynchronous mode. After creating the event objects (one object for each output bitstream buffer allocated), the client needs to register them with the NVIDIA Video Encoder Interface using the NvEncRegisterAsyncEvent. The client is required to pass a bitstream buffer handle and the corresponding event handle as input to NvEncEncodePicture. The NVIDIA Video Encoder Interface will signal this event when the hardware encoder finishes encoding the current input data. The client can then call NvEncLockBitstream in non-blocking mode NV_ENC_LOCK_BITSTREAM::doNotWait flag set to 1 to fetch the output data.</span><br><span class="line"></span><br><span class="line">The client should call NvEncUnregisterAsyncEvent to unregister the Event handles before destroying the event objects. Whenever possible, NVIDIA recommends using the asynchronous mode of operation instead of synchronous mode.</span><br><span class="line"></span><br><span class="line">A step-by-step control flow for asynchronous mode is as follows:</span><br><span class="line"></span><br><span class="line">When working in asynchronous mode, the output sample must consist of an event + output buffer and clients must work in multi-threaded manner (D3D9 device should be created with MULTITHREADED flag).</span><br><span class="line">The output buffers are allocated using NvEncCreateBitstreamBuffer API. The NVIDIA Video Encoder Interface will return an opaque pointer to the output memory in NV_ENC_CREATE_BITSTREAM_BUFFER::bitstreambuffer. This opaque output pointer should be used in NvEncEncodePicture and NvEncLockBitsteam/ NvEncUnlockBitsteam calls. For accessing the output memory using CPU, client must call NvEncLockBitsteam API. The number of IO buffers should be at least 4 + number of B frames.</span><br><span class="line">The events are windows event handles allocated using Windows’ CreateEvent API and registered using the function NvEncRegisterAsyncEvent before encoding. The registering of events is required only once per encoding session. Clients must unregister the events using NvEncUnregisterAsyncEvent before destroying the event handles. The number of event handles must be same as number of output buffers as each output buffer is associated with an event.</span><br><span class="line">Client must create a secondary thread in which it can wait on the completion event and copy the bitstream data from the output sample. Client will have two threads: one is the main application thread which submits encoding work to NVIDIA Encoder while secondary thread waits on the completion events and copies the compressed bitstream data from the output buffer.</span><br><span class="line">Client must send the output buffer and event in NV_ENC_PIC_PARAMS::outputBitstream and NV_ENC_PIC_PARAMS:: completionEvent fields respectively as part of NvEncEncodePicture API call.</span><br><span class="line">Client should then wait on the event on the secondary thread in the same order in which it has called NvEncEncodePicture calls irrespective of input buffer re-ordering (encode order! = display order). When enablePTD = 1, NVIDIA Encoder takes care of the reordering in case of B frames in a way that is transparent to the encoder clients. For AV1, NVIDIA encoder also transparently performs frame bitstream packing, meaning it always concatenates into a single output buffer the bitstream corresponding to leading no-show frames with the bitstream of the first show frame that follows. Each output buffer therefore always contains a single frame to display along with all the preceding non-display frames in encode order since the previous frame to display.</span><br><span class="line">When the event gets signalled client must send down the output buffer of sample event it was waiting on in NV_ENC_LOCK_BITSTREAM::outputBitstream field as part of NvEncLockBitstream call.</span><br><span class="line">The NVIDIA Encoder Interface returns a CPU pointer and bitstream size in bytes as part of the NV_ENC_LOCK_BITSTREAM.</span><br><span class="line">After copying the bitstream data, client must call NvEncUnlockBitstream for the locked output bitstream buffer.</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The client will receive the event&#x27;s signal and output buffer in the same order in which they were queued.</span><br><span class="line">The NV_ENC_LOCK_BITSTREAM::pictureType notifies the output picture type to the clients.</span><br><span class="line">Both, the input and output sample (output buffer and the output completion event) are free to be reused once the NVIDIA Video Encoder Interface has signalled the event and the client has copied the data from the output buffer.</span><br><span class="line"></span><br><span class="line">Synchronous Mode</span><br><span class="line">This mode of operation is used for synchronous output buffer processing. In this mode the client makes a blocking call to the NVIDIA Video Encoder Interface to retrieve the output bitstream data from the encoder. The client sets the flag NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync to 0 for operation in synchronous mode. The client then must call NvEncEncodePicture without setting a completion event handle. The client must call NvEncLockBitstream with flag NV_ENC_LOCK_BITSTREAM::doNotWait set to 0, so that the lock call blocks until the hardware encoder finishes writing the output bitstream. The client can then operate on the generated bitstream data and call NvEncUnlockBitstream. This is the only mode supported on Linux.</span><br></pre></td></tr></table></figure><p>翻译一下大概意思：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">异步模式:</span><br><span class="line">这种操作模式用于异步输出缓冲区处理。对于这种模式，必须分配一个事件对象，并将事件与分配的输出缓冲区相关联。此事件对象作为 NVIDIA 编码器接口的一部分传递给NvEncEncodePicture应用程序接口。用户可以在单独的线程中等待事件。当事件发出信号时，用户调用 NVIDIA 视频编码器接口来复制编码器产生的输出比特流。请注意，编码器仅支持 Windows 7 及更高版本的异步操作模式，在 WDDM 模式下运行的驱动程序。</span><br><span class="line">用户应该设置标志NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync为1，表示它要在异步模式下运行。</span><br><span class="line">在创建事件对象（为每个输出比特流缓冲区分配一个对象）后，用户需要调用 NvEncRegisterAsyncEvent。</span><br><span class="line">用户需要将比特流缓冲区句柄和相应的事件句柄作为输入传递给NvEncEncodePicture。</span><br><span class="line">当硬件编码器完成对当前输入数据的编码时，NVIDIA 视频编码器接口将发出此事件信号。然后用户可以在非阻塞模式（NV_ENC_LOCK_BITSTREAM::doNotWait 标志设置为 1 ）下调用NvEncLockBitstream 以获取输出数据。</span><br><span class="line">在销毁事件对象之前，客户应该调用NvEncUnregisterAsyncEvent取消注册的事件句柄。只要有可能，NVIDIA 建议使用异步操作模式而不是同步模式。</span><br><span class="line">异步模式的分步控制流程如下：</span><br><span class="line"></span><br><span class="line">在异步模式下工作时，输出样本必须由事件 + 输出缓冲区组成，并且用户必须以多线程方式工作（D3D9 设备应使用 MULTITHREADED 标志创建）。</span><br><span class="line">输出缓冲区使用 NvEncCreateBitstreamBuffer来分配。它将返回一个指向输出内存的不透明指针 NV_ENC_CREATE_BITSTREAM_BUFFER::bitstreambuffer。这个不透明的输出指针应该用于NvEncEncodePicture 和 NvEncLockBitsteam/ NvEncUnlockBitsteam的调用中。要使用 CPU 访问输出存储器，用户必须调用NvEncLockBitsteam。IO 缓冲区的数量应至少为 4 + B 帧的数量。</span><br><span class="line">如果这些事件是使用CreateEvent分配的 Windows 事件句柄，则在编码前需要使用NvEncRegisterAsyncEvent进行注册。每个编码会话只需要注册一次事件。用户必须在销毁事件句柄之前，使用NvEncUnregisterAsyncEvent取消注册事件。事件句柄的数量必须与输出缓冲区的数量相同，因为每个输出缓冲区都与一个事件相关联。</span><br><span class="line">用户必须创建一个辅助线程，它可以在其中等待完成事件并从输出样本中复制比特流数据。用户将有两个线程：一个是主应用程序线程，它向 NVIDIA 编码器提交编码工作，而辅助线程等待完成事件并从输出缓冲区复制压缩的比特流数据。</span><br><span class="line">用户必须将输出缓冲区和事件发送到 NV_ENC_PIC_PARAMS::outputBitstream 和 NV_ENC_PIC_PARAMS::completionEvent字段，依次调用NvEncEncodePicture API。</span><br><span class="line">然后用户应该按照它调用的相同顺序在辅助线程上等待事件，NvEncEncodePicture调用与输入缓冲区重新排序无关（编码顺序 != 显示顺序）。NVIDIA Encoder 负责处理 B 帧的重新排序，并且应该对编码器用户透明。</span><br><span class="line">当事件得到信号时，用户必须向下发送它正在等待的样本事件的输出缓冲区，即调用NvEncLockBitstream的参数NV_ENC_LOCK_BITSTREAM::outputBitstream。</span><br><span class="line">NVIDIA 编码器接口返回作为NV_ENC_LOCK_BITSTREAM一部分的，以字节为单位的CPU指针和比特流大小。</span><br><span class="line">复制比特流数据后，对于锁定的输出比特流缓冲区，用户必须调用 NvEncUnlockBitstream。</span><br><span class="line">提示：</span><br><span class="line">用户将按照它们排队的相同顺序接收事件的信号和输出缓冲区。</span><br><span class="line">NV_ENC_LOCK_BITSTREAM::pictureType 将输出图片类型通知给用户。</span><br><span class="line">一旦 NVIDIA 视频编码器接口发出事件信号并且用户已从输出缓冲区复制数据，输入和输出样本（输出缓冲区和输出完成事件）都可以自由重用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">同步模式：</span><br><span class="line">这种操作模式用于同步输出缓冲处理。在这种模式下，用户对 NVIDIA 视频编码器接口进行阻塞调用，以从编码器检索输出比特流数据。</span><br><span class="line">同步模式下，用户设置标志NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync为 0。然后用户必须调用NvEncEncodePicture无需设置完成事件句柄。用户调用NvEncLockBitstream，NV_ENC_LOCK_BITSTREAM::doNotWait需设置为 0，以便阻塞和锁定调用，直到硬件编码器完成输出比特流的写入。然后用户可以对生成的比特流数据进行操作，然后调用NvEncUnlockBitstream。这是 Linux 上唯一支持的模式。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因此我们将AllocateIOBuffers函数修改成以下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//Allocate output surface</span></span><br><span class="line">        m_stBitstreamBuffer[i].dwSize = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">        NV_ENC_CREATE_BITSTREAM_BUFFER stAllocBitstream;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;stAllocBitstream, <span class="number">0</span>, <span class="built_in">sizeof</span>(stAllocBitstream));</span><br><span class="line">        <span class="built_in">SET_VER</span>(stAllocBitstream, NV_ENC_CREATE_BITSTREAM_BUFFER);</span><br><span class="line">        stAllocBitstream.size                      =  m_stBitstreamBuffer[i].dwSize;</span><br><span class="line">        stAllocBitstream.memoryHeap                = NV_ENC_MEMORY_HEAP_SYSMEM_CACHED;</span><br><span class="line"></span><br><span class="line">        status = m_pEncodeAPI-&gt;<span class="built_in">nvEncCreateBitstreamBuffer</span>(m_hEncoder, &amp;stAllocBitstream);</span><br><span class="line">        <span class="built_in">checkNVENCErrors</span>(status);</span><br><span class="line"></span><br><span class="line">        m_stBitstreamBuffer[i].hBitstreamBuffer    = stAllocBitstream.bitstreamBuffer;</span><br><span class="line">        m_stBitstreamBuffer[i].pBitstreamBufferPtr = stAllocBitstream.bitstreamBufferPtr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO : need to fix the ucode to set the bitstream position</span></span><br><span class="line">        <span class="keyword">if</span> (m_stEncoderInput.outBandSPSPPS == <span class="number">0</span>)</span><br><span class="line">            m_stBitstreamBuffer[i].pBitstreamBufferPtr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line"> NV_ENC_EVENT_PARAMS nvEventParams = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">SET_VER</span>(nvEventParams, NV_ENC_EVENT_PARAMS);</span><br><span class="line">        m_stBitstreamBuffer[i].hOutputEvent        = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">        nvEventParams.completionEvent              = m_stBitstreamBuffer[i].hOutputEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register the resource for interop with NVENC</span></span><br><span class="line">        nvEventParams.completionEvent              = m_stBitstreamBuffer[i].hOutputEvent;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        m_stBitstreamBuffer[i].hOutputEvent = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line">        m_pEncodeAPI-&gt;<span class="built_in">nvEncRegisterAsyncEvent</span>(m_hEncoder, &amp;nvEventParams);<span class="comment">//Linux端不支持异步模式，只能用同步模式</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        m_stOutputSurfQueue.<span class="built_in">Add</span>(&amp;m_stBitstreamBuffer[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_stEOSOutputBfr.bEOSFlag = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line"> NV_ENC_EVENT_PARAMS nvEventParams = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">SET_VER</span>(nvEventParams, NV_ENC_EVENT_PARAMS);</span><br><span class="line">    m_stEOSOutputBfr.hOutputEvent = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">    nvEventParams.completionEvent = m_stEOSOutputBfr.hOutputEvent;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    m_stEOSOutputBfr.hOutputEvent = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line">    m_pEncodeAPI-&gt;<span class="built_in">nvEncRegisterAsyncEvent</span>(m_hEncoder, &amp;nvEventParams);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32 </span></span><br><span class="line">    <span class="comment">// intialize output thread</span></span><br><span class="line">    <span class="keyword">if</span> (hr == S_OK &amp;&amp; !m_pEncoderThread)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pEncoderThread = <span class="keyword">new</span> <span class="built_in">CNvEncoderThread</span>(<span class="built_in">reinterpret_cast</span>&lt;CNvEncoder*&gt;(<span class="keyword">this</span>), MAX_OUTPUT_QUEUE);</span><br><span class="line">        <span class="keyword">if</span> (!m_pEncoderThread)</span><br><span class="line">        &#123;</span><br><span class="line">            hr = E_FAIL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_pEncoderThread-&gt;<span class="built_in">ThreadStart</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>    </span></span><br><span class="line"><span class="comment">///////</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// transfer the encoder-settings to m_sei_user_payload</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">m_sei_user_payload_str = oss.<span class="built_in">str</span>();</span><br><span class="line"><span class="comment">//printf( &quot;m_sei_user_payload(%0u) = &#x27;%s&#x27;\n&quot;, m_sei_user_payload_str.length(), m_sei_user_payload_str.c_str() );</span></span><br><span class="line"></span><br><span class="line">m_sei_user_payload.payloadType = <span class="number">5</span>;<span class="comment">// Annex D : Type 5 = &#x27;user data unregistered&#x27;</span></span><br><span class="line">m_sei_user_payload.payloadSize = m_sei_user_payload_str.<span class="built_in">length</span>();<span class="comment">// fill in later</span></span><br><span class="line"><span class="keyword">if</span> ( m_sei_user_payload.payload != <span class="literal">NULL</span> )</span><br><span class="line"><span class="keyword">delete</span> [] m_sei_user_payload.payload;</span><br><span class="line"></span><br><span class="line">m_sei_user_payload.payload = <span class="keyword">new</span> <span class="type">uint8_t</span>[ m_sei_user_payload.payloadSize ];</span><br><span class="line"><span class="built_in">memcpy</span>( (<span class="type">char</span> *)m_sei_user_payload.payload, m_sei_user_payload_str.<span class="built_in">c_str</span>(), m_sei_user_payload.payloadSize );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hr == S_OK)</span><br><span class="line">        m_bEncoderInitialized = <span class="literal">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">HRESULT <span class="title">CNvEncoderH264::EncodeCudaMemFrame</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">EncodeFrameConfig *pEncodeFrame, CUdeviceptr oDecodedFrame[<span class="number">3</span>], <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> oFrame_pitch, <span class="type">bool</span> bFlush )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NVENCSTATUS nvStatus = NV_ENC_SUCCESS;</span><br><span class="line">    HRESULT hr = S_OK;</span><br><span class="line">    NV_ENC_MAP_INPUT_RESOURCE mapRes = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bFlush)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">FlushEncoder</span>();</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pEncodeFrame)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> E_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EncodeInputSurfaceInfo  *pInput;</span><br><span class="line">    EncodeOutputBuffer      *pOutputBitstream;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_stInputSurfQueue.<span class="built_in">Remove</span>(pInput, INFINITE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_stOutputSurfQueue.<span class="built_in">Remove</span>(pOutputBitstream, INFINITE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lockedPitch = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// encode width and height</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwWidth =  m_uMaxWidth; <span class="comment">//m_stEncoderInput.width;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwHeight = m_uMaxHeight;<span class="comment">//m_stEncoderInput.height;</span></span><br><span class="line">    <span class="comment">// Align 32 as driver does the same</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwSurfWidth  = (dwWidth + <span class="number">0x1f</span>) &amp; ~<span class="number">0x1f</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwSurfHeight = (dwHeight + <span class="number">0x1f</span>) &amp; ~<span class="number">0x1f</span>;</span><br><span class="line">    <span class="comment">//unsigned char *pLuma    = pEncodeFrame-&gt;yuv[0];</span></span><br><span class="line">    <span class="comment">//unsigned char *pChromaU = pEncodeFrame-&gt;yuv[1];</span></span><br><span class="line">    <span class="comment">//unsigned char *pChromaV = pEncodeFrame-&gt;yuv[2];</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pInputSurface = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pInputSurfaceCh = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">const</span>    <span class="type">bool</span> need_2d_memcpy = (oFrame_pitch % pInput-&gt;dwCuPitch) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CUDA or DX9 interop with NVENC</span></span><br><span class="line">    <span class="keyword">if</span> (m_stEncoderInput.useMappedResources)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Here we copy from Host to Device Memory (CUDA)</span></span><br><span class="line">        <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_CUDA)</span><br><span class="line">        &#123;</span><br><span class="line">            CUresult result;</span><br><span class="line">            <span class="built_in">cuCtxPushCurrent</span>(m_cuContext); <span class="comment">// Necessary to bind the </span></span><br><span class="line">            CUcontext cuContextCurr;</span><br><span class="line"><span class="comment">// YUV444     : we don&#x27;t actually support this correctly.  Copy only the luma (Y) plane</span></span><br><span class="line"><span class="comment">// NV12  (420): the #bytes to </span></span><br><span class="line"><span class="keyword">if</span> ( need_2d_memcpy ) &#123;</span><br><span class="line"><span class="comment">// The source-framebuffer and destination-framebuffer have different pitches.</span></span><br><span class="line"><span class="comment">// (This seems to only happen when decoding HEVC-video using the DXVA/hybrid decoder.)</span></span><br><span class="line"></span><br><span class="line">CUDA_MEMCPY2D cuda_memcpy2d;</span><br><span class="line"><span class="built_in">memset</span>( (<span class="type">void</span> *)&amp;cuda_memcpy2d, <span class="number">0</span>, <span class="built_in">sizeof</span>(cuda_memcpy2d) );<span class="comment">// clear cuda_memcpy2d</span></span><br><span class="line"></span><br><span class="line">cuda_memcpy2d.dstDevice   = (CUdeviceptr) pInput-&gt;pExtAlloc;</span><br><span class="line">cuda_memcpy2d.dstMemoryType = CU_MEMORYTYPE_DEVICE;</span><br><span class="line">cuda_memcpy2d.dstPitch    = pInput-&gt;dwCuPitch;</span><br><span class="line">cuda_memcpy2d.dstXInBytes = <span class="number">0</span>; <span class="comment">// pInput-&gt;dwWidth;</span></span><br><span class="line">cuda_memcpy2d.dstY = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ( m_stEncoderInput.chromaFormatIDC == cudaVideoChromaFormat_444 )</span><br><span class="line">cuda_memcpy2d.Height = pInput-&gt;dwHeight;           <span class="comment">// luma(Y) plane only</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cuda_memcpy2d.Height = (pInput-&gt;dwHeight * <span class="number">3</span>) &gt;&gt; <span class="number">1</span>;<span class="comment">// Y + UV plane</span></span><br><span class="line"><span class="comment">//cuda_memcpy2d.srcArray </span></span><br><span class="line">cuda_memcpy2d.srcDevice = oDecodedFrame[<span class="number">0</span>];</span><br><span class="line">cuda_memcpy2d.srcHost = <span class="literal">NULL</span>;</span><br><span class="line">cuda_memcpy2d.srcMemoryType = CU_MEMORYTYPE_DEVICE;</span><br><span class="line">cuda_memcpy2d.srcPitch = oFrame_pitch;</span><br><span class="line">cuda_memcpy2d.srcXInBytes = <span class="number">0</span>; <span class="comment">// pInput-&gt;dwWidth;</span></span><br><span class="line">cuda_memcpy2d.srcY = <span class="number">0</span>;</span><br><span class="line">cuda_memcpy2d.WidthInBytes = oFrame_pitch;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nCNvEncoderH264::EncodeCudaMemFrame(): cuMemcpy2D(src_pitch=%0u -&gt; dst_pitch=%0u)\n&quot;</span>,</span><br><span class="line">oFrame_pitch, cuda_memcpy2d.dstPitch</span><br><span class="line">);</span><br><span class="line">result = <span class="built_in">cuMemcpy2D</span>(&amp;cuda_memcpy2d);</span><br><span class="line"><span class="comment">//result = cuMemcpy2DUnaligned(&amp;cuda_memcpy2d);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// source framebuffer and dest framebuffer have matching pitch,</span></span><br><span class="line"><span class="comment">// we can use a simpler 1D-memcpy</span></span><br><span class="line"><span class="keyword">if</span> (m_stEncoderInput.chromaFormatIDC == cudaVideoChromaFormat_444)</span><br><span class="line">result = <span class="built_in">cuMemcpyDtoD</span>((CUdeviceptr)pInput-&gt;pExtAlloc, oDecodedFrame[<span class="number">0</span>], pInput-&gt;dwCuPitch*pInput-&gt;dwHeight * <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">result = <span class="built_in">cuMemcpyDtoD</span>((CUdeviceptr)pInput-&gt;pExtAlloc, oDecodedFrame[<span class="number">0</span>], (pInput-&gt;dwCuPitch*pInput-&gt;dwHeight*<span class="number">3</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="built_in">checkCudaErrors</span>(result);</span><br><span class="line">            <span class="built_in">cuCtxPopCurrent</span>(&amp;cuContextCurr);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//#if defined(NV_WINDOWS)</span></span><br><span class="line"><span class="comment">//        // <span class="doctag">TODO:</span> Grab a pointer GPU Device Memory (DX9) and then copy the result</span></span><br><span class="line"><span class="comment">//        if (m_stEncoderInput.interfaceType == NV_ENC_DX9)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            IDirect3DSurface9 *pSurf = (IDirect3DSurface9 *)pInput-&gt;pExtAlloc;</span></span><br><span class="line"><span class="comment">//            pSurf-&gt;UnlockRect();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//#endif</span></span><br><span class="line">        <span class="built_in">SET_VER</span>(mapRes, NV_ENC_MAP_INPUT_RESOURCE);</span><br><span class="line">        mapRes.registeredResource  = pInput-&gt;hRegisteredHandle;</span><br><span class="line">        nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncMapInputResource</span>(m_hEncoder, &amp;mapRes);</span><br><span class="line">        pInput-&gt;hInputSurface = mapRes.mappedResource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// here we just pass the frame in system memory to NVENC</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CNvEncoderH264::EncodeCudaMemFrame ERROR !useMappedResources\n&quot;</span>);</span><br><span class="line">        <span class="built_in">UnlockInputBuffer</span>(pInput-&gt;hInputSurface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;m_stEncodePicParams, <span class="number">0</span>, <span class="built_in">sizeof</span>(m_stEncodePicParams));</span><br><span class="line">    <span class="built_in">SET_VER</span>(m_stEncodePicParams, NV_ENC_PIC_PARAMS);</span><br><span class="line">    m_stEncodePicParams.inputBuffer = pInput-&gt;hInputSurface;</span><br><span class="line">    m_stEncodePicParams.bufferFmt = pInput-&gt;bufferFmt;</span><br><span class="line">    m_stEncodePicParams.inputWidth = pInput-&gt;dwWidth;</span><br><span class="line">    m_stEncodePicParams.inputHeight = pInput-&gt;dwHeight;</span><br><span class="line">    m_stEncodePicParams.outputBitstream = pOutputBitstream-&gt;hBitstreamBuffer;</span><br><span class="line">    m_stEncodePicParams.completionEvent = m_bAsyncModeEncoding == <span class="literal">true</span> ? pOutputBitstream-&gt;hOutputEvent : <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( m_stEncoderInput.FieldEncoding == NV_ENC_PARAMS_FRAME_FIELD_MODE_FRAME ) &#123;</span><br><span class="line">        <span class="comment">// progressive-video encoding mode</span></span><br><span class="line">        m_stEncodePicParams.pictureStruct = NV_ENC_PIC_STRUCT_FRAME;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// interlaced-video encoding mode</span></span><br><span class="line">        <span class="comment">// In interlaced-mode, NVENC requires interlaced-input, even if the frames are progressive</span></span><br><span class="line">        <span class="comment">// pEncodeFrame-&gt;fieldPicflag ?</span></span><br><span class="line">        m_stEncodePicParams.pictureStruct = pEncodeFrame-&gt;topField ? </span><br><span class="line">            NV_ENC_PIC_STRUCT_FIELD_TOP_BOTTOM : NV_ENC_PIC_STRUCT_FIELD_BOTTOM_TOP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    m_stEncodePicParams.codecPicParams.h264PicParams.h264ExtPicParams.mvcPicParams.viewID = pEncodeFrame-&gt;viewId;    </span></span><br><span class="line">    m_stEncodePicParams.encodePicFlags = <span class="number">0</span>;</span><br><span class="line">    m_stEncodePicParams.inputTimeStamp = <span class="number">0</span>;</span><br><span class="line">    m_stEncodePicParams.inputDuration = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For H264-only: embed encoder-settings (text-string) into the encoded videostream</span></span><br><span class="line"><span class="keyword">if</span> (m_sei_user_payload_str.<span class="built_in">length</span>()) &#123; <span class="comment">// m_sei_user_payload.payloadSize ) &#123;</span></span><br><span class="line">m_stEncodePicParams.codecPicParams.h264PicParams.seiPayloadArrayCnt = <span class="number">1</span>;</span><br><span class="line">m_stEncodePicParams.codecPicParams.h264PicParams.seiPayloadArray = &amp;m_sei_user_payload;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete the payload.  This way, our user-sei is only embedded into the *first* frame</span></span><br><span class="line"><span class="comment">// of the output-bitstream, and nothing subsequent.  While we really should mebed</span></span><br><span class="line"><span class="comment">// it in every frame, that would bloat the output filesize, and MediaInfo only</span></span><br><span class="line"><span class="comment">// needs the user-sei in the first-frame to display the info. </span></span><br><span class="line">m_sei_user_payload_str.<span class="built_in">clear</span>();</span><br><span class="line">&#125; <span class="comment">// sei</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!m_stInitEncParams.enablePTD)</span><br><span class="line">&#123;</span><br><span class="line">m_stEncodePicParams.codecPicParams.h264PicParams.refPicFlag = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//m_stEncodePicParams.codecPicParams.h264PicParams.frameNumSyntax = m_dwFrameNumInGOP;</span></span><br><span class="line">m_stEncodePicParams.codecPicParams.h264PicParams.displayPOCSyntax = <span class="number">2</span> * m_dwFrameNumInGOP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!m_stInitEncParams.enablePTD)</span><br><span class="line">m_stEncodePicParams.pictureType = ((m_dwFrameNumInGOP % m_stEncoderInput.gopLength) == <span class="number">0</span>) ? NV_ENC_PIC_TYPE_IDR : NV_ENC_PIC_TYPE_P;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handling Dynamic Resolution Changing    </span></span><br><span class="line">    <span class="keyword">if</span> (pEncodeFrame-&gt;dynResChangeFlag)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ERROR, dynResChangeFlag != 0: is not supported&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handling Dynamic Bitrate Change</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pEncodeFrame-&gt;dynBitrateChangeFlag == DYN_DOWNSCALE)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ERROR, dynBitrateChangeFlag == DYN_UPSCALE: is not supported&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pEncodeFrame-&gt;dynBitrateChangeFlag == DYN_UPSCALE)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ERROR, dynBitrateChangeFlag == DYN_UPSCALE: is not supported&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((m_bAsyncModeEncoding == <span class="literal">false</span>) &amp;&amp; </span><br><span class="line">        (m_stInitEncParams.enablePTD == <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        EncoderThreadData stThreadData;</span><br><span class="line">        stThreadData.pOutputBfr = pOutputBitstream;</span><br><span class="line">        stThreadData.pInputBfr = pInput;</span><br><span class="line">        stThreadData.pOutputBfr-&gt;bDynResChangeFlag = pEncodeFrame-&gt;dynResChangeFlag == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        pOutputBitstream-&gt;bWaitOnEvent = <span class="literal">false</span>;</span><br><span class="line">        m_pEncodeFrameQueue.<span class="built_in">Add</span>(stThreadData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncEncodePicture</span>(m_hEncoder, &amp;m_stEncodePicParams);</span><br><span class="line">    </span><br><span class="line">    m_dwFrameNumInGOP++;</span><br><span class="line">    <span class="keyword">if</span> ((m_bAsyncModeEncoding == <span class="literal">false</span>) &amp;&amp; </span><br><span class="line">        (m_stInitEncParams.enablePTD == <span class="number">1</span>))</span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="keyword">if</span> (nvStatus == NV_ENC_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            EncoderThreadData stThreadData;</span><br><span class="line">            <span class="keyword">while</span> (m_pEncodeFrameQueue.<span class="built_in">Remove</span>(stThreadData, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">                m_pEncoderThread-&gt;<span class="built_in">QueueSample</span>(stThreadData);<span class="comment">//只在Win下支持异步，所以Win下才能用m_pEncoderThread</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">CopyBitstreamData</span>(stThreadData);<span class="comment">//Linux下只能同步，不需要线程</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span> (nvStatus != NV_ENC_ERR_NEED_MORE_INPUT) &#123;</span><br><span class="line"><span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="built_in">assert</span>(nvStatus == NV_ENC_ERR_NEED_MORE_INPUT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nvStatus == NV_ENC_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            EncoderThreadData stThreadData;</span><br><span class="line">            stThreadData.pOutputBfr = pOutputBitstream;</span><br><span class="line">            stThreadData.pInputBfr = pInput;</span><br><span class="line">            pOutputBitstream-&gt;bWaitOnEvent = <span class="literal">true</span>;</span><br><span class="line">            stThreadData.pOutputBfr-&gt;bDynResChangeFlag = pEncodeFrame-&gt;dynResChangeFlag == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32            </span></span><br><span class="line">            <span class="comment">// Queue o/p Sample</span></span><br><span class="line">            <span class="keyword">if</span> (!m_pEncoderThread-&gt;<span class="built_in">QueueSample</span>(stThreadData))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>            </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line">            <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux端音视频开发注意事项</title>
      <link href="/2023/01/13/Linux%E7%AB%AF%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2023/01/13/Linux%E7%AB%AF%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="运行依赖"><a href="#运行依赖" class="headerlink" title="运行依赖"></a>运行依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y libwebp-dev zlib1g-dev uuid-dev </span><br><span class="line">sudo apt install -y libglfw3-dev </span><br></pre></td></tr></table></figure><h2 id="Ubuntu开发环境"><a href="#Ubuntu开发环境" class="headerlink" title="Ubuntu开发环境"></a>Ubuntu开发环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install meld filezilla cmake gcc g++ ninja-build </span><br><span class="line">sudo apt install codeblocks</span><br><span class="line">sudo apt install ssh</span><br><span class="line">sudo apt install vim</span><br><span class="line">sudo apt install sudo</span><br><span class="line">sudo apt install yasm</span><br><span class="line">sudo apt install libzlib1g-dev</span><br><span class="line">sudo apt install -y libwebp-dev zlib1g-dev uuid-dev </span><br><span class="line">sudo apt install -y libglfw3-dev</span><br><span class="line">sudo apt install libglfw3-dev</span><br><span class="line">sudo apt install xorg-dev</span><br><span class="line">sudo apt install libglew-dev</span><br><span class="line">sudo apt install libopenal-dev</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="CentOS开发环境"><a href="#CentOS开发环境" class="headerlink" title="CentOS开发环境"></a>CentOS开发环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install meld filezilla cmake gcc g++ ninja-build </span><br><span class="line"></span><br><span class="line">sudo yum install vim</span><br><span class="line"></span><br><span class="line"><span class="comment">#yasm</span></span><br><span class="line">wget http://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gz</span><br><span class="line">tar zxvf yasm-1.3.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> yasm-1.3.0</span><br><span class="line">./configure</span><br><span class="line">sudo make &amp;&amp; sudo make install</span><br><span class="line"></span><br><span class="line">sudo yum install libwebp-tools　<span class="comment">#或者https://icxzl.com/3107.html</span></span><br><span class="line"></span><br><span class="line">sudo yum install -y zlib zlib-devel</span><br><span class="line"></span><br><span class="line">sudo yum install libuuid-devel</span><br><span class="line"></span><br><span class="line"><span class="comment">#VLC</span></span><br><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install https://download1.rpmfusion.org/free/el/rpmfusion-free-release-7.noarch.rpm</span><br><span class="line">sudo yum install vlc</span><br><span class="line"></span><br><span class="line"><span class="comment">#mediainfo</span></span><br><span class="line">sudo yum  install  mediainfo</span><br><span class="line"></span><br><span class="line"><span class="comment">#ffmpeg</span></span><br><span class="line">https://trac.ffmpeg.org/wiki/CompilationGuide/Centos</span><br><span class="line"></span><br><span class="line"><span class="comment">#CodeBloks</span></span><br><span class="line"></span><br><span class="line">访问这个[网站](https://download.fosshub.com/Protected/expiretime=1695403666;badurl=aHR0cHM6Ly93d3cuZm9zc2h1Yi5jb20vQ29kZS1CbG9ja3MuaHRtbA==/978443aca2ee82061fb6e02204e1bd6d228032c5e34710da1a67aef0a21c865c/5b85805cf9ee5a5c3e979f1b/5e80624f7d74bb810359a46c/codeblocks_20.03_i386_stable.tar.xz)进行下载</span><br><span class="line"></span><br><span class="line">sudo yum install gcc</span><br><span class="line">sudo yum install gcc-c++</span><br><span class="line"></span><br><span class="line">sudo yum -y install gtk2-devel cscope binutils-devel wxGTK xterm squirrel-libs tinyxml cppcheck gamin</span><br><span class="line"></span><br><span class="line">tar xvf codeblocks_20.03.tar.xz </span><br><span class="line"><span class="built_in">cd</span> sources-20.03/</span><br><span class="line">./configure --prefix=/usr --with-contrib-plugins=all</span><br><span class="line"><span class="comment">#如果报错：wxWidgets must be installed on your system，则去https://www.wxwidgets.org/downloads/下载wxw　tar -xvf wxWidgets-3.0.5.tar.bz2 　cd wxWidgets-3.0.5　./configure --prefix=/opt/wx/3.0.5 &amp;&amp; make &amp;&amp; sudo make install</span></span><br><span class="line"><span class="comment">#如果报错：No package &#x27;hunspell&#x27; found　则：sudo yum install hunspell-devel  sudo yum install boost-devel</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/bin:/opt/wx/3.0.5/bin:<span class="variable">$PATH</span></span><br><span class="line">ldconfig</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">sudo make installs</span><br></pre></td></tr></table></figure><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sudo yum install -y docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line">sudo su</span><br><span class="line">systemctl enable docker #设置开机自动启动docker</span><br></pre></td></tr></table></figure><h1 id="编译所有工程"><a href="#编译所有工程" class="headerlink" title="编译所有工程"></a>编译所有工程</h1><h2 id="在当前目录下进入命令行模式，运行autobuild-bash-h查看自动编译脚本信息"><a href="#在当前目录下进入命令行模式，运行autobuild-bash-h查看自动编译脚本信息" class="headerlink" title="在当前目录下进入命令行模式，运行autobuild.bash -h查看自动编译脚本信息"></a>在当前目录下进入命令行模式，运行autobuild.bash -h查看自动编译脚本信息</h2><h1 id="调试编译后的工程"><a href="#调试编译后的工程" class="headerlink" title="调试编译后的工程"></a>调试编译后的工程</h1><p>如果想要使用vscode调试编译后的debug代码的话，可以在当前目录下进入命令行模式，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code .</span><br></pre></td></tr></table></figure><p>进入vscode后，通过建立launch.json脚本进行调试，以下是该脚本的参考代码</p><p>Linux_Test_cb的</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) Linux_Test_cb Launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span>   <span class="comment">//正在使用的调试器,使用Visual Studio Windows时必须为cppvsdbg,使用GDB或LLDB时必须为cppdbg.</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span>  <span class="comment">//表示此配置是用于启动程序还是附加到已运行的实例上</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/../../../Src/BinUbuntu/x64/Debug/Linux_Test_cb&quot;</span><span class="punctuation">,</span>   <span class="comment">//要执行的可执行文件的完整路径</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span>            <span class="comment">//设置调试器启动的应用程序的工作目录</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LD_LIBRARY_PATH&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/../../../Src/BinUbuntu/x64/Debug&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span>   <span class="comment">//要连接的调试器</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>QtConverter的</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) QtConverter Launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span>   <span class="comment">//正在使用的调试器,使用Visual Studio Windows时必须为cppvsdbg,使用GDB或LLDB时必须为cppdbg.</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span>  <span class="comment">//表示此配置是用于启动程序还是附加到已运行的实例上</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/../../../../../Src/BinUbuntu/x64/Debug/QtConverter&quot;</span><span class="punctuation">,</span>   <span class="comment">//要执行的可执行文件的完整路径</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/../../../../../Src/BinUbuntu/x64/Debug&quot;</span><span class="punctuation">,</span>            <span class="comment">//设置调试器启动的应用程序的工作目录</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line"> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LD_LIBRARY_PATH&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;LD_LIBRARY_PATH&#125;:$&#123;workspaceFolder&#125;/../../../../../Document/QtDemo/Qt5.12.8/Linux/lib;$&#123;LD_LIBRARY_PATH&#125;:$&#123;workspaceFolder&#125;/../../../../../Src/BinUbuntu/x64/Debug&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span>   <span class="comment">//要连接的调试器</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改program和environment中的value后，即可调试</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Nvida的Video_Codec_SDK中参考例程的讲解（二）：搭建AppDecGL的调试环境</title>
      <link href="/2023/01/12/Nvida%E7%9A%84Video_Codec_SDK%E4%B8%AD%E5%8F%82%E8%80%83%E4%BE%8B%E7%A8%8B%E7%9A%84%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%90%AD%E5%BB%BAAppDecGL%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/"/>
      <url>/2023/01/12/Nvida%E7%9A%84Video_Codec_SDK%E4%B8%AD%E5%8F%82%E8%80%83%E4%BE%8B%E7%A8%8B%E7%9A%84%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%90%AD%E5%BB%BAAppDecGL%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>首先我们cd到Samples文件夹中,打算开命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code .</span><br></pre></td></tr></table></figure><p>等待vscode打开后，接着在AppDecGL.cpp文件的110行上打一个断点．</p><h1 id="配置launch-json调试脚本"><a href="#配置launch-json调试脚本" class="headerlink" title="配置launch.json调试脚本"></a>配置launch.json调试脚本</h1><p>接着在VS Code中同时按下Ctrl + Shift + P打开输入”launch.json”。</p><p>如果没有这个选项的话，那就同时按下Ctrl + Shift + D，选择创建一个”launch.json”，点击Web app(Egd)</p><p>接着在launch.json文件中输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) AppDecGL Launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span>   <span class="comment">//正在使用的调试器,使用Visual Studio Windows时必须为cppvsdbg,使用GDB或LLDB时必须为cppdbg.</span></span><br><span class="line">          <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span>  <span class="comment">//表示此配置是用于启动程序还是附加到已运行的实例上</span></span><br><span class="line">          <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/ws/Desktop/Nvida/Video_Codec_SDK_11.1.5/Samples/build_linux/AppDecGL&quot;</span><span class="punctuation">,</span>   <span class="comment">//要执行的可执行文件的完整路径</span></span><br><span class="line">          <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span>            <span class="comment">//设置调试器启动的应用程序的工作目录</span></span><br><span class="line">          <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span>   <span class="comment">//要连接的调试器</span></span><br><span class="line">          <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此时，我们如果直接点击右上角的三角形符号，选择Debug C&#x2F;C++ File，接着在弹出框中选择打开(gdb) AppDecGL Launch的话，会直接运行程序，而我们在cpp文件中打的断点是无法命中的，因为我们之前用cmake编译生成出来的可执行文件是不包含Debug调试信息的．</p><p>为了方便我们调试信息，同时也方便后面对程序进行修改和单独编译，此时我们用两种方法</p><h2 id="方法一：改变Cmake的CMAKE-BUILD-TYPE为Debug"><a href="#方法一：改变Cmake的CMAKE-BUILD-TYPE为Debug" class="headerlink" title="方法一：改变Cmake的CMAKE_BUILD_TYPE为Debug"></a>方法一：改变Cmake的CMAKE_BUILD_TYPE为Debug</h2><p>先把build_linux文件夹清空，<br>接着在命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake .. -DCMAKE_BUILD_TYPE=Debug</span><br><span class="line">make -j 20 #我的电脑是２０核CPU，如果不知道CPU核数的话，可以直接输入make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>此时编译出来的可执行文件就包含着调试信息，我们就可以直接通过launch,json脚本来调试程序了<br><img src="/./picture/Video_Codec_SDK%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2/1.png"></p><h2 id="方法二：需要通过AppDecGL文件夹中的CMakeList-txt文件来配置编译的json脚本"><a href="#方法二：需要通过AppDecGL文件夹中的CMakeList-txt文件来配置编译的json脚本" class="headerlink" title="方法二：需要通过AppDecGL文件夹中的CMakeList.txt文件来配置编译的json脚本"></a>方法二：需要通过AppDecGL文件夹中的CMakeList.txt文件来配置编译的json脚本</h2><p>具体可参考这篇<a href="https://blog.csdn.net/wanzew/article/details/83097457">文章</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++ build active file&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/g++&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-L /usr/local/cuda-11.8/targets/x86_64-linux/lib&quot;</span><span class="punctuation">,</span><span class="string">&quot;-I /usr/local/cuda-11.8/targets/x86_64-linux/include&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Task generated by Debugger.&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/usr/local/cuda-11.8/targets/x86_64-linux/include&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/../Interface&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/NvCodec&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/AppTranscode&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/Utils&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/External&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c11&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gnu++14&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux-gcc-x64&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>注：请安装如下2个VS Code插件：C&#x2F;C++、C&#x2F;C++ Runner</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Nvida的Video_Codec_SDK中参考例程的讲解（一）：编译Sample样例</title>
      <link href="/2023/01/10/Nvida%E7%9A%84Video_Codec_SDK%E4%B8%AD%E5%8F%82%E8%80%83%E4%BE%8B%E7%A8%8B%E7%9A%84%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BC%96%E8%AF%91Sample%E6%A0%B7%E4%BE%8B/"/>
      <url>/2023/01/10/Nvida%E7%9A%84Video_Codec_SDK%E4%B8%AD%E5%8F%82%E8%80%83%E4%BE%8B%E7%A8%8B%E7%9A%84%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BC%96%E8%AF%91Sample%E6%A0%B7%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>现在我们通过Nvida提供的Video_Codec_SDK中的Sample来学习硬件解码编码相关知识</p><h1 id="1-前期准备："><a href="#1-前期准备：" class="headerlink" title="1 前期准备："></a>1 前期准备：</h1><p>先阅读完Nvida的这个<a href="https://docs.nvidia.com/video-technologies/video-codec-sdk/ffmpeg-with-nvidia-gpu/index.html">文档</a></p><p>接着下载FFmpeg以及与Nvidia编解码器API接口所需的FFmpeg版本的标头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone -b release/xx  https://git.ffmpeg.org/ffmpeg.git</span><br><span class="line">git clone -b sdk/xx https://github.com/FFmpeg/nv-codec-headers.git</span><br></pre></td></tr></table></figure><p><a href="https://www.nvidia.com/Download/index.aspx?lang=en-us">下载对应的Nvida驱动程序</a></p><p><a href="https://wujianqiangcode.github.io/Linux%E4%B8%8BNvidia%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4">安装Nvidia驱动教程</a></p><p><a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux&target_arch=x86_64&Distribution=Ubuntu&target_version=20.04">下载CUDA Toolkit</a></p><p><a href="https://developer.nvidia.com/nvidia-video-codec-sdk/download">下载Nvida的Video_Codec_SDK</a></p><p>接着下载CUDA演示样例验证是否成功安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/NVIDIA/cuda-samples.git</span><br></pre></td></tr></table></figure><p>注：如果make后提示找不到glut的话，输入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install libgl1-mesa-dev</span><br><span class="line">sudo apt-get install libglu1-mesa-dev</span><br><span class="line">sudo apt-get install libglut-dev</span><br></pre></td></tr></table></figure><p>出现：E: 无法定位软件包 libglut-dev，执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install freeglut3-dev</span><br></pre></td></tr></table></figure><p>如果成功显示该画面就说明安装成功：<br><img src="/./picture/Video_Codec_SDK%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1/CUDA%E6%BC%94%E7%A4%BA%E6%A0%B7%E4%BE%8B%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5.png"></p><p>接着可以用cmake工具构建一下Video_Codec_SDK里面的Samples，如果能成功构建，那么就代表CUDA Toolkit安装成功了。<br><img src="/./picture/Video_Codec_SDK%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1/%E9%AA%8C%E8%AF%81CUDA%20Toolkit%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png"></p><h1 id="Ubuntu下编译Sample文件夹中的例程"><a href="#Ubuntu下编译Sample文件夹中的例程" class="headerlink" title="Ubuntu下编译Sample文件夹中的例程"></a>Ubuntu下编译Sample文件夹中的例程</h1><h2 id="设置FFmpeg库路径"><a href="#设置FFmpeg库路径" class="headerlink" title="设置FFmpeg库路径"></a>设置FFmpeg库路径</h2><p>首先进入Sample文件夹中，打开CMakeList.txt文件，可以看出文档中有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(NV_FFMPEG_HDRS $&#123;PC_AVCODEC_INCLUDE_DIRS&#125;)</span><br></pre></td></tr></table></figure><p>因此，如果你已经安装完成ffmpeg的话，我们就可以直接指定一下FFmpeg所在的目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PKG_CONFIG_PATH=/usr/local/ffmpeg/lib/pkgconfig</span><br></pre></td></tr></table></figure><h2 id="安装vulkan"><a href="#安装vulkan" class="headerlink" title="安装vulkan"></a>安装vulkan</h2><p>命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa</span><br><span class="line">sudo apt upgrade</span><br><span class="line"> </span><br><span class="line">sudo apt-get install vulkan-tools vulkan-utils libvulkan1 libvulkan-dev  #如果装不下来就一直装，会慢慢装成功的</span><br><span class="line"> </span><br><span class="line">sudo add-apt-repository -r ppa:graphics-drivers/ppa   #最后移除这个新加的repository</span><br></pre></td></tr></table></figure><h2 id="安装GL相关的库"><a href="#安装GL相关的库" class="headerlink" title="安装GL相关的库"></a>安装GL相关的库</h2><p>命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libgl1-mesa-dev libglu1-mesa-dev freeglut3-dev</span><br><span class="line"> </span><br><span class="line">sudo apt-cache search glew  #先用这行查看libglew的可用版本，下面的libglew2.0改成你的可用版本</span><br><span class="line">sudo apt-get install libglew2.0 libglew-dev</span><br></pre></td></tr></table></figure><h2 id="Sample的编译与验证"><a href="#Sample的编译与验证" class="headerlink" title="Sample的编译与验证"></a>Sample的编译与验证</h2><p>随后进入AppDecGL文件夹，打开AppDecGL.cpp，跳到110行，将main()的szInFilePath的值为你的某一个视频文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> szInFilePath[<span class="number">256</span>] = <span class="string">&quot;/home/ws/Videos/1.mp4&quot;</span>;</span><br></pre></td></tr></table></figure><p>接着回到Sample文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd ./Video_Codec_SDK_10.0.26/Samples</span><br><span class="line">mkdir build</span><br><span class="line">cd build/</span><br><span class="line">cmake ..</span><br><span class="line">make -j 20 #我的电脑是２０核CPU，如果不知道CPU核数的话，可以直接输入make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>接着运行例程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./AppDecGL</span><br></pre></td></tr></table></figure><p>此时将会显示视频画面窗口，同时命令行窗口也会显示以下信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GPU in use: NVIDIA GeForce RTX 3060 Ti</span><br><span class="line">Decode with NvDecoder.</span><br><span class="line">[INFO ][15:46:13] Media format: QuickTime / MOV (mov,mp4,m4a,3gp,3g2,mj2)</span><br><span class="line">Session Initialization Time: 33 ms </span><br><span class="line">[INFO ][15:46:13] Video Input Information</span><br><span class="line">Codec        : AVC/H.264</span><br><span class="line">Frame rate   : 30/1 = 30 fps</span><br><span class="line">Sequence     : Progressive</span><br><span class="line">Coded size   : [3840, 2160]</span><br><span class="line">Display area : [0, 0, 3840, 2160]</span><br><span class="line">Chroma       : YUV 420</span><br><span class="line">Bit depth    : 8</span><br><span class="line">Video Decoding Params:</span><br><span class="line">Num Surfaces : 4</span><br><span class="line">Crop         : [0, 0, 0, 0]</span><br><span class="line">Resize       : 3840x2160</span><br><span class="line">Deinterlace  : Weave</span><br><span class="line"></span><br><span class="line">Total frame decoded: 6635</span><br><span class="line">XIO:  fatal IO error 17 (File exists) on X server &quot;:1&quot;</span><br><span class="line">      after 77 requests (77 known processed) with 0 events remaining.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>后续章节我们将通过讲解Nvida的Video_Codec_SDK中的Sample来学习硬件解码编码的相关知识点</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CodeBloks相关编译选项详解</title>
      <link href="/2023/01/09/CodeBloks%E7%9B%B8%E5%85%B3%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/01/09/CodeBloks%E7%9B%B8%E5%85%B3%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>gcc 与 g++ 分别是 gnu 的 c &amp; c++ 编译器</p><p>gcc&#x2F;g++ 在执行编译工作的时候，总共需要4步：</p><ul><li>预处理,生成 .i 的文件[预处理器cpp]</li><li>将预处理后的文件转换成汇编语言, 生成文件 .s [编译器egcs]</li><li>有汇编变为目标代码(机器代码)生成 .o 的文件[汇编器as]</li><li>连接目标代码, 生成可执行程序 [链接器ld]</li></ul><p>以下是在CodeBloks中使用到频率比较高的编译选项</p><h3 id="“-s”"><a href="#“-s”" class="headerlink" title="“-s”"></a>“-s”</h3><p>只激活预处理和编译，就是指把文件编译成为汇编代码。</p><h3 id="“-g”"><a href="#“-g”" class="headerlink" title="“-g”"></a>“-g”</h3><p>只是编译器，在编译的时候，产生调试信息。</p><h3 id="O0-、-O1-、-O2-、-O3"><a href="#O0-、-O1-、-O2-、-O3" class="headerlink" title="-O0 、-O1 、-O2 、-O3"></a>-O0 、-O1 、-O2 、-O3</h3><p>编译器的优化选项的 4 个级别，-O0 表示没有优化, -O1 为默认值，-O3 优化级别最高。</p><h3 id="Wl-options"><a href="#Wl-options" class="headerlink" title="-Wl,options"></a>-Wl,options</h3><p>我们通过gcc间接使用链接器时，需要在链接器的编译选项前面加上-Wl,，然后跟着编译选项，即标题中的options</p><p>格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wl,param1,param2,param3,...</span><br></pre></td></tr></table></figure><p>在调用ld命令时，会等效于如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld param1 param2 param3 </span><br></pre></td></tr></table></figure><p>注意：-Wl, 后的逗号（，）必不可少，如果要传递多个参数，参数间用，分隔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Wl,-Bstatic</span><br></pre></td></tr></table></figure><p>指定后续ld在处理 -l 参数来链接库文件的链接方式首选静态库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Wl,-Bdynamic</span><br></pre></td></tr></table></figure><p>指定后续ld在处理 -l 参数来链接库文件的链接方式首选动态库</p><p>例如： -Wl,-Bstatic -la -lb -lc -Wl,-Bdynamic -ld -l e</p><p>会被解释成 ：ld liba.a libb.a libc.a libd.so libe.so</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Wl,-rpath=dir</span><br></pre></td></tr></table></figure><p>在编译链接时，链接器会在dir目录下搜索动态库。同时，把动态库搜索路径dir添加到可执行文件中，以便可执行文件加载运行时使用。</p><p><font color =red>要注意该选项与-L选项的区别，-L选项用于编译链接时添加库文件的搜索路径；而该选项仅限于动态库，并且既可以在编译链接时添加搜索路径，同时也能将搜索路径添加到可执行文件中。</font><br>在GCC编译程序时，由于GCC命令不经能够编译，也能够链接程序，GCC链接程序是通过ld命令实现的，如何将GCC的命令行参数传递给ld命令呢，这就是通过-Wl,来实现的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Wl,-rpath -Wl,/data/workroom/libs/lib</span><br></pre></td></tr></table></figure><p>会被解释成：ld -rpath &#x2F;data&#x2F;workroom&#x2F;libs&#x2F;lib1、介绍<br>-Wl后面的东西是作为参数传递给链接器ld的。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wl,aaa,bbb,ccc</span><br></pre></td></tr></table></figure><p>最后会被解释为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld aaa bbb ccc</span><br></pre></td></tr></table></figure><p>2、-Wl,-Map&#x3D;xxx.txt 生成map文件<br>如下会生成map文件mymap.txt。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wl,-Map=mymap.txt -g main.c -o main</span><br></pre></td></tr></table></figure><p>3、 -Wl,-Bstatic 和 -Wl,-Bdynamic 指定链接动态库或者静态库<br>-Wl,-Bstatic -laaa -lbbb -lccc -Wl,-Bdynamic -lddd -l ccc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Wl,-Bstatic 后面的库是静态链接的;</span><br><span class="line"></span><br><span class="line">-Wl,-Bdynamic 后面的都是动态链接的。</span><br></pre></td></tr></table></figure><p>4、 -Wl,–as-needed和 -Wl,–no-as-needed<br>在生成可执行文件的时候，通过 -lxxx 选项指定需要链接的库文件,连接器会在可执行文件的文件头中会记录下该库的信息。<br>在可执行文件运行的时候，动态加载器会读取文件头信息，并加载所有的链接库。</p><p>在这个过程中，如果用户指定链接了一个毫不相关的库，则这个库在最终的可执行程序运行时也会被加载，如果类似这样的不相关库很多，会明显拖慢程序启动过程。</p><p>通过指定 -Wl,–as-needed 选项，链接过程中，链接器会检查所有的依赖库，没有实际被引用的库，不再写入可执行文件头。最终生成的可执行文件头中包含的都是必要的链接库信息。<br>-Wl,–no-as-needed 选项不会做这样的检查，会把用户指定的链接库完全写入可执行文件中。</p><h3 id="“-Wl-Bsymbolic”"><a href="#“-Wl-Bsymbolic”" class="headerlink" title="“-Wl,-Bsymbolic”"></a>“-Wl,-Bsymbolic”</h3><p>其中Wl表示将紧跟其后的参数，传递给连接器ld。Bsymbolic表示强制采用本地的全局变量定义，这样就不会出现动态链接库的全局变量定义被应用程序&#x2F;动态链接库中的同名定义给覆盖了！</p><h3 id="“–unresolved-symbols-x3D-report-all”"><a href="#“–unresolved-symbols-x3D-report-all”" class="headerlink" title="“–unresolved-symbols&#x3D;report-all”"></a>“–unresolved-symbols&#x3D;report-all”</h3><p>报告全部未解析的符号</p><h3 id="fPIC"><a href="#fPIC" class="headerlink" title="-fPIC"></a>-fPIC</h3><p>用于编译阶段，告诉编译器产生与位置无关代码(Position-Independent Code)，则产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC -o 1.so 1.c</span><br></pre></td></tr></table></figure><p>这里有一个-fPIC参数</p><p>PIC就是position independent code</p><p>PIC使.so文件的代码段变为真正意义上的共享</p><p>如果不加-fPIC,则加载.so文件的代码段时,代码段引用的数据对象需要重定位, 重定位会修改代码段的内容,这就造成每个使用这个.so文件代码段的进程在内核里都会生成这个.so文件代码段的copy.每个copy都不一样,取决于这个.so文件代码段和数据段内存映射的位置.</p><p>不加fPIC编译出来的so,是要再加载时根据加载到的位置再次重定位的.(因为它里面的代码并不是位置无关代码)<br>如果被多个应用程序共同使用,那么它们必须每个程序维护一份so的代码副本了.(因为so被每个程序加载的位置都不同,显然这些重定位后的代码也不同,当然不能共享)<br>我们总是用fPIC来生成so,也从来不用fPIC来生成a.<br>fPIC与动态链接可以说基本没有关系,libc.so一样可以不用fPIC编译,只是这样的so必须要在加载到用户程序的地址空间时重定向所有表目.</p><p>因此,不用fPIC编译so并不总是不好.<br>如果你满足以下4个需求&#x2F;条件:<br>1.该库可能需要经常更新<br>2.该库需要非常高的效率(尤其是有很多全局量的使用时)<br>3.该库并不很大.<br>4.该库基本不需要被多个应用程序共享</p><p>如果用没有加这个参数的编译后的共享库，也可以使用的话，可能是两个原因：<br>1：gcc默认开启-fPIC选项<br>2：loader使你的代码位置无关</p><h3 id="GCC的符号可见性-“-fvisibility-x3D-hidden”"><a href="#GCC的符号可见性-“-fvisibility-x3D-hidden”" class="headerlink" title="GCC的符号可见性 “-fvisibility&#x3D;hidden”"></a>GCC的符号可见性 “-fvisibility&#x3D;hidden”</h3><p>该符号为了解决的问题：<br>    主程序依赖的库中的函数中，函数内封装的子函数中存在同名的现象<br>例如：<br>主程序依赖了两个库Lib_A的Func_A函数和Lib_B的Func_B函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Func_A</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Func_B</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, <span class="built_in">Func_A</span>(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Func_B</span>(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lib_A库中Func_A的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Func_A</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sub</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lib_B库中Fun_B的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Func_B</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sub</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序段中，Func_A调用了Lib_A中的内部函数sub，Func_B调用了Lib_B中的内部函数sub，这两个sub实现不同，但名字不小心是一样的。<br>进行编译后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g++ -fPIC Lib_A.cpp -shared -o Lib_A.so</span><br><span class="line">g++ -fPIC Lib_B.cpp -shared -o Lib_B.so</span><br><span class="line"></span><br><span class="line">g++ main.cpp libA.so libB.so -o main</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH=../main</span><br></pre></td></tr></table></figure><p>我们期望的结果是3,1（Func_A和Func_B各自调用不同的sub实现），<br>实际得到的结果是3,3（Func_A和Func_B都调用了LibA中的sub实现）</p><p>通过readelf来查看符号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -a Lib_A.so | grep sub</span><br><span class="line">000000200a60  000200000007 R_X86_64_JUMP_SLO 0000000000000708 _Z7subii + 0</span><br><span class="line">     2: 0000000000000708    20 FUNC    GLOBAL DEFAULT   10 _Z7subii</span><br><span class="line">    45: 0000000000000708    20 FUNC    GLOBAL DEFAULT   10 _Z7subii</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -a Lib_B.so | grep sub </span><br><span class="line">000000200a60  000200000007 R_X86_64_JUMP_SLO 0000000000000708 _Z7subii + 0</span><br><span class="line">     2: 0000000000000708    22 FUNC    GLOBAL DEFAULT   10 _Z7subii</span><br><span class="line">    45: 0000000000000708    22 FUNC    GLOBAL DEFAULT   10 _Z7subii</span><br></pre></td></tr></table></figure><p>Lib_A和Lib_B里面都有sub符号，名字完全一样，而且都是GLOBAL的；GLOBAL的符号即全局的符号，同名的全局符号会被认为是同一个符号，由于main先加载了Lib_A，得到了Lib_A中的sub符号，再加载Lib_B时，就把Lib_B中的sub忽略了.</p><p>解决方案:这其实是符号的可见性（Symbol Visibility）问题，既然有GLOBAL符号，那自然会有LOCAL符号，LOCAL的符号只在当前Lib可见，全局不可见。</p><p>如何将符号变成LOCAL的呢，最直接的就是加上visibility为hidden的标志，修改后的Lib_A.cpp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__attribute__ ((<span class="built_in">visibility</span> (<span class="string">&quot;hidden&quot;</span>))) <span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Func_A</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sub</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时sub符号已经变成了LOCAL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -a Lib_A.so | grep sub</span><br><span class="line">    40: 00000000000006a8    20 FUNC    LOCAL  DEFAULT   10 _Z7subii</span><br></pre></td></tr></table></figure><p>上面的方法可以解决问题，但是，实际情况往往是，Lib_A里面有很多的内部函数，而暴露给外部的只有少数，能不能指定少数符号为GLOBAL，其它的都是LOCAL呢？答案是肯定的，修改Lib_A.cpp如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__ ((<span class="built_in">visibility</span> (<span class="string">&quot;default&quot;</span>))) <span class="function"><span class="type">int</span> <span class="title">Func_A</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sub</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，Lib_A的编译参数需要加上-fvisibility&#x3D;hidden：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -fPIC Lib_A.cpp -shared -fvisibility=hidden -o Lib_A.so</span><br></pre></td></tr></table></figure><h3 id="“-static”"><a href="#“-static”" class="headerlink" title="“-static”"></a>“-static”</h3><p>此选项将禁止使用动态库，所以，编译出来的东西，一般都很大，也不需要什么动态连接库，就可以运行。gcc 加上 -static，会在链接阶段, 查找对应模块的静态库, 而非动态库, 并把需要的东西，都带进目标文件），编译好后，文件会非常大，但是，运行时就不需要依赖任何动态库。此选项的不同变体是为了与各种系统兼容。您可以在命令行上多次使用此选项：它会影响库搜索后面的-l选项。此选项还意味着–unresolved-symbols &#x3D; report-all。此选项可与-shared一起使用。这样做意味着正在创建共享库，但必须通过从静态库中提取条目来解析所有库的外部引用。</p><h3 id="“-share”"><a href="#“-share”" class="headerlink" title="“-share”"></a>“-share”</h3><p>此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库。</p><p>深析静态链接库和动态链接库相同函数覆盖及库调用顺序问题:<a href="http://blog.chinaunix.net/uid-26548237-id-3837099.html">http://blog.chinaunix.net/uid-26548237-id-3837099.html</a></p><p>记录一下编译x264第三方库时，出现以下报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unrecognized command-line option ‘--unresolved-symbols=report-all’</span><br></pre></td></tr></table></figure><p>原因是必须在–unresolved-symbols&#x3D;report-all加上-wl,</p><p><img src="/./picture/11.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下的Nvidia驱动的安装步骤</title>
      <link href="/2023/01/05/Linux%E4%B8%8BNvidia%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/"/>
      <url>/2023/01/05/Linux%E4%B8%8BNvidia%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>安装对应的必备软件和依赖</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update  </span><br><span class="line">sudo apt-get install g++</span><br><span class="line">sudo apt-get install gcc</span><br><span class="line">sudo apt-get install make</span><br></pre></td></tr></table></figure><h1 id="查看GPU型号"><a href="#查看GPU型号" class="headerlink" title="查看GPU型号"></a>查看GPU型号</h1><p>接着查看一下GPU型号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci | grep -i vga</span><br></pre></td></tr></table></figure><p>返回结果如下：</p><p><font color = yellow>ws@wujianqiang-ubuntu-18</font>:~$ lspci | grep -i vga</p><p>65:00.0 <font color = red>VGA</font> compatible controller: NVIDIA Corporation Device 2489 (rev a1)</p><p><font color = yellow>ws@wujianqiang-ubuntu-18</font>:~$ </p><p>通过序列号在<a href="https://devicehunt.com/view/type/pci/vendor/10DE/device/2489">该网站</a>上查看显卡型号</p><h1 id="官网下载驱动"><a href="#官网下载驱动" class="headerlink" title="官网下载驱动"></a>官网下载驱动</h1><p>接着我们去<a href="https://www.nvidia.com/Download/index.aspx?lang=en-us">Nvida官网</a>下载对应驱动</p><h1 id="卸载原有的驱动"><a href="#卸载原有的驱动" class="headerlink" title="卸载原有的驱动"></a>卸载原有的驱动</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove --purge nvidia*</span><br></pre></td></tr></table></figure><h1 id="禁用nouveau"><a href="#禁用nouveau" class="headerlink" title="禁用nouveau"></a>禁用nouveau</h1><p>nouveau是通用驱动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/modprobe.d/blacklist.conf </span><br></pre></td></tr></table></figure><p>接着在打开的文集尾部加上这两句话</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset=0</span><br></pre></td></tr></table></figure><p>然后输入该命令进行更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-initramfs –u</span><br></pre></td></tr></table></figure><p>最后重启电脑后输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep nouveau</span><br></pre></td></tr></table></figure><p>如果没有显示任何输出，则证明屏蔽成功</p><h1 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h1><p>输入以下命令，停止当前显示服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo telinit 3</span><br></pre></td></tr></table></figure><p>等待界面黑屏后，按下Ctrl+Alt+F1，等待弹出login，然后输入对应帐号密码（帐号是root，密码就是您登录ubuntu的密码）<br><font color =red>注：在该界面下进行输入时，键盘右侧的数字键盘处于无法使用的状态</font></p><p>登录成功后，接着输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -a</span><br><span class="line">sudo /home/ws/...... #进入到你下载的驱动的对应位置</span><br><span class="line">sudo chmod 777 NVIDIA-Linux-x86_64-515.76.run #给该驱动文集授权</span><br></pre></td></tr></table></figure><p>接着，如果是台式机的话输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./NVIDIA-Linux-x86_64-515.76.run </span><br></pre></td></tr></table></figure><p>如果是笔记本的话输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./NVIDIA-Linux-x86_64-515.76.run （–no-opengl-files）</span><br></pre></td></tr></table></figure><p><font color =red>注：笔记本一定要加上–no-opengl-files，否则会出现循环登录现象，也就是loop login</font></p><h1 id="安装过程中的选项"><a href="#安装过程中的选项" class="headerlink" title="安装过程中的选项"></a>安装过程中的选项</h1><p>1.The distribution-provided pre-install script failed! Are you sure you want to continue?<br>选择continue installation</p><p>2.Would you like to register the kernel module souces with DKMS? This will allow DKMS to automatically build a new module, if you install a different kernel later?<br>选择 No </p><p>3.问题没记住，选项是：install without signing</p><p>4.问题大概是：Nvidia’s 32-bit compatibility libraries? 选择 No 继续。</p><p>5.Would you like to run the nvidia-xconfigutility to automatically update your x configuration so that the NVIDIA x driver will be used when you restart x? Any pre-existing x confile will be backed up.<br>选择 Yes </p><p>安装成功后重启电脑，接着命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>出现以下界面则表示安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Tue Oct 25 14:19:45 2022       </span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 515.76       Driver Version: 515.76       CUDA Version: 11.7     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                               |                      |               MIG M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  NVIDIA GeForce ...  Off  | 00000000:65:00.0  On |                  N/A |</span><br><span class="line">|  0%   43C    P8    11W / 200W |    600MiB /  8192MiB |      0%      Default |</span><br><span class="line">|                               |                      |                  N/A |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">                                                                               </span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                                  |</span><br><span class="line">|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |</span><br><span class="line">|        ID   ID                                                   Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">|    0   N/A  N/A      1258      G   /usr/lib/xorg/Xorg                 24MiB |</span><br><span class="line">|    0   N/A  N/A      1308      G   /usr/bin/gnome-shell               82MiB |</span><br><span class="line">|    0   N/A  N/A      1579      G   /usr/lib/xorg/Xorg                317MiB |</span><br><span class="line">|    0   N/A  N/A      1712      G   /usr/bin/gnome-shell               68MiB |</span><br><span class="line">|    0   N/A  N/A      2061      G   ...AAAAAAAAA= --shared-files       20MiB |</span><br><span class="line">|    0   N/A  N/A      4948      G   ...RendererForSitePerProcess       72MiB |</span><br><span class="line">|    0   N/A  N/A      6319      G   ...264068829843617026,131072       10MiB |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何通过FFmpeg抽取音频数据</title>
      <link href="/2022/11/25/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87FFmpeg%E6%8A%BD%E5%8F%96%E9%9F%B3%E9%A2%91%E6%95%B0%E6%8D%AE/"/>
      <url>/2022/11/25/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87FFmpeg%E6%8A%BD%E5%8F%96%E9%9F%B3%E9%A2%91%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>抽取音频主要有以下几个步骤：</p><ul><li>参数的初始化</li><li>打开多媒体文件</li><li>从多媒体文件中找到音频流</li><li>打开目的文件到上下文</li><li>为目的文件创建一个新的音频流</li><li>设置输出音频参数</li><li>写多媒体文件头到目的文件</li><li>从多媒体文件中读出音频数据到目的文件中</li><li>写多媒体文件尾到文件中</li><li>将申请的资源释放掉</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/avutil.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.处理一些参数</span></span><br><span class="line">    <span class="type">char</span>* src;</span><br><span class="line">    <span class="type">char</span>* dst;</span><br><span class="line"></span><br><span class="line">    AVFormatContext *pFmtCtx = <span class="literal">NULL</span>;</span><br><span class="line">    AVFormatContext *oFmtCtx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    AVOutputFormat *outFmt = <span class="literal">NULL</span>;</span><br><span class="line">    AVStream *outStream = <span class="literal">NULL</span>;</span><br><span class="line">    AVStream *inStream = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    AVPacket pkt;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_log_set_level</span>(AV_LOG_DEBUG);</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;<span class="number">3</span>)&#123;<span class="comment">//argv[0]:extra_audio;argv[1]:源数据；argv[2]:目的数据；</span></span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">&quot;arguments must be more than 3&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    src = argv[<span class="number">1</span>];</span><br><span class="line">    dst = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.打开多媒体文件</span></span><br><span class="line">    ret = <span class="built_in">avformat_open_input</span>(&amp;pFmtCtx,src,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;%s\n&quot;</span>,<span class="built_in">av_err2str</span>(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.从多媒体文件中找到音频流</span></span><br><span class="line">    idx = <span class="built_in">av_find_best_stream</span>(pFmtCtx, AVMEDIA_TYPE_AUDIO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(idx &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">av_log</span>(pFmtCtx, AV_LOG_ERROR, <span class="string">&quot;Does not include audio&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> _ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.打开目的文件到上下文</span></span><br><span class="line">    oFmtCtx = <span class="built_in">avformat_alloc_context</span>();</span><br><span class="line">    <span class="keyword">if</span>(!oFmtCtx)&#123;</span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;NO Memory!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> _ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    outFmt = <span class="built_in">av_guess_format</span>(<span class="literal">NULL</span>, dst, <span class="literal">NULL</span>);</span><br><span class="line">    oFmtCtx-&gt;oformat =outFmt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.为目的文件创建一个新的音频流</span></span><br><span class="line">    outStream = <span class="built_in">avformat_new_stream</span>(oFmtCtx, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.设置输出音频参数</span></span><br><span class="line">    inStream = pFmtCtx-&gt;streams[idx];</span><br><span class="line">    <span class="built_in">avcodec_parameters_copy</span>(outStream-&gt;codecpar, inStream-&gt;codecpar);</span><br><span class="line">    outStream-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;<span class="comment">//设置为0的话，会自动适配合适的编解码器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    ret = <span class="built_in">avio_open2</span>(&amp;oFmtCtx-&gt;pb, dst, AVIO_FLAG_WRITE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">av_log</span>(oFmtCtx, AV_LOG_ERROR, <span class="string">&quot;%s&quot;</span>, <span class="built_in">av_err2str</span>(ret));</span><br><span class="line">        <span class="keyword">goto</span> _ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.写多媒体文件头到目的文件</span></span><br><span class="line">    ret = <span class="built_in">avformat_write_header</span>(oFmtCtx, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">av_log</span>(oFmtCtx, AV_LOG_ERROR, <span class="string">&quot;%s&quot;</span>, <span class="built_in">av_err2str</span>(ret));</span><br><span class="line">        <span class="keyword">goto</span> _ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//8.从多媒体文件中读出音频数据到目的文件中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">av_read_frame</span>(pFmtCtx, &amp;pkt)  &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pkt.stream_index == idx)&#123;<span class="comment">//判断是否是要读取的音频帧</span></span><br><span class="line">            pkt.pts = <span class="built_in">av_rescale_q_rnd</span>(pkt.pts, inStream-&gt;time_base, outStream-&gt;time_base, (AV_ROUND_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">            pkt.dts = pkt.pts;<span class="comment">//音频的dts和pts是相同的</span></span><br><span class="line">            pkt.duration = <span class="built_in">av_rescale_q</span>(pkt.duration, inStream-&gt;time_base, outStream-&gt;time_base);</span><br><span class="line">            pkt.stream_index = <span class="number">0</span>;</span><br><span class="line">            pkt.pos = <span class="number">-1</span>;<span class="comment">//设置为-1时，则会自动计算</span></span><br><span class="line">            <span class="built_in">av_interleaved_write_frame</span>(oFmtCtx, &amp;pkt);</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(&amp;pkt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//9.写多媒体文件尾到文件中</span></span><br><span class="line">    <span class="built_in">av_write_trailer</span>(oFmtCtx);</span><br><span class="line">    <span class="comment">//10.将申请的资源释放掉</span></span><br><span class="line"></span><br><span class="line">_ERROR:</span><br><span class="line">    <span class="keyword">if</span>(pFmtCtx)&#123;</span><br><span class="line">        <span class="built_in">avformat_close_input</span>(&amp;pFmtCtx);</span><br><span class="line">        pFmtCtx = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(oFmtCtx-&gt;pb)&#123;</span><br><span class="line">        <span class="built_in">avio_close</span>(oFmtCtx-&gt;pb);<span class="comment">//关闭目标文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(oFmtCtx)&#123;</span><br><span class="line">        <span class="built_in">avformat_free_context</span>(oFmtCtx);</span><br><span class="line">        oFmtCtx = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello ffmpeg&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将代码文件保存成extra_audio.c文件，并在当前路径下建立一个build.sh文件，打开该文件后，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">clang -g -o extra_audio extra_audio.c `pkg-config --libs --cflags libavutil libavformat libavcodec`</span><br></pre></td></tr></table></figure><p>保存退出后，在当前路径下打开命令行窗口，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build.sh</span><br></pre></td></tr></table></figure><p>如果没有报错信息出现，那么就证明我们完成了该文件的编译工作，接着就能在当前路径上看到我们生成的extra_audio可执行程序文件和extra_audio.dSYM这个具备调试信息的目标文件。</p><p>接着我们找个具备音频信息的文件来进行演示，我们可以先用ffplay播放一下这个文件，以下是我这边通过ffplay播放该文件时，命令行窗口输出的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input #0, mov,mp4,m4a,3gp,3g2,mj2, from &#x27;1.mp4&#x27;:</span><br><span class="line">  Metadata:</span><br><span class="line">    major_brand     : isom</span><br><span class="line">    minor_version   : 512</span><br><span class="line">    compatible_brands: isomiso2avc1mp41</span><br><span class="line">    comment         : vid:v0200fg10000cbuq3hjc77ua8dieuid0</span><br><span class="line">    encoder         : Lavf58.45.100</span><br><span class="line">  Duration: 00:00:35.32, start: 0.000000, bitrate: 2348 kb/s</span><br><span class="line">    Stream #0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(tv, bt709), 720x1280 [SAR 1:1 DAR 9:16], 2217 kb/s, 29.83 fps, 30 tbr, 15360 tbn, 60 tbc (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      handler_name    : VideoHandler</span><br><span class="line">    Stream #0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 128 kb/s (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      handler_name    : SoundHandler</span><br><span class="line">   7.79 A-V: -0.024 fd=   6 aq=   23KB vq=  247KB sq=    0B f=0/0   </span><br></pre></td></tr></table></figure><p>可以看到该文件一共有两路流。<br>一路上视频流（h264）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream #0:0(und): Video: h264 (High)</span><br></pre></td></tr></table></figure><p>一路是音频流(aac)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream #0:1(und): Audio: aac (LC)</span><br></pre></td></tr></table></figure><p>此时我们在命令行窗口输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code .</span><br></pre></td></tr></table></figure><p>打开vscode后，在lauch.json文件中输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(lldb) 启动&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;/Users/wujianqiang/Desktop/1.mp4&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;1.aac&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我们要抽取的1.mp4放在&#x2F;Users&#x2F;wujianqiang&#x2F;Desktop路径下，而抽取后生成的文件起名为1.aac</p><p>设置好后，我们启动程序，此时就可以进行代码的调试了。<br><img src="/./picture/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87FFmpeg%E6%8A%BD%E5%8F%96%E9%9F%B3%E9%A2%91%E6%95%B0%E6%8D%AE/1.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何通过FFmpeg抽取视频数据</title>
      <link href="/2022/11/25/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87FFmpeg%E6%8A%BD%E5%8F%96%E8%A7%86%E9%A2%91%E6%95%B0%E6%8D%AE/"/>
      <url>/2022/11/25/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87FFmpeg%E6%8A%BD%E5%8F%96%E8%A7%86%E9%A2%91%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>FFmpeg抽取视频数据的具体步骤其实和上一篇文章讲的FFmpeg抽取音频数据的步骤差不多。程序中唯二两个需要修改的地方是：</p><ul><li>av_find_best_stream函数中的输入参数AVMEDIA_TYPE_AUDIO需要修改成AVMEDIA_TYPE_VIDEO</li><li>视频的pkt.dts不能直接与pkt.pts直接相等（因为视频中可能存在B帧），需要跟pkt.pts一样通过av_rescale_q_rnd函数进行转换</li></ul><p>抽取视频主要有以下几个步骤：</p><ul><li>参数的初始化</li><li>打开多媒体文件</li><li>从多媒体文件中找到视频流</li><li>打开目的文件到上下文</li><li>为目的文件创建一个新的视频流</li><li>设置输出视频参数</li><li>写多媒体文件头到目的文件</li><li>从多媒体文件中读出视频数据到目的文件中</li><li>写多媒体文件尾到文件中</li><li>将申请的资源释放掉</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/avutil.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.处理一些参数</span></span><br><span class="line">    <span class="type">char</span>* src;</span><br><span class="line">    <span class="type">char</span>* dst;</span><br><span class="line"></span><br><span class="line">    AVFormatContext *pFmtCtx = <span class="literal">NULL</span>;</span><br><span class="line">    AVFormatContext *oFmtCtx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    AVOutputFormat *outFmt = <span class="literal">NULL</span>;</span><br><span class="line">    AVStream *outStream = <span class="literal">NULL</span>;</span><br><span class="line">    AVStream *inStream = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    AVPacket pkt;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_log_set_level</span>(AV_LOG_DEBUG);</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;<span class="number">3</span>)&#123;<span class="comment">//argv[0]:extra_video;argv[1]:源数据；argv[2]:目的数据；</span></span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">&quot;arguments must be more than 3&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    src = argv[<span class="number">1</span>];</span><br><span class="line">    dst = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.打开多媒体文件</span></span><br><span class="line">    ret = <span class="built_in">avformat_open_input</span>(&amp;pFmtCtx,src,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;%s\n&quot;</span>,<span class="built_in">av_err2str</span>(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.从多媒体文件中找到视频流</span></span><br><span class="line">    idx = <span class="built_in">av_find_best_stream</span>(pFmtCtx, AVMEDIA_TYPE_VIDEO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(idx &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">av_log</span>(pFmtCtx, AV_LOG_ERROR, <span class="string">&quot;Does not include video&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> _ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.打开目的文件到上下文</span></span><br><span class="line">    oFmtCtx = <span class="built_in">avformat_alloc_context</span>();</span><br><span class="line">    <span class="keyword">if</span>(!oFmtCtx)&#123;</span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;NO Memory!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> _ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    outFmt = <span class="built_in">av_guess_format</span>(<span class="literal">NULL</span>, dst, <span class="literal">NULL</span>);</span><br><span class="line">    oFmtCtx-&gt;oformat =outFmt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.为目的文件创建一个新的视频流</span></span><br><span class="line">    outStream = <span class="built_in">avformat_new_stream</span>(oFmtCtx, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.设置输出视频参数</span></span><br><span class="line">    inStream = pFmtCtx-&gt;streams[idx];</span><br><span class="line">    <span class="built_in">avcodec_parameters_copy</span>(outStream-&gt;codecpar, inStream-&gt;codecpar);</span><br><span class="line">    outStream-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;<span class="comment">//设置为0的话，会自动适配合适的编解码器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    ret = <span class="built_in">avio_open2</span>(&amp;oFmtCtx-&gt;pb, dst, AVIO_FLAG_WRITE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">av_log</span>(oFmtCtx, AV_LOG_ERROR, <span class="string">&quot;%s&quot;</span>, <span class="built_in">av_err2str</span>(ret));</span><br><span class="line">        <span class="keyword">goto</span> _ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.写多媒体文件头到目的文件</span></span><br><span class="line">    ret = <span class="built_in">avformat_write_header</span>(oFmtCtx, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">av_log</span>(oFmtCtx, AV_LOG_ERROR, <span class="string">&quot;%s&quot;</span>, <span class="built_in">av_err2str</span>(ret));</span><br><span class="line">        <span class="keyword">goto</span> _ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//8.从多媒体文件中读出视频数据到目的文件中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">av_read_frame</span>(pFmtCtx, &amp;pkt)  &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pkt.stream_index == idx)&#123;<span class="comment">//判断是否是要读取的音频帧</span></span><br><span class="line">            pkt.pts = <span class="built_in">av_rescale_q_rnd</span>(pkt.pts, inStream-&gt;time_base, outStream-&gt;time_base, (AV_ROUND_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">            pkt.dts = <span class="built_in">av_rescale_q_rnd</span>(pkt.dts, inStream-&gt;time_base, outStream-&gt;time_base, (AV_ROUND_INF | AV_ROUND_PASS_MINMAX));<span class="comment">//视频的dts和pts可能是不同的</span></span><br><span class="line">            pkt.duration = <span class="built_in">av_rescale_q</span>(pkt.duration, inStream-&gt;time_base, outStream-&gt;time_base);</span><br><span class="line">            pkt.stream_index = <span class="number">0</span>;</span><br><span class="line">            pkt.pos = <span class="number">-1</span>;<span class="comment">//设置为-1时，则会自动计算</span></span><br><span class="line">            <span class="built_in">av_interleaved_write_frame</span>(oFmtCtx, &amp;pkt);</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(&amp;pkt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//9.写多媒体文件尾到文件中</span></span><br><span class="line">    <span class="built_in">av_write_trailer</span>(oFmtCtx);</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//10.将申请的资源释放掉</span></span><br><span class="line">_ERROR:</span><br><span class="line">    <span class="keyword">if</span>(pFmtCtx)&#123;</span><br><span class="line">        <span class="built_in">avformat_close_input</span>(&amp;pFmtCtx);</span><br><span class="line">        pFmtCtx = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(oFmtCtx-&gt;pb)&#123;</span><br><span class="line">        <span class="built_in">avio_close</span>(oFmtCtx-&gt;pb);<span class="comment">//关闭目标文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(oFmtCtx)&#123;</span><br><span class="line">        <span class="built_in">avformat_free_context</span>(oFmtCtx);</span><br><span class="line">        oFmtCtx = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello ffmpeg&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将代码文件保存成extra_audio.c文件，并在当前路径下建立一个build.sh文件，打开该文件后，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">clang -g -o extra_video extra_video.c `pkg-config --libs --cflags libavutil libavformat libavcodec`</span><br></pre></td></tr></table></figure><p>保存退出后，在当前路径下打开命令行窗口，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build.sh</span><br></pre></td></tr></table></figure><p>如果没有报错信息出现，那么就证明我们完成了该文件的编译工作，接着就能在当前路径上看到我们生成的extra_audio可执行程序文件和extra_audio.dSYM这个具备调试信息的目标文件。</p><p>接着我们找个具备音频信息的文件来进行演示，我们可以先用ffplay播放一下这个文件，以下是我这边通过ffplay播放该文件时，命令行窗口输出的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input #0, mov,mp4,m4a,3gp,3g2,mj2, from &#x27;1.mp4&#x27;:</span><br><span class="line">  Metadata:</span><br><span class="line">    major_brand     : isom</span><br><span class="line">    minor_version   : 512</span><br><span class="line">    compatible_brands: isomiso2avc1mp41</span><br><span class="line">    comment         : vid:v0200fg10000cbuq3hjc77ua8dieuid0</span><br><span class="line">    encoder         : Lavf58.45.100</span><br><span class="line">  Duration: 00:00:35.32, start: 0.000000, bitrate: 2348 kb/s</span><br><span class="line">    Stream #0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(tv, bt709), 720x1280 [SAR 1:1 DAR 9:16], 2217 kb/s, 29.83 fps, 30 tbr, 15360 tbn, 60 tbc (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      handler_name    : VideoHandler</span><br><span class="line">    Stream #0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 128 kb/s (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      handler_name    : SoundHandler</span><br><span class="line">   7.79 A-V: -0.024 fd=   6 aq=   23KB vq=  247KB sq=    0B f=0/0   </span><br></pre></td></tr></table></figure><p>可以看到该文件一共有两路流。<br>一路上视频流（h264）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream #0:0(und): Video: h264 (High)</span><br></pre></td></tr></table></figure><p>一路是音频流(aac)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream #0:1(und): Audio: aac (LC)</span><br></pre></td></tr></table></figure><p>此时我们在命令行窗口输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code .</span><br></pre></td></tr></table></figure><p>打开vscode后，在lauch.json文件中输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(lldb) 启动&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;/Users/wujianqiang/Desktop/1.mp4&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;1.h264&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我们要抽取的1.mp4放在&#x2F;Users&#x2F;wujianqiang&#x2F;Desktop路径下，而抽取后生成的文件起名为1.h264</p><p>设置好后，我们启动程序，此时就可以进行代码的调试了。</p><p>此时，我们将最终生成的1.h264文件，通过ffplay进行播放时，命令行输出的窗口信息为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input #0, h264, from &#x27;/Users/wujianqiang/Desktop/LearningFFmpegNotes/ectra_video/1.h264&#x27;:</span><br><span class="line">  Duration: N/A, bitrate: N/A</span><br><span class="line">    Stream #0:0: Video: h264 (High), yuv420p(tv, bt709, progressive), 720x1280 [SAR 1:1 DAR 9:16], 30 fps, 30 tbr, 1200k tbn, 60 tbc</span><br><span class="line">    nan M-V:    nan fd=   0 aq=    0KB vq=  229KB sq=    0B f=0/0 </span><br></pre></td></tr></table></figure><p>此时我们与原视频信息进行对比后可以发现，由于1.h264是不带视频信息的视频压缩数据，因此不具备原始视频的相关信息，至于为什么1.h264文件的帧率是30帧，那是因为ffmpeg默认的h264输出的视频帧率是30帧，如果将</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多媒体基本概念</title>
      <link href="/2022/11/12/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/11/12/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="多媒体基本概念"><a href="#多媒体基本概念" class="headerlink" title="多媒体基本概念"></a>多媒体基本概念</h1><ul><li>多媒体文件其实上一个容器</li><li>在容器里有很多流（Stream&#x2F;Track）</li><li>每种流（轨道）是不同的编码器编码的</li><li>从流（轨道）中读出的数据称为包</li><li>在一个包中包含着一个或多个帧（这些帧数据都是被编码器压缩处理过的数据）</li></ul><p>注：流和轨道是同一个意思，在容器里的多个流（轨道）之间是平行关系，也就是说，无论是不同种类的流之间（视频、音频还是字幕流之间），还是视频流和视频流（音频流和音频流、字幕流和字幕流）之间，每个流和轨道之间都是平行关系，数据互相独立不交互</p><h1 id="FFmpeg几个重要的结构体"><a href="#FFmpeg几个重要的结构体" class="headerlink" title="FFmpeg几个重要的结构体"></a>FFmpeg几个重要的结构体</h1><ul><li>AVFormatContext<br>格式上下文，它说链接多个API之间的桥梁</li><li>AVStream<br>可以通过AVStream读取文件的流</li><li>AVPacket<br>可以通过AVStream中得到一个个AVPacket包（里面存放的就是压缩后的帧数据），之后就能通过解码器还原每个包中的帧原始数据</li></ul><h1 id="FFmpeg操作流数据的基本步骤"><a href="#FFmpeg操作流数据的基本步骤" class="headerlink" title="FFmpeg操作流数据的基本步骤"></a>FFmpeg操作流数据的基本步骤</h1><ul><li>解复用（打开容器的操作就是解复用）</li><li>获取流</li><li>读取数据包</li><li>解码数据包，获得原始数据</li><li>对原始数据进行操作（图片旋转，倍速播放，音频降噪等）</li><li>释放资源</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何使用VSCode调试自己写的ffmpeg代码</title>
      <link href="/2022/11/12/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8VSCode%E8%B0%83%E8%AF%95%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84ffmpeg%E4%BB%A3%E7%A0%81/"/>
      <url>/2022/11/12/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8VSCode%E8%B0%83%E8%AF%95%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84ffmpeg%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>打开命令行，进入到所要编译运行到.c文件下，接着在命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code .</span><br></pre></td></tr></table></figure><p>等待VSCode到打开</p><p>打开VSCode后，如果该.c文件中的#inlcude头文件无法寻找到，那么将鼠标放在该include该语句上，此时会提示检测到 #include 错误。请更新 includePath。已为此翻译单元。</p><p>此时点击编辑includePath设置。进入后在IntelliSense 配置<br>使用此编辑器编辑在基础 c_cpp_properties.json 文件中定义的 IntelliSense 设置。在此编辑器中所做的更改仅适用于所选的配置。要一次编辑多个配置，请转到 c_cpp_properties.json。<br>中点击c_cpp_properties.json。在”includePath”: 上添加头文件到相关路径</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Mac&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/usr/local/ffmpeg/include&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;macFrameworkPath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/clang&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;macos-clang-x64&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>接着点击vscode左上角终端里面的配置任务，打开tasks.json文件，输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/clang&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fcolor-diagnostics&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-fansi-escape-codes&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;`pkg-config --libs --cflags libavutil`&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>继续点击运行，如果出现以下报错:<br><img src="/./picture/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8VSCode%E8%B0%83%E8%AF%95%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84ffmpeg%E4%BB%A3%E7%A0%81/2.png"></p><p>则通过命令后进入当前文件夹，输入输入以下命令（这里用Log.c这个测试文件进行测试）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wujianqiang@wujianqiangdeMacBook-Pro ~ % cd /Users/wujianqiang/Desktop/LearningFFmpegNotes/av_log</span><br><span class="line">wujianqiang@wujianqiangdeMacBook-Pro av_log % vim build.sh</span><br></pre></td></tr></table></figure><p>接着在build.sh中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">clang -g -o Log Log.c `pkg-config --libs --cflags libavutil`</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>保存退出后，给该文件进行授权后，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wujianqiang@wujianqiangdeMacBook-Pro av_log % ls</span><br><span class="line">Log.cbuild.shloglog.dSYM</span><br><span class="line">wujianqiang@wujianqiangdeMacBook-Pro av_log % ./build.sh</span><br><span class="line">zsh: permission denied: ./build.sh</span><br><span class="line">wujianqiang@wujianqiangdeMacBook-Pro av_log % chmod +x build.sh </span><br><span class="line">wujianqiang@wujianqiangdeMacBook-Pro av_log % chmod 777 build.sh </span><br><span class="line">wujianqiang@wujianqiangdeMacBook-Pro av_log % ./build.sh </span><br><span class="line">wujianqiang@wujianqiangdeMacBook-Pro av_log % </span><br></pre></td></tr></table></figure><p>接着回到VSCode，点击右侧的三角运行标志，接着点击显示所有自动调试设置，添加配置,输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(lldb) 启动&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/./picture/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8VSCode%E8%B0%83%E8%AF%95%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84ffmpeg%E4%BB%A3%E7%A0%81/1.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac下编译可调式的Debug版本FFmpeg全过程</title>
      <link href="/2022/11/10/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%8F%AF%E8%B0%83%E8%AF%95%E7%9A%84Debug%E7%89%88%E6%9C%ACFFmpeg%EF%BC%8C%E5%B9%B6%E9%80%9A%E8%BF%87GDB%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/"/>
      <url>/2022/11/10/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%8F%AF%E8%B0%83%E8%AF%95%E7%9A%84Debug%E7%89%88%E6%9C%ACFFmpeg%EF%BC%8C%E5%B9%B6%E9%80%9A%E8%BF%87GDB%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>今天说一个比较好用的学习ffmpeg的方法。我们经常通过ffmpeg的命令来进行文件格式转换或者是查看文件的媒体信息。</p><p>如果这个时候，我们想知道ffmpeg在执行我们输入命令后的具体程序运行流程，那么，我们就需要编译一个可调式版本的ffmpeg。事实上，通过调试我们输入的ffmpeg命令，在一定程度上有利于我们加深对ffmpeg的理解与学习。</p><p>接下来，本文将通过以下几个步骤来演示如何调试ffmpeg</p><ul><li>ffmpeg的下载与编译</li><li>如何通过gdb调试ffmpeg</li><li>如何在vscode调试ffmpeg</li></ul><h1 id="FFmpeg的下载与编译"><a href="#FFmpeg的下载与编译" class="headerlink" title="FFmpeg的下载与编译"></a>FFmpeg的下载与编译</h1><p>输入以下参数进行下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b release/xx  https://git.ffmpeg.org/ffmpeg.git</span><br></pre></td></tr></table></figure><p>这边可以根据选择选择自己需要的ffmpeg版本</p><p>clone后的ffmpeg文件夹结构如下：</p><ul><li>libavcodec：用于各种类型声音&#x2F;图像编解码；</li><li>libavdevice：用于音视频数据采集和渲染等功能的设备相关;</li><li>libavfilter：包含多媒体处理常用的滤镜功能;</li><li>libavformat：包含多种多媒体容器格式的封装、解封装工具;</li><li>libavutil：包含一些公共的工具函数；</li><li>libpostproc：用于后期效果处理；</li><li>libswresample：用于音频重采样和格式转换等功能;</li><li>libswscale：用于视频场景比例缩放、色彩映射转换；</li></ul><p>接着进入ffmpeg文件夹，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/home/ws/Desktop/FFmpeg/4.2/FFmpeg4.2_debug/ --enable-shared --disable-optimizations --enable-debug --disable-x86asm --extra-cflags=-g --disable-stripping</span><br></pre></td></tr></table></figure><p>其中：</p><h2 id="prefix"><a href="#prefix" class="headerlink" title="prefix:"></a>prefix:</h2><p>生成的bin lib include share存放的位置</p><h2 id="shared"><a href="#shared" class="headerlink" title="shared:"></a>shared:</h2><p>ffmpeg生成的库一共有三个版本：static(静态库版本)、shared(动态库版本)、Dev(开发者版本)</p><ul><li>static: 里面只有3个应用程序：ffmpeg.exe，ffplay.exe，ffprobe.exe，每个exe的体积都很大，相关的Dll已经被编译到exe里面去了。作为工具而言此版本就可以满足我们的需求；</li><li>shared:里面除了3个应用程序：ffmpeg.exe，ffplay.exe，ffprobe.exe之外，还有一些Dll(或dylib或so)，比如说avcodec-54.dll之类的。shared里面的可执行程序体积很小，他们在运行的时候，到相应的Dll中调用功能。程序运行过程必须依赖于提供的dll文件；</li><li>dev:是用于开发的，里面包含了库文件xxx.lib以及头文件xxx.h，这个版本不包含exe文件。dev版本中include文件夹内文件用途</li></ul><h2 id="optimizations"><a href="#optimizations" class="headerlink" title="optimizations:"></a>optimizations:</h2><p>编译器优化，这个需要禁止</p><h2 id="debug"><a href="#debug" class="headerlink" title="debug:"></a>debug:</h2><p>是否生成可调试的ffmpeg</p><h2 id="x86asm"><a href="#x86asm" class="headerlink" title="x86asm:"></a>x86asm:</h2><p>独立x86程序集</p><h2 id="–extra-cflag"><a href="#–extra-cflag" class="headerlink" title="–extra-cflag:"></a>–extra-cflag:</h2><p>第三方库不在默认的include路径，则需要指定–extra-cflags&#x3D;-I&#x2F;xxxx&#x2F;include<br>extra-cflags的额外用法：比如–extra-cflags&#x3D;-Dxxx，-D的意思是宏，指的就是在编译的时候预定义了xxx这样的宏</p><h2 id="stripping"><a href="#stripping" class="headerlink" title="stripping:"></a>stripping:</h2><p>–disable-stripping：禁用剥离可执行文件和共享库</p><p>其他ffmpeg的相关配置参数具体含义，<a href="https://www.cnblogs.com/x_wukong/p/12746031.html">详见</a></p><p>等待configure检验完成后，接着输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure><p>如果想让编译的速度快一点可以查看一下电脑配置，通过make的-j命令（加速程序编译），比如我的电脑可以开到20</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make -j 20</span><br></pre></td></tr></table></figure><p>等待make运行结束后，再输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>此时，我们完成了FFmpeg的编译</p><h1 id="如何通过gdb调试ffmpeg"><a href="#如何通过gdb调试ffmpeg" class="headerlink" title="如何通过gdb调试ffmpeg"></a>如何通过gdb调试ffmpeg</h1><p>当我们完成FFmpeg后，我们可以在当前文件夹看到ffmpeg_g这个文件(带_g的就表示是可以调试的)<br>我们可以查看一下这个文件信息，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ffmpeg_g -version</span><br></pre></td></tr></table></figure><p>接着，运行gdb首，并指定ffmpeg_g作为调试程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./ffmpeg_g</span><br></pre></td></tr></table></figure><p>此时，我们可以验证一下是否可以调试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set args -version #设置运行参数linux 上使用 vscode debug ffmpeg ?</span><br><span class="line">b main #将断电打在main函数的入口处</span><br><span class="line">layout src #显示源码布局</span><br><span class="line">run #运行程序</span><br></pre></td></tr></table></figure><p>接着输入n后回车即可进行单步调试<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%8F%AF%E8%B0%83%E8%AF%95%E7%9A%84Debug%E7%89%88%E6%9C%ACFFmpeg%EF%BC%8C%E5%B9%B6%E9%80%9A%E8%BF%87GDB%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/1.png"></p><p>在此，我们继续演示一下如何进行调试。输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb ./ffmpeg_g</span><br><span class="line">set args -i &#x27;/home/ws/Videos/1.mp4&#x27;  #获取mp4信息</span><br><span class="line">b main #将断电打在main函数的入口处</span><br><span class="line">layout src #显示源码布局</span><br><span class="line">run #运行程序</span><br></pre></td></tr></table></figure><p>gdb常用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n #单步调试</span><br><span class="line">s #单步单步跟踪到函数内部</span><br><span class="line">continue #直接运行到下一个断点处</span><br><span class="line">u 行数 #运行到指定位置</span><br><span class="line">b #添加断点，可根据行数、函数名、条件进行断点设置</span><br><span class="line">info breakpoints #查看已设置断点</span><br><span class="line">p #打印基本类型变量，数组，字符数组</span><br><span class="line">l #打印源码</span><br></pre></td></tr></table></figure><p>具体可参考这篇<a href="https://zhuanlan.zhihu.com/p/74897601">文章</a></p><h1 id="如何在vscode调试ffmpeg"><a href="#如何在vscode调试ffmpeg" class="headerlink" title="如何在vscode调试ffmpeg"></a>如何在vscode调试ffmpeg</h1><p>首先cd到FFmpeg文件夹，然后在命令行输入以下命令打开vscode：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code . </span><br></pre></td></tr></table></figure><p>接着在VS Code中同时按下Ctrl + Shift + P打开输入”launch.json”。<br>如果没有这个选项的话，那就同时按下Ctrl + Shift + D，选择创建一个”launch.json”，点击Web app(Egd)<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%8F%AF%E8%B0%83%E8%AF%95%E7%9A%84Debug%E7%89%88%E6%9C%ACFFmpeg%EF%BC%8C%E5%B9%B6%E9%80%9A%E8%BF%87GDB%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/2.png"></p><p>把下面这段话替换进行</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gcc - 生成和调试活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;/../ffmpeg_g&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;-version&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// &quot;preLaunchTask&quot;: &quot;C/C++: gcc 生成活动文件&quot;,</span></span><br><span class="line">        <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gdb&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) Launch&quot;</span><span class="punctuation">,</span> <span class="comment">// 配置名称，将会在启动配置的下拉菜单中显示</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span> <span class="comment">// 配置类型，对于C/C++可认为此处只能是cppdbg，由cpptools提供；不et args -version #设置运行参数linux 上使用 vscode debug ffmpeg ?</span></span><br><span class="line">b main #将断电打在main函数的入口处</span><br><span class="line">layout src #显示源码布局</span><br><span class="line">run #运行程序同编程语言不同</span><br><span class="line">        <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span> <span class="comment">// 可以为launch（启动）或attach（附加）</span></span><br><span class="line">        <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span> <span class="comment">// 将要进行调试的程序的路径</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span>    <span class="comment">// 指定输出文件名，不加该参数则默认输出a.exe，Linux下默认a.out</span></span><br><span class="line">            <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span>    <span class="comment">// 生成和调试有关的信息</span></span><br><span class="line">            <span class="string">&quot;-m64&quot;</span><span class="punctuation">,</span>  <span class="comment">// 不知为何有时会生成16位程序而无法运行，此条可强制生成64位的</span></span><br><span class="line">            <span class="string">&quot;-Wall&quot;</span><span class="punctuation">,</span> <span class="comment">// 开启额外警告</span></span><br><span class="line">            <span class="string">&quot;-static-libgcc&quot;</span><span class="punctuation">,</span>     <span class="comment">// 静态链接libgcc，一般都会加上</span></span><br><span class="line">            <span class="string">&quot;-fexec-charset=GBK&quot;</span><span class="punctuation">,</span> <span class="comment">// 生成的程序使用GBK编码，不加这条会导致Win下输出中文乱码；繁体系统改成BIG5</span></span><br><span class="line">            <span class="string">&quot;-D__USE_MINGW_ANSI_STDIO&quot;</span><span class="punctuation">,</span> <span class="comment">// 用MinGW写C时留着，否则不需要，用于支持printf的%zd和%Lf等</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 编译的命令，其实相当于VSC帮你在终端中输了这些东西</span></span><br><span class="line">        <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="comment">// 设为true时程序将暂停在程序入口处，相当于在main上打断点</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span> <span class="comment">// 调试程序时的工作目录，此为工作区文件夹；改成$&#123;fileDirname&#125;可变为文件所在目录</span></span><br><span class="line">        <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 环境变量ffmpeg_g器的内容，具体作用自行Google</span></span><br><span class="line">                <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Compile&quot;</span> <span class="comment">// 调试前执行的任务，一般为编译程序。与tasks.json的label相对应</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>保存退出后，我们打开想要调试的文件，以本次要调试的ffmpeg_g为例，打开fftools文件夹中的ffmpeg.c文件，并在4852行加上断点（鼠标挪到行号的左边会出现一个淡淡的小红点，点下之后会显示红点，代表你在本行打了一个断点）</p><p><font color =red>注：请安装如下2个VS Code插件：Cffmpeg_g&#x2F;C++、C&#x2F;C++ Runner</font></p><p>接下来可以点击上方的工具栏来执行相关调试操作，也可以使用快捷键来进行操作：<br>F5：继续执行<br>F10：单步跳过<br>F11：单步调试<br>Shift + F11：单步跳出<br>Shift + F5：停止调试</p><p>之后我们可以通过”args”: [“-version”],这个参数来调试ffmpeg</p><p>左边的DEBUG工具栏可以让你轻松地查看本地变量和寄存器，可以添加相关的变量监视，也可以查看函数的调用堆栈等信息。</p><p>再举个查看文件信息的例子，修改launch.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gcc - 生成和调试活动文件&quot;</span><span class="punctuation">,</span>ffmpeg_g</span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;/../ffmpeg_g&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;-i&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;&#x27;/home/ws/Videos/1.mp4&#x27;&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// &quot;preLaunchTask&quot;: &quot;C/C++: gcc 生成活动文件&quot;,</span></span><br><span class="line">      <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gdb&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%8F%AF%E8%B0%83%E8%AF%95%E7%9A%84Debug%E7%89%88%E6%9C%ACFFmpeg%EF%BC%8C%E5%B9%B6%E9%80%9A%E8%BF%87GDB%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/3.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg文件IO操作</title>
      <link href="/2022/10/04/FFmpeg%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/10/04/FFmpeg%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>简单介绍一下如何使用FFmpeg进行文件IO操作，从操作文件和操作目录两个层面讲起，首先是文件的相关操作。</p><h2 id="文件的删除与重命名"><a href="#文件的删除与重命名" class="headerlink" title="文件的删除与重命名"></a>文件的删除与重命名</h2><ul><li>avpriv_io_delete()</li><li>avpriv_io_move()</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子1：删除文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//delete url</span></span><br><span class="line">    <span class="type">int</span> ret = avpriv_io_delete(<span class="string">&quot;./a.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Failed to delete a.txt\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">&quot;Success to delete a.txt \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子2：文件重命名</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = avpriv_io_move(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;2.txt&quot;</span>);<span class="comment">//avpriv_io_move(src, dst)；</span></span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Failed to rename \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">&quot;Success to rename \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>命令行窗口输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -g -o ffmpeg_del ffmpeg_file.c `pkg-config --cflags  --libs libavutil libavformat `</span><br></pre></td></tr></table></figure><p>如果出现该报错：<br><img src="/./picture/FFmpeg%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/1.png"></p><p>说明你现在安装的FFmpeg是最新版本的，没有这个函数，年可以选择切换成4.x版本的FFmpeg重新进行编译</p><p>这里我们切换到4.2版本演示一下，因为之前是通过git clone的方式下载代码的，因此可以直接用git命令切换到4.2版本的release分支上重新进行编译，你也可以重新git clone <a href="https://github.com/FFmpeg/FFmpeg.git">https://github.com/FFmpeg/FFmpeg.git</a><br>代码下来切换分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout release/4.2</span><br></pre></td></tr></table></figure><p>git branch查看切换完成后输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --cc=/usr/bin/clang --prefix=/usr/local/ffmpeg --enable-gpl --enable-nonfree --enable-libfdk-aac --enable-libx264 --enable-libmp3lame --enable-libx265  --enable-filter=delogo --enable-debug --disable-optimizations --enable-libspeex --enable-videotoolbox --enable-shared --enable-pthreads --enable-version3 --enable-hardcoded-tables --host-cflags= --host-ldflags=</span><br></pre></td></tr></table></figure><p>如果出现报错，请根据<a href="https://wujianqiangcode.github.io/2022/10/02/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/">这篇文章</a>进行修改。</p><p>接着输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><p>此时回到之前的位置，继续输入命令即可完成编译<br><img src="/./picture/FFmpeg%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/2.png"></p><h2 id="操作目录到重要函数"><a href="#操作目录到重要函数" class="headerlink" title="操作目录到重要函数"></a>操作目录到重要函数</h2><ul><li>avio_open_dir()</li><li>avio_read_dir()</li><li>avio_close_dir()</li></ul><h3 id="操作目录到重要结构体"><a href="#操作目录到重要结构体" class="headerlink" title="操作目录到重要结构体"></a>操作目录到重要结构体</h3><ul><li>AVIODirContext：操作目录到上下文，存储例如打开的是哪个目录之类的信息，串联作用，作为输入参数来传递给后续要进行的操作函数。实际上我们在调用avio_open_dir()函数后，程序就会自动给我们生成一个AVIODirContext，里面存储了一些目录的基本信息，因此在后续我们调用avio_read_dir()或者是avio_close_dir()时候，它将作为参数进行传递，这样avio_read_dir()或者是avio_close_dir()就知道我们实际上要操作的是哪个目录。</li><li>AVIODirEntry：目录项。用于存放该目录下每个文件的文件名，文件大小等信息</li></ul><p>接下来通过这几个函数，我们来简单的实现一下ls这个命令的具体功能。</p><p>PS：在终端输入ls后，即可显示该目录下所有文件的文件名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    AVIODirContext *ctx = <span class="literal">NULL</span>;</span><br><span class="line">    AVIODirEntry *entry = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    av_log_set_level(AV_LOG_INFO);</span><br><span class="line">    <span class="type">int</span> ret = avio_open_dir(&amp;ctx, <span class="string">&quot;./&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Cant open dir %s\n &quot;</span>,av_err2str(ret));</span><br><span class="line">        <span class="keyword">goto</span> __fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ret = avio_read_dir(ctx, &amp;entry);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Cant read dir %s\n &quot;</span>,av_err2str(ret));</span><br><span class="line">            <span class="keyword">goto</span> __fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!entry)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">&quot;%12&quot;</span>PRId64<span class="string">&quot; %s \n&quot;</span>, entry-&gt;size, entry-&gt;name);</span><br><span class="line">        avio_free_directory_entry(&amp;entry);<span class="comment">//释放</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">__fail:</span><br><span class="line">    avio_close_dir(&amp;ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入编译命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -g -o list ffmpeg_list.c `pkg-config --cflags  --libs libavutil libavformat `</span><br></pre></td></tr></table></figure><p><img src="/./picture/FFmpeg%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/3.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg日志系统</title>
      <link href="/2022/10/04/FFmpeg%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/10/04/FFmpeg%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="步骤一：引入相关头文件"><a href="#步骤一：引入相关头文件" class="headerlink" title="步骤一：引入相关头文件"></a>步骤一：引入相关头文件</h2><p>从libavutil这个包含工具函数的文件夹中引入log.h头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/log.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="步骤二：设置日志级别"><a href="#步骤二：设置日志级别" class="headerlink" title="步骤二：设置日志级别"></a>步骤二：设置日志级别</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">av_log_set_level</span>(AV_LOG_DEBUG)</span><br></pre></td></tr></table></figure><p><strong>常用的日志级别：</strong></p><ul><li>AV_LOG_ERROR</li><li>AV_LOG_WARNING</li><li>AV_LOG_INFO</li><li>AV_LOG_DEBUG</li></ul><p>从上到下看，这四个优先级别：从高到低。<br>也就是说如果设置为最低级别的AV_LOG_DEBUG，那么所有的日志信息都会打印出来；而如果设置为最高级别的AV_LOG_ERROR，那么只有AV_LOG_ERROR的日志信息才会打印出来。</p><h2 id="步骤三：打印日志信息"><a href="#步骤三：打印日志信息" class="headerlink" title="步骤三：打印日志信息"></a>步骤三：打印日志信息</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">&quot;...%s\n&quot;</span>, op)</span><br></pre></td></tr></table></figure><p>av_log(…)函数中的第1个参数指定该log所属的结构体,例如AVFormatContext、AVCodecContext等等，一般都设置成NULL；第2个参数表示该日志的级别；第3个参数是需要打印的字符串信息，里面可以添加%s，%d等占位符，第4，5，…参数代表第3个参数中字符串内占位符要显示的内容。</p><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    av_log_set_level(AV_LOG_DEBUG);<span class="comment">//设置日志级别</span></span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">&quot;Hello word!\n&quot;</span>);<span class="comment">//设置输出内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存成.cw文件退出后，打开命令行窗口，</p><p>Mac下输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clang -g -o log log.c -I/usr/local/ffmpeg/include -L/usr/local/ffmpeg/lib -lavutil</span><br><span class="line">或者是输入：</span><br><span class="line">clang -g -o log log.c `pkg-config --cflags --libs libavutil`</span><br></pre></td></tr></table></figure><p>Linux下输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -o</span><br></pre></td></tr></table></figure><p>PS：</p><p>-g 参数：输出有调试信息的</p><p>-o 参数：-o参数后面接的是输出执行文件的名称</p><p>-I 参数：指定引入的FFmpeg头文件的路径</p><p>-L 参数：指定所依赖的FFmpeg库的路径</p><p>-l 参数：指定所依赖的FFmpeg库的名称</p><p>–cflag参数：表示获取所需要引入的头文件目录地址</p><p> –libs参数：表示获取所依赖的库路径以及指定所要添加的库的名字（后面接库的名字）</p><p>回车编译后，执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./log</span><br></pre></td></tr></table></figure><p>就能看到结果了。</p><p><img src="/./picture/FFmpeg%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/1.png"></p><p>如果将代码中的日志级别改成AV_LOG_INFO的话，那就无法输出AV_LOG_DEBUG级别的信息了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    av_log_set_level(AV_LOG_INFO);<span class="comment">//改成AV_LOG_INFO级别</span></span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">&quot;AV_LOG_DEBUG级别日志信息\n&quot;</span>);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">&quot;AV_LOG_INFO级别日志信息&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./FFmpeg%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/2.png"></p><p>而比AV_LOG_INFO级别更高的日志是可以正常打印的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    av_log_set_level(AV_LOG_INFO);<span class="comment">//改成AV_LOG_INFO级别</span></span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">&quot;AV_LOG_DEBUG级别日志信息\n&quot;</span>);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">&quot;AV_LOG_INFO级别日志信息&quot;</span>);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;AV_LOG_ERROR级别日志信息&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./picture/FFmpeg%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/3.png"></p><p>PS：</p><p>如果采用pkg-config报以下错误的话：<br><img src="/./picture/FFmpeg%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/4.png"></p><p>说明没有配置环境，首先在命令行窗口输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim ~/.bash_profile </span><br></pre></td></tr></table></figure><p>打开后添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;/usr/local/ffmpeg/bin:$PATH&quot;</span><br><span class="line"></span><br><span class="line">export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/ffmpeg/lib/pkgconfig</span><br><span class="line">export LD_LIBRARY_PATH=$LIB_LIBRARY_PATH:/usr/local/ffmpeg/lib</span><br></pre></td></tr></table></figure><p>然后按下esc退出编辑后，按下:wq保存退出</p><p>接着输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>此时环境配置生效，再次运行命令，即可正常编译<br><img src="/./picture/FFmpeg%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/5.png"></p><p>PS:<br>MAC设置环境变量时, 配置的 bash_profile 没有生效，需要手动执行下面命令才生效。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>原因：zsh和bash有别， zsh模式不执行上述脚本，bash模式才执行。mac自带zsh，新款的默认使用后zsh。</p><p>解决方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd //Users/wujianqiang</span><br><span class="line"></span><br><span class="line">sudo su</span><br><span class="line"></span><br><span class="line">bash</span><br><span class="line"></span><br><span class="line">vim   ~/.bashrc </span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;/usr/local/ffmpeg/bin:$PATH&quot;</span><br><span class="line">export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/ffmpeg/lib/pkgconfig</span><br><span class="line">export LD_LIBRARY_PATH=$LIB_LIBRARY_PATH:/usr/local/ffmpeg/lib</span><br></pre></td></tr></table></figure><p>借助输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br><span class="line">zsh</span><br><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;/usr/local/ffmpeg/bin:$PATH&quot;</span><br><span class="line">export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/ffmpeg/lib/pkgconfig</span><br><span class="line">export LD_LIBRARY_PATH=$LIB_LIBRARY_PATH:/usr/local/ffmpeg/lib</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>最后:wq退出即可。</p><p>PS:为了让.bash_profile生效，一般在zhsrc加上一句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg学习笔记</title>
      <link href="/2022/10/03/FFmpeg%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/10/03/FFmpeg%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>之前学习FFmpeg一直是跳着学，用到什么学习什么，没有一个系统性的学习过程。因此趁着最近这段时间刚好有空，想从头到尾仔仔细细的学习一遍，同时整理一下相关的学习笔记，帮助别其他伙伴们快速入门FFmpeg，同时也方便自己后续进行回顾学习。</p><p>本篇博客的目的是让零基础的读者可以通过阅读该博客，从而彻底的熟练使用FFmpeg，以及音视频的相关知识。因此我将通过之前学习雷霄骅前辈的博客，李超大佬的课程，以及实际项目工作中运用到知识和遇到的问题进行精华总结。帮助其他伙伴们从零开始彻底掌握FFmpeg。</p><h1 id="本课程分为四个部分："><a href="#本课程分为四个部分：" class="headerlink" title="本课程分为四个部分："></a>本课程分为四个部分：</h1><h2 id="第一部分：音视频基础知识"><a href="#第一部分：音视频基础知识" class="headerlink" title="第一部分：音视频基础知识"></a>第一部分：音视频基础知识</h2><h3 id="帧率、码率、比特率等参数含义"><a href="#帧率、码率、比特率等参数含义" class="headerlink" title="- 帧率、码率、比特率等参数含义"></a>- 帧率、码率、比特率等参数含义</h3><h3 id="I帧、B帧、P帧的区别"><a href="#I帧、B帧、P帧的区别" class="headerlink" title="- I帧、B帧、P帧的区别"></a>- I帧、B帧、P帧的区别</h3><h3 id="YUV和RGB是什么"><a href="#YUV和RGB是什么" class="headerlink" title="- YUV和RGB是什么"></a>- YUV和RGB是什么</h3><h3 id="H264是什么"><a href="#H264是什么" class="headerlink" title="- H264是什么"></a>- H264是什么</h3><h2 id="第二部分：-如何在各个平台上编译FFmpeg"><a href="#第二部分：-如何在各个平台上编译FFmpeg" class="headerlink" title="第二部分： 如何在各个平台上编译FFmpeg"></a>第二部分： 如何在各个平台上编译FFmpeg</h2><h3 id="Windows系统编译FFmpeg"><a href="#Windows系统编译FFmpeg" class="headerlink" title="- Windows系统编译FFmpeg"></a>- Windows系统编译FFmpeg</h3><h3 id="MacOS系统编译FFmpeg"><a href="#MacOS系统编译FFmpeg" class="headerlink" title="- MacOS系统编译FFmpeg"></a>- <a href="https://wujianqiangcode.github.io/2022/10/02/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/">MacOS系统编译FFmpeg</a></h3><h3 id="Linux系统编译FFmpeg"><a href="#Linux系统编译FFmpeg" class="headerlink" title="- Linux系统编译FFmpeg"></a>- Linux系统编译FFmpeg</h3><h3 id="编译IOS系统可用的FFmpeg"><a href="#编译IOS系统可用的FFmpeg" class="headerlink" title="- 编译IOS系统可用的FFmpeg"></a>- 编译IOS系统可用的FFmpeg</h3><h3 id="编译Android系统可用的FFmpeg"><a href="#编译Android系统可用的FFmpeg" class="headerlink" title="- 编译Android系统可用的FFmpeg"></a>- 编译Android系统可用的FFmpeg</h3><h2 id="第三部分：FFmpeg常用的命令有哪些"><a href="#第三部分：FFmpeg常用的命令有哪些" class="headerlink" title="第三部分：FFmpeg常用的命令有哪些"></a>第三部分：FFmpeg常用的命令有哪些</h2><h2 id="第四部分：如何调用FFmpeg的函数实现功能"><a href="#第四部分：如何调用FFmpeg的函数实现功能" class="headerlink" title="第四部分：如何调用FFmpeg的函数实现功能"></a>第四部分：如何调用FFmpeg的函数实现功能</h2><h3 id="FFmpeg源代码结构"><a href="#FFmpeg源代码结构" class="headerlink" title="- FFmpeg源代码结构"></a>- <a href="https://wujianqiangcode.github.io/2022/10/03/FFmpeg%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/">FFmpeg源代码结构</a></h3><h3 id="FFmpeg日志系统"><a href="#FFmpeg日志系统" class="headerlink" title="- FFmpeg日志系统"></a>- <a href="https://wujianqiangcode.github.io/2022/10/04/FFmpeg%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/">FFmpeg日志系统</a></h3><h3 id="FFmpeg的文件IO操作"><a href="#FFmpeg的文件IO操作" class="headerlink" title="- FFmpeg的文件IO操作"></a>- <a href="https://wujianqiangcode.github.io/2022/10/04/FFmpeg%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/">FFmpeg的文件IO操作</a></h3><h2 id="第五部分：深入理解主流的音视频协议"><a href="#第五部分：深入理解主流的音视频协议" class="headerlink" title="第五部分：深入理解主流的音视频协议"></a>第五部分：深入理解主流的音视频协议</h2><h2 id="第六部分：深度剖析FFmpeg源代码"><a href="#第六部分：深度剖析FFmpeg源代码" class="headerlink" title="第六部分：深度剖析FFmpeg源代码"></a>第六部分：深度剖析FFmpeg源代码</h2><h2 id="第七部分：第三方开源库和主流渲染引擎框架的学习"><a href="#第七部分：第三方开源库和主流渲染引擎框架的学习" class="headerlink" title="第七部分：第三方开源库和主流渲染引擎框架的学习"></a>第七部分：第三方开源库和主流渲染引擎框架的学习</h2><h3 id="第三方开源库"><a href="#第三方开源库" class="headerlink" title="第三方开源库"></a>第三方开源库</h3><h4 id="WebRTC-学习笔记"><a href="#WebRTC-学习笔记" class="headerlink" title="- WebRTC 学习笔记"></a>- WebRTC 学习笔记</h4><h4 id="libyuv"><a href="#libyuv" class="headerlink" title="- libyuv"></a>- libyuv</h4><h4 id="Mplayer"><a href="#Mplayer" class="headerlink" title="- Mplayer"></a>- Mplayer</h4><h4 id="x264"><a href="#x264" class="headerlink" title="- x264"></a>- x264</h4><h4 id="OpenCV-学习笔记"><a href="#OpenCV-学习笔记" class="headerlink" title="- OpenCV 学习笔记"></a>- OpenCV 学习笔记</h4><h3 id="主流渲染引擎框架"><a href="#主流渲染引擎框架" class="headerlink" title="主流渲染引擎框架"></a>主流渲染引擎框架</h3><h4 id="OpenGL-学习笔记"><a href="#OpenGL-学习笔记" class="headerlink" title="- OpenGL 学习笔记"></a>- OpenGL 学习笔记</h4><h4 id="Metal-学习笔记"><a href="#Metal-学习笔记" class="headerlink" title="- Metal 学习笔记"></a>- Metal 学习笔记</h4><h4 id="DirectX-3D-学习笔记"><a href="#DirectX-3D-学习笔记" class="headerlink" title="- DirectX 3D 学习笔记"></a>- DirectX 3D 学习笔记</h4><h4 id="OpenCL"><a href="#OpenCL" class="headerlink" title="- OpenCL"></a>- OpenCL</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg源代码结构</title>
      <link href="/2022/10/03/FFmpeg%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/"/>
      <url>/2022/10/03/FFmpeg%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="FFmpeg源代码目录："><a href="#FFmpeg源代码目录：" class="headerlink" title="FFmpeg源代码目录："></a>FFmpeg源代码目录：</h1><p><img src="/./picture/FFmpeg%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/1.png"></p><table>  <tr>    <th>libavcodec</th>    <th>包含一系列编解码器等实现（如：h264、h265、AAC、Opus等）  </tr>  <tr>    <td>libavformat</td>    <td>包含音视频协议、容器格式以及IO访问的相关函数实现</td>  </tr>  <tr>    <td>libavutil</td>    <td>包含hash器，解码器和各种工具函数</td>  </tr>  <tr>    <td>libavfilter</td>    <td>提供了各种音视频过滤器（如：多路流合并、变速等特效）</td>  </tr>  <tr>    <td>libavdevice</td>    <td>包含对所有音视频设备等操作，提供访问捕获设备和回放设备等接口</td>  </tr>  <tr>    <td>libswresample</td>    <td>实现了混音和重采样</td>  </tr>  <tr>    <td>libswscale</td>    <td>实现了色彩转换和图像的缩放功能</td>  </tr></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac下编译FFmpeg全过程</title>
      <link href="/2022/10/02/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/10/02/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="下载源代码"><a href="#下载源代码" class="headerlink" title="下载源代码"></a>下载源代码</h2><p>首先用在命令行窗口用Git命令下载FFmpeg源代码</p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://git.ffmpeg.org/ffmpeg.git</span><br></pre></td></tr></table></figure><p>进行源代码的下载</p><h2 id="编译FFmpeg"><a href="#编译FFmpeg" class="headerlink" title="编译FFmpeg"></a>编译FFmpeg</h2><p>下载完后，进入ffmpeg文件夹切换到对应分支，这边切换到4.2版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout release/4.2</span><br></pre></td></tr></table></figure><p>首先输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --cc=/usr/bin/clang --prefix=/usr/local/ffmpeg --enable-gpl --enable-nonfree --enable-libfdk-aac --enable-libx264 --enable-libmp3lame --enable-libx265  --enable-filter=delogo --enable-debug --disable-optimizations --enable-libspeex --enable-videotoolbox --enable-shared --enable-pthreads --enable-version3 --enable-hardcoded-tables --host-cflags= --host-ldflags=</span><br></pre></td></tr></table></figure><span id="more"></span><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/1.png"></p><h3 id="检测编译环境"><a href="#检测编译环境" class="headerlink" title="检测编译环境"></a>检测编译环境</h3><h4 id="安装yasm"><a href="#安装yasm" class="headerlink" title="安装yasm"></a>安装yasm</h4><p>如果出现该报错提示，说明还需要下载一下yasm</p><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/2.png"></p><p><a href="http://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gz">yasm的下载链接</a></p><p>解压完yasm后，切换路径：</p><p>cd yasm-1.3.0<br> 接着进行执行配置，输入：</p><p> .&#x2F;configure<br>然后进行编译，输入：</p><p>make<br>最后进行安装，输入：</p><p>make install（提示：Permission denied，就执行sudo make install）</p><p>安装成功yasm后，我们继续cd进入到ffmpeg的文件夹下，进行.&#x2F;configure操作</p><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/3.png"></p><h4 id="安装libmp3lame"><a href="#安装libmp3lame" class="headerlink" title="安装libmp3lame"></a>安装libmp3lame</h4><p>如果出现以下报错，说明我们还得安装一下libmp3lame</p><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/5.png"></p><p><a href="https://sourceforge.net/projects/lame/files/lame/3.99/">libmp3lame的下载地址</a></p><p>解压完lame-3.100后，切换路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd lame-3.100</span><br></pre></td></tr></table></figure><p> 接着进行执行配置，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><p>然后进行编译，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/6.png"></p><p>如果出现以上报错，进入include文件夹，找到libmp3lame.sym文件</p><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/7.png"></p><p>删除lame_init_old所在行</p><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/8.png"></p><p>然后继续make</p><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/9.png"></p><p> 最后进行安装，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install（提示：Permission denied，就执行sudo make install）</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/10.png"></p><p>继续cd到ffmpeg文件夹中，进行.&#x2F;configure操作</p><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/11.png"></p><h4 id="安装x264、x265-等"><a href="#安装x264、x265-等" class="headerlink" title="安装x264、x265 等"></a>安装x264、x265 等</h4><p>大概率x264、x265这些也没有安装，直接一口气输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install fdk-aac&amp;&amp;brew install x264&amp;&amp;brew install x265&amp;&amp;brew install speex&amp;&amp;brew install pkg-config&amp;&amp;brew  install sdl2</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/12.png"><br>等待跑完后 再执行<br>之前ffmpeg到configure操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --cc=/usr/bin/clang --prefix=/usr/local/ffmpeg --enable-gpl --enable-nonfree --enable-libfdk-aac --enable-libx264 --enable-libmp3lame --enable-libx265  --enable-filter=delogo --enable-debug --disable-optimizations --enable-libspeex --enable-videotoolbox --enable-shared --enable-pthreads --enable-version3 --enable-hardcoded-tables --host-cflags= --host-ldflags=</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/13.png"></p><p>此时输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><p>必须加上sudo，否则会出现改报错<br><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/15.png"><br>开始进行编译<br><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/14.png"><br><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/16.png"></p><p>等待编译完成后，我们输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/ffmpeg/</span><br></pre></td></tr></table></figure><p>进入后就能看到我们编译完成的文件了。<br><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/17.png"></p><h2 id="添加ffmpeg环境变量"><a href="#添加ffmpeg环境变量" class="headerlink" title="添加ffmpeg环境变量"></a>添加ffmpeg环境变量</h2><p>接下来为了方便，我们修改一下环境变量，命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br></pre></td></tr></table></figure><p>回车后输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH: /usr/local/ffmpeg/bin</span><br></pre></td></tr></table></figure><p>然后输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure><p>接着输入，让环境变量生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>然后查看环境变量的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure><p>此时如果生效后在任意位置打开命令行窗口输入ffmpeg，将显示如下内容，证明已成功安装完成。<br><img src="/./picture/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%9C%A8mac%E4%B8%8B%E7%BC%96%E8%AF%91FFmpeg%E7%9A%84%E8%BF%87%E7%A8%8B/18.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>利用Hexo搭建个人博客全过程</title>
      <link href="/2022/10/01/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/10/01/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p><a href="https://nodejs.org/en/">安装地址</a></p><p>点击16.17.1.LTS</p><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1.png"><br>下载完成后，一直点击下一步进行安装即可</p><p><font color = gree>PS:这个安装包内除了Node.js以外，还包含npm包管理器，这个是等会搭建hexo博客所必须用到的东西。</font></p><h2 id="通过npm安装cnpm"><a href="#通过npm安装cnpm" class="headerlink" title="通过npm安装cnpm"></a>通过npm安装cnpm</h2><p>接着打开终端,切换到root用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure><p>输入密码<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/2.png"></p><span id="more"></span><p>此时我们可以查看一下刚刚安装的版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/3.png"></p><p>此时证明刚刚有成功安装node.js</p><p>接着利用npm来安装cmpn，通过镜像圆来解决访问国外网站较慢的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/4.png"><br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/5.png"></p><p>接着用cmpn来安装hexo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/6.png"></p><h2 id="通过hexo搭建博客"><a href="#通过hexo搭建博客" class="headerlink" title="通过hexo搭建博客"></a>通过hexo搭建博客</h2><p>输入pwd查看当前位置</p><p>接着新建一个空白文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir blog</span><br></pre></td></tr></table></figure><p><font color =gree>PS：后续如果在搭建博客的过程中出现问题的话，可以把该文件夹删掉，再重来接下来的所有步骤</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd blog/</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/7.png"></p><p>接下来可以真正使用hexo来生成我们的博客，先初始化一个博客，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo init</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/8.png"><br>等待安装初始化完成后，启动我们的博客，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/9.png"></p><p>用浏览器打开<a href="http://localhost:4000/">http://localhost:4000/</a><br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/10.png"></p><p>接着键盘输入control+c断开连接</p><p>此时，我们可以创建一篇文章，按照顺序输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;第一篇文章&quot;</span><br><span class="line">cd source/_posts/</span><br><span class="line">ls</span><br><span class="line">vim 第一篇文章.md</span><br></pre></td></tr></table></figure><p>进入vim后可以随便输入点内容,然后保存退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure><p>接着按照顺序输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>继续用浏览器打开<a href="http://localhost:4000/%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%88%9A%E5%88%9A%E5%86%99%E7%9A%84%E5%86%85%E5%AE%B9%E4%BA%86">http://localhost:4000/，就可以看到刚刚写的内容了</a></p><h2 id="将博客部署到Github上"><a href="#将博客部署到Github上" class="headerlink" title="将博客部署到Github上"></a>将博客部署到Github上</h2><p>接下来，我们先在浏览器上登陆Github，并新建一个仓库</p><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/11.png"></p><p>然后输入Repository name<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/12.png"></p><p>Description里面可以简单写一下<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/13.png"></p><p>最后点击Creat repository<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/14.png"></p><p>接着安装git部署插件，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/15.png"></p><p>然后用vim打开config.yml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim _config.yml</span><br></pre></td></tr></table></figure><p>到文件最底部，找到# Deployment配置<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/16.png"></p><p>在type:后面写上：<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/18.png"><br>并输入:wq保存退出</p><p>PS:repo的地址在这：<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/17.png"></p><p>此时将它部署到GitHub上，，先配置git信息，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;wujianqiangCode&quot;</span><br><span class="line">git config --global user.email &quot;ijianqiangwu@outlook.com&quot;</span><br></pre></td></tr></table></figure><p>接着输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>如果出现该报错：<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/19.png"><br>github在2021年8月14日七夕这天搞事情，如果这天你提交了github代码报错如下：<br>remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.<br>那么就得换成token登陆了，坑爹！</p><p>登录自己的github账号，个人设置那里<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20.png"></p><p><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/21.png"></p><p>找到Developer seetings，点击进入配置<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/22.png"></p><p>最后点击Generate生成令牌<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/23.png"></p><p>记得把你的token保存下来，因为你再次刷新网页的时候，你已经没有办法看到它了！！！</p><p>之后就可以用自己生成的token登录，把上面生成的token粘贴到输入密码的位置，然后成功hexo d了。</p><p>此时输入<a href="https://wujianqiangcode.github.io/%E5%B0%B1%E8%83%BD%E7%9C%8B%E5%88%B0%E5%8D%9A%E5%AE%A2%E4%BA%86">https://wujianqiangcode.github.io/就能看到博客了</a></p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>接着是更换主题，浏览器输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github.com/litten/hexo-theme-yilia</span><br></pre></td></tr></table></figure><p>这边推荐可以换成🀄这个作者的主题,将他的主题仓库克隆到我们的themes&#x2F;yilia文件夹中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure><p>clone完后输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim _config.yml </span><br></pre></td></tr></table></figure><p>找到theme<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/24.png"><br>换成yilia后保存退出<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/25.png"></p><p>接着为了能够插入图片，找到post_asset_folder：<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/27.png"></p><p>改成：<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/28.png"></p><p>保存退出后，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-marked</span><br></pre></td></tr></table></figure><p>接着输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>此时登陆博客，多刷新几次后就能看到结果<br><img src="/./picture/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/26.png"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
