<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>基于NvDec+CUDA+OpenGL+NvEnc的全流程GPU加速方案 | 吴健强のBLOG</title><meta name="keywords" content="Nvidia OpenGL FFmpeg NvDec CUDA NvEnc"><meta name="author" content="吴健强"><meta name="copyright" content="吴健强"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="如何通过Nvidia提供的硬件编解码器结合OpenGL来实现全流程GPU加速">
<meta property="og:type" content="article">
<meta property="og:title" content="基于NvDec+CUDA+OpenGL+NvEnc的全流程GPU加速方案">
<meta property="og:url" content="http://example.com/2024/02/03/%E5%9F%BA%E4%BA%8ENvDec+CUDA+OpenGL+NvEnc%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8BGPU%E5%8A%A0%E9%80%9F%E6%96%B9%E6%A1%88/index.html">
<meta property="og:site_name" content="吴健强のBLOG">
<meta property="og:description" content="如何通过Nvidia提供的硬件编解码器结合OpenGL来实现全流程GPU加速">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/IronMan/5.jpg">
<meta property="article:published_time" content="2024-02-02T16:00:00.000Z">
<meta property="article:modified_time" content="2024-02-24T08:46:02.530Z">
<meta property="article:author" content="吴健强">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/IronMan/5.jpg"><link rel="shortcut icon" href="/img/IronMan/1.jpg"><link rel="canonical" href="http://example.com/2024/02/03/%E5%9F%BA%E4%BA%8ENvDec+CUDA+OpenGL+NvEnc%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8BGPU%E5%8A%A0%E9%80%9F%E6%96%B9%E6%A1%88/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '基于NvDec+CUDA+OpenGL+NvEnc的全流程GPU加速方案',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-24 16:46:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/IronMan/3.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">99</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/IronMan/2.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">吴健强のBLOG</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">基于NvDec+CUDA+OpenGL+NvEnc的全流程GPU加速方案</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-02T16:00:00.000Z" title="发表于 2024-02-03 00:00:00">2024-02-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-24T08:46:02.530Z" title="更新于 2024-02-24 16:46:02">2024-02-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="基于NvDec+CUDA+OpenGL+NvEnc的全流程GPU加速方案"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="0-介绍："><a href="#0-介绍：" class="headerlink" title="0 介绍："></a>0 介绍：</h1><p>在编解码领域中，对音视频文件进行解码编码主要有两种方式：</p>
<ul>
<li>软件解码编码</li>
<li>硬件解码编码</li>
</ul>
<p>软件解码编码实际上就是直接用CPU进行解码编码，硬件解码编码则是采用GPU进行解码编码．<br>两种方式的区别在于：GPU解码编码的效率高于CPU解码编码，但是CPU解码编码的质量确高于GPU解码编码．</p>
<p>当处理较大数据量的时候，往往会用GPU进行运算，比如OpenGL或者CUDA。在实际的操作中，往往CUDA实现并行计算会比OpenGL更加方便，而OpenGL在进行后期渲染更具有优势。由于CUDA中的运算结果存储在GPU中，如果将数据download到CPU，然后再将CPU中的数据上传到GPU，使用OpenGL进行渲染，中间的GPU与CPU的交互会很耗时，毕竟使用GPU的目的就是为了加速，这样的数据传输会降低效率。</p>
<p>所以我们在进行编解码时，在某些注重时间效率的场景下，如何提高解码渲染编码的速度，就绕开CPU，直接通过CUDA和OpenGL进行GPU全流程加速（硬件解码－＞硬件渲染－＞硬件编码），则成了我们的一个研究重点．</p>
<p>而作为GPU第一大厂的Nvidia，则刚好有一套方案满足我们的需求．<br>CUDA是Nvidia推出的一个通用GPU计算平台，对于提升并行任务的效率非常有帮助。CUDA支持与OpenGL和D3D等图形API的互操作。NVIDIA还提供了一些示例来展示它的工作原理，包括设备到主机复制和零复制（仅限设备到设备）。显然，从设备复制到主机并再次上传进行渲染会影响性能。但是所有零拷贝示例都依赖于CUDA内核将NV12转换为RGB。结果是我们必须使用nvcc编译器来构建代码，并且我们的构建环境会很复杂（CUDA7 支持在线编译器），有时是不可能的（我使用CUDA驱动程序API在任何构建环境中为所有平台构建支持CUDA的代码）。</p>
<p>是否有任何解决方案可以仅使用图形API实现零拷贝？回答是肯定的。</p>
<p>由于D3D只支持Win系统，因此接下来我们将以FFmpeg+CUDA+NvDec+OpenGL+NvEnc的方式，来演示GPU全流程</p>
<p>PS:<br>NVDEC(硬件加速的视频解码):NVIDIA GPU 包含基于硬件的解码器 (NVDEC)，可为几种热门的编解码器提供基于硬件的全加速视频解码。由于解码工作流完全卸载至 NVDEC，图形引擎和 CPU 可以有更多的时间执行其他操作。NVDEC 比实时解码速度更快，非常适合用于转码应用以及视频播放应用。借助 NVDECODE API，软件开发者能够配置此专用硬件视频解码器。此专用加速器支持在 Windows 和 Linux 平台上对以下视频编解码器进行硬件加速解码：MPEG-2、VC-1、H.264 (AVCHD)、H.265 (HEVC)、VP8、VP9 和 AV1。</p>
<p>NVENC(硬件加速的视频编码):从 Kepler 这一代开始，NVIDIA GPU 包含基于硬件的编码器（简称为 NVENC），可提供基于硬件的全加速视频编码，且独立于图形性能。由于计算复杂的编码工作流完全卸载至 NVENC，图形引擎和 CPU 可以有更多的时间执行其他操作。例如，在游戏录制和直播过程中（如使用 Open Broadcaster Software (OBS) 在 Twitch.tv 上直播），编码工作流完全卸载至 NVENC，从而使图形引擎带宽可全部用于游戏渲染。借助 NVENC，我们可以：</p>
<ul>
<li>在不使用 CPU 的情况下以高质量和超低延迟对游戏和应用进行编码和串流</li>
<li>针对存档、OTT 串流、网络视频进行高质量编码</li>
<li>以超低功耗对每个流进行编码（瓦特&#x2F;流）</li>
</ul>
<p>现在我们通过FFmpeg来介绍基于OpenGL的NVIDIA硬件解码和编码功能，从而实现一套全流程GPU的加速方案</p>
<h1 id="1-前期准备："><a href="#1-前期准备：" class="headerlink" title="1 前期准备："></a>1 前期准备：</h1><p>先阅读完NVIDIA的这个<a target="_blank" rel="noopener" href="https://docs.nvidia.com/video-technologies/video-codec-sdk/ffmpeg-with-nvidia-gpu/index.html">文档</a></p>
<p>接着进行编译工作</p>
<h2 id="1-1-安装CUDA-Toolkit"><a href="#1-1-安装CUDA-Toolkit" class="headerlink" title="1.1 安装CUDA Toolkit"></a>1.1 安装CUDA Toolkit</h2><p><a target="_blank" rel="noopener" href="https://developer.nvidia.com/cuda-downloads?target_os=Linux&target_arch=x86_64&Distribution=Ubuntu&target_version=20.04">下载CUDA Toolkit</a><br>PS:这个是Ubuntu20.04版本的，其他版本请对应下载</p>
<p><a target="_blank" rel="noopener" href="https://wujianqiangcode.github.io/2023/01/13/Linux%E7%AB%AF%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">Linux端音视频开发注意事项</a></p>
<h2 id="1-1-NVIDIA驱动程序"><a href="#1-1-NVIDIA驱动程序" class="headerlink" title="1.1 NVIDIA驱动程序"></a>1.1 NVIDIA驱动程序</h2><p><a target="_blank" rel="noopener" href="https://www.nvidia.com/Download/index.aspx?lang=en-us">下载对应的NVIDIA驱动程序</a></p>
<p><a target="_blank" rel="noopener" href="https://wujianqiangcode.github.io/2023/01/05/Linux%E4%B8%8BNvidia%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4">安装Nvidia驱动教程</a></p>
<h2 id="1-2-验证"><a href="#1-2-验证" class="headerlink" title="1.2 验证"></a>1.2 验证</h2><p>接下来来就是验证环节：</p>
<h3 id="1-2-1-验证cuda是否能正常使用"><a href="#1-2-1-验证cuda是否能正常使用" class="headerlink" title="1.2.1 验证cuda是否能正常使用"></a>1.2.1 验证cuda是否能正常使用</h3><p>下载CUDA演示样例验证是否成功安装：</p>
<p>首先在命令行窗口输入一下命令查看cuda版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>
<p>例如显示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ws@wujianqiang-ubuntu-18:~$ nvidia-smi</span><br><span class="line">Thu Jan 12 13:43:47 2023       </span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 520.61.05    Driver Version: 520.61.05    CUDA Version: 11.8     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                               |                      |               MIG M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  NVIDIA GeForce ...  On   | 00000000:65:00.0  On |                  N/A |</span><br><span class="line">|  0%   55C    P8    15W / 200W |   1250MiB /  8192MiB |      2%      Default |</span><br><span class="line">|                               |                      |                  N/A |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">                                                                               </span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                                  |</span><br><span class="line">|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |</span><br><span class="line">|        ID   ID                                                   Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">|    0   N/A  N/A      1294      G   /usr/lib/xorg/Xorg                 24MiB |</span><br><span class="line">|    0   N/A  N/A      1401      G   /usr/bin/gnome-shell               82MiB |</span><br><span class="line">|    0   N/A  N/A      1823      G   /usr/lib/xorg/Xorg                573MiB |</span><br><span class="line">|    0   N/A  N/A      1953      G   /usr/bin/gnome-shell              129MiB |</span><br><span class="line">|    0   N/A  N/A      2341      G   ...AAAAAAAAA= --shared-files       60MiB |</span><br><span class="line">|    0   N/A  N/A      2743      G   ...RendererForSitePerProcess      181MiB |</span><br><span class="line">|    0   N/A  N/A      9243      C   ...ffice/program/soffice.bin      128MiB |</span><br><span class="line">|    0   N/A  N/A     22138      G   ...377498332981217288,131072       61MiB |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>则代表cuda的版本是11.8,因此我们要将cuda-samples切换到对应版本进行编译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b v11.8 https://github.com/NVIDIA/cuda-samples.git</span><br></pre></td></tr></table></figure>
<p>注：如果make后提示找不到glut的话，输入：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install libgl1-mesa-dev</span><br><span class="line">sudo apt-get install libglu1-mesa-dev</span><br><span class="line">sudo apt-get install libglut-dev</span><br></pre></td></tr></table></figure>

<p>出现：E: 无法定位软件包 libglut-dev，执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install freeglut3-dev</span><br></pre></td></tr></table></figure>
<p>如果成功显示该画面就说明CUDA Toolkit安装成功：<br><img src="/./picture/%E5%9F%BA%E4%BA%8ENvDec+CUDA+OpenGL+NvEnc%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8BGPU%E5%8A%A0%E9%80%9F%E6%96%B9%E6%A1%88/CUDA%E6%BC%94%E7%A4%BA%E6%A0%B7%E4%BE%8B%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5.png"></p>
<h3 id="1-2-2-验证NvDec和NvEnc是否能正常使用"><a href="#1-2-2-验证NvDec和NvEnc是否能正常使用" class="headerlink" title="1.2.2 验证NvDec和NvEnc是否能正常使用"></a>1.2.2 验证NvDec和NvEnc是否能正常使用</h3><p><a target="_blank" rel="noopener" href="https://developer.nvidia.com/nvidia-video-codec-sdk/download">下载NVIDIA的Video_Codec_SDK</a></p>
<p>接着可以用cmake工具构建一下Video_Codec_SDK里面的Samples，如果能成功构建，那么就代表Nvidia的NvDec和NvEnc都安装成功了。<br><img src="/./picture/%E5%9F%BA%E4%BA%8ENvDec+CUDA+OpenGL+NvEnc%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8BGPU%E5%8A%A0%E9%80%9F%E6%96%B9%E6%A1%88/%E9%AA%8C%E8%AF%81CUDA%20Toolkit%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png"></p>
<p>PS:如果想学习Nvidia提供的Video_Codec_SDK中的样例，请查看这篇两篇文章：<br><a target="_blank" rel="noopener" href="https://wujianqiangcode.github.io/2023/01/10/NVIDIA%E7%9A%84Video_Codec_SDK%E4%B8%AD%E5%8F%82%E8%80%83%E4%BE%8B%E7%A8%8B%E7%9A%84%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BC%96%E8%AF%91Sample%E6%A0%B7%E4%BE%8B">NVIDIA的Video_Codec_SDK中参考例程的讲解（一）：编译Sample样例</a></p>
<p><a target="_blank" rel="noopener" href="https://wujianqiangcode.github.io/2023/01/12/NVIDIA%E7%9A%84Video_Codec_SDK%E4%B8%AD%E5%8F%82%E8%80%83%E4%BE%8B%E7%A8%8B%E7%9A%84%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%90%AD%E5%BB%BAAppDecGL%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83">NVIDIA的Video_Codec_SDK中参考例程的讲解（二）：搭建AppDecGL的调试环境</a></p>
<h2 id="1-3-安装FFmpeg和对应的nv-codec-headers"><a href="#1-3-安装FFmpeg和对应的nv-codec-headers" class="headerlink" title="1.3 安装FFmpeg和对应的nv-codec-headers"></a>1.3 安装FFmpeg和对应的nv-codec-headers</h2><p>由于我们进行解码操作使用还需要对音视频文件进行Demux操作，分离出视频流出来进行NvDec的硬件解码，因此，我们还需要使用第三方软件(如FFMPEG)进行Demux操作，所以我们还要下载一下FFmpeg进行编译</p>
<p>接着下载FFmpeg以及与Nvidia编解码器API接口所需的FFmpeg版本的标头</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone -b release/xx  https://git.ffmpeg.org/ffmpeg.git</span><br><span class="line">git clone -b sdk/xx https://github.com/FFmpeg/nv-codec-headers.git</span><br></pre></td></tr></table></figure>

<h1 id="2-具体解码流程步骤"><a href="#2-具体解码流程步骤" class="headerlink" title="2 具体解码流程步骤"></a>2 具体解码流程步骤</h1><p>首先我们根据Nvidia官方的<a target="_blank" rel="noopener" href="https://docs.nvidia.com/video-technologies/video-codec-sdk/nvdec-video-decoder-api-prog-guide/index.html">NVDEC API</a>指南进行学习．</p>
<p>其硬件解码流程，具体过程如下所示：</p>
<ul>
<li>初始化设置</li>
<li>创建CUDA上下文</li>
<li>查询硬件解码器解码能力</li>
<li>创建解码器实例</li>
<li>使用第三方软件(如FFMPEG)进行Demux</li>
<li>使用NVDECODE API提供的解析器或第三方解析器（如FFmpeg）解析视频比特流</li>
<li>使用NVDECODE API启动解码</li>
<li>获取解码后的YUV进行进一步处理</li>
<li>查询解码帧状态</li>
<li>根据解码状态，使用解码后的输出进行进一步的处理(如渲染、后处理等)<br>  如果应用程序需要显示输出：<br>- a、将解码后的YUV转化为RGB格式<br>- b、将RGB映射到DirectX或OpenGL纹理<br>- c、将纹理绘制到屏幕上</li>
<li>在译码过程完成后销毁解码器实例</li>
<li>销毁CUDA上下文</li>
</ul>
<h2 id="2-1-初始化设置"><a href="#2-1-初始化设置" class="headerlink" title="2.1 初始化设置"></a>2.1 初始化设置</h2><p>首先进行初始化，需要初始化的地方有三个：</p>
<ul>
<li>加载对应头文件和动态库</li>
<li>CUDA初始化</li>
<li>解码器初始化</li>
</ul>
<h3 id="2-1-1-加载对应头文件和动态库"><a href="#2-1-1-加载对应头文件和动态库" class="headerlink" title="2.1.1 加载对应头文件和动态库"></a>2.1.1 加载对应头文件和动态库</h3><p>根据官方的操作指南提示：所有 NVDECODE API 都暴露在两个头文件中：cuviddec.h和 nvcuvid.h. 这两个文件可以在Nvidia提供的Video_Codec_SDK包中的Interface文件夹中找到。NVIDIA的Video_Codec_SDK中的示例静态加载库（作为 Windows SDK 包的一部分提供）函数并包括cuviddec.h和 nvcuvid.h在源文件中。Windows DLLnvcuvid.dll 包含在适用于 Windows 的 NVIDIA 显示驱动程序中。Linux 库 libnvcuvid.so包含在用于 Linux 的 NVIDIA 显示驱动程序中。</p>
<p>我们在工程中一般是通过动态库的方式进行加载：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cuviddec.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nvcuvid.h&quot;</span></span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">	<span class="type">void</span>* hrnvcuda = <span class="built_in">LoadLibrary</span>(<span class="string">L&quot;NVCUDA.DLL&quot;</span>);</span><br><span class="line">	<span class="type">void</span>* hrnvcuvid = <span class="built_in">LoadLibrary</span>(<span class="string">L&quot;NVCUVID.DLL&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__    </span></span><br><span class="line">    <span class="type">void</span>* hrnvcuda = <span class="built_in">dlopen</span>(<span class="string">&quot;libcuda.so&quot;</span>,RTLD_LAZY );</span><br><span class="line">    <span class="type">void</span>* hrnvcuvid = <span class="built_in">dlopen</span>(<span class="string">&quot;libnvcuvid.so&quot;</span>,RTLD_LAZY );</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>    </span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-CUDA初始化"><a href="#2-1-2-CUDA初始化" class="headerlink" title="2.1.2 CUDA初始化"></a>2.1.2 CUDA初始化</h3><p>在cuda的api中，采用的是cuda.h中的cuInit进行初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CUresult CUDAAPI <span class="title">cuInit</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里的flags目前必须给0，对于cuda的所有函数，必须先调用cuInit，否则其他API都会返CUDA_ERROR_NOT_INITIALIZED．<br>但是我们在实际的生成开发环境中，只调用cuInit进行初始化是远远不够的，因此在我们下载的nv-codec-headers的include文件夹的dynlink_cuda.h文件中对这个函数进行了一层封装：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cuInit</span>(<span class="type">unsigned</span> <span class="type">int</span> Flags, <span class="type">int</span> cudaVersion, <span class="type">void</span> *pHandleDriver,<span class="type">int</span> dxtype);</span><br></pre></td></tr></table></figure>
<p>该封装的函数除了调用cuInit进行初始化以外，还做了两件事：</p>
<ul>
<li>调用cuDriverGetVersion函数得到此时设备的cuda驱动版本信息，从而针对性的进行对应版本的相关函数的加载</li>
<li>通过设定的宏和输入参数类型，来确定是加载cuGraphicsGLRegisterImage等cuda和OpenGL交互的接口还是cuda和哪个版本的DX交互的接口</li>
</ul>
<p><font color =red>注：没有对应的cuDestroy，不需要释放，程序销毁自动释放；</font></p>
<h4 id="相关参数的具体含义："><a href="#相关参数的具体含义：" class="headerlink" title="相关参数的具体含义："></a>相关参数的具体含义：</h4><h5 id="Flags："><a href="#Flags：" class="headerlink" title="Flags："></a>Flags：</h5><p>目前，Flags参数必须为 0。如果尚未调用cuInit()，则驱动程序 API 中的任何函数都将返回CUDA_ERROR_NOT_INITIALIZED。</p>
<h5 id="cudaVersion：："><a href="#cudaVersion：：" class="headerlink" title="cudaVersion：："></a>cudaVersion：：</h5><p>这个值直接设计成0就行，我们用不到v2接口,所以也不需要指定cudaVersion来针对性进行_v2相关接口的加载，只需要加载默认的接口就可以了</p>
<h5 id="pHandleDriver："><a href="#pHandleDriver：" class="headerlink" title="pHandleDriver："></a>pHandleDriver：</h5><p>CUDADRIVER cudadriver &#x3D; 0;<br>将cudadriver作为参数传递进去，函数内部会将cuda驱动的句柄值赋值给cudadriver（这个值对我们实际应用时，一般用不到，因此无需特别在意）</p>
<h5 id="dxtype："><a href="#dxtype：" class="headerlink" title="dxtype："></a>dxtype：</h5><p>该参数只在Win下调用DX的时候使用，如果用OpenGL的话，该参数无实际含义,只需记得打开INIT_CUDA_GL这个宏即可。</p>
<p>注意需要根据使用的DX类型和宏的开关与否进行参数设置。</p>
<p>可设置dxtype结构体为:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">D3DX_SUPPORT_TYPE</span></span><br><span class="line">&#123;</span><br><span class="line">    SUPPORT_D3D9EX,</span><br><span class="line">    SUPPORT_D3D10,</span><br><span class="line">    SUPPORT_D3D11,</span><br><span class="line">    SUPPORT_UNKOWN,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过宏和dxtype来针对性的进行初始化设置的具体代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> INIT_CUDA_GL</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cuInitGL</span>(<span class="number">0</span>, __CUDA_API_VERSION, CudaDrvLib) != CUDA_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> CUDA_ERROR_INVALID_DEVICE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> INIT_CUDA_D3D9</span></span><br><span class="line">	<span class="keyword">if</span> (dxtype == <span class="number">0</span> &amp;&amp;  <span class="built_in">cuInitD3D9</span>(<span class="number">0</span>, __CUDA_API_VERSION, CudaDrvLib) != CUDA_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> CUDA_ERROR_INVALID_DEVICE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> INIT_CUDA_D3D10</span></span><br><span class="line">	<span class="keyword">if</span> (dxtype == <span class="number">1</span> &amp;&amp; <span class="built_in">cuInitD3D10</span>(<span class="number">0</span>, __CUDA_API_VERSION, CudaDrvLib) != CUDA_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> CUDA_ERROR_INVALID_DEVICE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> INIT_CUDA_D3D11</span></span><br><span class="line">	<span class="keyword">if</span> (dxtype == <span class="number">2</span> &amp;&amp; <span class="built_in">cuInitD3D11</span>(<span class="number">0</span>, __CUDA_API_VERSION, CudaDrvLib) != CUDA_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> CUDA_ERROR_INVALID_DEVICE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-3-解码器初始化"><a href="#2-1-3-解码器初始化" class="headerlink" title="2.1.3 解码器初始化"></a>2.1.3 解码器初始化</h3><p>同样的，我们对NvDec解码器也得进行初始化操作．我们调用的还是之前下载的nv-codec-headers的include文件夹中的dynlink_nvcuvid.h文件里的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CUresult  CUDAAPI <span class="title">cuvidInit</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们可以看下dynlink_nvcuvid.cpp中这个函数的源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CUresult CUDAAPI <span class="title">cuvidInit</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLLDRIVER DriverLib;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CHECKED_CALL</span>(<span class="built_in">LOAD_LIBRARY</span>(&amp;DriverLib));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fetch all function pointers</span></span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCreateVideoSource);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCreateVideoSourceW);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidDestroyVideoSource);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidSetVideoSourceState);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidGetVideoSourceState);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidGetSourceVideoFormat);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidGetSourceAudioFormat);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCreateVideoParser);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidParseVideoData);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidDestroyVideoParser);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCreateDecoder);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidDestroyDecoder);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidDecodePicture);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(WIN64) || defined(_WIN64) || defined(__x86_64) || defined(AMD64) || defined(_M_AMD64)</span></span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidMapVideoFrame64);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidUnmapVideoFrame64);</span><br><span class="line">    cuvidMapVideoFrame #  = cuvidMapVideoFrame64;</span><br><span class="line">    cuvidUnmapVideoFrame = cuvidUnmapVideoFrame64;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidMapVideoFrame);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidUnmapVideoFrame);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    GET_PROC(cuvidGetVideoFrameSurface);</span></span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCtxLockCreate);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCtxLockDestroy);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCtxLock);</span><br><span class="line">    <span class="built_in">GET_PROC</span>(cuvidCtxUnlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CUDA_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出其实就做了一件事情，就是加载对应的函数接口．其中输入参数Flags默认设置为0就行了</p>
<h2 id="2-2-创建CUDA上下文"><a href="#2-2-创建CUDA上下文" class="headerlink" title="2.2 创建CUDA上下文"></a>2.2 创建CUDA上下文</h2><p>通过2.1的步骤，我们已经将该加载的h文件和动态库文件都加载了，对应的接口函数我们也都加载完成了，接下来就是对cuda进行创建了，而在创建cuda之前，我们需要对电脑的硬件进行检测，我们得知道是哪个型号的gpu后，才能进行CUDA上下文的创建．</p>
<h3 id="2-2-1-显卡设备信息的获取以及显卡的选择"><a href="#2-2-1-显卡设备信息的获取以及显卡的选择" class="headerlink" title="2.2.1 显卡设备信息的获取以及显卡的选择"></a>2.2.1 显卡设备信息的获取以及显卡的选择</h3><p>首先我们要知道设备有多少张显卡，通过cuDeviceGetCount(int *count)函数，得到设备的显卡数量。<br>具体API定义如下(nv-codec-headers的include文件夹中的dynlink_cuda.h文件里)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuDeviceGetCount</span><span class="params">(<span class="type">int</span> *count)</span></span>;</span><br><span class="line">tcuDeviceGetCount                     *cuDeviceGetCount;</span><br></pre></td></tr></table></figure>

<p>接着我们需要得到这些显卡的具体信息。</p>
<p>此时就用到cuDeviceGet和cuDeviceGetName函数；<br>其中cuDeviceGet通过for循环输入1～count来得到每张显卡设备的设备句柄：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcuDeviceGet                          *cuDeviceGet;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuDeviceGet</span><span class="params">(CUdevice *device, <span class="type">int</span> ordinal)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="相关参数的具体含义：-1"><a href="#相关参数的具体含义：-1" class="headerlink" title="相关参数的具体含义："></a>相关参数的具体含义：</h4><h5 id="device："><a href="#device：" class="headerlink" title="device："></a>device：</h5><p>设备句柄</p>
<h5 id="ordinal："><a href="#ordinal：" class="headerlink" title="ordinal："></a>ordinal：</h5><p>设备id号</p>
<p>cuDeviceGetName通过输入设备句柄得到每张显卡的名称</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuDeviceGetName</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> len, CUdevice dev)</span></span>;</span><br><span class="line">tcuDeviceGetName                      *cuDeviceGetName;</span><br></pre></td></tr></table></figure>
<p>相关参数信息：</p>
<h5 id="dev："><a href="#dev：" class="headerlink" title="dev："></a>dev：</h5><p>设备句柄</p>
<h5 id="len："><a href="#len：" class="headerlink" title="len："></a>len：</h5><p>默认输入为256</p>
<p>然后调用helper_cuda_drvapi.h文件中的checkCudaCapabilitiesDRV函数，来进行CUDA GPU SM功能的常规检查</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">checkCudaCapabilitiesDRV</span>(<span class="type">int</span> major_version, <span class="type">int</span> minor_version, <span class="type">int</span> devID)</span><br></pre></td></tr></table></figure>
<p>Streaming Multiprocessor (SM)的具体含义参考这篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/asasasaababab/article/details/80447254">文章</a></p>
<p><font color = red>注：major_version和minor_version默认输入为1，若想了解checkCudaCapabilitiesDRV函数的具体实现，详见helper_cuda_drvapi.h文件。</font></p>
<p>最后调用cuDeviceGetAttribute来返回返回有关设备的信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuDeviceGetAttribute</span><span class="params">(<span class="type">int</span> *pi, CUdevice_attribute attrib, CUdevice dev)</span></span>;</span><br><span class="line">tcuDeviceGetAttribute           *cuDeviceGetAttribute;</span><br></pre></td></tr></table></figure>

<h4 id="相关参数的具体含义：-2"><a href="#相关参数的具体含义：-2" class="headerlink" title="相关参数的具体含义："></a>相关参数的具体含义：</h4><h5 id="pi"><a href="#pi" class="headerlink" title="pi:"></a>pi:</h5><p>返回设备属性值</p>
<h5 id="attrib"><a href="#attrib" class="headerlink" title="attrib:"></a>attrib:</h5><p>要查询的设备属性，详见dynlink_cuda_cuda.h文件的CUdevice_attribute_enum结构体内容</p>
<h5 id="dev"><a href="#dev" class="headerlink" title="dev:"></a>dev:</h5><p>设备句柄</p>
<hr>
<p>这里有个使用技巧，通过checkCUDADecodecErrors来接收各个API接口返回的CUresult值，从而查看是否成功调用各API接口。<br>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">checkCUDADecodecErrors</span>(<span class="built_in">cuDeviceGetAttribute</span>(xx,xx,xx)))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<hr>
<p>此时经过上面步骤后，我们已经成功获取到了每一张NVIDIA显卡设备的相关信息，紧接着我们就需要从中挑选出性能最好的一张来使用。</p>
<p>我们可以通过<a target="_blank" rel="noopener" href="https://github.com/NVIDIA/cuda-samples/blob/master/Common/helper_cuda_drvapi.h">helper_cuda_drvapi.h文件</a>的gpuGetMaxGflopsGLDeviceIdDRV函数，来挑选出最好的一张显卡。当我们调用<br>gpuGetMaxGflopsGLDeviceIdDRV()函数时，返回的值是最佳显卡的id值，此时我们再调用cuDeviceGet函数，将id值作为输入参数，即可得到该张显卡的设备句柄。</p>
<p>接着我们调用cuDeviceComputeCapability函数查看一下这张最佳显卡的算力情况，以及通过cuDeviceTotalMem返回设备上的内存总量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuDeviceComputeCapability</span><span class="params">(<span class="type">int</span> *major, <span class="type">int</span> *minor, CUdevice dev)</span></span>;</span><br><span class="line">tcuDeviceComputeCapability            *cuDeviceComputeCapability;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __CUDA_API_VERSION &gt;= 3020</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuDeviceTotalMem</span><span class="params">(<span class="type">size_t</span> *bytes, CUdevice dev)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuDeviceTotalMem</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *bytes, CUdevice dev)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">tcuDeviceTotalMem                     *cuDeviceTotalMem;</span><br></pre></td></tr></table></figure>
<h4 id="相关参数的具体设置："><a href="#相关参数的具体设置：" class="headerlink" title="相关参数的具体设置："></a>相关参数的具体设置：</h4><h5 id="major、minor：："><a href="#major、minor：：" class="headerlink" title="major、minor：："></a>major、minor：：</h5><p>在major和minor中返回定义设备dev计算能力的主要和次要修订号</p>
<h5 id="dev：-1"><a href="#dev：-1" class="headerlink" title="dev："></a>dev：</h5><p>设备句柄</p>
<h3 id="2-2-2-创建CUDA上下文"><a href="#2-2-2-创建CUDA上下文" class="headerlink" title="2.2.2 创建CUDA上下文"></a>2.2.2 创建CUDA上下文</h3><p>当我们完成上面步骤后，我们就可以创建CUDA上下文咯！</p>
<p>在低CUDA版本我们需要将这张显卡与OpenGL的互操作性创建CUDA上下文，此时调用cuGLCtxCreate函数进行最终的CUDA上下文的创建</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult CUDAAPI <span class="title">tcuGLCtxCreate</span><span class="params">(CUcontext *pCtx, <span class="type">unsigned</span> <span class="type">int</span> Flags, CUdevice device)</span></span>;</span><br><span class="line">tcuGLCtxCreate                        *cuGLCtxCreate;</span><br></pre></td></tr></table></figure>
<h4 id="相关参数的具体设置：-1"><a href="#相关参数的具体设置：-1" class="headerlink" title="相关参数的具体设置："></a>相关参数的具体设置：</h4><h5 id="pCtx："><a href="#pCtx：" class="headerlink" title="pCtx："></a>pCtx：</h5><p>返回所创建的CUDA上下文</p>
<h5 id="Flags：-1"><a href="#Flags：-1" class="headerlink" title="Flags："></a>Flags：</h5><p>CUDA 上下文创建选项，默认输入：CU_CTX_SCHED_BLOCKING_SYNC</p>
<h5 id="CUdevice："><a href="#CUdevice：" class="headerlink" title="CUdevice："></a>CUdevice：</h5><p>创建的上下文的设备句柄</p>
<p>在Nvidia的cuda<a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1g931f6d260d7db412b37497cb4b2fdf5d">操作文档</a>中也有写到：</p>
<h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="Deprecated"></a>Deprecated</h4><p>This function is deprecated as of Cuda 3.0.</p>
<h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>Maps the buffer object specified by buffer into the address space of the current CUDA context and returns in *dptr and *size the base pointer and size of the resulting mapping.</p>
<p>There must be a valid OpenGL context bound to the current thread when this function is called. This must be the same context, or a member of the same shareGroup, as the context that was bound when the buffer was registered.</p>
<p>All streams in the current CUDA context are synchronized with the current GL context.</p>
<h4 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h4><p>Note that this function may also return error codes from previous, asynchronous launches.</p>
<p>因此在CUDA版本大于5的时候，我们就不需要专门去调用这个接口了，而是直接采用cuCtxCreate接口进行上下文创建：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuCtxCreate</span><span class="params">(CUcontext *pctx, <span class="type">unsigned</span> <span class="type">int</span> flags, CUdevice dev)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> tcuCtxCreate                    *cuCtxCreate;</span><br></pre></td></tr></table></figure>
<h4 id="相关参数的具体设置：-2"><a href="#相关参数的具体设置：-2" class="headerlink" title="相关参数的具体设置："></a>相关参数的具体设置：</h4><h5 id="pCtx：-1"><a href="#pCtx：-1" class="headerlink" title="pCtx："></a>pCtx：</h5><p>返回所创建的CUDA上下文</p>
<h5 id="Flags：-2"><a href="#Flags：-2" class="headerlink" title="Flags："></a>Flags：</h5><p>CUDA 上下文创建选项，默认输入：CU_CTX_SCHED_BLOCKING_SYNC</p>
<h5 id="CUdevice：-1"><a href="#CUdevice：-1" class="headerlink" title="CUdevice："></a>CUdevice：</h5><p>创建的上下文的设备句柄，也就是我们之前通过gpuGetMaxGflopsGLDeviceIdDRV拿到的最好设备的id号后，再将该id号作为输入参数设置到cuDeviceGet函数中得到的对应的dev值</p>
<h3 id="2-2-3-验证CUDA上下文是否成功创建以及当前上下文可用的内存总量是否充足"><a href="#2-2-3-验证CUDA上下文是否成功创建以及当前上下文可用的内存总量是否充足" class="headerlink" title="2.2.3 验证CUDA上下文是否成功创建以及当前上下文可用的内存总量是否充足"></a>2.2.3 验证CUDA上下文是否成功创建以及当前上下文可用的内存总量是否充足</h3><p>按道理，此时我们已经完成了CUDA上下文的创建，但是为了保险起见，我们还需要验证一下</p>
<p>接着从当前CPU线程中弹出当前CUDA上下文，看一下是否已经成功创建了，如果成功的话，我们再将其push进去。</p>
<p>cuCtxPushCurrent():将给定的上下文ctx推送到CPU线程的当前上下文堆栈中。指定的上下文成为CPU线程的当前上下文，因此所有对当前上下文进行操作的CUDA函数都会受到影响。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuCtxPopCurrent</span><span class="params">(CUcontext *pctx)</span></span>;</span><br><span class="line">tcuCtxPopCurrent                      *cuCtxPopCurrent;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult  CUDAAPI <span class="title">tcuCtxPushCurrent</span><span class="params">(CUcontext ctx)</span></span>;</span><br><span class="line">tcuCtxPushCurrent                     *cuCtxPushCurrent;</span><br></pre></td></tr></table></figure>

<p>然后我们通过cuMemGetInfo函数得到可用内存和总内存（以字节为单位）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult CUDAAPI <span class="title">tcuMemGetInfo</span><span class="params">(<span class="type">size_t</span> *free, <span class="type">size_t</span> *total)</span></span>;</span><br><span class="line">tcuMemGetInfo                         *cuMemGetInfo;</span><br></pre></td></tr></table></figure>
<p>在total中返回当前上下文可用的内存总量。在free中返回设备上根据操作系统空闲的内存量。不保证 CUDA 能够分配操作系统报告为空闲的所有内存。在多原则的情况下，返回的空闲估计容易出现竞争条件，在估计和报告空闲内存之间由不同进程或同一进程中的不同线程完成的新分配&#x2F;释放，将导致偏差报告的可用值和实际可用内存。</p>
<p>Tegra 上的集成 GPU 与 CPU 和 SoC 的其他组件共享内存。API 返回的可用值和总值不包括某些平台上操作系统维护的 SWAP 内存空间。当 GPU 或 CPU 分配或访问内存时，操作系统可能会将一些内存页面移动到交换区域。请参阅 Tegra 应用说明，了解如何计算 Tegra 上的总内存和可用内存。</p>
<p>当满足可用内存不小于300<em>1024</em>1024，总内存不小于512 <em>1024</em>1024时，我们认为此时是足够用的（这边可以用if语句来判断，满足则返回true，不满足则返回false）。</p>
<p>此时为了为了方便多线程实现，我们调用dynlink_nvcuvid.h中的cuvidCtxLockCreate函数来进行上下文的锁定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult CUDAAPI <span class="title">tcuvidCtxLockCreate</span><span class="params">(CUvideoctxlock *pLock, CUcontext ctx)</span></span>;</span><br><span class="line">tcuvidCtxLockCreate                   *cuvidCtxLockCreate;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-查询硬件解码器解码能力"><a href="#2-3-查询硬件解码器解码能力" class="headerlink" title="2.3 查询硬件解码器解码能力"></a>2.3 查询硬件解码器解码能力</h2><p>不同的GPU包含不同的能力. 因此，为了确保你的应用能在所有的GPU硬件上运行，很有必要查询硬件能力(当然你也可以调过这个流程，反正解不了就崩嘛，没啥区别)，然后根据所需的能力是否满足进行合适的操作</p>
<p>可以参考NVIDIA的Video_Codec_SDK中的NvDecoder.cpp中的HandleVideoSequence函数内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">CUVIDDECODECAPS decodecaps;</span><br><span class="line"><span class="built_in">memset</span>(&amp;decodecaps, <span class="number">0</span>, <span class="built_in">sizeof</span>(decodecaps));</span><br><span class="line"></span><br><span class="line">decodecaps.eCodecType = pVideoFormat-&gt;codec;</span><br><span class="line">decodecaps.eChromaFormat = pVideoFormat-&gt;chroma_format;</span><br><span class="line">decodecaps.nBitDepthMinus8 = pVideoFormat-&gt;bit_depth_luma_minus8;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPushCurrent</span>(m_cuContext)); <span class="comment">//启用context</span></span><br><span class="line"><span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidGetDecoderCaps</span>(&amp;decodecaps));</span><br><span class="line"><span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!decodecaps.bIsSupported)&#123;</span><br><span class="line">    <span class="built_in">NVDEC_THROW_ERROR</span>(<span class="string">&quot;Codec not supported on this GPU&quot;</span>, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">    <span class="keyword">return</span> nDecodeSurface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pVideoFormat-&gt;coded_width &gt; decodecaps.nMaxWidth) ||</span><br><span class="line">    (pVideoFormat-&gt;coded_height &gt; decodecaps.nMaxHeight))&#123;</span><br><span class="line"></span><br><span class="line">    std::ostringstream errorString;</span><br><span class="line">    errorString &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;Resolution          : &quot;</span> &lt;&lt; pVideoFormat-&gt;coded_width &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; pVideoFormat-&gt;coded_height &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;Max Supported (wxh) : &quot;</span> &lt;&lt; decodecaps.nMaxWidth &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; decodecaps.nMaxHeight &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;Resolution not supported on this GPU&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::string cErr = errorString.<span class="built_in">str</span>();</span><br><span class="line">    <span class="built_in">NVDEC_THROW_ERROR</span>(cErr, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">    <span class="keyword">return</span> nDecodeSurface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pVideoFormat-&gt;coded_width&gt;&gt;<span class="number">4</span>)*(pVideoFormat-&gt;coded_height&gt;&gt;<span class="number">4</span>) &gt; decodecaps.nMaxMBCount)&#123;</span><br><span class="line"></span><br><span class="line">    std::ostringstream errorString;</span><br><span class="line">    errorString &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;MBCount             : &quot;</span> &lt;&lt; (pVideoFormat-&gt;coded_width &gt;&gt; <span class="number">4</span>)*(pVideoFormat-&gt;coded_height &gt;&gt; <span class="number">4</span>) &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;Max Supported mbcnt : &quot;</span> &lt;&lt; decodecaps.nMaxMBCount &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;MBCount not supported on this GPU&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::string cErr = errorString.<span class="built_in">str</span>();</span><br><span class="line">    <span class="built_in">NVDEC_THROW_ERROR</span>(cErr, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">    <span class="keyword">return</span> nDecodeSurface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_nWidth &amp;&amp; m_nLumaHeight &amp;&amp; m_nChromaHeight) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cuvidCreateDecoder() has been called before, and now there&#x27;s possible config change</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ReconfigureDecoder</span>(pVideoFormat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// eCodec has been set in the constructor (for parser). Here it&#x27;s set again for potential correction</span></span><br><span class="line">m_eCodec = pVideoFormat-&gt;codec;</span><br><span class="line">m_eChromaFormat = pVideoFormat-&gt;chroma_format;</span><br><span class="line">m_nBitDepthMinus8 = pVideoFormat-&gt;bit_depth_luma_minus8;</span><br><span class="line">m_nBPP = m_nBitDepthMinus8 &gt; <span class="number">0</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the output surface format same as chroma format</span></span><br><span class="line"><span class="keyword">if</span> (m_eChromaFormat == cudaVideoChromaFormat_420 || cudaVideoChromaFormat_Monochrome)</span><br><span class="line">    m_eOutputFormat = pVideoFormat-&gt;bit_depth_luma_minus8 ? cudaVideoSurfaceFormat_P016 : cudaVideoSurfaceFormat_NV12;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_eChromaFormat == cudaVideoChromaFormat_444)</span><br><span class="line">    m_eOutputFormat = pVideoFormat-&gt;bit_depth_luma_minus8 ? cudaVideoSurfaceFormat_YUV444_16Bit : cudaVideoSurfaceFormat_YUV444;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_eChromaFormat == cudaVideoChromaFormat_422)</span><br><span class="line">    m_eOutputFormat = cudaVideoSurfaceFormat_NV12;  <span class="comment">// no 4:2:2 output format supported yet so make 420 default</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if output format supported. If not, check falback options</span></span><br><span class="line"><span class="keyword">if</span> (!(decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; m_eOutputFormat)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_NV12))</span><br><span class="line">        m_eOutputFormat = cudaVideoSurfaceFormat_NV12;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_P016))</span><br><span class="line">        m_eOutputFormat = cudaVideoSurfaceFormat_P016;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_YUV444))</span><br><span class="line">        m_eOutputFormat = cudaVideoSurfaceFormat_YUV444;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_YUV444_16Bit))</span><br><span class="line">        m_eOutputFormat = cudaVideoSurfaceFormat_YUV444_16Bit;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">NVDEC_THROW_ERROR</span>(<span class="string">&quot;No supported output format found&quot;</span>, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">&#125;</span><br><span class="line">m_videoFormat = *pVideoFormat;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-创建解码器实例"><a href="#2-4-创建解码器实例" class="headerlink" title="2.4 创建解码器实例"></a>2.4 创建解码器实例</h2><p>分为两个部分：</p>
<ul>
<li>CUVIDDECODECREATEINFO信息的获取</li>
<li>创建视频解码器</li>
</ul>
<h3 id="2-4-1-CUVIDDECODECREATEINFO信息的获取"><a href="#2-4-1-CUVIDDECODECREATEINFO信息的获取" class="headerlink" title="2.4.1 CUVIDDECODECREATEINFO信息的获取"></a>2.4.1 CUVIDDECODECREATEINFO信息的获取</h3><p>首先我们需要进行CUVIDDECODECREATEINFO信息的填充。CUVIDDECODECREATEINFO结构如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* \struct CUVIDDECODECREATEINFO</span></span><br><span class="line"><span class="comment">* Struct used in create decoder</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CUVIDDECODECREATEINFO</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulWidth;              <span class="comment">/**&lt; Coded Sequence Width */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulHeight;             <span class="comment">/**&lt; Coded Sequence Height */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulNumDecodeSurfaces;  <span class="comment">/**&lt; Maximum number of internal decode surfaces */</span></span><br><span class="line">    cudaVideoCodec CodecType;           <span class="comment">/**&lt; cudaVideoCodec_XXX */</span></span><br><span class="line">    cudaVideoChromaFormat ChromaFormat; <span class="comment">/**&lt; cudaVideoChromaFormat_XXX (only 4:2:0 is currently supported) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulCreationFlags;      <span class="comment">/**&lt; Decoder creation flags (cudaVideoCreateFlags_XXX解析器的创建;         /**&lt; Reserved for future use - set to zero */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * area of the frame thcuvidCreateDecoderat should be displayed</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">short</span> left;</span><br><span class="line">        <span class="type">short</span> top;</span><br><span class="line">        <span class="type">short</span> right;</span><br><span class="line">        <span class="type">short</span> bottom;</span><br><span class="line">    &#125; display_area;</span><br><span class="line">    cudaVideoSurfaceFormat OutputFormat;       <span class="comment">/**&lt; cudaVideoSurfaceFormat_XXX */</span></span><br><span class="line">    cudaVideoDeinterlaceMode DeinterlaceMode;  <span class="comment">/**&lt; cudaVideoDeinterlaceMode_XXX */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulTargetWidth;               <span class="comment">/**&lt; Post-processed Output Width (Should be aligned to 2) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulTargetHeight;              <span class="comment">/**&lt; Post-processed Output Height (Should be aligbed to 2) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulNumOutputSurfaces;         <span class="comment">/**&lt; Maximum number of output surfaces simultaneously mapped */</span></span><br><span class="line">    CUvideoctxlock vidLock;                    <span class="comment">/**&lt; If non-NULL, context lock used for synchronizing ownership of the cuda context */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * target rectangle in the output frame (for aspect ratio conversion)</span></span><br><span class="line"><span class="comment">    * if a null rectangle is specified, &#123;0,0,ulTargetWidth,ulTargetHeight&#125; will be used</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">short</span> left;</span><br><span class="line">        <span class="type">short</span> top;</span><br><span class="line">        <span class="type">short</span> right;</span><br><span class="line">        <span class="type">short</span> bottom;</span><br><span class="line">    &#125; target_rect;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> Reserved2[<span class="number">5</span>];                <span class="comment">/**&lt; Reserved for future use - set to zero */</span></span><br><span class="line">&#125; CUVIDDECODECREATEINFO;</span><br></pre></td></tr></table></figure>
<h4 id="相关参数具体设置："><a href="#相关参数具体设置：" class="headerlink" title="相关参数具体设置："></a>相关参数具体设置：</h4><h5 id="ulWidth、ulHeight："><a href="#ulWidth、ulHeight：" class="headerlink" title="ulWidth、ulHeight："></a>ulWidth、ulHeight：</h5><p>通过解码得到的视频流信息来获取，与视频文件的宽高保持一致</p>
<h5 id="ulNumDecodeSurfaces："><a href="#ulNumDecodeSurfaces：" class="headerlink" title="ulNumDecodeSurfaces："></a>ulNumDecodeSurfaces：</h5><p>默认值为：MAX_FRAME_COUNT（这是驱动程序将在内部分配用于存储解码帧的表面数。使用更高的数字可确保更好的流水线，但会增加 GPU 内存消耗。为了正确操作，最小值定义在 CUVIDEOFORMAT::min_num_decode_surfaces并且可以从 Nvidia 解析器的第一个序列回调中获得。NVDEC 引擎将解码数据写入这些表面之一。NVDECODE API 的用户无法访问这些表面，但 映射阶段（包括解码器输出格式转换、缩放、裁剪等）使用这些表面作为输入表面。）</p>
<h5 id="CodecType："><a href="#CodecType：" class="headerlink" title="CodecType："></a>CodecType：</h5><p>CodecType需要根据文件的FourCC来进行确认。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* \enum cudaVideoCodec</span></span><br><span class="line"><span class="comment">* Video Codec Enums</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">cudaVideoCodec_enum</span> &#123;</span><br><span class="line">    cudaVideoCodec_MPEG1=<span class="number">0</span>,                 <span class="comment">/**&lt;  MPEG1   */</span></span><br><span class="line">    cudaVideoCodec_MPEG2, <span class="number">4</span>                  <span class="comment">/**&lt;  HEVC   */</span></span><br><span class="line">    cudaVideoCodec_VP8,                     <span class="comment">/**&lt;  VP8   */</span></span><br><span class="line">    cudaVideoCodec_VP9,                     <span class="comment">/**&lt;  VP9   */</span></span><br><span class="line">    cudaVideoCodec_NumCodecs,               <span class="comment">/**&lt;  Max COdecs   */</span></span><br><span class="line">    <span class="comment">// Uncompressed YUV</span></span><br><span class="line">    cudaVideoCodec_YUV420 = ((<span class="string">&#x27;I&#x27;</span>&lt;&lt;<span class="number">24</span>)|(<span class="string">&#x27;Y&#x27;</span>&lt;&lt;<span class="number">16</span>)|(<span class="string">&#x27;U&#x27;</span>&lt;&lt;<span class="number">8</span>)|(<span class="string">&#x27;V&#x27;</span>)),   <span class="comment">/**&lt; Y,U,V (4:2:0)  */</span></span><br><span class="line">    cudaVideoCodec_YV12   = ((<span class="string">&#x27;Y&#x27;</span>&lt;&lt;<span class="number">24</span>)|(<span class="string">&#x27;V&#x27;</span>&lt;&lt;<span class="number">16</span>)|(<span class="string">&#x27;1&#x27;</span>&lt;&lt;<span class="number">8</span>)|(<span class="string">&#x27;2&#x27;</span>)),   <span class="comment">/**&lt; Y,V,U (4:2:0)  */</span></span><br><span class="line">    cudaVideoCodec_NV12   = ((<span class="string">&#x27;N&#x27;</span>&lt;&lt;<span class="number">24</span>)|(<span class="string">&#x27;V&#x27;</span>&lt;&lt;<span class="number">16</span>)|(<span class="string">&#x27;1&#x27;</span>&lt;&lt;<span class="number">8</span>)|(<span class="string">&#x27;2&#x27;</span>)),   <span class="comment">/**&lt; Y,UV  (4:2:0)  */</span></span><br><span class="line">    cudaVideoCodec_YUYV   = ((<span class="string">&#x27;Y&#x27;</span>&lt;&lt;<span class="number">24</span>)|(<span class="string">&#x27;U&#x27;</span>&lt;&lt;<span class="number">16</span>)|(<span class="string">&#x27;Y&#x27;</span>&lt;&lt;<span class="number">8</span>)|(<span class="string">&#x27;V&#x27;</span>)),   <span class="comment">/**&lt; YUYV/YUY2 (4:2:2)  */</span></span><br><span class="line">    cudaVideoCodec_UYVY   = ((<span class="string">&#x27;U&#x27;</span>&lt;&lt;<span class="number">24</span>)|(<span class="string">&#x27;Y&#x27;</span>&lt;&lt;<span class="number">16</span>)|(<span class="string">&#x27;V&#x27;</span>&lt;&lt;<span class="number">8</span>)|(<span class="string">&#x27;Y&#x27;</span>))    <span class="comment">/**&lt; UYVY (4:2:2)  */</span></span><br><span class="line">&#125; cudaVideoCodec;</span><br></pre></td></tr></table></figure>

<p>我们一般只需要通过FourCC来区分Cuda支持的这四种解码类型：</p>
<ul>
<li>H264（FourCC:’462H’、’462T’、’462X’、’ CVA’、’1CVA’、’1cva’）</li>
<li>H265（FourCC:’2VPM’）</li>
<li>MPEG2（FourCC:’CVEH’）</li>
<li>VP9（FourCC:’ 9PV’）</li>
</ul>
<p>其余的根据实际应用场景也可以进行适当的增加。</p>
<h5 id="ChromaFormat："><a href="#ChromaFormat：" class="headerlink" title="ChromaFormat："></a>ChromaFormat：</h5><p>默认设置为：cudaVideoChromaFormat_420</p>
<h5 id="ulCreationFlags："><a href="#ulCreationFlags：" class="headerlink" title="ulCreationFlags："></a>ulCreationFlags：</h5><p>默认设置为：cudaVideoCreate_PreferCUVID</p>
<p>接下来是CUVIDDECODECREATEINFO内一些输出格式的相关参数设置</p>
<h5 id="OutputFormat："><a href="#OutputFormat：" class="headerlink" title="OutputFormat："></a>OutputFormat：</h5><p>默认设置为：cudaVideoSurfaceFoCreatOpenGLTextruermat_NV12</p>
<h5 id="DeinterlaceMode："><a href="#DeinterlaceMode：" class="headerlink" title="DeinterlaceMode："></a>DeinterlaceMode：</h5><p>默认设置为：cudaVideoDeinterlaceMode_Weave</p>
<h5 id="bitDepthMinus8："><a href="#bitDepthMinus8：" class="headerlink" title="bitDepthMinus8："></a>bitDepthMinus8：</h5><p>该参数需要根据文件的bitdepth来进行设置。<br>如果不小30,设置为2,否则设置为0</p>
<h5 id="ulTargetWidth，ulTargetHeight："><a href="#ulTargetWidth，ulTargetHeight：" class="headerlink" title="ulTargetWidth，ulTargetHeight："></a>ulTargetWidth，ulTargetHeight：</h5><p>ulTargetWidth，ulTargetHeight与ulWidth、ulHeight的值一致<br>即：ulTargetWidth &#x3D; ulWidth；ulTargetWidth &#x3D; ulHeight；</p>
<h5 id="ulNumOutputSurfaces："><a href="#ulNumOutputSurfaces：" class="headerlink" title="ulNumOutputSurfaces："></a>ulNumOutputSurfaces：</h5><p>默认为2（这是用户将同时映射到解码表面以进行进一步处理 的输出表面的最大数量cuvidMapVideoFrame()。这些表面具有经过后处理的解码输出以供用户使用。驱动程序在内部分配相应数量的表面。用户将有权访问输出表面。请参阅准备解码帧以进行进一步处理以了解map的定义。）</p>
<h5 id="vidLock："><a href="#vidLock：" class="headerlink" title="vidLock："></a>vidLock：</h5><p>该参数值为之前调用cuvidCtxLockCreate函数得到的pLock</p>
<h4 id="target-rect"><a href="#target-rect" class="headerlink" title="target_rect:"></a>target_rect:</h4><p>arget_rect.left &#x3D; 0;<br>target_rect.top &#x3D; 0;<br>target_rect.right &#x3D; ulWidth;<br>target_rect.bottom &#x3D; ulHeight;</p>
<p><a target="_blank" rel="noopener" href="https://www.ffmpeg.org/doxygen/3.3/structCUVIDDECODECREATEINFO.html">CUVIDDECODECREATEINFO 结构参考</a></p>
<h3 id="2-4-2-创建视频解码器"><a href="#2-4-2-创建视频解码器" class="headerlink" title="2.4.2 创建视频解码器"></a>2.4.2 创建视频解码器</h3><p>然后调用cuvidCreateDecoder进行解码器的创建</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult CUDAAPI <span class="title">tcuvidCreateDecoder</span><span class="params">(CUvideodecoder *phDecoder, CUVIDDECODECREATEINFO *pdci)</span></span>;</span><br><span class="line">tcuvidCreateDecoder                   *cuvidCreateDecoder;</span><br></pre></td></tr></table></figure>



<h2 id="2-5-使用第三方软件-如FFMPEG-进行Demux"><a href="#2-5-使用第三方软件-如FFMPEG-进行Demux" class="headerlink" title="2.5 使用第三方软件(如FFMPEG)进行Demux"></a>2.5 使用第三方软件(如FFMPEG)进行Demux</h2><p>分为以下几个步骤：</p>
<ul>
<li>获取MediaInfo信息</li>
<li>创建解复用器</li>
<li>拿到额外数据信息</li>
<li>根据FourCC创建对应的硬件解码器</li>
<li>将其Seek到初始位置0<br>在Nvidia官方的<a target="_blank" rel="noopener" href="https://docs.nvidia.com/video-technologies/video-codec-sdk/nvdec-video-decoder-api-prog-guide/index.html">NVDEC API</a>指南中，它采用的是cuvidCreateVideoParser()来创建解析器，而在我们实际的工程开发过程中，我们一般都是采用FFMPEG来进行音视频文件的Demux．<br>因此在解复用器这一块，我们以调用FFmpeg的API为准．<br>而调用FFmpeg进行Demux的基本流程可以参考NVIDIA的Video_Codec_SDK示例AppDecGL中FFmpegDemuxer类的创建:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Demux 解析,获得每一帧码流的数据存在pVideo中,nVideoBytes为数据的字节数</span></span><br><span class="line"><span class="comment">//Demux将pVideo存储的地址值改变为pkt.data，即改变了pVideo指向的地址！！！</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Demux</span><span class="params">(<span class="type">uint8_t</span> **ppVideo, <span class="type">int</span> *pnVideoBytes, <span class="type">int64_t</span> *pts = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!fmtc) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *pnVideoBytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pkt.data) &#123;</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(&amp;pkt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> e = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = <span class="built_in">av_read_frame</span>(fmtc, &amp;pkt)) &gt;= <span class="number">0</span> &amp;&amp; pkt.stream_index != iVideoStream) &#123;</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(&amp;pkt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bMp4H264 || bMp4HEVC) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pktFiltered.data) &#123;</span><br><span class="line">                <span class="built_in">av_packet_unref</span>(&amp;pktFiltered);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ck</span>(<span class="built_in">av_bsf_send_packet</span>(bsfc, &amp;pkt));</span><br><span class="line">            <span class="built_in">ck</span>(<span class="built_in">av_bsf_receive_packet</span>(bsfc, &amp;pktFiltered));</span><br><span class="line">            *ppVideo = pktFiltered.data;</span><br><span class="line">            *pnVideoBytes = pktFiltered.size;</span><br><span class="line">            <span class="keyword">if</span> (pts)</span><br><span class="line">                *pts = (<span class="type">int64_t</span>) (pktFiltered.pts * userTimeScale * timeBase);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bMp4MPEG4 &amp;&amp; (frameCount == <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> extraDataSize = fmtc-&gt;streams[iVideoStream]-&gt;codecpar-&gt;extradata_size;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (extraDataSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// extradata contains start codes 00 00 01. Subtract its size</span></span><br><span class="line">                    pDataWithHeader = (<span class="type">uint8_t</span> *)<span class="built_in">av_malloc</span>(extraDataSize + pkt.size - <span class="number">3</span>*<span class="built_in">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!pDataWithHeader) &#123;</span><br><span class="line">                        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;FFmpeg error: &quot;</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; __LINE__;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">memcpy</span>(pDataWithHeader, fmtc-&gt;streams[iVideoStream]-&gt;codecpar-&gt;extradata, extraDataSize);</span><br><span class="line">                    <span class="built_in">memcpy</span>(pDataWithHeader+extraDataSize, pkt.data+<span class="number">3</span>, pkt.size - <span class="number">3</span>*<span class="built_in">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line"></span><br><span class="line">                    *ppVideo = pDataWithHeader;</span><br><span class="line">                    *pnVideoBytes = extraDataSize + pkt.size - <span class="number">3</span>*<span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *ppVideo = pkt.data;</span><br><span class="line">                *pnVideoBytes = pkt.size;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pts)</span><br><span class="line">                *pts = (<span class="type">int64_t</span>)(pkt.pts * userTimeScale * timeBase);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        frameCount++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ReadPacket</span><span class="params">(<span class="type">void</span> *opaque, <span class="type">uint8_t</span> *pBuf, <span class="type">int</span> nBuf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((DataProvider *)opaque)-&gt;<span class="built_in">GetData</span>(pBuf, nBuf);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-6-使用NVDECODE-API提供的解析器或第三方解析器（如FFmpeg）解析视频比特流"><a href="#2-6-使用NVDECODE-API提供的解析器或第三方解析器（如FFmpeg）解析视频比特流" class="headerlink" title="2.6 使用NVDECODE API提供的解析器或第三方解析器（如FFmpeg）解析视频比特流"></a>2.6 使用NVDECODE API提供的解析器或第三方解析器（如FFmpeg）解析视频比特流</h2><p>在这里直接采用的是NVDECODE API提供的解析器来解析视频比特流．</p>
<p>分为以下几个部分：</p>
<ul>
<li>CUVIDPARSERPARAMS信息的获取</li>
<li>相关回调函数的设计</li>
<li>解析器的创建</li>
<li>从解复用器提取数据包进行解码</li>
</ul>
<h3 id="2-6-1-CUVIDPARSERPARAMS信息的获取"><a href="#2-6-1-CUVIDPARSERPARAMS信息的获取" class="headerlink" title="2.6.1 CUVIDPARSERPARAMS信息的获取"></a>2.6.1 CUVIDPARSERPARAMS信息的获取</h3><p>首先创建一个CUVIDPARSERPARAMS类型的变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dynlink_nvcuvid.h文件中定义</span></span><br><span class="line"><span class="comment">/***********************************************************************************************************************/</span></span><br><span class="line"><span class="comment">//! Parser callbacks</span></span><br><span class="line"><span class="comment">//! The parser will call these synchronously from within cuvidParseVideoData(), whenever there is sequence change or a picture</span></span><br><span class="line"><span class="comment">//! is ready to be decoded and/or displayed. First argument in functions is &quot;void *pUserData&quot; member of structure CUVIDSOURCEPARAMS</span></span><br><span class="line"><span class="comment">//! Return values from these callbacks are interpreted as below. If the callbacks return failure, it will be propagated by</span></span><br><span class="line"><span class="comment">//! cuvidParseVideoData() to the application.</span></span><br><span class="line"><span class="comment">//! Parser picks default operating point as 0 and outputAllLayers flag as 0 if PFNVIDOPPOINTCALLBACK is not set or return value is</span></span><br><span class="line"><span class="comment">//! -1 or invalid operating point.</span></span><br><span class="line"><span class="comment">//! PFNVIDSEQUENCECALLBACK : 0: fail, 1: succeeded, &gt; 1: override dpb size of parser (set by CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces</span></span><br><span class="line"><span class="comment">//! while creating parser)</span></span><br><span class="line"><span class="comment">//! PFNVIDDECODECALLBACK   : 0: fail, &gt;=1: succeeded</span></span><br><span class="line"><span class="comment">//! PFNVIDDISPLAYCALLBACK  : 0: fail, &gt;=1: succeeded</span></span><br><span class="line"><span class="comment">//! PFNVIDOPPOINTCALLBACK  : &lt;0: fail, &gt;=0: succeeded (bit 0-9: OperatingPoint, bit 10-10: outputAllLayers, bit 11-30: reserved)</span></span><br><span class="line"><span class="comment">//! PFNVIDSEIMSGCALLBACK   : 0: fail, &gt;=1: succeeded</span></span><br><span class="line"><span class="comment">/***********************************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(CUDAAPI *PFNVIDSEQUENCECALLBACK)</span><span class="params">(<span class="type">void</span> *, CUVIDEOFORMAT *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(CUDAAPI *PFNVIDDECODECALLBACK)</span><span class="params">(<span class="type">void</span> *, CUVIDPICPARAMS *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(CUDAAPI *PFNVIDDISPLAYCALLBACK)</span><span class="params">(<span class="type">void</span> *, CUVIDPARSERDISPINFO *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(CUDAAPI *PFNVIDOPPOINTCALLBACK)</span><span class="params">(<span class="type">void</span> *, CUVIDOPERATINGPOINTINFO*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(CUDAAPI *PFNVIDSEIMSGCALLBACK)</span> <span class="params">(<span class="type">void</span> *, CUVIDSEIMESSAGEINFO *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CUVIDPARSERPARAMS</span></span><br><span class="line">&#123;</span><br><span class="line">    cudaVideoCodec CodecType;                   <span class="comment">/**&lt; IN: cudaVideoCodec_XXX                                                  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ulMaxNumDecodeSurfaces;        <span class="comment">/**&lt; IN: Max # of decode surfaces (parser will cycle through these)          */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ulClockRate;                   <span class="comment">/**&lt; IN: Timestamp units in Hz (0=default=10000000Hz)                        */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ulErrorThreshold;              <span class="comment">/**&lt; IN: % Error threshold (0-100) for calling pfnDecodePicture (100=always</span></span><br><span class="line"><span class="comment">                                                     IN: call pfnDecodePicture even if picture bitstream is fully corrupted) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ulMaxDisplayDelay;             <span class="comment">/**&lt; IN: Max display queue delay (improves pipelining of decode with display)</span></span><br><span class="line"><span class="comment">                                                         0=no delay (recommended values: 2..4)                               */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bAnnexb : <span class="number">1</span>;                   <span class="comment">/**&lt; IN: AV1 annexB stream                                                   */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uReserved : <span class="number">31</span>;                <span class="comment">/**&lt; Reserved for future use - set to zero                                   */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uReserved1[<span class="number">4</span>];                 <span class="comment">/**&lt; IN: Reserved for future use - set to 0                                  */</span></span><br><span class="line">    <span class="type">void</span> *pUserData;                            <span class="comment">/**&lt; IN: User data for callbacks                                             */</span></span><br><span class="line">    PFNVIDSEQUENCECALLBACK pfnSequenceCallback; <span class="comment">/**&lt; IN: Called before decoding frames and/or whenever there is a fmt change */</span></span><br><span class="line">    PFNVIDDECODECALLBACK pfnDecodePicture;      <span class="comment">/**&lt; IN: Called when a picture is ready to be decoded (decode order)         */</span></span><br><span class="line">    PFNVIDDISPLAYCALLBACK pfnDisplayPicture;    <span class="comment">/**&lt; IN: Called whenever a picture is ready to be displayed (display order)  */</span></span><br><span class="line">    PFNVIDOPPOINTCALLBACK pfnGetOperatingPoint; <span class="comment">/**&lt; IN: Called from AV1 sequence header to get operating point of a AV1</span></span><br><span class="line"><span class="comment">                                                         scalable bitstream                                                  */</span></span><br><span class="line">    PFNVIDSEIMSGCALLBACK pfnGetSEIMsg;          <span class="comment">/**&lt; IN: Called when all SEI messages are parsed for particular frame        */</span></span><br><span class="line">    <span class="type">void</span> *pvReserved2[<span class="number">5</span>];                       <span class="comment">/**&lt; Reserved for future use - set to NULL                                   */</span></span><br><span class="line">    CUVIDEOFORMATEX *pExtVideoInfo;             <span class="comment">/**&lt; IN: [Optional] sequence header data from system layer                   */</span></span><br><span class="line">&#125; CUVIDPARSERPARAMS;</span><br></pre></td></tr></table></figure>
<h4 id="相关参数具体设置：-1"><a href="#相关参数具体设置：-1" class="headerlink" title="相关参数具体设置："></a>相关参数具体设置：</h4><h5 id="CodecType"><a href="#CodecType" class="headerlink" title="CodecType"></a>CodecType</h5><p>与前面的CUVIDDECODECREATEINFO中的CodecType保持一致（必须来自枚举 cudaVideoCodec, 指示内容的编解码器类型，如 H.264、HEVC、VP9 等）</p>
<h5 id="ulMaxNumDecodeSurfaces"><a href="#ulMaxNumDecodeSurfaces" class="headerlink" title="ulMaxNumDecodeSurfaces"></a>ulMaxNumDecodeSurfaces</h5><p>与前面的CUVIDDECODECREATEINFO中的ulNumDecodeSurfaces保持一致（这是解析器的 DPB（解码图片缓冲区）中的表面数。该值在解析器初始化时可能是未知的，可以将其设置为虚拟数字（如 1）以创建解析器对象。应用程序必须注册回调pfn序列回调与驱动程序一起使用，当解析器遇到第一个序列头或序列中的任何更改时，解析器将调用它。此回调报告解析器的 DPB 正确解码所需的最小表面数 CUVIDEOFORMAT::min_num_decode_surfaces. 如果想要更新，序列回调可能会将此值返回给解析器 CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces. 然后解析器覆盖CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces与序列回调返回的值，如果序列回调的返回值大于 1（见说明pfn序列回调以下）。因此，为了优化内存分配，解码器对象的创建应该推迟到CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces是已知的，因此可以使用所需数量的缓冲区创建解码器对象，这样 CUVIDDECODECREATEINFO::ulNumDecodeSurfaces&#x3D; CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces）</p>
<h5 id="ulClockRate："><a href="#ulClockRate：" class="headerlink" title="ulClockRate："></a>ulClockRate：</h5><p>默认为0</p>
<h5 id="ulErrorThreshold"><a href="#ulErrorThreshold" class="headerlink" title="ulErrorThreshold"></a>ulErrorThreshold</h5><p>默认为0</p>
<h5 id="ulMaxDisplayDelay"><a href="#ulMaxDisplayDelay" class="headerlink" title="ulMaxDisplayDelay"></a>ulMaxDisplayDelay</h5><p>最大显示回调延迟。0 &#x3D; 无延迟，一设置0或者1,稳妥点也可以设置为2</p>
<h5 id="uReserved1-5"><a href="#uReserved1-5" class="headerlink" title="uReserved1[5]"></a>uReserved1[5]</h5><p>默认全为0(0&#x3D;default&#x3D;10000000Hz)</p>
<h5 id="pUserData"><a href="#pUserData" class="headerlink" title="pUserData"></a>pUserData</h5><p>回调函数</p>
<h5 id="pfnSequenceCallback"><a href="#pfnSequenceCallback" class="headerlink" title="pfnSequenceCallback"></a>pfnSequenceCallback</h5><p>pfnSequenceCallback是parser解析到序列及图像参数信息时的回调函数，其传入的参数是parser解析好的视频参数，可以用于初始化解码器或重置解码器。<br>应用程序必须注册一个函数来处理任何序列更改。解析器为初始序列头或遇到视频格式更改时触发此回调。序列回调的返回值由驱动程序解释如下：</p>
<ul>
<li>0：失败</li>
<li>1：成功，但驱动程序不应覆盖 CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces</li>
<li>&gt;1：成功，驱动程序应该覆盖 CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces有了这个返回值</li>
</ul>
<h5 id="pfnDecodePicture"><a href="#pfnDecodePicture" class="headerlink" title="pfnDecodePicture"></a>pfnDecodePicture</h5><p>pfnDecodePicture是parser解析到视频编码数据后的回调函数，其传入的参数parser处理好待解码的视频编码数据，需要在该函数中调用decoder的接口进行解码操作。<br>当一帧的比特流数据准备就绪时，解析器触发此回调。在场图片的情况下，每个显示调用可能有两个解码调用，因为两个场构成一个帧。此回调的返回值解释为：</p>
<ul>
<li>0：失败</li>
<li>≥1：成功</li>
</ul>
<h5 id="pfnDisplayPicture"><a href="#pfnDisplayPicture" class="headerlink" title="pfnDisplayPicture"></a>pfnDisplayPicture</h5><p>pfnDisplayPicture是parser对解码后的数据处理的回调函数，可以在该回调中对已解码的数据进行获取（从显存到系统内存）并处理。<br>当显示顺序中的帧准备就绪时，解析器触发此回调。此回调的返回值解释为：</p>
<ul>
<li>0：失败</li>
<li>≥1：成功</li>
</ul>
<h5 id="pvReserved2"><a href="#pvReserved2" class="headerlink" title="pvReserved2"></a>pvReserved2</h5><p>默认为0</p>
<h5 id="pExtVideoInfo"><a href="#pExtVideoInfo" class="headerlink" title="pExtVideoInfo"></a>pExtVideoInfo</h5><p>默认为NULL</p>
<h5 id="pfnGetOperatingPoint（只针对avi）"><a href="#pfnGetOperatingPoint（只针对avi）" class="headerlink" title="pfnGetOperatingPoint（只针对avi）"></a>pfnGetOperatingPoint（只针对avi）</h5><h5 id="pfnGetSEIMsg-一般用不到"><a href="#pfnGetSEIMsg-一般用不到" class="headerlink" title="pfnGetSEIMsg(一般用不到)"></a>pfnGetSEIMsg(一般用不到)</h5><p>当一帧所有未注册的用户 SEI 消息或元数据 OBU 被解析时，解析器按解码顺序触发此回调。目前此回调支持 H264、HEVC 和 AV1 编解码器。此回调的返回值解释为：</p>
<ul>
<li>0：失败</li>
<li>≥1：成功</li>
</ul>
<h3 id="2-6-2-相关回调函数的设计"><a href="#2-6-2-相关回调函数的设计" class="headerlink" title="2.6.2 相关回调函数的设计"></a>2.6.2 相关回调函数的设计</h3><p>上面三个回调函数的设置的非常重要的，如果不清楚回调函数需要实现的具体内容，可以参考NVIDIA的Video_Codec_SDK中的NvDecoder.cpp的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">NvDecoder::<span class="built_in">NvDecoder</span>(CUcontext cuContext, <span class="type">bool</span> bUseDeviceFrame, cudaVideoCodec eCodec, <span class="type">bool</span> bLowLatency, </span><br><span class="line">    <span class="type">bool</span> bDeviceFramePitched, <span class="type">const</span> Rect *pCropRect, <span class="type">const</span> Dim *pResizeDim, <span class="type">int</span> maxWidth, <span class="type">int</span> maxHeight, <span class="type">unsigned</span> <span class="type">int</span> clkRate,</span><br><span class="line">    <span class="type">bool</span> force_zero_latency) :</span><br><span class="line">    <span class="built_in">m_cuContext</span>(cuContext), <span class="built_in">m_bUseDeviceFrame</span>(bUseDeviceFrame), <span class="built_in">m_eCodec</span>(eCodec), <span class="built_in">m_bDeviceFramePitched</span>(bDeviceFramePitched),</span><br><span class="line">    <span class="built_in">m_nMaxWidth</span> (maxWidth), <span class="built_in">m_nMaxHeight</span>(maxHeight), <span class="built_in">m_bForce_zero_latency</span>(force_zero_latency)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pCropRect) m_cropRect = *pCropRect;</span><br><span class="line">    <span class="keyword">if</span> (pResizeDim) m_resizeDim = *pResizeDim;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidCtxLockCreate</span>(&amp;m_ctxLock, cuContext));</span><br><span class="line"></span><br><span class="line">    decoderSessionID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CUVIDPARSERPARAMS：该接口用来创建VideoParser</span></span><br><span class="line">    <span class="comment">//主要参数是设置三个回调函数，实现对解析出来的数据的处理</span></span><br><span class="line">    CUVIDPARSERPARAMS videoParserParameters = &#123;&#125;;<span class="comment">//结构体</span></span><br><span class="line">    videoParserParameters.CodecType = eCodec; <span class="comment">//解码视频类型，如H264</span></span><br><span class="line">    videoParserParameters.ulMaxNumDecodeSurfaces = <span class="number">1</span>;<span class="comment">//解码表面的最大数量（解析器将循环遍历这些表面）</span></span><br><span class="line">    videoParserParameters.ulClockRate = clkRate;<span class="comment">//1000</span></span><br><span class="line">    videoParserParameters.ulMaxDisplayDelay = bLowLatency ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    videoParserParameters.pUserData = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//三个回调函数</span></span><br><span class="line">    videoParserParameters.pfnSequenceCallback = HandleVideoSequenceProc;<span class="comment">//解码序列时调用</span></span><br><span class="line">    videoParserParameters.pfnDecodePicture = HandlePictureDecodeProc;<span class="comment">//准备开始解码时调用</span></span><br><span class="line">    videoParserParameters.pfnDisplayPicture = m_bForce_zero_latency ? <span class="literal">NULL</span> : HandlePictureDisplayProc;<span class="comment">//解码出数据调用</span></span><br><span class="line"></span><br><span class="line">    videoParserParameters.pfnGetOperatingPoint = HandleOperatingPointProc;<span class="comment">//这个是新增的回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Create video parser object and initialize</span></span><br><span class="line">    <span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidCreateVideoParser</span>(&amp;m_hParser, &amp;videoParserParameters));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们通过NVIDIA的Video_Codec_SDK中的NvDecoder.cpp来着重讲解一下这几个回调函数应该怎么样去设计！！！</p>
<h4 id="2-6-2-1-pfnSequenceCallback回调函数的设计"><a href="#2-6-2-1-pfnSequenceCallback回调函数的设计" class="headerlink" title="2.6.2.1 pfnSequenceCallback回调函数的设计"></a>2.6.2.1 pfnSequenceCallback回调函数的设计</h4><p>这个回调函数是在解码序列时才会被调用．</p>
<p>整个HandleVideoSequence函数其实主要分为几个步骤：</p>
<ul>
<li>相关结构体参数的数据填充</li>
<li>调用cuvidGetDecoderCaps接口来查询解码帧的状态</li>
<li>调用cuvidCreateDecoder接口来创建视频解码器</li>
</ul>
<p><font color = red >而这两个步骤，其实就是我们在前面2.4章节所说的，所以只要把2.4章节的步骤操作封装成一个函数，然后赋值给pfnSequenceCallback回调函数就可以了！！！</font></p>
<p>具体可以参考例程中的HandleVideoSequence函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return value from HandleVideoSequence() are interpreted as   :</span></span><br><span class="line"><span class="comment">*  0: fail, 1: succeeded, &gt; 1: override dpb size of parser (set by CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces while creating parser)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NvDecoder::HandleVideoSequence</span><span class="params">(CUVIDEOFORMAT *pVideoFormat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    START_TIMER</span><br><span class="line">    m_videoInfo.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    m_videoInfo.<span class="built_in">clear</span>();</span><br><span class="line">    m_videoInfo &lt;&lt; <span class="string">&quot;Video Input Information&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tCodec        : &quot;</span> &lt;&lt; <span class="built_in">GetVideoCodecString</span>(pVideoFormat-&gt;codec) &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tFrame rate   : &quot;</span> &lt;&lt; pVideoFormat-&gt;frame_rate.numerator &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; pVideoFormat-&gt;frame_rate.denominator</span><br><span class="line">            &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; <span class="number">1.0</span> * pVideoFormat-&gt;frame_rate.numerator / pVideoFormat-&gt;frame_rate.denominator &lt;&lt; <span class="string">&quot; fps&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tSequence     : &quot;</span> &lt;&lt; (pVideoFormat-&gt;progressive_sequence ? <span class="string">&quot;Progressive&quot;</span> : <span class="string">&quot;Interlaced&quot;</span>) &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tCoded size   : [&quot;</span> &lt;&lt; pVideoFormat-&gt;coded_width &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pVideoFormat-&gt;coded_height &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tDisplay area : [&quot;</span> &lt;&lt; pVideoFormat-&gt;display_area.left &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pVideoFormat-&gt;display_area.top &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">            &lt;&lt; pVideoFormat-&gt;display_area.right &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pVideoFormat-&gt;display_area.bottom &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tChroma       : &quot;</span> &lt;&lt; <span class="built_in">GetVideoChromaFormatString</span>(pVideoFormat-&gt;chroma_format) &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tBit depth    : &quot;</span> &lt;&lt; pVideoFormat-&gt;bit_depth_luma_minus8 + <span class="number">8</span></span><br><span class="line">    ;</span><br><span class="line">    m_videoInfo &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nDecodeSurface = pVideoFormat-&gt;min_num_decode_surfaces;</span><br><span class="line"></span><br><span class="line">    CUVIDDECODECAPS decodecaps;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;decodecaps, <span class="number">0</span>, <span class="built_in">sizeof</span>(decodecaps));</span><br><span class="line"></span><br><span class="line">    decodecaps.eCodecType = pVideoFormat-&gt;codec;</span><br><span class="line">    decodecaps.eChromaFormat = pVideoFormat-&gt;chroma_format;</span><br><span class="line">    decodecaps.nBitDepthMinus8 = pVideoFormat-&gt;bit_depth_luma_minus8;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPushCurrent</span>(m_cuContext)); <span class="comment">//启用context</span></span><br><span class="line">    <span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidGetDecoderCaps</span>(&amp;decodecaps));</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!decodecaps.bIsSupported)&#123;</span><br><span class="line">        <span class="built_in">NVDEC_THROW_ERROR</span>(<span class="string">&quot;Codec not supported on this GPU&quot;</span>, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">        <span class="keyword">return</span> nDecodeSurface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pVideoFormat-&gt;coded_width &gt; decodecaps.nMaxWidth) ||</span><br><span class="line">        (pVideoFormat-&gt;coded_height &gt; decodecaps.nMaxHeight))&#123;</span><br><span class="line"></span><br><span class="line">        std::ostringstream errorString;</span><br><span class="line">        errorString &lt;&lt; std::endl</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;Resolution          : &quot;</span> &lt;&lt; pVideoFormat-&gt;coded_width &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; pVideoFormat-&gt;coded_height &lt;&lt; std::endl</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;Max Supported (wxh) : &quot;</span> &lt;&lt; decodecaps.nMaxWidth &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; decodecaps.nMaxHeight &lt;&lt; std::endl</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;Resolution not supported on this GPU&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> std::string cErr = errorString.<span class="built_in">str</span>();</span><br><span class="line">        <span class="built_in">NVDEC_THROW_ERROR</span>(cErr, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">        <span class="keyword">return</span> nDecodeSurface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pVideoFormat-&gt;coded_width&gt;&gt;<span class="number">4</span>)*(pVideoFormat-&gt;coded_height&gt;&gt;<span class="number">4</span>) &gt; decodecaps.nMaxMBCount)&#123;</span><br><span class="line"></span><br><span class="line">        std::ostringstream errorString;</span><br><span class="line">        errorString &lt;&lt; std::endl</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;MBCount             : &quot;</span> &lt;&lt; (pVideoFormat-&gt;coded_width &gt;&gt; <span class="number">4</span>)*(pVideoFormat-&gt;coded_height &gt;&gt; <span class="number">4</span>) &lt;&lt; std::endl</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;Max Supported mbcnt : &quot;</span> &lt;&lt; decodecaps.nMaxMBCount &lt;&lt; std::endl</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;MBCount not supported on this GPU&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> std::string cErr = errorString.<span class="built_in">str</span>();</span><br><span class="line">        <span class="built_in">NVDEC_THROW_ERROR</span>(cErr, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">        <span class="keyword">return</span> nDecodeSurface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_nWidth &amp;&amp; m_nLumaHeight &amp;&amp; m_nChromaHeight) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cuvidCreateDecoder() has been called before, and now there&#x27;s possible config change</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ReconfigureDecoder</span>(pVideoFormat);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// eCodec has been set in the constructor (for parser). Here it&#x27;s set again for potential correction</span></span><br><span class="line">    m_eCodec = pVideoFormat-&gt;codec;</span><br><span class="line">    m_eChromaFormat = pVideoFormat-&gt;chroma_format;</span><br><span class="line">    m_nBitDepthMinus8 = pVideoFormat-&gt;bit_depth_luma_minus8;</span><br><span class="line">    m_nBPP = m_nBitDepthMinus8 &gt; <span class="number">0</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the output surface format same as chroma format</span></span><br><span class="line">    <span class="keyword">if</span> (m_eChromaFormat == cudaVideoChromaFormat_420 || cudaVideoChromaFormat_Monochrome)</span><br><span class="line">        m_eOutputFormat = pVideoFormat-&gt;bit_depth_luma_minus8 ? cudaVideoSurfaceFormat_P016 : cudaVideoSurfaceFormat_NV12;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_eChromaFormat == cudaVideoChromaFormat_444)</span><br><span class="line">        m_eOutputFormat = pVideoFormat-&gt;bit_depth_luma_minus8 ? cudaVideoSurfaceFormat_YUV444_16Bit : cudaVideoSurfaceFormat_YUV444;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_eChromaFormat == cudaVideoChromaFormat_422)</span><br><span class="line">        m_eOutputFormat = cudaVideoSurfaceFormat_NV12;  <span class="comment">// no 4:2:2 output format supported yet so make 420 default</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if output format supported. If not, check falback options</span></span><br><span class="line">    <span class="keyword">if</span> (!(decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; m_eOutputFormat)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_NV12))</span><br><span class="line">            m_eOutputFormat = cudaVideoSurfaceFormat_NV12;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_P016))</span><br><span class="line">            m_eOutputFormat = cudaVideoSurfaceFormat_P016;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_YUV444))</span><br><span class="line">            m_eOutputFormat = cudaVideoSurfaceFormat_YUV444;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (decodecaps.nOutputFormatMask &amp; (<span class="number">1</span> &lt;&lt; cudaVideoSurfaceFormat_YUV444_16Bit))</span><br><span class="line">            m_eOutputFormat = cudaVideoSurfaceFormat_YUV444_16Bit;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">NVDEC_THROW_ERROR</span>(<span class="string">&quot;No supported output format found&quot;</span>, CUDA_ERROR_NOT_SUPPORTED);</span><br><span class="line">    &#125;</span><br><span class="line">    m_videoFormat = *pVideoFormat;</span><br><span class="line"></span><br><span class="line">    CUVIDDECODECREATEINFO videoDecodeCreateInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    videoDecodeCreateInfo.CodecType = pVideoFormat-&gt;codec;</span><br><span class="line">    videoDecodeCreateInfo.ChromaFormat = pVideoFormat-&gt;chroma_format;</span><br><span class="line">    videoDecodeCreateInfo.OutputFormat = m_eOutputFormat;</span><br><span class="line">    videoDecodeCreateInfo.bitDepthMinus8 = pVideoFormat-&gt;bit_depth_luma_minus8;</span><br><span class="line">    <span class="keyword">if</span> (pVideoFormat-&gt;progressive_sequence)</span><br><span class="line">        videoDecodeCreateInfo.DeinterlaceMode = cudaVideoDeinterlaceMode_Weave;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        videoDecodeCreateInfo.DeinterlaceMode = cudaVideoDeinterlaceMode_Adaptive;</span><br><span class="line">    videoDecodeCreateInfo.ulNumOutputSurfaces = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// With PreferCUVID, JPEG is still decoded by CUDA while video is decoded by NVDEC hardware</span></span><br><span class="line">    videoDecodeCreateInfo.ulCreationFlags = cudaVideoCreate_PreferCUVID;</span><br><span class="line">    videoDecodeCreateInfo.ulNumDecodeSurfaces = nDecodeSurface;</span><br><span class="line">    videoDecodeCreateInfo.vidLock = m_ctxLock;</span><br><span class="line">    videoDecodeCreateInfo.ulWidth = pVideoFormat-&gt;coded_width;</span><br><span class="line">    videoDecodeCreateInfo.ulHeight = pVideoFormat-&gt;coded_height;</span><br><span class="line">    <span class="comment">// AV1 has max width/height of sequence in sequence header</span></span><br><span class="line">    <span class="keyword">if</span> (pVideoFormat-&gt;codec == cudaVideoCodec_AV1 &amp;&amp; pVideoFormat-&gt;seqhdr_data_length &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// dont overwrite if it is already set from cmdline or reconfig.txt</span></span><br><span class="line">        <span class="keyword">if</span> (!(m_nMaxWidth &gt; pVideoFormat-&gt;coded_width || m_nMaxHeight &gt; pVideoFormat-&gt;coded_height))</span><br><span class="line">        &#123;</span><br><span class="line">            CUVIDEOFORMATEX *vidFormatEx = (CUVIDEOFORMATEX *)pVideoFormat;</span><br><span class="line">            m_nMaxWidth = vidFormatEx-&gt;av1.max_width;</span><br><span class="line">            m_nMaxHeight = vidFormatEx-&gt;av1.max_height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_nMaxWidth &lt; (<span class="type">int</span>)pVideoFormat-&gt;coded_width)</span><br><span class="line">        m_nMaxWidth = pVideoFormat-&gt;coded_width;</span><br><span class="line">    <span class="keyword">if</span> (m_nMaxHeight &lt; (<span class="type">int</span>)pVideoFormat-&gt;coded_height)</span><br><span class="line">        m_nMaxHeight = pVideoFormat-&gt;coded_height;</span><br><span class="line">    videoDecodeCreateInfo.ulMaxWidth = m_nMaxWidth;</span><br><span class="line">    videoDecodeCreateInfo.ulMaxHeight = m_nMaxHeight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(m_cropRect.r &amp;&amp; m_cropRect.b) &amp;&amp; !(m_resizeDim.w &amp;&amp; m_resizeDim.h)) &#123;</span><br><span class="line">        m_nWidth = pVideoFormat-&gt;display_area.right - pVideoFormat-&gt;display_area.left;</span><br><span class="line">        m_nLumaHeight = pVideoFormat-&gt;display_area.bottom - pVideoFormat-&gt;display_area.top;</span><br><span class="line">        videoDecodeCreateInfo.ulTargetWidth = pVideoFormat-&gt;coded_width;</span><br><span class="line">        videoDecodeCreateInfo.ulTargetHeight = pVideoFormat-&gt;coded_height;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_resizeDim.w &amp;&amp; m_resizeDim.h) &#123;</span><br><span class="line">            videoDecodeCreateInfo.display_area.left = pVideoFormat-&gt;display_area.left;</span><br><span class="line">            videoDecodeCreateInfo.display_area.top = pVideoFormat-&gt;display_area.top;</span><br><span class="line">            videoDecodeCreateInfo.display_area.right = pVideoFormat-&gt;display_area.right;</span><br><span class="line">            videoDecodeCreateInfo.display_area.bottom = pVideoFormat-&gt;display_area.bottom;</span><br><span class="line">            m_nWidth = m_resizeDim.w;</span><br><span class="line">            m_nLumaHeight = m_resizeDim.h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_cropRect.r &amp;&amp; m_cropRect.b) &#123;</span><br><span class="line">            videoDecodeCreateInfo.display_area.left = m_cropRect.l;</span><br><span class="line">            videoDecodeCreateInfo.display_area.top = m_cropRect.t;</span><br><span class="line">            videoDecodeCreateInfo.display_area.right = m_cropRect.r;</span><br><span class="line">            videoDecodeCreateInfo.display_area.bottom = m_cropRect.b;</span><br><span class="line">            m_nWidth = m_cropRect.r - m_cropRect.l;</span><br><span class="line">            m_nLumaHeight = m_cropRect.b - m_cropRect.t;</span><br><span class="line">        &#125;</span><br><span class="line">        videoDecodeCreateInfo.ulTargetWidth = m_nWidth;</span><br><span class="line">        videoDecodeCreateInfo.ulTargetHeight = m_nLumaHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_nChromaHeight = (<span class="type">int</span>)(<span class="built_in">ceil</span>(m_nLumaHeight * <span class="built_in">GetChromaHeightFactor</span>(m_eOutputFormat)));</span><br><span class="line">    m_nNumChromaPlanes = <span class="built_in">GetChromaPlaneCount</span>(m_eOutputFormat);</span><br><span class="line">    m_nSurfaceHeight = videoDecodeCreateInfo.ulTargetHeight;</span><br><span class="line">    m_nSurfaceWidth = videoDecodeCreateInfo.ulTargetWidth;</span><br><span class="line">    m_displayRect.b = videoDecodeCreateInfo.display_area.bottom;</span><br><span class="line">    m_displayRect.t = videoDecodeCreateInfo.display_area.top;</span><br><span class="line">    m_displayRect.l = videoDecodeCreateInfo.display_area.left;</span><br><span class="line">    m_displayRect.r = videoDecodeCreateInfo.display_area.right;</span><br><span class="line"></span><br><span class="line">    m_videoInfo &lt;&lt; <span class="string">&quot;Video Decoding Params:&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tNum Surfaces : &quot;</span> &lt;&lt; videoDecodeCreateInfo.ulNumDecodeSurfaces &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tCrop         : [&quot;</span> &lt;&lt; videoDecodeCreateInfo.display_area.left &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; videoDecodeCreateInfo.display_area.top &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">        &lt;&lt; videoDecodeCreateInfo.display_area.right &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; videoDecodeCreateInfo.display_area.bottom &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tResize       : &quot;</span> &lt;&lt; videoDecodeCreateInfo.ulTargetWidth &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; videoDecodeCreateInfo.ulTargetHeight &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\tDeinterlace  : &quot;</span> &lt;&lt; std::vector&lt;<span class="type">const</span> <span class="type">char</span> *&gt;&#123;<span class="string">&quot;Weave&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adaptive&quot;</span>&#125;[videoDecodeCreateInfo.DeinterlaceMode]</span><br><span class="line">    ;</span><br><span class="line">    m_videoInfo &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPushCurrent</span>(m_cuContext));</span><br><span class="line">    <span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidCreateDecoder</span>(&amp;m_hDecoder, &amp;videoDecodeCreateInfo));</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="built_in">STOP_TIMER</span>(<span class="string">&quot;Session Initialization Time: &quot;</span>);</span><br><span class="line">    NvDecoder::<span class="built_in">addDecoderSessionOverHead</span>(<span class="built_in">getDecoderSessionID</span>(), elapsedTime);</span><br><span class="line">    <span class="keyword">return</span> nDecodeSurface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-6-2-2-pfnDecodePicture回调函数的设计"><a href="#2-6-2-2-pfnDecodePicture回调函数的设计" class="headerlink" title="2.6.2.2 pfnDecodePicture回调函数的设计"></a>2.6.2.2 pfnDecodePicture回调函数的设计</h4><p>这个回调函数是在准备开始解码时才会被调用<br>整个HandleVideoSequence函数其实主要就是调用cuvidDecodePicture接口</p>
<p>在2.6.2.1章节中我们调用了cuvidCreateDecoder接口来创建视频解码器，而这个接口将会返回phDecoder这个句柄，而接下来我们就要将phDecoder作为hDecoder输入参数设置到cuvidDecodePicture接口中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************************************************/</span></span><br><span class="line"><span class="comment">//! \fn CUresult CUDAAPI cuvidCreateDecoder(CUvideodecoder *phDecoder, CUVIDDECODECREATEINFO *pdci)</span></span><br><span class="line"><span class="comment">//! Create the decoder object based on pdci. A handle to the created decoder is returned</span></span><br><span class="line"><span class="comment">/*****************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> CUresult CUDAAPI <span class="title">cuvidCreateDecoder</span><span class="params">(CUvideodecoder *phDecoder, CUVIDDECODECREATEINFO *pdci)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************************************************************/</span></span><br><span class="line"><span class="comment">//! \fn CUresult CUDAAPI cuvidDecodePicture(CUvideodecoder hDecoder, CUVIDPICPARAMS *pPicParams)</span></span><br><span class="line"><span class="comment">//! Decode a single picture (field or frame)</span></span><br><span class="line"><span class="comment">//! Kicks off HW decoding </span></span><br><span class="line"><span class="comment">/*****************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> CUresult CUDAAPI <span class="title">cuvidDecodePicture</span><span class="params">(CUvideodecoder hDecoder, CUVIDPICPARAMS *pPicParams)</span></span>;</span><br></pre></td></tr></table></figure>
<p>除了这个参数以外，我们还需要将CUVIDPICPARAMS结构体作为第二个参数直接设置进去</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return value from HandlePictureDecode() are interpreted as:</span></span><br><span class="line"><span class="comment">*  0: fail, &gt;=1: succeeded</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NvDecoder::HandlePictureDecode</span><span class="params">(CUVIDPICPARAMS *pPicParams)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_hDecoder)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NVDEC_THROW_ERROR</span>(<span class="string">&quot;Decoder not initialized.&quot;</span>, CUDA_ERROR_NOT_INITIALIZED);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_nPicNumInDecodeOrder[pPicParams-&gt;CurrPicIdx] = m_nDecodePicCnt++;</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPushCurrent</span>(m_cuContext));</span><br><span class="line">    <span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidDecodePicture</span>(m_hDecoder, pPicParams));</span><br><span class="line">    <span class="keyword">if</span> (m_bForce_zero_latency &amp;&amp; ((!pPicParams-&gt;field_pic_flag) || (pPicParams-&gt;second_field)))</span><br><span class="line">    &#123;</span><br><span class="line">        CUVIDPARSERDISPINFO dispInfo;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;dispInfo, <span class="number">0</span>, <span class="built_in">sizeof</span>(dispInfo));</span><br><span class="line">        dispInfo.picture_index = pPicParams-&gt;CurrPicIdx;</span><br><span class="line">        dispInfo.progressive_frame = !pPicParams-&gt;field_pic_flag;</span><br><span class="line">        dispInfo.top_field_first = pPicParams-&gt;bottom_field_flag ^ <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">HandlePictureDisplay</span>(&amp;dispInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-6-2-3-pfnDisplayPicture回调函数的设计"><a href="#2-6-2-3-pfnDisplayPicture回调函数的设计" class="headerlink" title="2.6.2.3 pfnDisplayPicture回调函数的设计"></a>2.6.2.3 pfnDisplayPicture回调函数的设计</h4><p>这个回调函数是在解码出数据时才会被调用</p>
<p>整个HandlePictureDisplay函数其实主要就做了以下几件事情：</p>
<ul>
<li>CUVIDPROCPARAMS结构体参数的数据填充</li>
<li>cuCtxPushCurrent</li>
<li>调用cuvidMapVideoFrame接口，获取到设备内存中指定的YUV数据地址</li>
<li>分配空间</li>
<li>NV12TORGB</li>
<li>cuCtxPopCurrent</li>
<li>cuvidUnmapVideoFrame</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Return value from HandlePictureDisplay() are interpreted as:</span></span><br><span class="line"><span class="comment">*  0: fail, &gt;=1: succeeded</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//目的是找到解码后数据在显存中的位置以及指针的指向，因此重点看了HandlePictureDisplay函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NvDecoder::HandlePictureDisplay</span><span class="params">(CUVIDPARSERDISPINFO *pDispInfo)</span> </span>&#123;</span><br><span class="line">    CUVIDPROCPARAMS videoProcessingParameters = &#123;&#125;;</span><br><span class="line">    videoProcessingParameters.progressive_frame = pDispInfo-&gt;progressive_frame;</span><br><span class="line">    videoProcessingParameters.second_field = pDispInfo-&gt;repeat_first_field + <span class="number">1</span>;</span><br><span class="line">    videoProcessingParameters.top_field_first = pDispInfo-&gt;top_field_first;</span><br><span class="line">    videoProcessingParameters.unpaired_field = pDispInfo-&gt;repeat_first_field &lt; <span class="number">0</span>;</span><br><span class="line">    videoProcessingParameters.output_stream = m_cuvidStream;</span><br><span class="line"></span><br><span class="line">    CUdeviceptr dpSrcFrame = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nSrcPitch = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPushCurrent</span>(m_cuContext));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cuvidMapVideoFrame:返回cuda设备指针和视频帧的Pitch，获取到设备内存中指定的YUV数据地址</span></span><br><span class="line">    <span class="comment">// MapVideoFrame: 拿到解码后数据在显存的指针 --&gt; dpSrcFrame</span></span><br><span class="line">    <span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidMapVideoFrame</span>(m_hDecoder, pDispInfo-&gt;picture_index, &amp;dpSrcFrame,</span><br><span class="line">        &amp;nSrcPitch, &amp;videoProcessingParameters));</span><br><span class="line"></span><br><span class="line">    CUVIDGETDECODESTATUS DecodeStatus;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;DecodeStatus, <span class="number">0</span>, <span class="built_in">sizeof</span>(DecodeStatus));</span><br><span class="line">    CUresult result = <span class="built_in">cuvidGetDecodeStatus</span>(m_hDecoder, pDispInfo-&gt;picture_index, &amp;DecodeStatus);</span><br><span class="line">    <span class="keyword">if</span> (result == CUDA_SUCCESS &amp;&amp; (DecodeStatus.decodeStatus == cuvidDecodeStatus_Error || DecodeStatus.decodeStatus == cuvidDecodeStatus_Error_Concealed))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Decode Error occurred for picture %d\n&quot;</span>, m_nPicNumInDecodeOrder[pDispInfo-&gt;picture_index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> *pDecodedFrame = <span class="literal">nullptr</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// lock_guard 自动解锁 当控件离开lock_guard创建对象的范围时，lock_guard被破坏并释放互斥体</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mtxVPFrame)</span></span>;</span><br><span class="line">        <span class="comment">// 解出一帧 m_nDecodedFrame+1,且若不够空间了,则开辟空间</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">unsigned</span>)++m_nDecodedFrame &gt; m_vpFrame.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Not enough frames in stock</span></span><br><span class="line">            m_nFrameAlloc++;</span><br><span class="line">            <span class="type">uint8_t</span> *pFrame = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (m_bUseDeviceFrame)<span class="comment">//初始化解码器的时候设置的,是否使用显卡内存,是得解码出来的数据不转到CPU内存</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (m_bDeviceFramePitched)<span class="comment">//分配显存空间，并返回指向该空间的指针pFrame</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuMemAllocPitch</span>((CUdeviceptr *)&amp;pFrame, &amp;m_nDeviceFramePitch, <span class="built_in">GetWidth</span>() * m_nBPP, m_nLumaHeight + (m_nChromaHeight * m_nNumChromaPlanes), <span class="number">16</span>));</span><br><span class="line">                cuvidCreateVideoParser&#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//CPU内存</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuMemAlloc</span>((CUdeviceptr *)&amp;pFrame, <span class="built_in">GetFrameSize</span>()));<span class="comment">// 开辟空间</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pFrame = <span class="keyword">new</span> <span class="type">uint8_t</span>[<span class="built_in">GetFrameSize</span>()];</span><br><span class="line">            &#125;</span><br><span class="line">            m_vpFrame.<span class="built_in">push_back</span>(pFrame);<span class="comment">//压进堆栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        pDecodedFrame = m_vpFrame[m_nDecodedFrame - <span class="number">1</span>];<span class="comment">// 取堆栈最后一个帧数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy luma plane</span></span><br><span class="line">    CUDA_MEMCPY2D m = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    m.srcMemoryType = CU_MEMORYTYPE_DEVICE;</span><br><span class="line">    m.srcDevice = dpSrcFrame;<span class="comment">//解码后数据在显存的指针</span></span><br><span class="line">    m.srcPitch = nSrcPitch;</span><br><span class="line">    m.dstMemoryType = m_bUseDeviceFrame ? CU_MEMORYTYPE_DEVICE : CU_MEMORYTYPE_HOST;</span><br><span class="line">    m.dstDevice = (CUdeviceptr)(m.dstHost = pDecodedFrame);</span><br><span class="line">    m.dstPitch = m_nDeviceFramePitch ? m_nDeviceFramePitch : <span class="built_in">GetWidth</span>() * m_nBPP;</span><br><span class="line">    m.WidthInBytes = <span class="built_in">GetWidth</span>() * m_nBPP;</span><br><span class="line">    m.Height = m_nLumaHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码完成,NV12格式 pDecodedFrame</span></span><br><span class="line">    <span class="comment">// NV12TORGB</span></span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuMemcpy2DAsync</span>(&amp;m, m_cuvidStream));<span class="comment">//复制二维数组的内存。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy chroma plane</span></span><br><span class="line">    <span class="comment">// NVDEC output has luma height aligned by 2. Adjust chroma offset by aligning height</span></span><br><span class="line">    m.srcDevice = (CUdeviceptr)((<span class="type">uint8_t</span> *)dpSrcFrame + m.srcPitch * ((m_nSurfaceHeight + <span class="number">1</span>) &amp; ~<span class="number">1</span>));</span><br><span class="line">    m.dstDevice = (CUdeviceptr)(m.dstHost = pDecodedFrame + m.dstPitch * m_nLumaHeight);</span><br><span class="line">    m.Height = m_nChromaHeight;</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuMemcpy2DAsync</span>(&amp;m, m_cuvidStream));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_nNumChromaPlanes == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m.srcDevice = (CUdeviceptr)((<span class="type">uint8_t</span> *)dpSrcFrame + m.srcPitch * ((m_nSurfaceHeight + <span class="number">1</span>) &amp; ~<span class="number">1</span>) * <span class="number">2</span>);</span><br><span class="line">        m.dstDevice = (CUdeviceptr)(m.dstHost = pDecodedFrame + m.dstPitch * m_nLumaHeight * <span class="number">2</span>);</span><br><span class="line">        m.Height = m_nChromaHeight;</span><br><span class="line">        <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuMemcpy2DAsync</span>(&amp;m, m_cuvidStream));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuStreamSynchronize</span>(m_cuvidStream));</span><br><span class="line">    <span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>));<span class="comment">// 拷贝结束,取消上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">int</span>)m_vTimestamp.<span class="built_in">size</span>() &lt; m_nDecodedFrame) &#123;</span><br><span class="line">        m_vTimestamp.<span class="built_in">resize</span>(m_vpFrame.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    m_vTimestamp[m_nDecodedFrame - <span class="number">1</span>] = pDispInfo-&gt;timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取消映射先前映射的视频帧</span></span><br><span class="line">    <span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidUnmapVideoFrame</span>(m_hDecoder, dpSrcFrame));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-6-2-4-pfnGetOperatingPoint回调函数的设计"><a href="#2-6-2-4-pfnGetOperatingPoint回调函数的设计" class="headerlink" title="2.6.2.4 pfnGetOperatingPoint回调函数的设计"></a>2.6.2.4 pfnGetOperatingPoint回调函数的设计</h4><h4 id="2-6-2-5-pfnGetSEIMsg回调函数的设计"><a href="#2-6-2-5-pfnGetSEIMsg回调函数的设计" class="headerlink" title="2.6.2.5 pfnGetSEIMsg回调函数的设计"></a>2.6.2.5 pfnGetSEIMsg回调函数的设计</h4><h3 id="2-6-3-解析器的创建"><a href="#2-6-3-解析器的创建" class="headerlink" title="2.6.3 解析器的创建"></a>2.6.3 解析器的创建</h3><p>当我们把CUVIDPARSERPARAMS结构体填充完成后，就可以调用cuvidCreateVideoParser函数，将CUVIDPARSERPARAMS作为输入参数，进行解析器的创建。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult CUDAAPI <span class="title">tcuvidCreateVideoParser</span><span class="params">(CUvideoparser *pObj, CUVIDPARSERPARAMS *pParams)</span></span>;</span><br><span class="line">tcuvidCreateVideoParser               *cuvidCreateVideoParser;</span><br></pre></td></tr></table></figure>

<p>Video_Codec_SDK样例中NvDecoder文件:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CUVIDPARSERPARAMS：该接口用来创建VideoParser</span></span><br><span class="line"><span class="comment">//主要参数是设置三个回调函数，实现对解析出来的数据的处理</span></span><br><span class="line">CUVIDPARSERPARAMS videoParserParameters = &#123;&#125;;<span class="comment">//结构体</span></span><br><span class="line">videoParserParameters.CodecType = eCodec; <span class="comment">//解码视频类型，如H264</span></span><br><span class="line">videoParserParameters.ulMaxNumDecodeSurfaces = <span class="number">1</span>;<span class="comment">//解码表面的最大数量（解析器将循环遍历这些表面）</span></span><br><span class="line">videoParserParameters.ulClockRate = clkRate;</span><br><span class="line">videoParserParameters.ulMaxDisplayDelay = bLowLatency ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">videoParserParameters.pUserData = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三个回调函数</span></span><br><span class="line">videoParserParameters.pfnSequenceCallback = HandleVideoSequenceProc;<span class="comment">//解码序列时调用</span></span><br><span class="line">videoParserParameters.pfnDecodePicture = HandlePictureDecodeProc;<span class="comment">//准备开始解码时调用</span></span><br><span class="line">videoParserParameters.pfnDisplayPicture = m_bForce_zero_latency ? <span class="literal">NULL</span> : HandlePictureDisplayProc;<span class="comment">//解码出数据调用</span></span><br><span class="line">videoParserParameters.pfnGetOperatingPoint = HandleOperatingPointProc;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create video parser object and initialize</span></span><br><span class="line"><span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidCreateVideoParser</span>(&amp;m_hParser, &amp;videoParserParameters));</span><br></pre></td></tr></table></figure>

<h3 id="2-6-4-从解复用器提取数据包进行解码"><a href="#2-6-4-从解复用器提取数据包进行解码" class="headerlink" title="2.6.4 从解复用器提取数据包进行解码"></a>2.6.4 从解复用器提取数据包进行解码</h3><p>解析器创建完成后，我们就可以开始真正的进行解码咯，而解码就需要通过调用cuvidParseVideoData从解复用器提取数据包：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> CUresult CUDAAPI <span class="title">tcuvidParseVideoData</span><span class="params">(CUvideoparser obj, CUVIDSOURCEDATAPACKET *pPacket)</span></span>;</span><br><span class="line">tcuvidParseVideoData                  *cuvidParseVideoData;</span><br></pre></td></tr></table></figure>
<p>首先定义一个CUVIDSOURCEDATAPACKET结构体类型的变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CUVIDSOURCEDATAPACKET</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;            <span class="comment">/**&lt; Combination of CUVID_PKT_XXX flags */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> payload_size;     <span class="comment">/**&lt; number of bytes in the payload (may be zero if EOS flag is set) */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *payload;   <span class="comment">/**&lt; Pointer to packet payload data (may be NULL if EOS flag is set) */</span></span><br><span class="line">    CUvideotimestamp timestamp;     <span class="comment">/**&lt; Presentation timestamp (10MHz clock), only valid if CUVID_PKT_TIMESTAMP flag is set */</span></span><br><span class="line">&#125; CUVIDSOURCEDATAPACKET;</span><br></pre></td></tr></table></figure>
<h4 id="相关参数具体设置：-2"><a href="#相关参数具体设置：-2" class="headerlink" title="相关参数具体设置："></a>相关参数具体设置：</h4><p>首先使用memset函数将结构体初始化（全置为0）</p>
<h5 id="flags："><a href="#flags：" class="headerlink" title="flags："></a>flags：</h5><p>默认为0</p>
<h5 id="payload-size"><a href="#payload-size" class="headerlink" title="payload_size"></a>payload_size</h5><p>payload_size等于之前CUVIDEOFORMATEX结构体中format.seqhdr_data_length的值</p>
<h5 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h5><p>payload等于之前CUVIDEOFORMATEX结构体中raw_seqhdr_data的值</p>
<h5 id="timestamp"><a href="#timestamp" class="headerlink" title="timestamp"></a>timestamp</h5><p>默认为0</p>
<p>通过上面的参数，我们可以知道还必须得到CUVIDEOFORMATEX结构体变量的信息<br>因此我们接着定义一个CUVIDEOFORMATEX结构体类型的变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包含原始序列头信息的视频格式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    CUVIDEOFORMAT format;<span class="comment">//Video format</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> raw_seqhdr_data[<span class="number">1024</span>];</span><br><span class="line">&#125; CUVIDEOFORMATEX;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="相关参数具体设置：-3"><a href="#相关参数具体设置：-3" class="headerlink" title="相关参数具体设置："></a>相关参数具体设置：</h4><p>首先使用memset函数将结构体初始化（全置为0）</p>
<h5 id="format："><a href="#format：" class="headerlink" title="format："></a>format：</h5><p>只需要设置format.seqhdr_data_length ，值等于额外数据的长度</p>
<h5 id="raw-seqhdr-data："><a href="#raw-seqhdr-data：" class="headerlink" title="raw_seqhdr_data："></a>raw_seqhdr_data：</h5><p>通过memcpy将额外数据copy到raw_seqhdr_data中，长度为seqhdr_data_length<br>即：memcpy(CuVideoFormatEx.raw_seqhdr_data, exdata, exdataLen);</p>
<p>接着我们通过调用cuvidParseVideoData从解复用器提取数据包，该接口是用来向parser塞数据，通过不断地塞h.264数据，parser会通过回调接口对解析出来的数据进行处理。</p>
<p>提取成功后，紧接着调用cuCtxPopCurrent函数，将给定的上下文ctx从当前CPU线程的上下文堆栈中弹出。</p>
<p>Video_Codec_SDK样例中NvDecoder文件:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//AVPacket转CUVIDSOURCEDATAPACKET，并交给cuvidParaseVideoData进行</span></span><br><span class="line">CUVIDSOURCEDATAPACKET packet = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">packet.payload = pData;<span class="comment">//指向数据包有效载荷数据的指针</span></span><br><span class="line">packet.payload_size = nSize;<span class="comment">//负载中的字节数</span></span><br><span class="line">packet.flags = nFlags | CUVID_PKT_TIMESTAMP;</span><br><span class="line">packet.timestamp = nTimestamp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否是stream的最后一个packet</span></span><br><span class="line"><span class="keyword">if</span> (!pData || nSize == <span class="number">0</span>) &#123;</span><br><span class="line">    packet.flags |= CUVID_PKT_ENDOFSTREAM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidParseVideoData</span>(m_hParser, &amp;packet));</span><br><span class="line">```    </span><br><span class="line">## <span class="number">2.7</span> 获取解码后的 YUV 以供进一步处理</span><br><span class="line">这一步骤是在pfnDisplayPicture指向的回调函数进行处理的，在前面的<span class="number">2.6</span><span class="number">.2</span><span class="number">.3</span>章节中，我们说了pfnDisplayPicture这个回调函数是在解码出数据时才会被调用</span><br><span class="line"></span><br><span class="line">而整个HandlePictureDisplay函数其实主要就做了以下几件事情：</span><br><span class="line">- CUVIDPROCPARAMS结构体参数的数据填充</span><br><span class="line">- cuCtxPushCurrent</span><br><span class="line">- 调用cuvidMapVideoFrame接口，获取到设备内存中指定的YUV数据地址</span><br><span class="line">- 分配空间</span><br><span class="line">- NV12TORGB</span><br><span class="line">- cuCtxPopCurrent</span><br><span class="line">- cuvidUnmapVideoFrame</span><br><span class="line"></span><br><span class="line">其中的：</span><br><span class="line">- 调用cuvidMapVideoFrame接口，获取到设备内存中指定的YUV数据地址</span><br><span class="line">- 分配空间</span><br><span class="line">- NV12TORGB</span><br><span class="line">就是获取解码后的 YUV 的相关处理步骤</span><br><span class="line"></span><br><span class="line">## <span class="number">2.8</span> 查询解码帧的状态</span><br><span class="line">通过应用程序接口<span class="built_in">cuvidGetDecoderCaps</span>()查询底层硬件视频解码器的功能。</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line"><span class="comment">/**********************************************************************************************************************/</span></span><br><span class="line"><span class="comment">//! \fn CUresult CUDAAPI cuvidGetDecoderCaps(CUVIDDECODECAPS *pdc)</span></span><br><span class="line"><span class="comment">//! Queries decode capabilities of NVDEC-HW based on CodecType, ChromaFormat and BitDepthMinus8 parameters.</span></span><br><span class="line"><span class="comment">//! 1. Application fills IN parameters CodecType, ChromaFormat and BitDepthMinus8 of CUVIDDECODECAPS structure</span></span><br><span class="line"><span class="comment">//! 2. On calling cuvidGetDecoderCaps, driver fills OUT parameters if the IN parameters are supported</span></span><br><span class="line"><span class="comment">//!    If IN parameters passed to the driver are not supported by NVDEC-HW, then all OUT params are set to 0.</span></span><br><span class="line"><span class="comment">//! E.g. on Geforce GTX 960:</span></span><br><span class="line"><span class="comment">//!   App fills - eCodecType = cudaVideoCodec_H264; eChromaFormat = cudaVideoChromaFormat_420; nBitDepthMinus8 = 0;</span></span><br><span class="line"><span class="comment">//!   Given IN parameters are supported, hence driver fills: bIsSupported = 1; nMinWidth   = 48; nMinHeight  = 16; </span></span><br><span class="line"><span class="comment">//!   nMaxWidth = 4096; nMaxHeight = 4096; nMaxMBCount = 65536;</span></span><br><span class="line"><span class="comment">//! CodedWidth*CodedHeight/256 must be less than or equal to nMaxMBCount</span></span><br><span class="line"><span class="comment">/**********************************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> CUresult CUDAAPI <span class="title">cuvidGetDecoderCaps</span><span class="params">(CUVIDDECODECAPS *pdc)</span></span>;</span><br></pre></td></tr></table></figure>

<p>具体调用方式可以参考2.6.2.1章节pfnSequenceCallback回调函数的设计</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CUVIDDECODECAPS decodecaps;</span><br><span class="line"><span class="built_in">memset</span>(&amp;decodecaps, <span class="number">0</span>, <span class="built_in">sizeof</span>(decodecaps));</span><br><span class="line"></span><br><span class="line">decodecaps.eCodecType = pVideoFormat-&gt;codec;</span><br><span class="line">decodecaps.eChromaFormat = pVideoFormat-&gt;chroma_format;</span><br><span class="line">decodecaps.nBitDepthMinus8 = pVideoFormat-&gt;bit_depth_luma_minus8;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPushCurrent</span>(m_cuContext)); <span class="comment">//启用context</span></span><br><span class="line"><span class="built_in">NVDEC_API_CALL</span>(<span class="built_in">cuvidGetDecoderCaps</span>(&amp;decodecaps));</span><br><span class="line"><span class="built_in">CUDA_DRVAPI_CALL</span>(<span class="built_in">cuCtxPopCurrent</span>(<span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure>
<hr>
<p>此时关于硬件解码的部分我们已经基本上完成了，接下来就是如何使用OpenGL与CUDA进行交互操作了．</p>
<hr>
<h2 id="2-9-根据解码状态，使用解码后的输出进行进一步的处理-如渲染、后处理等"><a href="#2-9-根据解码状态，使用解码后的输出进行进一步的处理-如渲染、后处理等" class="headerlink" title="2.9 根据解码状态，使用解码后的输出进行进一步的处理(如渲染、后处理等)"></a>2.9 根据解码状态，使用解码后的输出进行进一步的处理(如渲染、后处理等)</h2><p>我们知道从解码器解码出来的数据格式是NV12，而我们如果想对该数据进行进一步的处理(如渲染、后处理等)的话，NV12数据无论是进行OpenGL的播放渲染还是进行相关特效处理（大部分OpenGL的filter都是对RGBA数据进行处理的）都不太适合，因此，我们拿到NV12数据后还需要进行一个步骤：将数据转换成容易处理的格式，也就是RGBA或者BGRA格式（每个像素用32比特位表示，占4个字节 ，R，G，B,A分量分别用8个bit表示）．</p>
<p>而如何将解码后的NV12数据转化为RGBA格式呢？</p>
<p>此时有两种方案:</p>
<ul>
<li>将解码后的NV12数据通过cuda的Kernel Functions转成了BGRA等格式</li>
<li>让OpeGL或者DX将获取到的NV12数据，通过使用特定shader实现RGB到YUV的图像格式</li>
</ul>
<p>这两者的区别就在于我们是让CUDA进行格式转换，还是通过OpenGL进行格式转换？</p>
<p>现在摆在我们面前的是：</p>
<p>我们的目的是：实现NvDec硬件解码-&gt;OpenGL渲染和filter处理-&gt;NvDec硬件编码的全流程GPU加速方案</p>
<p>NvDec解码后的数据是存放在GPU上的NV12数据，我们在渲染和filter功能实现上需要通过OpenGL来实现</p>
<p>因此我们需要OpenGL能够直接操作NvDec解码后在GPU上的地址数据，这一点就需要借助CUDA来实现，NVidia的CUDA提供了和OpenGL以及各版本DX的交互接口，这使得，通过OpenGL直接对NvDec解码后的数据进行操作成为了可能．详见NVidia相关<a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__OPENGL.html">官方文档</a></p>
<h3 id="2-9-1-为什么要采用OpenGL与CUDA互操作的方式"><a href="#2-9-1-为什么要采用OpenGL与CUDA互操作的方式" class="headerlink" title="2.9.1 为什么要采用OpenGL与CUDA互操作的方式"></a>2.9.1 为什么要采用OpenGL与CUDA互操作的方式</h3><p>其实传统的渲染方式一般是：</p>
<ul>
<li>将硬解码得到的NV12数据拷贝回CPU内存，</li>
<li>然后再将NV12格式转成YUV420格式，</li>
<li>进而再调用OpenGL渲染。</li>
</ul>
<p>缺点：GPU到CPU的数据拷贝在时间上花销过大，NV12格式转成YUV420格式计算花销大，因此造成解码渲染耗时较大，容易出现卡顿现象。</p>
<p>因此我们其实是有以下两个方案：<br>方案一：</p>
<ul>
<li>使用CUDA与OpenGL互操作，无需将数据传入CPU，将硬解码取得的NV12数据直接通过CUDA的Kernel Functions转成RGBA或BGRA。</li>
<li>然后再利用内存映射的方法，让OpeGL直接进行渲染和相关特效处理。<br>方案二：</li>
<li>使用CUDA与OpenGL互操作，无需将数据传入CPU，利用内存映射的方法，将CUDA与OpenGL进行绑定</li>
<li>让OpeGL将获取到的NV12数据，通过使用shader进行格式转换，最后再进行渲染。</li>
</ul>
<p>这两个方案的区别在于是让CUDA的核函数进行NV12-&gt;RGB的转换，还是通过OpenGL的shader进行NV12-&gt;RGB的转换．</p>
<p>而如果我们采用第二种方案的话，比较麻烦的问题在于，我们需要两条OpenGL纹理(一条存放Y数据，一体存放UV数据)来跟CUDA进行互操作．这样的操作太过于麻烦，且容易出错，因此我们一般还是参考例程的代码，统一采用的是第一种方案．当然，如果你想了解一下第二种方案的实现，可以参考这篇<a href="">博客</a></p>
<h3 id="2-9-2-CUDA与OpenGL互操作"><a href="#2-9-2-CUDA与OpenGL互操作" class="headerlink" title="2.9.2 CUDA与OpenGL互操作"></a>2.9.2 CUDA与OpenGL互操作</h3><p>OpenGL与CUDA互操作可以分成两种方法:</p>
<p>方法一：<br>OpenGL将Buffer对象注册到CUDA中去，供CUDA读写操作，然后再在OpenGL中使用。一般这种情况下注册的是<font color = red>VBO和PBO</font>，VBO一般用于存储顶点坐标、索引等数据；PBO则一般用于存储图像数据，因此称作Pixel Buffer Object。</p>
<p>方法二：<br>OpenGL将<font color =red>Texture</font>注册到CUDA中去，经CUDA处理后得到纹理内容，然后在OpenGL中渲染出来。</p>
<p>二者的操作流程一致：</p>
<ul>
<li>在OpenGL里面初始化Buffer Object</li>
<li>在CUDA中注册OpenGL中的Buffer Object</li>
<li>CUDA锁定资源，获取操作资源的指针，在<font color =red>CUDA核函数</font>中进行数据处理</li>
<li>CUDA释放资源，在OpenGL中使用Buffer Object进行渲染和显示</li>
</ul>
<p>接下来，我们将分别讲述一下这两种方法的实现步骤</p>
<h4 id="2-9-2-1-方法一-VBO-VAO-："><a href="#2-9-2-1-方法一-VBO-VAO-：" class="headerlink" title="2.9.2.1 方法一(VBO+VAO)："></a>2.9.2.1 方法一(VBO+VAO)：</h4><h5 id="2-9-2-1-1-VBO-VAO基础概念介绍"><a href="#2-9-2-1-1-VBO-VAO基础概念介绍" class="headerlink" title="2.9.2.1.1 VBO+VAO基础概念介绍"></a>2.9.2.1.1 VBO+VAO基础概念介绍</h5><p>VBO:顶点缓冲对象VBO<font color =red>是在显卡存储空间中开辟出的一块内存缓存区，用于存储顶点的各类属性信息，如顶点坐标，顶点法向量，顶点颜色数据等</font>。在渲染时，可以直接从VBO中取出顶点的各类属性数据，由于VBO在显存而不是在内存中，不需要从CPU传输数据，处理效率更高。<br>所以可以理解为VBO就是显存中的一个存储区域，可以保持大量的顶点属性信息。并且可以开辟很多个VBO，每个VBO在OpenGL中有它的唯一标识ID，这个ID对应着具体的VBO的显存地址，通过这个ID可以对特定的VBO内的数据进行存取操作。</p>
<p>VAO:是一个保存了所有顶点数据属性的状态结合，它存储了顶点数据的格式以及顶点数据所需的VBO对象的引用。<br>VAO本身并没有存储顶点的相关属性数据，这些信息是存储在VBO中的，<font color =red>VAO相当于是对很多个VBO的引用，把一些VBO组合在一起作为一个对象统一管理</font>。</p>
<p>EBO:索引缓冲对象EBO相当于OpenGL中的顶点数组的概念，，<font color =red>是为了解决同一个顶点多次重复调用的问题</font>，可以减少内存空间浪费，提高执行效率。当需要使用重复的顶点时，通过顶点的位置索引来调用顶点，而不是对重复的顶点信息重复记录，重复调用。<font color =red>EBO中存储的内容就是顶点位置的索引indices，EBO跟VBO类似，也是在显存中的一块内存缓冲器，只不过EBO保存的是顶点的索引</font>。</p>
<p>综上所述：<br>VBO存放的是顶点信息（坐标，颜色，法向量．．．．）；VAO是对多个VBO的管理器，也就是相当于VBO的集合，EBO也就是VBO中顶点信息中的坐标的索引集合</p>
<p>我们用C++语言来表达就是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    Coordinates xyz;</span><br><span class="line">    Color color;</span><br><span class="line">    NormalVectors normal_vectors;</span><br><span class="line">    .....</span><br><span class="line">&#125;VBO;</span><br><span class="line">VBO* pVAO =<span class="keyword">new</span> VBO[n]();</span><br><span class="line">Coordinates* pEBO = nwe Coordinates[n]();</span><br></pre></td></tr></table></figure>

<p>例程AppDecGL中对NV12转BGRA的CUDA操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Launch cuda kernels for colorspace conversion from raw video to raw image formats which OpenGL textures can work with</span></span><br><span class="line"><span class="keyword">if</span> (dec.<span class="built_in">GetBitDepth</span>() == <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dec.<span class="built_in">GetOutputFormat</span>() == cudaVideoSurfaceFormat_YUV444)</span><br><span class="line">        <span class="built_in">YUV444ToColor32</span>&lt;BGRA32&gt;(pFrame, dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// default assumed NV12</span></span><br><span class="line">        <span class="built_in">Nv12ToColor32</span>&lt;BGRA32&gt;(pFrame, dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dec.<span class="built_in">GetOutputFormat</span>() == cudaVideoSurfaceFormat_YUV444)</span><br><span class="line">        <span class="built_in">YUV444P16ToColor32</span>&lt;BGRA32&gt;(pFrame, <span class="number">2</span> * dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// default assumed P016</span></span><br><span class="line">        <span class="built_in">P016ToColor32</span>&lt;BGRA32&gt;(pFrame, <span class="number">2</span> * dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-9-2-1-2-代码实现（为了提高效率，同时操作两个VBO数据）"><a href="#2-9-2-1-2-代码实现（为了提高效率，同时操作两个VBO数据）" class="headerlink" title="2.9.2.1.2 代码实现（为了提高效率，同时操作两个VBO数据）"></a>2.9.2.1.2 代码实现（为了提高效率，同时操作两个VBO数据）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化Buffer Object</span></span><br><span class="line"><span class="comment">//vertex array object</span></span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;VAO);</span><br><span class="line"><span class="comment">//Create vertex buffer object</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">2</span>, <span class="keyword">this</span>-&gt;VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create Element Buffer Objects</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;EBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bind the Vertex Array Object first, then bind and set vertex buffer(s) and attribute pointer(s).</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="keyword">this</span>-&gt;VAO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定VBO后即在CUDA中注册Buffer Object</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="keyword">this</span>-&gt;VBO[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(*<span class="keyword">this</span>-&gt;malla)*<span class="keyword">this</span>-&gt;numPoints, <span class="keyword">this</span>-&gt;malla, GL_DYNAMIC_COPY);</span><br><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>(&amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>], <span class="keyword">this</span>-&gt;VBO[<span class="number">0</span>], cudaGraphicsRegisterFlagsNone);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="keyword">this</span>-&gt;VBO[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(*<span class="keyword">this</span>-&gt;malla)*<span class="keyword">this</span>-&gt;numPoints, <span class="keyword">this</span>-&gt;malla, GL_DYNAMIC_COPY);</span><br><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>(&amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">1</span>], <span class="keyword">this</span>-&gt;VBO[<span class="number">1</span>], cudaGraphicsRegisterFlagsNone);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在CUDA中映射资源，锁定资源</span></span><br><span class="line"><span class="built_in">cudaGraphicsMapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cudaGraphicsMapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">point *devicePoints1;</span><br><span class="line">point *devicePoints2;</span><br><span class="line"><span class="type">size_t</span> size = <span class="built_in">sizeof</span>(*<span class="keyword">this</span>-&gt;malla)*<span class="keyword">this</span>-&gt;numPoints;</span><br><span class="line"><span class="comment">// 获取操作资源的指针，以便在CUDA核函数中使用</span></span><br><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>((<span class="type">void</span> **)&amp;devicePoints1, &amp;size, <span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">cudaGraphicsResourceGetMappedPointer</span>((<span class="type">void</span> **)&amp;devicePoints2, &amp;size, <span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行CUDA的内核操作Nv12-&gt;BGRA操作．这边请参考例程</span></span><br><span class="line"><span class="built_in">Nv12ToColor32</span>&lt;BGRA32&gt;(pFrame, dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理完了即可解除资源锁定，OpenGL可以开始利用处理结果了。</span></span><br><span class="line"><span class="comment">// 注意在CUDA处理过程中，OpenGL如果访问这些锁定的资源会出错。</span></span><br><span class="line"><span class="built_in">cudaGraphicsUnmapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cudaGraphicsUnmapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">1</span>], <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>值得注意的是，由于这里绑定的是VBO，属于Buffer对象，因此调用的CUDA API是这两个：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>();</span><br><span class="line"><span class="built_in">cudaGraphicsResourceGetMappedPointer</span>();</span><br></pre></td></tr></table></figure>
<h4 id="2-9-2-2-方法二-texture-："><a href="#2-9-2-2-方法二-texture-：" class="headerlink" title="2.9.2.2 方法二(texture)："></a>2.9.2.2 方法二(texture)：</h4><h5 id="2-9-2-2-2-代码实现（为了提高效率，同时操作两个Texture数据）"><a href="#2-9-2-2-2-代码实现（为了提高效率，同时操作两个Texture数据）" class="headerlink" title="2.9.2.2.2 代码实现（为了提高效率，同时操作两个Texture数据）"></a>2.9.2.2.2 代码实现（为了提高效率，同时操作两个Texture数据）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化两个Texture并绑定</span></span><br><span class="line">cudaGraphicsResource_t cudaResources[<span class="number">2</span>];</span><br><span class="line">GLuint textureID[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">glEnable</span>(GL_TEXTURE_2D);</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">2</span>, textureID);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在CUDA中注册这两个Texture</span></span><br><span class="line">cudaError_t err = <span class="built_in">cudaGraphicsGLRegisterImage</span>(&amp;cudaResources[<span class="number">0</span>], textureID[<span class="number">0</span>], GL_TEXTURE_2D, cudaGraphicsRegisterFlagsWriteDiscard);</span><br><span class="line"><span class="keyword">if</span> (err != cudaSuccess)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;cudaGraphicsGLRegisterImage: &quot;</span> &lt;&lt; err &lt;&lt; <span class="string">&quot;Line: &quot;</span> &lt;&lt; __LINE__;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">err = <span class="built_in">cudaGraphicsGLRegisterImage</span>(&amp;cudaResources[<span class="number">1</span>], textureID[<span class="number">1</span>], GL_TEXTURE_2D, cudaGraphicsRegisterFlagsWriteDiscard);</span><br><span class="line"><span class="keyword">if</span> (err != cudaSuccess)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;cudaGraphicsGLRegisterImage: &quot;</span> &lt;&lt; err &lt;&lt; <span class="string">&quot;Line: &quot;</span> &lt;&lt; __LINE__;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在CUDA中锁定资源，获得操作Texture的指针，这里是CudaArray*类型</span></span><br><span class="line">cudaError_t err = <span class="built_in">cudaGraphicsMapResources</span>(<span class="number">2</span>, cudaResource, <span class="number">0</span>);</span><br><span class="line">err = <span class="built_in">cudaGraphicsSubResourceGetMappedArray</span>(&amp;<span class="keyword">this</span>-&gt;cuArrayL, cudaResource[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">err = <span class="built_in">cudaGraphicsSubResourceGetMappedArray</span>(&amp;<span class="keyword">this</span>-&gt;cuArrayR, cudaResource[<span class="number">1</span>], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据拷贝至CudaArray。这里因为得到的是CudaArray，处理时不方便操作，于是先在设备内存中</span></span><br><span class="line"><span class="comment">// 分配缓冲区处理，处理完后再把结果存到CudaArray中，仅仅是GPU内存中的操作。</span></span><br><span class="line"><span class="built_in">cudaMemcpyToArray</span>(cuArrayL, <span class="number">0</span>, <span class="number">0</span>, pHostDataL, imgWidth*imgHeight * <span class="built_in">sizeof</span>(uchar4), cudaMemcpyDeviceToDevice);</span><br><span class="line"><span class="built_in">cudaMemcpyToArray</span>(cuArrayR, <span class="number">0</span>, <span class="number">0</span>, pHostDataR, imgWidth*imgHeight * <span class="built_in">sizeof</span>(uchar4), cudaMemcpyDeviceToDevice);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行CUDA的内核操作Nv12-&gt;BGRA操作．这边请参考例程</span></span><br><span class="line"><span class="built_in">Nv12ToColor32</span>&lt;BGRA32&gt;(pFrame, dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理完后即解除资源锁定，OpenGL可以利用得到的Texture对象进行纹理贴图操作了。</span></span><br><span class="line"><span class="built_in">cudaGraphicsUnmapResources</span>(<span class="number">1</span>, &amp;cudaResource[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cudaGraphicsUnmapResources</span>(<span class="number">1</span>, &amp;cudaResource[<span class="number">1</span>], <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>注意这里因为使用的是Texture对象，因此使用了不同的API：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cudaGraphicsGLRegisterImage</span>();</span><br><span class="line"><span class="built_in">cudaGraphicsSubResourceGetMappedArray</span>();</span><br></pre></td></tr></table></figure>
<p>由于NvDec解码出来的是Nv12数据，也就是一个个像素数据，因此显然我们是没办法采用VBO+VAO方式的，所以也只有第二种方法适合我们，</p>
<p>但是，我们查看例程会发现，NVidia提供的例程压根就没采用这两种方式，而是采用了PBO进行映射！！！</p>
<p>因此我们这里引入pbo概念：PBO一般用于存储图像数据，因此称作Pixel Buffer Object</p>
<p>而我们的例程中用到的也是这种方案（PBO＋Texture），其本质就是将NvDec解码后的数据的地址与PBO进行绑定，这样我们就能通过PBO来跟CUDA进行互操作，等到NvDec解码后的数据通过CUDA的的Kernel Functions转成了BGRA等格式后，我们再从PBO将数据读到纹理上，之后我们就可以通过对纹理id进行操作，来实现各种特效处理和渲染操作啦！</p>
<p>至于为啥我们不直接通过OpenGL的纹理和CUDA进行交互的原因就是PBO可以通过 DMA (Direct Memory Access) 快速地在显卡上传递像素数据，而不影响CPU的时钟周期（中断）。同时它还具备异步 DMA 传输的优势。说到底就是这样干效率会高一点！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在OpenGL中分配和图像相同大小的pbo和texture</span></span><br><span class="line">GLuint pbo[<span class="number">2</span>];</span><br><span class="line">GLuint textureID[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//双pbo模式</span></span><br><span class="line"><span class="built_in">glGenBuffersARB</span>(<span class="number">2</span>, pbo);</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">2</span>, textureID);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个pbo存放第一个texture</span></span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, pbo[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">glBufferDataARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, nTexWidth*nTexHeight*<span class="number">4</span>, <span class="literal">NULL</span>, GL_STREAM_DRAW_ARB);</span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA8, width, height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>(&amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>], <span class="keyword">this</span>-&gt;pbo[<span class="number">0</span>], cudaGraphicsRegisterFlagsNone);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个pbo存放第二个texture</span></span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, pbo[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">glBufferDataARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, nTexWidth*nTexHeight*<span class="number">4</span>, <span class="literal">NULL</span>, GL_STREAM_DRAW_ARB);</span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA8, width, height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>(&amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>], <span class="keyword">this</span>-&gt;pbo[<span class="number">1</span>], cudaGraphicsRegisterFlagsNone);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在CUDA中映射资源，锁定资源</span></span><br><span class="line"><span class="built_in">cudaGraphicsMapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cudaGraphicsMapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">point *devicePoints1;</span><br><span class="line">point *devicePoints2;</span><br><span class="line"><span class="type">size_t</span> size = <span class="built_in">sizeof</span>(*<span class="keyword">this</span>-&gt;malla)*<span class="keyword">this</span>-&gt;numPoints;</span><br><span class="line"><span class="comment">// 获取操作资源的指针，以便在CUDA核函数中使用</span></span><br><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>((<span class="type">void</span> **)&amp;devicePoints1, &amp;size, <span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">cudaGraphicsResourceGetMappedPointer</span>((<span class="type">void</span> **)&amp;devicePoints2, &amp;size, <span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行CUDA的内核操作Nv12-&gt;BGRA操作．这边请参考例程</span></span><br><span class="line"><span class="built_in">Nv12ToColor32</span>&lt;BGRA32&gt;(pFrame, dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理完了即可解除资源锁定，OpenGL可以开始利用处理结果了。</span></span><br><span class="line"><span class="comment">// 注意在CUDA处理过程中，OpenGL如果访问这些锁定的资源会出错。</span></span><br><span class="line"><span class="built_in">cudaGraphicsUnmapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cudaGraphicsUnmapResources</span>(<span class="number">1</span>, &amp;<span class="keyword">this</span>-&gt;cudaResourceBuf[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从OpenGL在CUDA映射的PBO中将数据读取到对应的OpenGL纹理上</span></span><br><span class="line"><span class="comment">// load texture from pbo</span></span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, pbo[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_TYPE, textureID[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">glTexSubImage2D</span>(GL_TEXTURE_TYPE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, width, height, GL_BGRA, GL_UNSIGNED_BYTE, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_TYPE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, pbo[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_TYPE, textureID[<span class="number">1</span>]));</span><br><span class="line"><span class="built_in">glTexSubImage2D</span>(GL_TEXTURE_TYPE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, width, height, GL_BGRA, GL_UNSIGNED_BYTE, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBufferARB</span>(GL_PIXEL_UNPACK_BUFFER_ARB, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_TYPE, <span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>值得注意的是，由于这里绑定的是PBO，属于Buffer对象，而不是Texture对象（可以理解成用PBO对Texture对象进行了封装），因此调用的CUDA API是这两个：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cudaGraphicsGLRegisterBuffer</span>();</span><br><span class="line"><span class="built_in">cudaGraphicsResourceGetMappedPointer</span>();</span><br></pre></td></tr></table></figure>

<p>在上述的代码中都有一段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行CUDA的内核操作Nv12-&gt;BGRA操作．这边请参考例程</span></span><br><span class="line"><span class="built_in">Nv12ToColor32</span>&lt;BGRA32&gt;(pFrame, dec.<span class="built_in">GetWidth</span>(), (<span class="type">uint8_t</span> *)dpFrame, nPitch, dec.<span class="built_in">GetWidth</span>(), dec.<span class="built_in">GetHeight</span>(), iMatrix);</span><br></pre></td></tr></table></figure>
<p>其实这段就是CUDA的内核的操作，通过启动 cuda 内核，用于从原始视频到 OpenGL 纹理可以使用的原始图像格式的色彩空间转换，而因为我这里有NV12ToARGB_drvapi.cu文件，因此我也可以通过执行这个文件的NV12ToARGB_drvapi函数来进行CUDA的内核操作（CUDA kernel for outputing the final ARGB output from NV12）；<br>当然你也可以像Nvidia给的例程中一样，通过NvCodecUtils.h这个文件的Nv12ToColor32接口来进行CUDA的内核操作，从而实现NV12-&gt;RGB32的转换．这个本质上是一样的，没啥区别．</p>
<p>当然为了我们后面进行OpenGL的渲染和特效处理，从上面的代码可以看出，我们在进行从OpenGL在CUDA映射的PBO中将数据读取到对应的OpenGL纹理上时，我们调用的glTexSubImage2D函数的第七个参数不是GL_RGBA而是GL_BGRA，知道为啥这样吗？<br>因为我们一开始创建纹理在调用glTexImage2D的时候，用的是GL_RGBA参数，而我们进行的CUDA的内核的操作是将Nv12转成了BGRA数据，也就是说现在我们PBO中存放的数据是BGRA排列的数据，而我们一般是习惯用RGBA数据来进行OpenGL操作的，所以如果我们调用glTexSubImage2D函数进行PBO到Texture的操作时，我们还是采用的GL_RGBA参数的话，那么此时Texture上的数据就是BGRA排列的数据了，但是我们如果偷偷的将glTexSubImage2D第七个参数从GL_RGBA改成GL_BGRA的话，那么B和R的数据将会被OpenGL自动进行调换，此时，我们OpenGL的Texture上对应的数据排列就是RGBARGBA了，这操作是不是很秀！</p>
<h1 id="３-中间渲染和filter链路的构建的具体流程步骤"><a href="#３-中间渲染和filter链路的构建的具体流程步骤" class="headerlink" title="３ 中间渲染和filter链路的构建的具体流程步骤"></a>３ 中间渲染和filter链路的构建的具体流程步骤</h1><h2 id="3-1-OpenGL的屏幕绘制和filter链路的构建"><a href="#3-1-OpenGL的屏幕绘制和filter链路的构建" class="headerlink" title="3.1 OpenGL的屏幕绘制和filter链路的构建"></a>3.1 OpenGL的屏幕绘制和filter链路的构建</h2><h2 id="3-2-OpenGL的filter链路的构建"><a href="#3-2-OpenGL的filter链路的构建" class="headerlink" title="3.2 OpenGL的filter链路的构建"></a>3.2 OpenGL的filter链路的构建</h2><h1 id="4-具体编码流程步骤"><a href="#4-具体编码流程步骤" class="headerlink" title="4 具体编码流程步骤"></a>4 具体编码流程步骤</h1><p>首先我们根据Nvidia官方的<a target="_blank" rel="noopener" href="https://docs.nvidia.com/video-technologies/video-codec-sdk/nvenc-video-encoder-api-prog-guide/">NVENC API</a>指南进行学习．</p>
<p>通过上面的文档我们可以知道NVENC将YUV&#x2F;RGB作为输入并生成符合H.264&#x2F;HEVC&#x2F;AV1标准的视频比特流。<br>而我们则是要通过使用 NVIDIA Video Codec SDK 中提供的 NVENCODE API来实现硬件编码功能．<br>NVENCODE API 函数、结构和其他参数被公开在NVIDIA Video Codec SDK 中提供的nvEncodeAPI.h中，因此我们在进行编码操作时，就需要将该文件include进去，同时还需要加载对应的动态库（Windows上调用的是nvEncodeAPI.dll；linux上调用的是libnvidia-encode.so）．头文件和动态库导入的大致流程如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nvEncodeAPI.h&quot;</span></span></span><br><span class="line">...... </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line"><span class="type">static</span> <span class="type">wchar_t</span> __NVEncodeLibName32[] = <span class="string">L&quot;nvEncodeAPI.dll&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">wchar_t</span> __NVEncodeLibName64[] = <span class="string">L&quot;nvEncodeAPI64.dll&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined __linux__</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> __NVEncodeLibName[] = <span class="string">&quot;libnvidia-encode.so&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">...... </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> BOOL <span class="title">Is64Bit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">sizeof</span>(<span class="type">void</span> *)!=<span class="built_in">sizeof</span>(DWORD));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...... </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Is64Bit</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        m_hinstLib = <span class="built_in">LoadLibrary</span>(__NVEncodeLibName64);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_hinstLib = <span class="built_in">LoadLibrary</span>(__NVEncodeLibName32);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    m_hinstLib = <span class="built_in">dlopen</span>(__NVEncodeLibName, RTLD_LAZY);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>其硬件编码流程，具体过程如下所示：</p>
<ul>
<li>初始化编码器</li>
<li>设置所需的编码参数</li>
<li>分配输入&#x2F;输出缓冲区</li>
<li>将帧复制到输入缓冲区并从输出缓冲区读取比特流。这可以同步（Windows 和 Linux）或异步（仅限 Windows 7 及更高版本）完成。</li>
<li>清理&#x2F;释放所有分配的输入&#x2F;输出缓冲区</li>
<li>关闭编码会话</li>
</ul>
<h2 id="4-1-初始化编码器"><a href="#4-1-初始化编码器" class="headerlink" title="4.1 初始化编码器"></a>4.1 初始化编码器</h2><p>接下来的讲解，我们将基于在<a target="_blank" rel="noopener" href="https://community.adobe.com/t5/adobe-media-encoder-discussions/nvidia-gpu-accelerated-h264-encoder-plugin-ready-for-public-testing/td-p/5213367">Adobe Support Community</a>网站上一位名叫Guest的作者在2013年提供的<a target="_blank" rel="noopener" href="https://github.com/jetkiwi/NVENC_export">NVENC_export</a>作为参考来进行适当修改，来实现我们的功能．</p>
<p>当我们加载完nvEncodeAPI对应的库文件后，第一步就是调用NvEncodeAPICreateInstance．这个接口会将动态库中的函数加载到对应的函数指针中，这样我们在后续的操作中才能调用NVENCODE中的其他API接口．</p>
<p>具体的参考代码在NVENC_export&#x2F;Samples&#x2F;nvEncode2&#x2F;src文件夹中的CNVEncoder.cpp文件中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    NVENCSTATUS nvStatus;</span><br><span class="line">    MYPROC nvEncodeAPICreateInstance; <span class="comment">// function pointer to create instance in nvEncodeAPI</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Is64Bit</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        m_hinstLib = <span class="built_in">LoadLibrary</span>(<span class="built_in">TEXT</span>(__NVEncodeLibName64));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_hinstLib = <span class="built_in">LoadLibrary</span>(<span class="built_in">TEXT</span>(__NVEncodeLibName32));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    m_hinstLib = <span class="built_in">dlopen</span>(__NVEncodeLibName, RTLD_LAZY);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_hinstLib != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line">        nvEncodeAPICreateInstance = (MYPROC) <span class="built_in">GetProcAddress</span>(m_hinstLib, <span class="string">&quot;NvEncodeAPICreateInstance&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        nvEncodeAPICreateInstance = (MYPROC) <span class="built_in">dlsym</span>(m_hinstLib, <span class="string">&quot;NvEncodeAPICreateInstance&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != nvEncodeAPICreateInstance) </span><br><span class="line">        &#123;</span><br><span class="line">            m_pEncodeAPI = <span class="keyword">new</span> NV_ENCODE_API_FUNCTION_LIST;</span><br><span class="line">            <span class="keyword">if</span> (m_pEncodeAPI)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(m_pEncodeAPI, <span class="number">0</span>, <span class="built_in">sizeof</span>(NV_ENCODE_API_FUNCTION_LIST));</span><br><span class="line">                m_pEncodeAPI-&gt;version = NV_ENCODE_API_FUNCTION_LIST_VER;</span><br><span class="line">                nvStatus = <span class="built_in">nvEncodeAPICreateInstance</span>(m_pEncodeAPI);</span><br><span class="line">                m_bEncodeAPIFound = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_bEncodeAPIFound = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">PRINTERR</span>((<span class="string">&quot;CNvEncoder::CNvEncoder() failed to find NvEncodeAPICreateInstance&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，我们拿到m_pEncodeAPI后(也就是执行完nvStatus &#x3D; nvEncodeAPICreateInstance(m_pEncodeAPI)语句后)，为了确保拿到的m_pEncodeAPI可以调用到我们后续需要的nvEncodeAPI接口，其实我们可以在加个if语句进行判断</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!m_pEncodeAPI-&gt;nvEncCreateBitstreamBuffer || !m_pEncodeAPI-&gt;nvEncOpenEncodeSession || !m_pEncodeAPI-&gt;nvEncGetEncodeGUIDCount || !m_pEncodeAPI-&gt;nvEncGetEncodeProfileGUIDCount ||</span><br><span class="line">						!m_pEncodeAPI-&gt;nvEncGetEncodeProfileGUIDs || !m_pEncodeAPI-&gt;nvEncGetEncodeGUIDs || !m_pEncodeAPI-&gt;nvEncGetInputFormatCount || !m_pEncodeAPI-&gt;nvEncGetInputFormats ||</span><br><span class="line">						!m_pEncodeAPI-&gt;nvEncGetEncodeCaps || !m_pEncodeAPI-&gt;nvEncGetEncodePresetCount || !m_pEncodeAPI-&gt;nvEncGetEncodePresetGUIDs || !m_pEncodeAPI-&gt;nvEncGetEncodePresetConfig ||</span><br><span class="line">						!m_pEncodeAPI-&gt;nvEncInitializeEncoder || !m_pEncodeAPI-&gt;nvEncCreateInputBuffer || !m_pEncodeAPI-&gt;nvEncDestroyInputBuffer || !m_pEncodeAPI-&gt;nvEncCreateBitstreamBuffer ||</span><br><span class="line">						!m_pEncodeAPI-&gt;nvEncDestroyBitstreamBuffer || !m_pEncodeAPI-&gt;nvEncEncodePicture || !m_pEncodeAPI-&gt;nvEncLockBitstream || !m_pEncodeAPI-&gt;nvEncUnlockBitstream ||</span><br><span class="line">						!m_pEncodeAPI-&gt;nvEncLockInputBuffer || !m_pEncodeAPI-&gt;nvEncUnlockInputBuffer || !m_pEncodeAPI-&gt;nvEncGetEncodeStats || !m_pEncodeAPI-&gt;nvEncGetSequenceParams ||</span><br><span class="line">						!m_pEncodeAPI-&gt;nvEncRegisterAsyncEvent || !m_pEncodeAPI-&gt;nvEncUnregisterAsyncEvent || !m_pEncodeAPI-&gt;nvEncMapInputResource || !m_pEncodeAPI-&gt;nvEncUnmapInputResource ||</span><br><span class="line">						!m_pEncodeAPI-&gt;nvEncDestroyEncoder || !m_pEncodeAPI-&gt;nvEncInvalidateRefFrames || !m_pEncodeAPI-&gt;nvEncOpenEncodeSessionEx || !m_pEncodeAPI-&gt;nvEncRegisterResource ||</span><br><span class="line">						!m_pEncodeAPI-&gt;nvEncUnregisterResource || !m_pEncodeAPI-&gt;nvEncReconfigureEncoder)</span><br><span class="line">                        &#123;</span><br><span class="line">                            m_bEncodeAPIFound = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            m_bEncodeAPIFound = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure>

<p>此时，如果m_bEncodeAPIFound为true就代表着我们已经成功的加载了我们后续需要的所有nvEncodeAPI接口（｡♥‿♥｡）</p>
<h2 id="4-2-设置所需的编码参数"><a href="#4-2-设置所需的编码参数" class="headerlink" title="4.2 设置所需的编码参数"></a>4.2 设置所需的编码参数</h2><p>至此，我们已经成功完成了编码器的初始化，接下来就需要对编码器的参数进行设置了．<br>具体步骤如下：</p>
<ul>
<li>获取编码会话句柄</li>
<li>选择编码器GUID</li>
<li>获取编码器信息</li>
<li>选择编码器预设配置</li>
<li>选择编码器配置文件</li>
<li>获取支持的输入格式列表</li>
</ul>
<h3 id="4-2-1-获取编码会话句柄"><a href="#4-2-1-获取编码会话句柄" class="headerlink" title="4.2.1 获取编码会话句柄"></a>4.2.1 获取编码会话句柄</h3><p>当我们成功加载 NVENC 接口后，还必须要调用NvEncOpenEncodeSessionEx打开编码会话。此函数返回一个编码会话句柄，该句柄必须用于当前会话中对 API 函数的所有后续调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NVENCSTATUS</span> <span class="params">(NVENCAPI* PNVENCOPENENCODESESSIONEX)</span>       <span class="params">(NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS *openSessionExParams, </span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">PNVENCOPENENCODESESSIONEX       nvEncOpenEncodeSessionEx;    </span></span></span><br></pre></td></tr></table></figure>
<p>在NVENC_export&#x2F;Samples&#x2F;nvEncode2&#x2F;src文件夹中的CNVEncoder.cpp文件中的CNvEncoder::OpenEncodeSession函数中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">    HRESULT hr = S_OK;</span><br><span class="line">    <span class="comment">//NVENCSTATUS nvStatus = NV_ENC_SUCCESS;</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;m_stEncoderInput, &amp;encodeConfig, <span class="built_in">sizeof</span>(m_stEncoderInput));</span><br><span class="line">    m_fOutput = m_stEncoderInput.fOutput;</span><br><span class="line">    <span class="type">bool</span> bCodecFound = <span class="literal">false</span>;</span><br><span class="line">    NV_ENC_CAPS_PARAM stCapsParam = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS stEncodeSessionParams = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uArraysize = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">SET_VER</span>(stCapsParam, NV_ENC_CAPS_PARAM);</span><br><span class="line">    <span class="built_in">SET_VER</span>(stEncodeSessionParams, NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If another NVENC session is already open, close it (to avoid mem-leak)</span></span><br><span class="line">	<span class="built_in">DestroyEncodeSession</span>();</span><br><span class="line"></span><br><span class="line">	nvStatus = NV_ENC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (m_stEncoderInput.interfaceType)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line">        <span class="keyword">case</span> NV_ENC_DX9:</span><br><span class="line">            <span class="built_in">InitD3D9</span>(deviceID);</span><br><span class="line">            stEncodeSessionParams.device = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(m_pD3D9Device);</span><br><span class="line">            stEncodeSessionParams.deviceType = NV_ENC_DEVICE_TYPE_DIRECTX;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> NV_ENC_DX10:</span><br><span class="line">            <span class="built_in">InitD3D10</span>(deviceID);</span><br><span class="line">            stEncodeSessionParams.device = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(m_pD3D10Device);</span><br><span class="line">            stEncodeSessionParams.deviceType = NV_ENC_DEVICE_TYPE_DIRECTX;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> NV_ENC_DX11:</span><br><span class="line">            <span class="built_in">InitD3D11</span>(deviceID);</span><br><span class="line">            stEncodeSessionParams.device = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(m_pD3D11Device);</span><br><span class="line">            stEncodeSessionParams.deviceType = NV_ENC_DEVICE_TYPE_DIRECTX;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">case</span> NV_ENC_CUDA:</span><br><span class="line">			<span class="keyword">if</span> ( !m_useExternalContext )</span><br><span class="line">				<span class="built_in">InitCuda</span>(deviceID);</span><br><span class="line">            stEncodeSessionParams.device = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(m_cuContext);</span><br><span class="line">            stEncodeSessionParams.deviceType = NV_ENC_DEVICE_TYPE_CUDA;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">assert</span>(<span class="string">&quot;Encoder interface not supported&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="comment">// switch</span></span><br><span class="line"></span><br><span class="line">    nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncOpenEncodeSessionEx</span>( &amp;stEncodeSessionParams, &amp;m_hEncoder);</span><br><span class="line">    <span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">my_printf</span>(<span class="string">&quot;nvEncOpenEncodeSessionEx() returned with error %d\n&quot;</span>, nvStatus);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Note: GUID key may be invalid or incorrect.  Recommend to upgrade your drivers and obtain a new key\n&quot;</span>);</span><br><span class="line">        <span class="comment">//checkNVENCErrors(nvStatus);// prevent NVNEC-plugin from exiting prematurely</span></span><br><span class="line">		<span class="keyword">return</span> E_FAIL;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以从上面的代码看出，由于Guest的作者在2013年提供的<a target="_blank" rel="noopener" href="https://github.com/jetkiwi/NVENC_export">NVENC_export</a>只适用于Win端，因此在上面的switch判断中，我们还需要加上一段针对Linux端的判断</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line">        <span class="keyword">case</span> NV_ENC_OPENGL:</span><br><span class="line">            <span class="comment">//NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS::device must be NULL if type is NV_ENC_OPENGL</span></span><br><span class="line">            stEncodeSessionParams.device = <span class="literal">nullptr</span>;</span><br><span class="line">            stEncodeSessionParams.deviceType = NV_ENC_DEVICE_TYPE_OPENGL;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>对应的将修改成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_NvEncodeInterfaceType</span></span><br><span class="line">&#123;</span><br><span class="line">    NV_ENC_DX9=<span class="number">0</span>,</span><br><span class="line">    NV_ENC_DX11=<span class="number">1</span>,</span><br><span class="line">    NV_ENC_CUDA=<span class="number">2</span>, <span class="comment">// On Linux, CUDA is the only NVENC interface available</span></span><br><span class="line">    NV_ENC_DX10=<span class="number">3</span>,</span><br><span class="line">    NV_ENC_OPENGL=<span class="number">4</span>,</span><br><span class="line">&#125; NvEncodeInterfaceType;</span><br></pre></td></tr></table></figure>
<p>至于为什么将device参数设置为nullptr，其实在官方提供的<a target="_blank" rel="noopener" href="https://docs.nvidia.com/video-technologies/video-codec-sdk/nvenc-video-encoder-api-prog-guide/">文档</a>里面是有说明的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">OpenGL</span><br><span class="line">    The client should create an OpenGL context and make it current (in order to associate the context with the thread/process that is making calls to NVENCODE API) to the thread calling into NVENCODE API. NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS::device must be NULL and NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS::deviceType must be set to NV_ENC_DEVICE_TYPE_OPENGL. Use of the OpenGL device type for encoding is supported only on Linux.</span><br><span class="line">```   </span><br><span class="line">### 4.2.2 选择编码器GUID</span><br><span class="line">大致的设置流程分为以下几个部分：</span><br><span class="line">- 调用NvEncGetEncodeGUIDCount从 NVIDIA 视频编码器接口获取支持的编码器 GUID 的数量。</span><br><span class="line">- 使用获取到的支持的编码器 GUID 的数量结果来分配一个足够大的缓冲区，来容纳支持的编码器 GUID</span><br><span class="line">- 调用NvEncGetEncodeGUIDs填充此列表。</span><br><span class="line"></span><br><span class="line">PS:一般来说调用nvEncGetEncodeGUIDCount接口后，m_dwEncodeGUIDCount返回的值应该为2，也就是支持H264和HEVC这两种编码方式，如果返回的值不是2，那就需要你自己去查一下你的显卡到底咋回事了；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">// Enumerate the codec support by the HW Encoder</span><br><span class="line">    nvStatus = m_pEncodeAPI-&gt;nvEncGetEncodeGUIDCount(m_hEncoder, &amp;m_dwEncodeGUIDCount);</span><br><span class="line">    if (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        my_printf(&quot;nvEncGetEncodeGUIDCount() returned with error %d\n&quot;, nvStatus);</span><br><span class="line">        checkNVENCErrors(nvStatus);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">		delete_array( m_stEncodeGUIDArray );</span><br><span class="line">        m_stEncodeGUIDArray       = new GUID[m_dwEncodeGUIDCount];</span><br><span class="line">        memset(m_stEncodeGUIDArray, 0, sizeof(GUID) * m_dwEncodeGUIDCount);</span><br><span class="line">        uArraysize = 0;</span><br><span class="line">        nvStatus = m_pEncodeAPI-&gt;nvEncGetEncodeGUIDs(m_hEncoder, m_stEncodeGUIDArray, m_dwEncodeGUIDCount, &amp;uArraysize);</span><br><span class="line">        assert(uArraysize &lt;= m_dwEncodeGUIDCount);</span><br><span class="line">        if (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            my_printf(&quot;nvEncGetEncodeGUIDs() returned with error %d\n&quot;, nvStatus);</span><br><span class="line">            checkNVENCErrors(nvStatus);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            for (unsigned int i = 0; i &lt; uArraysize; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                // check if HW encoder supports the particular codec -</span><br><span class="line">                if (GetCodecType(m_stEncodeGUIDArray[i]) == (unsigned int)m_stEncoderInput.codec)</span><br><span class="line">                &#123;</span><br><span class="line">					// Found the desired codec GUID - store it as &quot;m_stEncodeGUID&quot;</span><br><span class="line">                    bCodecFound = true;</span><br><span class="line">                    memcpy(&amp;m_stEncodeGUID, &amp;m_stEncodeGUIDArray[i], sizeof(GUID));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    if (bCodecFound == false)</span><br><span class="line">    &#123;</span><br><span class="line">		// Hardware doesn&#x27;t support our requested codec-type &lt;m_stEncoderInput.codec&gt;</span><br><span class="line">        assert(0);</span><br><span class="line">        return E_FAIL;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-3-获取编码器信息"><a href="#4-2-3-获取编码器信息" class="headerlink" title="4.2.3 获取编码器信息"></a>4.2.3 获取编码器信息</h3><p>NVIDIA 编码器接口公开了四种不同的调整信息枚举（高质量、低延迟、超低延迟和无损）来满足不同的视频编码应用场景<br>对于每个调整信息，提供了从 P1（最高性能）到 P7（最低性能）的七个预设来控制性能&#x2F;质量权衡。使用这些预设将自动为所选调谐信息设置所有相关编码参数。这是 API 公开的粗略控制级别。如果需要，可以调整预设中的特定属性&#x2F;参数。</p>
<p>获取编码器信息和预设配置的大致的设置流程分为以下几个部分：</p>
<ul>
<li>调用NvEncGetEncodePresetCount获取支持的编码器 GUID 的数量。</li>
<li>使用这个计数来分配一个足够大的缓冲区来保存支持的预设GUID。</li>
<li>调用NvEncGetEncodePresetGUIDs填充此列表。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetPresetConfig():</span></span><br><span class="line"><span class="comment">//    Gets the requested NVENC preset and stores it in this.m_stPresetConfig </span></span><br><span class="line"><span class="comment">//    Note, if requested preset is &#x27;default&#x27; (0), then allow any preset to be returned.</span></span><br><span class="line"><span class="comment">//    (This is a workaround for Geforce WHQL driver 314.21, where nvEncGetEncodePresetGUIDs returns</span></span><br><span class="line"><span class="comment">//    DEFAULT_GUID as a supported preset, but nvEncGetEncodePresetConfig returns ERROR for the</span></span><br><span class="line"><span class="comment">//    same DEFAULT_GUID.)</span></span><br><span class="line"><span class="function">HRESULT <span class="title">CNvEncoder::GetPresetConfig</span><span class="params">(<span class="type">const</span> <span class="type">int</span> iPresetIdx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NVENCSTATUS nvStatus = NV_ENC_SUCCESS;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uPresetCount2 = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncGetEncodePresetCount</span>(m_hEncoder, m_stEncodeGUID, &amp;m_dwCodecPresetGUIDCount);</span><br><span class="line">    <span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">		<span class="keyword">return</span> E_FAIL;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">delete_array</span>(m_stCodecPresetGUIDArray);</span><br><span class="line">    m_stCodecPresetGUIDArray = <span class="keyword">new</span> GUID[m_dwCodecPresetGUIDCount];</span><br><span class="line">    nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncGetEncodePresetGUIDs</span>(m_hEncoder, m_stEncodeGUID, m_stCodecPresetGUIDArray, m_dwCodecPresetGUIDCount, &amp;uPresetCount2);</span><br><span class="line">    <span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">		<span class="keyword">return</span> E_FAIL;</span><br><span class="line"></span><br><span class="line">	nvStatus = NV_ENC_ERR_GENERIC;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; m_dwCodecPresetGUIDCount; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// hack: if ( iPresetIdx == 0 &quot;default&quot;), then return the first valid preset.</span></span><br><span class="line">		<span class="keyword">if</span> ((<span class="type">int</span>)i == iPresetIdx || (iPresetIdx == <span class="number">0</span>) )</span><br><span class="line">		&#123;</span><br><span class="line">			nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncGetEncodePresetConfig</span>(m_hEncoder, m_stEncodeGUID, m_stCodecPresetGUIDArray[i], &amp;m_stPresetConfig);</span><br><span class="line">			<span class="keyword">if</span> (nvStatus == NV_ENC_SUCCESS)</span><br><span class="line">			&#123;</span><br><span class="line">				m_stPresetIdx  = iPresetIdx;</span><br><span class="line">				m_stPresetGUID = m_stCodecPresetGUIDArray[m_stPresetIdx];</span><br><span class="line"></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ( iPresetIdx != <span class="number">0</span> )</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nvStatus == NV_ENC_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> E_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-4-选择编码器预设配置"><a href="#4-2-4-选择编码器预设配置" class="headerlink" title="4.2.4 选择编码器预设配置"></a>4.2.4 选择编码器预设配置</h3><p>以下是获取预设编码配置并可选择更改选择配置参数的步骤：</p>
<ul>
<li>调用NvEncGetEncodePresetConfigEx与选定的 encodeGUID，调整信息和预设GUID作为输入</li>
<li>可以通过以下方式检索所需的预设编码器配置 NV_ENC_PRESET_CONFIG::presetCfg.</li>
<li>如果需要，使用相应的配置 API 覆盖默认编码器参数。</li>
</ul>
<p>这个可以不选择设置，直接采用默认的就行了，正常来说默认参数就够用了．</p>
<h3 id="4-2-5-选择编码器配置文件"><a href="#4-2-5-选择编码器配置文件" class="headerlink" title="4.2.5 选择编码器配置文件"></a>4.2.5 选择编码器配置文件</h3><p>大致的设置流程分为以下几个部分：</p>
<ul>
<li>调用NvEncGetEncodeProfileGUIDCount从 NVIDIA 视频编码器接口获取支持的编码器 GUID 的数量。</li>
<li>使用此计数来分配足够大小的缓冲区以容纳支持的编码配置文件 GUID。</li>
<li>调用NvEncGetEncodeProfileGUIDs填充此列表。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Enumerate the profile(s) available for selected codec &lt;m_stEncodeGUID&gt;</span></span><br><span class="line">  nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncGetEncodeProfileGUIDCount</span>(m_hEncoder, m_stEncodeGUID, &amp;m_dwCodecProfileGUIDCount);</span><br><span class="line">  <span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">my_printf</span>( <span class="string">&quot;nvEncGetEncodeProfileGUIDCount() returned with error %d\n&quot;</span>, nvStatus);</span><br><span class="line">      <span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">delete_array</span>( m_stCodecProfileGUIDArray );</span><br><span class="line">      m_stCodecProfileGUIDArray = <span class="keyword">new</span> GUID[m_dwCodecProfileGUIDCount];</span><br><span class="line">      <span class="built_in">memset</span>(m_stCodecProfileGUIDArray, <span class="number">0</span>, <span class="built_in">sizeof</span>(GUID) * m_dwCodecProfileGUIDCount);</span><br><span class="line">      uArraysize = <span class="number">0</span>;</span><br><span class="line">      nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncGetEncodeProfileGUIDs</span>(m_hEncoder,  m_stEncodeGUID, m_stCodecProfileGUIDArray, m_dwCodecProfileGUIDCount, &amp;uArraysize);</span><br><span class="line">      <span class="built_in">assert</span>(uArraysize &lt;= m_dwCodecProfileGUIDCount);</span><br><span class="line">      <span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">my_printf</span>( <span class="string">&quot;nvEncGetEncodeProfileGUIDs() returned with error %d\n&quot;</span>, nvStatus);</span><br><span class="line">          <span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          bCodecFound = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; uArraysize; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">// check if this HW-codec supports the requested profile &lt;m_stEncoderInput.profile&gt;</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">GetCodecProfile</span>(m_stCodecProfileGUIDArray[i]) == m_stEncoderInput.profile)</span><br><span class="line">              &#123;</span><br><span class="line">			<span class="comment">// Found the desired Profile - store it as &quot;m_stCodecProfileGUID&quot;</span></span><br><span class="line">                  bCodecFound = <span class="literal">true</span>;</span><br><span class="line">                  <span class="built_in">memcpy</span>(&amp;m_stCodecProfileGUID, &amp;m_stCodecProfileGUIDArray[i], <span class="built_in">sizeof</span>(GUID));</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bCodecFound == <span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="comment">// Codec doesn&#x27;t support our requested profile &lt;m_stEncoderInput.profile&gt;</span></span><br><span class="line">      <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> E_FAIL;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-2-6-获取支持的输入格式列表"><a href="#4-2-6-获取支持的输入格式列表" class="headerlink" title="4.2.6 获取支持的输入格式列表"></a>4.2.6 获取支持的输入格式列表</h3><p>NVENCODE API 接受几种不同格式的输入帧，例如特定格式的 YUV 和 RGB。</p>
<p>可以按如下方式检索支持的输入格式列表：</p>
<ul>
<li>调用NvEncGetInputFormatCount获取支持的输入格式的数量。</li>
<li>使用这个计数来分配一个缓冲区来保存支持的输入缓冲区格式列表（它们是类型的列表元素NV_ENC_BUFFER_FORMAT).</li>
<li>通过调用NvEncGetInputFormats检索支持的输入缓冲区格式.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// Enumerate the (framebuffer) InputFormats available for selected codec &lt;m_stEncodeGUID&gt;</span></span><br><span class="line">   nvStatus =  m_pEncodeAPI-&gt;<span class="built_in">nvEncGetInputFormatCount</span>(m_hEncoder, m_stEncodeGUID, &amp;m_dwInputFmtCount);</span><br><span class="line">   <span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">my_printf</span>(<span class="string">&quot;nvEncGetInputFormatCount() returned with error %d\n&quot;</span>, nvStatus);</span><br><span class="line">       <span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">delete_array</span>( m_pAvailableSurfaceFmts );</span><br><span class="line">       m_pAvailableSurfaceFmts = <span class="keyword">new</span> NV_ENC_BUFFER_FORMAT[m_dwInputFmtCount];</span><br><span class="line">       <span class="built_in">memset</span>(m_pAvailableSurfaceFmts, <span class="number">0</span>, <span class="built_in">sizeof</span>(NV_ENC_BUFFER_FORMAT) * m_dwInputFmtCount);</span><br><span class="line">       nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncGetInputFormats</span>(m_hEncoder, m_stEncodeGUID, m_pAvailableSurfaceFmts, m_dwInputFmtCount, &amp;uArraysize);</span><br><span class="line">       <span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">my_printf</span>(<span class="string">&quot;nvEncGetInputFormats() returned with error %d\n&quot;</span>, nvStatus);</span><br><span class="line">           <span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>  &#123;</span><br><span class="line">           <span class="type">bool</span> bFmtFound = <span class="literal">false</span>;</span><br><span class="line">		<span class="type">bool</span> bFound_420 = <span class="literal">false</span>;</span><br><span class="line">		<span class="type">bool</span> bFound_444 = <span class="literal">false</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> idx;</span><br><span class="line">           <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; m_dwInputFmtCount; idx++)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// check if this HW-codec supports the requested (framebuffer) InputFormat </span></span><br><span class="line">               bFound_420 = encodeConfig.chromaFormatIDC == cudaVideoChromaFormat_420 &amp;&amp;</span><br><span class="line">					(m_pAvailableSurfaceFmts[idx] == NV_ENC_BUFFER_FORMAT_NV12);</span><br><span class="line"></span><br><span class="line">			bFound_444 = encodeConfig.chromaFormatIDC == cudaVideoChromaFormat_444 &amp;&amp;</span><br><span class="line">     ## <span class="number">4.3</span> 分配输入/输出缓冲区                  (m_pAvailableSurfaceFmts[idx] == NV_ENC_BUFFER_FORMAT_YUV444);</span><br><span class="line">			<span class="keyword">if</span> ( bFound_420 || bFound_444 )</span><br><span class="line">			&#123;</span><br><span class="line">	            m_dwInputFormat = m_pAvailableSurfaceFmts[idx];</span><br><span class="line">				bFmtFound = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">           &#125;</span><br><span class="line">		<span class="keyword">if</span> ( !bFmtFound ) &#123;</span><br><span class="line">			<span class="built_in">my_printf</span>(<span class="string">&quot;ERROR, Unable to locate a compatible chromaformatIDC\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">           <span class="built_in">assert</span>(bFmtFound == <span class="literal">true</span>);</span><br><span class="line">           <span class="built_in">assert</span>(uArraysize &lt;= m_dwInputFmtCount);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (encodeConfig.preset &gt; <span class="number">-1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       hr = <span class="built_in">GetPresetConfig</span>(encodeConfig.preset);</span><br><span class="line">       <span class="keyword">if</span> (hr == S_OK)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">memcpy</span>(&amp;m_stEncodeConfig, &amp;m_stPresetConfig.presetCfg, <span class="built_in">sizeof</span>(NV_ENC_CONFIG));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if this HW-codec supports the requested (framebuffer) InputFormat </span></span><br><span class="line"><span class="keyword">if</span> (nvStatus != NV_ENC_SUCCESS)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (Premiere Pro only): setup which optimizations the format-repacker </span></span><br><span class="line"><span class="comment">//                      is allowed to use</span></span><br><span class="line">m_Repackyuv.<span class="built_in">set_cpu_allow_avx</span>(m_stEncoderInput.CPU_enableAVX);</span><br><span class="line">m_Repackyuv.<span class="built_in">set_cpu_allow_avx2</span>(m_stEncoderInput.CPU_enableAVX2);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-2-7-初始化硬件编码器会话"><a href="#4-2-7-初始化硬件编码器会话" class="headerlink" title="4.2.7 初始化硬件编码器会话"></a>4.2.7 初始化硬件编码器会话</h3><p>大致的设置流程分为以下几个部分：</p>
<ul>
<li>编码会话属性的配置</li>
<li>初始化硬件编码器会话</li>
</ul>
<h4 id="4-2-7-1-编码会话属性的配置"><a href="#4-2-7-1-编码会话属性的配置" class="headerlink" title="4.2.7.1 编码会话属性的配置"></a>4.2.7.1 编码会话属性的配置</h4><p>编码会话参数配置分为三部分：</p>
<ul>
<li>基本的编码会话参数</li>
<li>高级编码器级参数</li>
</ul>
<h5 id="4-2-7-1-1-基本的编码会话参数"><a href="#4-2-7-1-1-基本的编码会话参数" class="headerlink" title="4.2.7.1.1 基本的编码会话参数"></a>4.2.7.1.1 基本的编码会话参数</h5><p>输入格式、输出尺寸、显示纵横比、帧率、平均码率等常用参数在NV_ENC_INITIALIZE_PARAMS结构体。用户应使用此结构的实例作为输入 NvEnc初始化编码器.</p>
<p>必须填充以下成员 NV_ENC_INITIALIZE_PARAMS成功初始化编码会话的结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NV_ENC_INITALIZE_PARAMS::encodeGUID：必须选择合适的编解码器 GUID，如选择编码器GUID部分所述。</span><br><span class="line">NV_ENC_INITIALIZE_PARAMS::编码宽度：必须指定编码视频的所需宽度。</span><br><span class="line">NV_ENC_INITIALIZE_PARAMS::encodeHeight：必须指定编码视频的所需高度。</span><br><span class="line">NV_ENC_INITALIZE_PARAMS::reportSliceOffsets：可用于启用切片偏移的报告。此功能需要NV_ENC_INITALIZE_PARAMS::enableEncodeAsync设置为<span class="number">0</span>，并且不适用于Kepler GPU上基于MB和基于字节的切片。</span><br></pre></td></tr></table></figure>
<h5 id="4-2-7-1-2-高级编解码器级参数"><a href="#4-2-7-1-2-高级编解码器级参数" class="headerlink" title="4.2.7.1.2 高级编解码器级参数"></a>4.2.7.1.2 高级编解码器级参数</h5><p>参数NV_ENC_INITIALIZE_PARAMS::NV_ENC_CONFIG encodeConfig：处理编码比特流的参数，如 GOP 长度、编码器配置文件、速率控制模式等</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_NV_ENC_CONFIG</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span>                        version;           </span><br><span class="line">    GUID                            profileGUID;       </span><br><span class="line">    <span class="type">uint32_t</span>                        gopLength;         </span><br><span class="line">    <span class="type">int32_t</span>                         frameIntervalP;    </span><br><span class="line">    <span class="type">uint32_t</span>                        monoChromeEncoding;</span><br><span class="line">    NV_ENC_PARAMS_FRAME_FIELD_MODE  frameFieldMode;    </span><br><span class="line">                                                                                                              </span><br><span class="line">    NV_ENC_MV_PRECISION             mvPrecision;       </span><br><span class="line">    NV_ENC_RC_PARAMS                rcParams;          </span><br><span class="line">    NV_ENC_CODEC_CONFIG             encodeCodecConfig; </span><br><span class="line">    <span class="type">uint32_t</span>                        reserved [<span class="number">278</span>];    </span><br><span class="line">    <span class="type">void</span>*                           reserved2[<span class="number">64</span>];     </span><br><span class="line">&#125; NV_ENC_CONFIG;</span><br></pre></td></tr></table></figure>


<p>结构中提供高级 H.264、HEVC 和 AV1 特定参数 NV_ENC_CONFIG_H264,NV_ENC_CONFIG_HEVC和NV_ENC_CONFIG_AV1分别。用户可以通过该结构传递特定于编解码器的参数 NV_ENC_CONFIG::encodeCodecConfig.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \struct _NV_ENC_CODEC_CONFIG</span></span><br><span class="line"><span class="comment"> * Codec-specific encoder configuration parameters to be set during initialization.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">_NV_ENC_CODEC_CONFIG</span></span><br><span class="line">&#123;</span><br><span class="line">    NV_ENC_CONFIG_H264        h264Config;                <span class="comment">/**&lt; [in]: Specifies the H.264-specific encoder configuration. */</span></span><br><span class="line">    NV_ENC_CONFIG_HEVC        hevcConfig;                <span class="comment">/**&lt; [in]: Specifies the HEVC-specific encoder configuration. */</span></span><br><span class="line">    NV_ENC_CONFIG_H264_MEONLY h264MeOnlyConfig;          <span class="comment">/**&lt; [in]: Specifies the H.264-specific ME only encoder configuration. */</span></span><br><span class="line">    NV_ENC_CONFIG_HEVC_MEONLY hevcMeOnlyConfig;          <span class="comment">/**&lt; [in]: Specifies the HEVC-specific ME only encoder configuration. */</span></span><br><span class="line">    <span class="type">uint32_t</span>                reserved[<span class="number">320</span>];               <span class="comment">/**&lt; [in]: Reserved and must be set to 0 */</span></span><br><span class="line">&#125; NV_ENC_CODEC_CONFIG;</span><br></pre></td></tr></table></figure>

<p>具体的参考代码在NVENC_export&#x2F;Samples&#x2F;nvEncode2&#x2F;src文件夹中的CNvEncoderH264.cpp文件中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">HRESULT <span class="title">CNvEncoderH264::InitializeEncoderCodec</span><span class="params">(<span class="type">void</span> * <span class="type">const</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	NV_ENC_CONFIG_H264_VUI_PARAMETERS *pvui;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> x264_sei_uuid[<span class="number">16</span>] = <span class="comment">// X264&#x27;s unregistered_user SEI</span></span><br><span class="line">	&#123;   <span class="comment">// random ID number generated according to ISO-11578</span></span><br><span class="line">		<span class="number">0xdc</span>, <span class="number">0x45</span>, <span class="number">0xe9</span>, <span class="number">0xbd</span>, <span class="number">0xe6</span>, <span class="number">0xd9</span>, <span class="number">0x48</span>, <span class="number">0xb7</span>,</span><br><span class="line">		<span class="number">0x96</span>, <span class="number">0x2c</span>, <span class="number">0xd8</span>, <span class="number">0x20</span>, <span class="number">0xd9</span>, <span class="number">0x23</span>, <span class="number">0xee</span>, <span class="number">0xef</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">    HRESULT hr           = S_OK;</span><br><span class="line">    <span class="type">int</span> numFrames        = <span class="number">0</span>;</span><br><span class="line">    NVENCSTATUS nvStatus = NV_ENC_SUCCESS;</span><br><span class="line">    <span class="type">bool</span> bMVCEncoding    = m_stEncoderInput.profile == NV_ENC_H264_PROFILE_STEREO ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    m_bAsyncModeEncoding = ((m_stEncoderInput.syncMode==<span class="number">0</span>) ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">	string            s; <span class="comment">// text-buffer</span></span><br><span class="line">	ostringstream   oss; <span class="comment">// text-buffer to generate encoder-settings</span></span><br><span class="line"></span><br><span class="line">    m_uMaxHeight         = m_stEncoderInput.maxHeight;</span><br><span class="line">    m_uMaxWidth          = m_stEncoderInput.maxWidth;</span><br><span class="line">    m_dwFrameWidth       = m_stEncoderInput.width;</span><br><span class="line">    m_dwFrameHeight      = m_stEncoderInput.height;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;m_stInitEncParams, <span class="number">0</span>, <span class="built_in">sizeof</span>(NV_ENC_INITIALIZE_PARAMS));</span><br><span class="line">    <span class="built_in">SET_VER</span>(m_stInitEncParams, NV_ENC_INITIALIZE_PARAMS);</span><br><span class="line">    m_stInitEncParams.encodeConfig = &amp;m_stEncodeConfig;</span><br><span class="line">    <span class="built_in">SET_VER</span>(m_stEncodeConfig, NV_ENC_CONFIG);</span><br><span class="line"></span><br><span class="line">	pvui = <span class="built_in">reinterpret_cast</span>&lt;NV_ENC_CONFIG_H264_VUI_PARAMETERS *&gt;(p);</span><br><span class="line"></span><br><span class="line">    m_stInitEncParams.darHeight           = m_stEncoderInput.darRatioY;</span><br><span class="line">    m_stInitEncParams.darWidth            = m_stEncoderInput.darRatioX;</span><br><span class="line"><span class="comment">//    m_stInitEncParams.encodeHeight        = m_uMaxHeight;</span></span><br><span class="line"><span class="comment">//    m_stInitEncParams.encodeWidth         = m_uMaxWidth;</span></span><br><span class="line">    m_stInitEncParams.encodeHeight        = m_dwFrameHeight;</span><br><span class="line">    m_stInitEncParams.encodeWidth         = m_dwFrameWidth;</span><br><span class="line">    </span><br><span class="line">    m_uCurHeight                          = m_stInitEncParams.encodeHeight;</span><br><span class="line">    m_uCurWidth                           = m_stInitEncParams.encodeWidth;</span><br><span class="line">    </span><br><span class="line">    m_stInitEncParams.maxEncodeHeight     = m_uMaxHeight;</span><br><span class="line">    m_stInitEncParams.maxEncodeWidth      = m_uMaxWidth;</span><br><span class="line"></span><br><span class="line">    m_stInitEncParams.frameRateNum        = m_stEncoderInput.frameRateNum;</span><br><span class="line">    m_stInitEncParams.frameRateDen        = m_stEncoderInput.frameRateDen;</span><br><span class="line">    <span class="comment">//Fix me add theading model</span></span><br><span class="line">    m_stInitEncParams.enableEncodeAsync   = m_bAsyncModeEncoding;</span><br><span class="line">    m_stInitEncParams.enablePTD           = !m_stEncoderInput.disable_ptd;</span><br><span class="line">    m_stInitEncParams.reportSliceOffsets  = m_stEncoderInput.report_slice_offsets;</span><br><span class="line">    m_stInitEncParams.enableSubFrameWrite = m_stEncoderInput.enableSubFrameWrite;</span><br><span class="line">    m_stInitEncParams.encodeGUID          = m_stEncodeGUID;</span><br><span class="line">    m_stInitEncParams.presetGUID          = m_stPresetGUID;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// user_SEI: (1) Create 16-byte UUID header (this is x264&#x27;s uuid)</span></span><br><span class="line">	<span class="keyword">for</span>( <span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(x264_sei_uuid)/<span class="built_in">sizeof</span>(x264_sei_uuid[<span class="number">0</span>]); ++i ) </span><br><span class="line">		oss &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(x264_sei_uuid[i]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// user_SEI: (2) start putting NVENC&#x27;s encoder-settings</span></span><br><span class="line">    CUresult        cuResult = CUDA_SUCCESS;</span><br><span class="line">    CUdevice        cuDevice = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span>            gpu_name[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">checkCudaErrors</span>(<span class="built_in">cuDeviceGet</span>(&amp;cuDevice, m_deviceID));</span><br><span class="line">	<span class="built_in">checkCudaErrors</span>(<span class="built_in">cuDeviceGetName</span>(gpu_name, <span class="number">100</span>, cuDevice));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get the Geforce driver-version using NVAPI -</span></span><br><span class="line">	<span class="comment">//   NVENC functionality is a hardware+firmware implementation, so it is important</span></span><br><span class="line">	<span class="comment">//   to report both the GPU-hardware and the Geforce driver revision.</span></span><br><span class="line">	NvU32             NVidia_DriverVersion;</span><br><span class="line">	NvAPI_ShortString szBuildBranchString;</span><br><span class="line">	NvAPI_Status      nvs = <span class="built_in">NvAPI_SYS_GetDriverAndBranchVersion</span>( &amp;NVidia_DriverVersion, szBuildBranchString);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//oss &lt;&lt; &quot;x264 - core 141 - H.264/MPEG-4 AVC codec - Copyleft 2003-2012 - &quot; &lt;&lt; __DATE__ &quot;&#125;, NVENC API &quot; &lt;&lt; std::dec &lt;&lt; NVENCAPI_MAJOR_VERSION</span></span><br><span class="line">	oss &lt;&lt; <span class="string">&quot;CNvEncoderH264[&quot;</span> &lt;&lt; __DATE__  &lt;&lt; <span class="string">&quot;, NVENC API &quot;</span></span><br><span class="line">		&lt;&lt; std::dec &lt;&lt; NVENCAPI_MAJOR_VERSION &lt;&lt; <span class="string">&quot;.&quot;</span></span><br><span class="line">		&lt;&lt; std::dec &lt;&lt; NVENCAPI_MINOR_VERSION &lt;&lt; <span class="string">&quot;]&quot;</span></span><br><span class="line">		&lt;&lt; gpu_name;</span><br><span class="line">	<span class="keyword">if</span> ( nvs == NVAPI_OK )</span><br><span class="line">		oss &lt;&lt; <span class="string">&quot; (driver &quot;</span> &lt;&lt; szBuildBranchString &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; std::dec </span><br><span class="line">			&lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span>&gt;(NVidia_DriverVersion)  &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		oss &lt;&lt; <span class="string">&quot; (driver ???)&quot;</span>; <span class="comment">// unknown driver version</span></span><br><span class="line">	oss	&lt;&lt; <span class="string">&quot; - options: &quot;</span>;</span><br><span class="line"></span><br><span class="line">	oss &lt;&lt; <span class="string">&quot; / PROFILE=&quot;</span> &lt;&lt; std::dec &lt;&lt; m_stEncoderInput.profile;</span><br><span class="line">	<span class="comment">// NVENC PRESET - print the index-value instead of the actual GUID (which isn&#x27;t really informative)</span></span><br><span class="line">	desc_nv_enc_preset_names.<span class="built_in">value2string</span>(m_stPresetIdx, s);</span><br><span class="line">	oss &lt;&lt; <span class="string">&quot;,PRESET=&quot;</span> &lt;&lt; std::dec &lt;&lt; m_stPresetIdx;</span><br><span class="line">	oss &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;)&quot;</span>; <span class="comment">// show ascii-name of the preset</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//速率控制</span></span><br><span class="line">    <span class="keyword">if</span> (m_stEncoderInput.disableCodecCfg == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;profileGUID                  = m_stCodecProfileGUID;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.averageBitRate      = m_stEncoderInput.avgBitRate;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.maxBitRate          = m_stEncoderInput.peakBitRate;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.constQP.qpIntra     = m_stEncoderInput.qpI;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.constQP.qpInterP    = m_stEncoderInput.qpP;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.constQP.qpInterB    = m_stEncoderInput.qpB;</span><br><span class="line">		m_stInitEncParams.encodeConfig-&gt;rcParams.enableMinQP       = m_stEncoderInput.min_qp_ena;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.minQP.qpIntra     = m_stEncoderInput.min_qpI;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.minQP.qpInterP    = m_stEncoderInput.min_qpP;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.minQP.qpInterB    = m_stEncoderInput.min_qpB;</span><br><span class="line">		m_stInitEncParams.encodeConfig-&gt;rcParams.enableMaxQP       = m_stEncoderInput.max_qp_ena;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.maxQP.qpIntra     = m_stEncoderInput.max_qpI;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.maxQP.qpInterP    = m_stEncoderInput.max_qpP;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.maxQP.qpInterB    = m_stEncoderInput.max_qpB;</span><br><span class="line">		m_stInitEncParams.encodeConfig-&gt;rcParams.enableInitialRCQP    = m_stEncoderInput.initial_qp_ena;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.initialRCQP.qpIntra  = m_stEncoderInput.initial_qpI;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.initialRCQP.qpInterP = m_stEncoderInput.initial_qpP;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.initialRCQP.qpInterB = m_stEncoderInput.initial_qpB;</span><br><span class="line"></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;rcParams.rateControlMode     = (NV_ENC_PARAMS_RC_MODE)m_stEncoderInput.rateControl;</span><br><span class="line">		m_stInitEncParams.encodeConfig-&gt;rcParams.vbvBufferSize       =  m_stEncoderInput.vbvBufferSize;</span><br><span class="line">		m_stInitEncParams.encodeConfig-&gt;rcParams.vbvInitialDelay     =  m_stEncoderInput.vbvInitialDelay;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// user_SEI: (3) more NVENC&#x27;s encoder-settings</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">		oss 创建保存输入/输出数据所需的资源&lt;&lt; <span class="string">&quot; / rateMode=&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">switch</span>( m_stInitEncParams.encodeConfig-&gt;rcParams.rateControlMode ) &#123;</span><br><span class="line">			<span class="keyword">case</span> NV_ENC_PARAMS_RC_CONSTQP:        <span class="comment">/**&lt; Constant QP mode */</span></span><br><span class="line">				oss &lt;&lt; <span class="string">&quot;CONSTQP(I:P:B)=&quot;</span></span><br><span class="line">					&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.qpI &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">					&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.qpP &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">					&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.qpB;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> NV_ENC_PARAMS_RC_VBR:            <span class="comment">/**&lt; Variable bitrate mode */</span></span><br><span class="line">				oss &lt;&lt; <span class="string">&quot;VBR(avg:max)=&quot;</span></span><br><span class="line">					&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.avgBitRate &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">					&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.peakBitRate;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> NV_ENC_PARAMS_RC_CBR:            <span class="comment">/**&lt; Constant bitrate mode */</span></span><br><span class="line">				oss &lt;&lt; <span class="string">&quot;CBR(avg)=&quot;</span></span><br><span class="line">					&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.avgBitRate;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> NV_ENC_PARAMS_RC_VBR_MINQP:      <span class="comment">/**&lt; Variable bitrate mode with MinQP */</span></span><br><span class="line">				<span class="comment">// ASSUME min_qp_ena is set!</span></span><br><span class="line">				oss &lt;&lt; <span class="string">&quot;VBR_MINQP(avg:max)=&quot;</span></span><br><span class="line">					&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.avgBitRate &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">					&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.peakBitRate;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> NV_ENC_PARAMS_RC_2_PASS_QUALITY: <span class="comment">/**&lt; Multi pass CBR encoding optimized for image quality and works only with low latency mode */</span></span><br><span class="line">				oss &lt;&lt; <span class="string">&quot;2_PASS_QUALITY(avg)=&quot;</span></span><br><span class="line">					&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.avgBitRate;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> NV_ENC_PARAMS_RC_2_PASS_FRAMESIZE_CAP: <span class="comment">/**&lt; Multi pass CBR encoding optimized for maintaining frame size and works only with low latency mode */</span></span><br><span class="line">				oss &lt;&lt; <span class="string">&quot;2_PASS_FRAMESIZE_CAP(avg)=&quot;</span></span><br><span class="line">					&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.avgBitRate;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> NV_ENC_PARAMS_RC_2_PASS_VBR: <span class="comment">/**&lt; Multi pass VBR encoding for higher quality */</span></span><br><span class="line">				oss &lt;&lt; <span class="string">&quot;2_PASS_VBR(avg:max)=&quot;</span></span><br><span class="line">					&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.avgBitRate &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">					&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.peakBitRate;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( m_stEncoderInput.initial_qp_ena ) &#123;</span><br><span class="line">			oss &lt;&lt; <span class="string">&quot;,IniQP(I:P:B)=&quot;</span></span><br><span class="line">				&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.initial_qpI &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">				&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.initial_qpP &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">				&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.initial_qpB;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (m_stEncoderInput.min_qp_ena &amp;&amp; m_stEncoderInput.max_qp_ena) &#123;</span><br><span class="line">			oss &lt;&lt; <span class="string">&quot;,Min*MaxQP(I:P:B)=&quot;</span> </span><br><span class="line">				&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.min_qpI &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">				&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.min_qpP &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">				&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.min_qpB &lt;&lt; <span class="string">&quot;*&quot;</span></span><br><span class="line">				&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.max_qpI &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">				&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.max_qpP &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">				&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.max_qpB;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (m_stEncoderInput.min_qp_ena) &#123;</span><br><span class="line">			oss &lt;&lt; <span class="string">&quot;,MinQP(I:P:B)=&quot;</span></span><br><span class="line">				&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.min_qpI &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">				&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.min_qpP &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">				&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.min_qpB;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (m_stEncoderInput.max_qp_ena) &#123;</span><br><span class="line">			oss &lt;&lt; <span class="string">&quot;,MaxQP(I:P:B)=&quot;</span></span><br><span class="line">				&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.max_qpI &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">				&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.max_qpP &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">				&lt;&lt; std::dec &lt;&lt; m_stEncoderInput.max_qpB;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// report adaptive-quantization for everything, &#x27;cause I don&#x27;t know its effect</span></span><br><span class="line">		<span class="keyword">if</span> (m_stInitEncParams.encodeConfig-&gt;rcParams.enableAQ )</span><br><span class="line">			oss &lt;&lt; <span class="string">&quot;,AQ&quot;</span>; <span class="comment">// adaptive quantization</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIG_RCPARAM_2_OSS2(var,name) \</span></span><br><span class="line"><span class="meta">	oss <span class="string">&lt;&lt; &quot; / &quot; &lt;&lt; name &lt;&lt; &quot;=&quot; &lt;&lt; std::dec &lt;&lt; (unsigned) m_stInitEncParams.encodeConfig-&gt;</span>rcParams. ## var</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIG_RCPARAM_2_OSS( var ) ADD_ENCODECONFIG_RCPARAM_2_OSS2(var,#var) </span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIG_RCPARAM_2_OSS2</span>(vbvBufferSize,<span class="string">&quot;vbvBS&quot;</span>);</span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIG_RCPARAM_2_OSS2</span>(vbvInitialDelay,<span class="string">&quot;vbvID&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// user_SEI: (3) more NVENC&#x27;s encoder-settings</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;frameIntervalP       = m_stEncoderInput.numBFrames + <span class="number">1</span>;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;gopLength            = (m_stEncoderInput.gopLength &gt; <span class="number">0</span>) ?  m_stEncoderInput.gopLength : <span class="number">30</span>;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;monoChromeEncoding   = m_stEncoderInput.monoChromeEncoding;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;frameFieldMode       = m_stEncoderInput.FieldEncoding ;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;mvPrecision          = m_stEncoderInput.mvPrecision;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIG_2_OSS2( var, name ) \</span></span><br><span class="line"><span class="meta">	oss <span class="string">&lt;&lt; &quot; / &quot; &lt;&lt; name &lt;&lt; &quot;=&quot; &lt;&lt; std::dec &lt;&lt; (unsigned) m_stInitEncParams.encodeConfig-&gt;</span> ## var</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIG_2_OSS(var) ADD_ENCODECONFIG_2_OSS2(var,#var)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIG_2_OSS2_if_nz( var, name ) \</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span> ( m_stInitEncParams.encodeConfig-&gt; ## var ) \</span></span><br><span class="line"><span class="meta">		oss <span class="string">&lt;&lt; &quot; / &quot; &lt;&lt; name &lt;&lt; &quot;=&quot; &lt;&lt; std::dec &lt;&lt; (unsigned) m_stInitEncParams.encodeConfig-&gt;</span> ## var</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIG_2_OSS_if_nz( var ) ADD_ENCODECONFIG_2_OSS2_if_nz(var,#var)</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIG_2_OSS2</span>(frameIntervalP,<span class="string">&quot;IntervalP&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> ( m_stEncoderInput.numBFrames )</span><br><span class="line">			oss &lt;&lt; <span class="string">&quot; (BFrames=&quot;</span> &lt;&lt; std::dec &lt;&lt; m_stEncoderInput.numBFrames &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIG_2_OSS2</span>(gopLength,<span class="string">&quot;gop&quot;</span>);</span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIG_2_OSS2_if_nz</span>(monoChromeEncoding,<span class="string">&quot;mono&quot;</span>);</span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIG_2_OSS2</span>(frameFieldMode,<span class="string">&quot;frameMode&quot;</span>);</span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIG_2_OSS2</span>(mvPrecision,<span class="string">&quot;mv&quot;</span>);</span><br><span class="line"></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.disableDeblockingFilterIDC = m_stEncoderInput.disableDeblock; <span class="comment">// alawys enable deblk filter for h264</span></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.adaptiveTransformMode      = (m_stEncoderInput.profile &gt;= NV_ENC_H264_PROFILE_HIGH) ? m_stEncoderInput.adaptive_transform_mode : NV_ENC_H264_ADAPTIVE_TRANSFORM_AUTOSELECT;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.fmoMode                    = m_stEncoderInput.enableFMO;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.bdirectMode                = m_stEncoderInput.numBFrames &gt; <span class="number">0</span> ? m_stEncoderInput.bdirectMode : NV_ENC_H264_BDIRECT_MODE_DISABLE;</span><br><span class="line"><span class="comment">//        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.bdirectMode                = m_stEncoderInput.numBFrames &gt; 0 ? NV_ENC_H264_BDIRECT_MODE_TEMPORAL : NV_ENC_H264_BDIRECT_MODE_DISABLE;</span></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.outputAUD                  = m_stEncoderInput.aud_enable;</span><br><span class="line"><span class="comment">//      m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.entropyCodingMode        = (m_stEncoderInput.profile &gt; NV_ENC_H264_PROFILE_BASELINE) ? m_stEncoderInput.vle_entropy_mode : NV_ENC_H264_ENTROPY_CODING_MODE_CAVLC;</span></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.idrPeriod                = m_stInitEncParams.encodeConfig-&gt;gopLength ;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.level                    = m_stEncoderInput.level;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.numTemporalLayers        = m_stEncoderInput.numlayers;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		if (m_stEncoderInput.svcTemporal)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.enableTemporalSVC = 1;</span></span><br><span class="line"><span class="comment">            m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.h264Extension.svcTemporalConfig.basePriorityID           = 0;</span></span><br><span class="line"><span class="comment">            m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.h264Extension.svcTemporalConfig.numTemporalLayers = m_stEncoderInput.numlayers;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// NVENC 4.0 API</span></span><br><span class="line">		<span class="comment">// -------------</span></span><br><span class="line">		<span class="comment">// From documentation, setting the chromaFromatIDC to 3 will select</span></span><br><span class="line">		<span class="comment">// 4:4:4 chroma-format!</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// Don&#x27;t need to specify &#x27;separate color planes&#x27;</span></span><br><span class="line">		<span class="keyword">switch</span> (m_stEncoderInput.chromaFormatIDC) &#123;</span><br><span class="line">			<span class="keyword">case</span> cudaVideoChromaFormat_444:</span><br><span class="line">				m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.chromaFormatIDC = <span class="number">3</span>; <span class="comment">// YUV444</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">default</span>: <span class="comment">// cudaVideoChromaFormat_420:</span></span><br><span class="line">				m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.chromaFormatIDC = <span class="number">1</span>; <span class="comment">// YUV420</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIGH264_2_OSS2(var,name) \</span></span><br><span class="line"><span class="meta">	oss <span class="string">&lt;&lt; &quot; / &quot; &lt;&lt; name &lt;&lt; &quot;=&quot; &lt;&lt; std::dec &lt;&lt; (unsigned) m_stInitEncParams.encodeConfig-&gt;</span>encodeCodecConfig.h264Config. ## var</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIGH264_2_OSS( var ) ADD_ENCODECONFIGH264_2_OSS2(var,#var)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIGH264_2_OSS2_if_nz(var,name) \</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span> ( m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config. ## var ) \</span></span><br><span class="line"><span class="meta">		oss <span class="string">&lt;&lt; &quot; / &quot; &lt;&lt; name &lt;&lt; &quot;=&quot; &lt;&lt; std::dec &lt;&lt; (unsigned) m_stInitEncParams.encodeConfig-&gt;</span>encodeCodecConfig.h264Config. ## var</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_ENCODECONFIGH264_2_OSS_if_nz(var,name) ADD_ENCODECONFIGH264_2_OSS2_if_nz(var,#var)</span></span><br><span class="line"></span><br><span class="line">		desc_nv_enc_buffer_format_names.<span class="built_in">value2string</span>(</span><br><span class="line">			m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.chromaFormatIDC, s</span><br><span class="line">		);</span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIGH264_2_OSS2</span>(chromaFormatIDC,<span class="string">&quot;chroma&quot;</span>);</span><br><span class="line">		<span class="comment">//oss &lt;&lt; &quot;(&quot; &lt;&lt; s &lt;&lt; &quot;)&quot;; // show ascii-name of the chromaFormatIDC</span></span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(separateColourPlaneFlag,<span class="string">&quot;sepCPF&quot;</span>);</span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(disableDeblockingFilterIDC,<span class="string">&quot;disDF&quot;</span>);</span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIGH264_2_OSS2</span>(adaptiveTransformMode,<span class="string">&quot;adaTM&quot;</span>);</span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIGH264_2_OSS_if_nz</span>(fmoMode,<span class="string">&quot;fmoMode&quot;</span>);</span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIGH264_2_OSS</span>(bdirectMode);</span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIGH264_2_OSS_if_nz</span>(outputAUD,<span class="string">&quot;outputAUD&quot;</span>);</span><br><span class="line">		<span class="comment">//ADD_ENCODECONFIGH264_2_OSS(entropyCodingMode);</span></span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIGH264_2_OSS</span>(idrPeriod);</span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIGH264_2_OSS</span>(level);</span><br><span class="line">		<span class="comment">//ADD_ENCODECONFIGH264_2_OSS(numTemporalLayers);</span></span><br><span class="line"></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.outputBufferingPeriodSEI = m_stEncoderInput.output_sei_BufferPeriod;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.outputPictureTimingSEI   = m_stEncoderInput.output_sei_PictureTime;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.hierarchicalPFrames      = !! m_stEncoderInput.hierarchicalP;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.hierarchicalBFrames      = !! m_stEncoderInput.hierarchicalB;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.disableSPSPPS            = !! m_stEncoderInput.outBandSPSPPS;</span><br><span class="line"><span class="comment">//        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.outputFramePackingSEI    = m_stEncoderInput.stereo3dMode!= NV_ENC_STEREO_PACKING_MODE_NONE ? 1 : 0;</span></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.outputFramePackingSEI    = m_stEncoderInput.stereo3dEnable ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.stereoMode               = (NV_ENC_STEREO_PACKING_MODE)m_stEncoderInput.stereo3dMode;</span><br><span class="line">		m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.enableStereoMVC          = m_stEncoderInput.stereo3dEnable;</span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.separateColourPlaneFlag  = m_stEncoderInput.separateColourPlaneFlag;<span class="comment">// set to 1 to enable 4:4:4 mode</span></span><br><span class="line">        m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.entropyCodingMode        = (m_stEncoderInput.profile &gt; NV_ENC_H264_PROFILE_BASELINE) ? m_stEncoderInput.vle_entropy_mode : NV_ENC_H264_ENTROPY_CODING_MODE_CAVLC;</span><br><span class="line">        <span class="keyword">if</span> (m_stEncoderInput.max_ref_frames&gt;<span class="number">0</span>) </span><br><span class="line">             m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.maxNumRefFrames     = m_stEncoderInput.max_ref_frames;</span><br><span class="line">        <span class="keyword">if</span> ( pvui != <span class="literal">NULL</span> )</span><br><span class="line">            m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.h264VUIParameters = *pvui;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(outputBufferingPeriodSEI,<span class="string">&quot;outBPSEI&quot;</span>);</span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(outputPictureTimingSEI,<span class="string">&quot;outPTSEI&quot;</span>);</span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(hierarchicalPFrames,<span class="string">&quot;hierP&quot;</span>);</span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(hierarchicalBFrames,<span class="string">&quot;hierB&quot;</span>);</span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(disableSPSPPS,<span class="string">&quot;disSPSPPS&quot;</span>);</span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(outputFramePackingSEI,<span class="string">&quot;outFPSEI&quot;</span>);</span><br><span class="line"><span class="comment">//		ADD_ENCODECONFIGH264_2_OSS2_if_nz(enableStereoMVC,&quot;enableStereo&quot;);</span></span><br><span class="line"><span class="comment">//		if ( m_stEncoderInput.stereo3dEnable )</span></span><br><span class="line"><span class="comment">//			ADD_ENCODECONFIGH264_2_OSS2(stereoMode,&quot;stereoMode&quot;);</span></span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIGH264_2_OSS2</span>(entropyCodingMode,<span class="string">&quot;entCM&quot;</span>);</span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIGH264_2_OSS2</span>(maxNumRefFrames,<span class="string">&quot;maxRef&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (m_stEncoderInput.enableLTR) &#123;</span><br><span class="line">			<span class="built_in">ADD_ENCODECONFIGH264_2_OSS2</span>(ltrNumFrames, <span class="string">&quot;ltrnf&quot;</span>);</span><br><span class="line">			<span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(ltrTrustMode, <span class="string">&quot;ltrtm&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.sliceMode = m_stEncoderInput.sliceMode;</span><br><span class="line">		m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.sliceModeData = m_stEncoderInput.sliceModeData;</span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIGH264_2_OSS2</span>(sliceMode, <span class="string">&quot;SM&quot;</span>);</span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIGH264_2_OSS2</span>(sliceModeData, <span class="string">&quot;SMData&quot;</span>);</span><br><span class="line"></span><br><span class="line">		m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.enableLTR    = m_stEncoderInput.enableLTR;</span><br><span class="line">		m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.ltrNumFrames = m_stEncoderInput.ltrNumFrames;</span><br><span class="line">		m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.ltrTrustMode = m_stEncoderInput.ltrTrustMode;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// NVENC API 3</span></span><br><span class="line">		m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.enableVFR = m_stEncoderInput.enableVFR ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(enableVFR,<span class="string">&quot;enaVFR&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// NVENC API 4</span></span><br><span class="line">		m_stInitEncParams.encodeConfig-&gt;encodeCodecConfig.h264Config.qpPrimeYZeroTransformBypassFlag = m_stEncoderInput.qpPrimeYZeroTransformBypassFlag;</span><br><span class="line">		<span class="built_in">ADD_ENCODECONFIGH264_2_OSS2_if_nz</span>(qpPrimeYZeroTransformBypassFlag,<span class="string">&quot;qpPrimeYZero&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ..........</span><br></pre></td></tr></table></figure>
<h4 id="4-2-7-2-初始化硬件编码器会话"><a href="#4-2-7-2-初始化硬件编码器会话" class="headerlink" title="4.2.7.2 初始化硬件编码器会话"></a>4.2.7.2 初始化硬件编码器会话</h4><p>当我们完成上面的参数设置后，就可以将前面设置的NV_ENC_INITIALIZE_PARAMS作为输入参数，调用nvEncInitializeEncoder，来完成编码器的初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// Initialize the Encoder</span></span><br><span class="line">   nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncInitializeEncoder</span>(m_hEncoder, &amp;m_stInitEncParams);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nvStatus == NV_ENC_SUCCESS)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (m_stEncoderInput.outBandSPSPPS &gt; <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">           <span class="built_in">SET_VER</span>(m_spspps, NV_ENC_SEQUENCE_PARAM_PAYLOAD);</span><br><span class="line">           m_spspps.spsppsBuffer = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">char</span> [<span class="number">1024</span>];</span><br><span class="line">           m_spspps.inBufferSize = <span class="number">1024</span>;</span><br><span class="line">           m_spspps.outSPSPPSPayloadSize = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">int</span>[<span class="number">1</span>];</span><br><span class="line">           nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncGetSequenceParams</span>(m_hEncoder, &amp;m_spspps);</span><br><span class="line">           <span class="built_in">assert</span>(nvStatus == NV_ENC_SUCCESS);</span><br><span class="line">           <span class="keyword">if</span> (nvStatus == NV_ENC_SUCCESS)</span><br><span class="line">           &#123;</span><br><span class="line">               (*m_fwrite_callback)(m_spspps.spsppsBuffer, <span class="number">1</span>, *m_spspps.outSPSPPSPayloadSize, m_fOutput, m_privateData);</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt; outSPSPPS PayloadSize = %d, Payload=&quot;</span>, *m_spspps.outSPSPPSPayloadSize);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(*m_spspps.outSPSPPSPayloadSize) ; i++) </span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, ((<span class="type">unsigned</span> <span class="type">char</span> *)m_spspps.spsppsBuffer)[i]);</span><br><span class="line"></span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-3-分配输入-x2F-输出缓冲区"><a href="#4-3-分配输入-x2F-输出缓冲区" class="headerlink" title="4.3 分配输入&#x2F;输出缓冲区"></a>4.3 分配输入&#x2F;输出缓冲区</h2><p>当我们完成初始化编码会话后，此时应该分配缓冲区来保存输入&#x2F;输出数据。</p>
<p>而我们由于我们是在Linux端，通过OpenGL来给NvEnc数据，因此我们此时就那不通过直接调用NvEncCreateInputBuffer应用程序接口来分配输入缓冲区了．<br>具体解释，在官方文档中也有重点提到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Creating Resources Required to Hold Input/output Data</span><br><span class="line">Once the encode session is initialized, the client should allocate buffers to hold the input/output data.</span><br><span class="line"></span><br><span class="line">The client may choose to allocate input buffers through NVIDIA Video Encoder Interface by calling NvEncCreateInputBuffer API. In this case, the client is responsible for destroying the allocated input buffers before closing the encode session. It is also the client’s responsibility to fill the input buffer with valid input data according to the chosen input buffer format.</span><br><span class="line"></span><br><span class="line">The client should allocate buffers to hold the output encoded bit stream using the NvEncCreateBitstreamBuffer API. It is the client’s responsibility to destroy these buffers before closing the encode session.</span><br><span class="line"></span><br><span class="line">Alternatively, in scenarios where the client cannot or does not want to allocate input buffers through the NVIDIA Video Encoder Interface, it can use any externally allocated DirectX resource as an input buffer. However, the client must perform some simple processing to map these resources to resource handles that are recognized by the NVIDIA Video Encoder Interface before use. The translation procedure is explained in Section Input buffers allocated externally.</span><br><span class="line"></span><br><span class="line">If the client has used a CUDA device to initialize the encoder session and wishes to use input buffers NOT allocated through the NVIDIA Video Encoder Interface, the client is required to use buffers allocated using the cuMemAlloc family of APIs. NVIDIA Video Encoder Interface supports CUdeviceptr and CUarray input formats.</span><br><span class="line"></span><br><span class="line">If the client has used the OpenGL device type to initialize the encoder session and wishes to use input buffers NOT allocated through the NVIDIA Video Encoder Interface, the client is required to provide the textures allocated earlier.</span><br><span class="line"></span><br><span class="line">The client may generate textures using glGenTextures(), bind it to either the NV_ENC_INPUT_RESOURCE_OPENGL_TEX::GL_TEXTURE_RECTANGLE or NV_ENC_INPUT_RESOURCE_OPENGL_TEX::GL_TEXTURE_2D target, allocate storage for it using glTexImage2D() and copy data to it.</span><br><span class="line"></span><br><span class="line">Note that the OpenGL interface for NVENCODE API is only supported on Linux.</span><br><span class="line"></span><br><span class="line">If the client has used a DirectX 12 device to initialize encoder session, then client must allocate input and output buffers using ID3D12Device::CreateCommittedResource() API. The client must perform some simple processing to map these input and output resources to resource handles that are recognized by the NVIDIA Video Encoder Interface before use. The translation procedure is explained in Section Input output buffer allocation for DirectX 12.</span><br><span class="line"></span><br><span class="line">Note: The client should allocate at least (1 + NB) input and output buffers, where NB is the number of B frames between successive P frames.</span><br></pre></td></tr></table></figure>
<h3 id="4-3-1-外部分配的输入缓冲区"><a href="#4-3-1-外部分配的输入缓冲区" class="headerlink" title="4.3.1 外部分配的输入缓冲区"></a>4.3.1 外部分配的输入缓冲区</h3><p>要将外部分配的缓冲区传递给编码器，需要执行以下步骤：</p>
<ul>
<li>填充具有外部分配缓冲区的属性的NV_ENC_REGISTER_RESOURCE。</li>
<li>调用NvEncRegisterResource，将上述填充好的NV_ENC_REGISTER_RESOURCE属性注册。</li>
<li>NvEncRegisterResource返回一个已注册的资源句柄NV_ENC_REGISTER_RESOURCE::registeredResource。</li>
<li>使用上述的句柄调用NvEncMapInputResource。</li>
<li>NV_ENC_MAP_INPUT_RESOURCE::mappedResource映射的句柄将会生效。</li>
<li>用户应当使用这个映射的句柄(NV_ENC_MAP_INPUT_RESOURCE::mappedResource) 作为输入缓冲句柄参数(NV_ENC_PIC_PARAMS)。</li>
<li>用户使用完资源后NvEncUnmapInputResource必须被调用。</li>
<li>在销毁注册的资源之前，用户还必须调用NvEncUnregisterResource，传入NvEncRegisterResource返回的句柄。映射的资源句柄 (NV_ENC_MAP_INPUT_RESOURCE::mappedResource) 不应在 NVIDIA 视频编码器接口处于映射状态时用于任何其他目的。这种用法不受支持，可能会导致未定义的行为。</li>
</ul>
<p>我们需要思考一个问题，外部分配的输入缓冲区要多大？这就需要看一下NvEnc支持什么格式的数据进行编码了，通过文档我们可以看出编码支持YUV和RGB格式直接编码，那么我们就可以直接将OpenGL渲染和特效处理后的RGBA数据直接进行编码啦！！！（如果你想知道NV12的数据如何编码可以参考例程，后面我写的这些代码里面的NV_ENC_BUFFER_FORMAT_NV12_TYPE走的就是NV12的编码，但是是只有一条纹理(直接把NV12存到一条上，你也可以用两条，具体参考例程吧)）</p>
<h3 id="4-3-1-1-NV-ENC-REGISTER-RESOURCE的填充和注册"><a href="#4-3-1-1-NV-ENC-REGISTER-RESOURCE的填充和注册" class="headerlink" title="4.3.1.1 NV_ENC_REGISTER_RESOURCE的填充和注册"></a>4.3.1.1 NV_ENC_REGISTER_RESOURCE的填充和注册</h3><p>我们可以先看下NVENC_export&#x2F;Samples&#x2F;nvEncode2&#x2F;src文件夹中的CNvEncoderH264.cpp文件中对应的这段代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配 IO 缓冲区 -</span></span><br><span class="line">        <span class="comment">// 注意，这里的表面必须分配给源视频的*编码高度*和*编码宽度*，</span></span><br><span class="line">        <span class="comment">// 而不是显示高度和宽度。如果我们使用显示高度和宽度，那么色度部分</span></span><br><span class="line">        <span class="comment">// 解码帧的偏移很可能不正确（导致颜色未对齐。）</span></span><br><span class="line">        <span class="comment">// 例子：</span></span><br><span class="line">        <span class="comment">// 源视频编码宽度 x 高度 = 1920 x 1088（编码尺寸 VC1/MPEG2/MPEG4/H264）</span></span><br><span class="line">        <span class="comment">// 源视频显示尺寸 = 1920 x 1080</span></span><br><span class="line">        <span class="comment">// ...AllocateIOBuffers( 1920, 1088, ...);</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"><span class="comment">// 在隔行编码模式下，编码器将输入作为一个整体帧（即一对场）接收，</span></span><br><span class="line"><span class="comment">// 所以仍然使用全高。</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dwPicHeight = m_uMaxHeight;</span><br><span class="line"><span class="type">int</span> numMBs = ((m_dwFrameWidth + <span class="number">15</span>)/<span class="number">16</span>) * ((dwPicHeight + <span class="number">15</span>)/<span class="number">16</span>);</span><br><span class="line"><span class="type">int</span> NumIOBuffers = m_stEncoderInput.numBFrames + <span class="number">4</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AllocateIOBuffers</span>(m_uMaxWidth, dwPicHeight, NumIOBuffers);</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>在AllocateIOBuffers函数中，我们可以看到由于NVENC_export在设计之初是只为使用在Win端的，因此它整个类型判断只有NV_ENC_CUDA和NV_ENC_DX9，缺少了Linux端的代码，因此我们需要多新增一个NV_ENC_OPENGL枚举变量，并添加改类型的代码，如下所示，可以看出在NV_ENC_OPENGL类型的if语句中，我们首先使用 glGenTextures() 生成纹理，并将其绑定到NV_ENC_INPUT_RESOURCE_OPENGL_TEX::GL_TEXTURE_2D 目标，接着使用 glTexImage2D() 为其分配存储空间．</p>
<p>PS:这边顺便也加了一段NV_ENC_DX11的代码，如果你用到NV_ENC_DX12,NV_ENC_DX10那就参考着这个改就行了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">CNvEncoder::AllocateIOBuffers</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> dwInputWidth, <span class="type">unsigned</span> <span class="type">int</span> dwInputHeight, <span class="type">unsigned</span> <span class="type">int</span> maxFrmCnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_dwMaxSurfCount = maxFrmCnt;</span><br><span class="line">    NVENCSTATUS status = NV_ENC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &gt; CNvEncoder::AllocateIOBuffers() = Size (%dx%d @ %d frames)\n&quot;</span>, dwInputWidth, dwInputHeight, maxFrmCnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; m_dwMaxSurfCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        m_stInputSurface[i].dwWidth  = dwInputWidth;</span><br><span class="line">        m_stInputSurface[i].dwHeight = dwInputHeight;</span><br><span class="line">        <span class="keyword">if</span> (m_stEncoderInput.useMappedResources)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_CUDA)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; &gt; CUDA+NVENC InterOp using %d buffers.\n&quot;</span>, m_dwMaxSurfCount);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Illustrate how to use a Cuda buffer not allocated using NvEncCreateInputBuffer as input to the encoder.</span></span><br><span class="line">                <span class="built_in">cuCtxPushCurrent</span>(m_cuContext);</span><br><span class="line">                CUcontext   cuContextCurr;</span><br><span class="line">                CUdeviceptr devPtrDevice;</span><br><span class="line">                CUresult    result = CUDA_SUCCESS;                          </span><br><span class="line"></span><br><span class="line">				<span class="comment">// For each buffer, allocate a host-memory space and a device-memory space.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// (1) Allocate Cuda buffer. We will use this to hold the input YUV data.</span></span><br><span class="line">				<span class="type">unsigned</span> row_count;</span><br><span class="line">				<span class="keyword">if</span> ( m_stEncoderInput.chromaFormatIDC == cudaVideoChromaFormat_420 ) &#123;</span><br><span class="line">					m_stInputSurface[i].bufferFmt = NV_ENC_BUFFER_FORMAT_NV12;</span><br><span class="line">					row_count = dwInputHeight*<span class="number">3</span>/<span class="number">2</span>; <span class="comment">// enough rows for NV12 frame</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// YUV 4:4:4</span></span><br><span class="line">					m_stInputSurface[i].bufferFmt = NV_ENC_BUFFER_FORMAT_YUV444;</span><br><span class="line">					row_count = dwInputHeight*<span class="number">3</span>; <span class="comment">// enough rows for YUV444 frame</span></span><br><span class="line">				&#125;</span><br><span class="line">                result = <span class="built_in">cuMemAllocPitch</span>(&amp;devPtrDevice, (<span class="type">size_t</span> *)&amp;m_stInputSurface[i].dwCuPitch, dwInputWidth, row_count, <span class="number">16</span>);</span><br><span class="line">                m_stInputSurface[i].pExtAlloc      = (<span class="type">void</span>*)devPtrDevice;</span><br><span class="line">				<span class="built_in">cuMemsetD8</span>( devPtrDevice, <span class="number">128</span>, m_stInputSurface[i].dwCuPitch*row_count);<span class="comment">// clear the memory</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// (2) Allocate Cuda buffer in host memory. We will use this to load data onto the Cuda buffer we want to use as input.</span></span><br><span class="line">                result = <span class="built_in">cuMemAllocHost</span>((<span class="type">void</span>**)&amp;m_stInputSurface[i].pExtAllocHost, m_stInputSurface[i].dwCuPitch*row_count);</span><br><span class="line"></span><br><span class="line">                m_stInputSurface[i].type           = NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR;</span><br><span class="line">				<span class="built_in">memset</span>( (<span class="type">void</span> *)m_stInputSurface[i].pExtAllocHost, <span class="number">128</span>, m_stInputSurface[i].dwCuPitch*row_count);<span class="comment">// clear the memory</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">cuCtxPopCurrent</span>(&amp;cuContextCurr);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(NV_WINDOWS)</span></span><br><span class="line">            <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_DX9)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; &gt; DirectX+NVENC InterOp using %d buffers.\n&quot;</span>, m_dwMaxSurfCount);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Illustrate how to use an externally allocated IDirect3DSurface9* as input to the encoder.</span></span><br><span class="line">                IDirect3DSurface9 *pSurf = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> dwFormat = <span class="built_in">MAKE_FOURCC</span>(<span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>);;</span><br><span class="line">                HRESULT hr = S_OK;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">IsNV12Format</span>(m_dwInputFormat))</span><br><span class="line">                &#123;</span><br><span class="line">                    dwFormat = <span class="built_in">MAKE_FOURCC</span>(<span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">IsYV12Format</span>(m_dwInputFormat))</span><br><span class="line">                &#123;</span><br><span class="line">                    dwFormat = <span class="built_in">MAKE_FOURCC</span>(<span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                hr = m_pD3D9Device-&gt;<span class="built_in">CreateOffscreenPlainSurface</span>(dwInputWidth, dwInputHeight, (D3DFORMAT)dwFormat, D3DPOOL_DEFAULT, (IDirect3DSurface9 **)&amp;m_stInputSurface[i].pExtAlloc, <span class="literal">NULL</span>);</span><br><span class="line">                m_stInputSurface[i].bufferFmt      = NV_ENC_BUFFER_FORMAT_NV12;</span><br><span class="line">                m_stInputSurface[i].type           = NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_DX11)</span><br><span class="line">			&#123;</span><br><span class="line">				ID3D11Texture2D *pInputTextures = <span class="literal">NULL</span>;</span><br><span class="line">				D3D11_TEXTURE2D_DESC desc;</span><br><span class="line">				<span class="built_in">ZeroMemory</span>(&amp;desc, <span class="built_in">sizeof</span>(D3D11_TEXTURE2D_DESC));</span><br><span class="line">				desc.Width = m_stEncoderInput.width;</span><br><span class="line">				desc.Height = m_stEncoderInput.height;</span><br><span class="line">				desc.MipLevels = <span class="number">1</span>;</span><br><span class="line">				desc.ArraySize = <span class="number">1</span>;</span><br><span class="line">				desc.Format = <span class="built_in">DXGI_FORMAT</span>(<span class="number">103</span>);</span><br><span class="line">				desc.SainputFramesmpleDesc.Count = <span class="number">1</span>;</span><br><span class="line">				desc.Usage = D3D11_USAGE_DEFAULT;</span><br><span class="line">				desc.BindFlags = D3D11_BIND_RENDER_TARGET;</span><br><span class="line">				desc.CPUAccessFlags = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (m_pD3D11Device-&gt;<span class="built_in">CreateTexture2D</span>(&amp;desc, <span class="literal">NULL</span>, &amp;pInputTextures) != S_OK)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				m_stInputSurface[i].pExtAlloc = (<span class="type">void</span> *)pInputTextures;</span><br><span class="line">				m_stInputSurface[i].type = NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX;</span><br><span class="line">				m_stInputSurface[i].bufferFmt = NV_ENC_BUFFER_FORMAT_NV12_PL;</span><br><span class="line">				m_stInputSurface[i].dwCuPitch = m_stEncoderInput.width;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_OPENGL)<span class="comment">//NVENCODE API 的 OpenGL 接口仅在 Linux 上受支持</span></span><br><span class="line">			&#123;</span><br><span class="line">				NV_ENC_INPUT_RESOURCE_OPENGL_TEX *pResource = <span class="keyword">new</span> NV_ENC_INPUT_RESOURCE_OPENGL_TEX;</span><br><span class="line"></span><br><span class="line">				<span class="type">uint32_t</span> tex;</span><br><span class="line"></span><br><span class="line">				<span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;tex);</span><br><span class="line">				<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, tex);</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NV_ENC_BUFFER_FORMAT_NV12_TYPE	</span></span><br><span class="line">                <span class="comment">//因此存放的是NV12，所以分配空间m_stEncoderInput.width*m_stEncoderInput.height* 3 / 2就够了</span></span><br><span class="line">				<span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_R8, m_stEncoderInput[<span class="number">0</span>].width, m_stEncoderInput[<span class="number">0</span>].height* <span class="number">3</span> / <span class="number">2</span>, <span class="number">0</span>, GL_RED, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">				<span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, m_stEncoderInput[<span class="number">0</span>].width, m_stEncoderInput[<span class="number">0</span>].height, <span class="number">0</span>, GL_RED, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">				<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">glIsTexture</span>(tex)== <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">WSLogEx</span>(<span class="string">L&quot;Failed to create opengltextures \n&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				pResource-&gt;texture = tex;</span><br><span class="line">            	pResource-&gt;target = GL_TEXTURE_2D;</span><br><span class="line"></span><br><span class="line">				m_stInputSurface[i].pExtAlloc = pResource;</span><br><span class="line">				m_stInputSurface[i].type = NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NV_ENC_BUFFER_FORMAT_NV12_TYPE</span></span><br><span class="line">				m_stInputSurface[i].bufferFmt = NV_ENC_BUFFER_FORMAT_NV12_PL;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">				m_stInputSurface[i].bufferFmt      = NV_ENC_BUFFER_FORMAT_ARGB;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>		</span></span><br><span class="line">				m_stInputSurface[i].dwCuPitch = m_stEncoderInput.width;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="comment">// Register the allocated buffer with NvEncodeAPI</span></span><br><span class="line">            NV_ENC_REGISTER_RESOURCE stRegisterRes;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;stRegisterRes, <span class="number">0</span>, <span class="built_in">sizeof</span>(NV_ENC_REGISTER_RESOURCE));</span><br><span class="line">            <span class="built_in">SET_VER</span>(stRegisterRes, NV_ENC_REGISTER_RESOURCE);</span><br><span class="line">            stRegisterRes.resourceType = m_stInputSurface[i].type;</span><br><span class="line">			stRegisterRes.bufferFormat = m_stInputSurface[i].bufferFmt;</span><br><span class="line">            <span class="comment">// Pass the resource handle to be registered and mapped during registration.</span></span><br><span class="line">            <span class="comment">// Do not pass this handle while mapping</span></span><br><span class="line">            stRegisterRes.resourceToRegister       = m_stInputSurface[i].pExtAlloc;</span><br><span class="line">            stRegisterRes.width                    = m_stInputSurface[i].dwWidth;</span><br><span class="line">            stRegisterRes.height                   = m_stInputSurface[i].dwHeight;</span><br><span class="line">            stRegisterRes.pitch                    = m_stInputSurface[i].dwCuPitch;</span><br><span class="line">            </span><br><span class="line">            status = m_pEncodeAPI-&gt;<span class="built_in">nvEncRegisterResource</span>(m_hEncoder, &amp;stRegisterRes);</span><br><span class="line">            <span class="built_in">checkNVENCErrors</span>(status);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Use this registered handle to retrieve an encoder-understandable mapped resource handle, through NvEncMapInputResource.</span></span><br><span class="line">            <span class="comment">// The mapped handle can be directly used with NvEncEncodePicture.</span></span><br><span class="line">            m_stInputSurface[i].hRegisteredHandle = stRegisterRes.registeredResource;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">// Premiere Plugin: allocate non-mapped resources</span></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &gt; System Memory with %d buffers.\n&quot;</span>, m_dwMaxSurfCount);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Allocate input surface</span></span><br><span class="line">            NV_ENC_CREATE_INPUT_BUFFER stAllocInputSurface;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;stAllocInputSurface, <span class="number">0</span>, <span class="built_in">sizeof</span>(stAllocInputSurface));</span><br><span class="line">            <span class="built_in">SET_VER</span>(stAllocInputSurface, NV_ENC_CREATE_INPUT_BUFFER);</span><br><span class="line">            stAllocInputSurface.width              = (m_dwFrameWidth  + <span class="number">31</span>)&amp;~<span class="number">31</span>;<span class="comment">//dwFrameWidth;</span></span><br><span class="line">            stAllocInputSurface.height             = (m_dwFrameHeight + <span class="number">31</span>)&amp;~<span class="number">31</span>; <span class="comment">//dwFrameHeight;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line">            stAllocInputSurface.memoryHeap         = NV_ENC_MEMORY_HEAP_SYSMEM_CACHED;</span><br><span class="line">            stAllocInputSurface.bufferFmt          = NV_ENC_BUFFER_FORMAT_NV12;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            stAllocInputSurface.memoryHeap         = NV_ENC_MEMORY_HEAP_SYSMEM_UNCACHED;</span><br><span class="line">            stAllocInputSurface.bufferFmt          = m_dwInputFormat;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (m_stEncoderInput.chromaFormatIDC == cudaVideoChromaFormat_420)</span><br><span class="line">				stAllocInputSurface.bufferFmt = NV_ENC_BUFFER_FORMAT_NV12;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				stAllocInputSurface.bufferFmt = NV_ENC_BUFFER_FORMAT_YUV444;</span><br><span class="line"></span><br><span class="line">            status = m_pEncodeAPI-&gt;<span class="built_in">nvEncCreateInputBuffer</span>(m_hEncoder, &amp;stAllocInputSurface);</span><br><span class="line">            <span class="built_in">checkNVENCErrors</span>(status);</span><br><span class="line"></span><br><span class="line">            m_stInputSurface[i].hInputSurface      = stAllocInputSurface.inputBuffer;</span><br><span class="line">            m_stInputSurface[i].bufferFmt          = stAllocInputSurface.bufferFmt;</span><br><span class="line">            m_stInputSurface[i].dwWidth            = (m_dwFrameWidth  + <span class="number">31</span>)&amp;~<span class="number">31</span>;</span><br><span class="line">            m_stInputSurface[i].dwHeight           = (m_dwFrameHeight + <span class="number">31</span>)&amp;~<span class="number">31</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_stInputSurfQueue.<span class="built_in">Add</span>(&amp;m_stInputSurface[i]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此时，我们已经完成NV_ENC_REGISTER_RESOURCE的填充和注册，接下来就是通过NvEncRegisterResource返回的资源句柄NV_ENC_REGISTER_RESOURCE::registeredResource来进行句柄的映射操作，从而将OpenGL分配的外部输入缓冲区映射到NV_ENC中</p>
<h3 id="4-3-1-2-将OpenGL分配的外部输入缓冲区映射到NV-ENC中"><a href="#4-3-1-2-将OpenGL分配的外部输入缓冲区映射到NV-ENC中" class="headerlink" title="4.3.1.2 将OpenGL分配的外部输入缓冲区映射到NV_ENC中"></a>4.3.1.2 将OpenGL分配的外部输入缓冲区映射到NV_ENC中</h3><p>继续参考NVENC_export&#x2F;Samples&#x2F;nvEncode2&#x2F;src文件夹中的CNvEncoderH264.cpp文件中EncodeCudaMemFrame，可以看出也缺少了Linux端的代码，我们将他补完整．<br>PS:这边顺便也加了一段NV_ENC_DX11的代码，如果你用到NV_ENC_DX12,NV_ENC_DX10那就参考着这个改就行了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">CNvEncoderH264::EncodeCudaMemFrame</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	EncodeFrameConfig *pEncodeFrame, CUdeviceptr oDecodedFrame[<span class="number">3</span>], <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> oFrame_pitch, <span class="type">bool</span> bFlush )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NVENCSTATUS nvStatus = NV_ENC_SUCCESS;</span><br><span class="line">    HRESULT hr = S_OK;</span><br><span class="line">    NV_ENC_MAP_INPUT_RESOURCE mapRes = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bFlush)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">FlushEncoder</span>();</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pEncodeFrame)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> E_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EncodeInputSurfaceInfo  *pInput;</span><br><span class="line">    EncodeOutputBuffer      *pOutputBitstream;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_stInputSurfQueue.<span class="built_in">Remove</span>(pInput, INFINITE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_stOutputSurfQueue.<span class="built_in">Remove</span>(pOutputBitstream, INFINITE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lockedPitch = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// encode width and height</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwWidth =  m_uMaxWidth; <span class="comment">//m_stEncoderInput.width;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwHeight = m_uMaxHeight;<span class="comment">//m_stEncoderInput.height;</span></span><br><span class="line">    <span class="comment">// Align 32 as driver does the same</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwSurfWidth  = (dwWidth + <span class="number">0x1f</span>) &amp; ~<span class="number">0x1f</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwSurfHeight = (dwHeight + <span class="number">0x1f</span>) &amp; ~<span class="number">0x1f</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pLuma    = pEncodeFrame-&gt;yuv[<span class="number">0</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pChromaU = pEncodeFrame-&gt;yuv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pChromaV = pEncodeFrame-&gt;yuv[<span class="number">2</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pInputSurface = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pInputSurfaceCh = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">const</span>    <span class="type">bool</span> need_2d_memcpy = (oFrame_pitch % pInput-&gt;dwCuPitch) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CUDA or DX9 interop with NVENC</span></span><br><span class="line">    <span class="keyword">if</span> (m_stEncoderInput.useMappedResources)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Here we copy from Host to Device Memory (CUDA)</span></span><br><span class="line">        <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_CUDA)</span><br><span class="line">        &#123;</span><br><span class="line">            CUresult result;</span><br><span class="line">            <span class="built_in">cuCtxPushCurrent</span>(m_cuContext); <span class="comment">// Necessary to bind the </span></span><br><span class="line">            CUcontext cuContextCurr;</span><br><span class="line">			<span class="comment">// YUV444     : we don&#x27;t actually support this correctly.  Copy only the luma (Y) plane</span></span><br><span class="line">			<span class="comment">// NV12  (420): the #bytes to </span></span><br><span class="line">			<span class="keyword">if</span> ( need_2d_memcpy ) &#123;</span><br><span class="line">				<span class="comment">// The source-framebuffer and destination-framebuffer have different pitches.</span></span><br><span class="line">				<span class="comment">// (This seems to only happen when decoding HEVC-video using the DXVA/hybrid decoder.)</span></span><br><span class="line"></span><br><span class="line">				CUDA_MEMCPY2D cuda_memcpy2d;</span><br><span class="line">				<span class="built_in">memset</span>( (<span class="type">void</span> *)&amp;cuda_memcpy2d, <span class="number">0</span>, <span class="built_in">sizeof</span>(cuda_memcpy2d) );<span class="comment">// clear cuda_memcpy2d</span></span><br><span class="line"></span><br><span class="line">				cuda_memcpy2d.dstDevice   = (CUdeviceptr) pInput-&gt;pExtAlloc;</span><br><span class="line">				cuda_memcpy2d.dstMemoryType = CU_MEMORYTYPE_DEVICE;</span><br><span class="line">				cuda_memcpy2d.dstPitch    = pInput-&gt;dwCuPitch;</span><br><span class="line">				cuda_memcpy2d.dstXInBytes = <span class="number">0</span>; <span class="comment">// pInput-&gt;dwWidth;</span></span><br><span class="line">				cuda_memcpy2d.dstY = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> ( m_stEncoderInput.chromaFormatIDC == cudaVideoChromaFormat_444 )</span><br><span class="line">					cuda_memcpy2d.Height = pInput-&gt;dwHeight;           <span class="comment">// luma(Y) plane only</span></span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					cuda_memcpy2d.Height = (pInput-&gt;dwHeight * <span class="number">3</span>) &gt;&gt; <span class="number">1</span>;<span class="comment">// Y + UV plane</span></span><br><span class="line">				<span class="comment">//cuda_memcpy2d.srcArray </span></span><br><span class="line">				cuda_memcpy2d.srcDevice = oDecodedFrame[<span class="number">0</span>];</span><br><span class="line">				cuda_memcpy2d.srcHost = <span class="literal">NULL</span>;</span><br><span class="line">				cuda_memcpy2d.srcMemoryType = CU_MEMORYTYPE_DEVICE;</span><br><span class="line">				cuda_memcpy2d.srcPitch = oFrame_pitch;</span><br><span class="line">				cuda_memcpy2d.srcXInBytes = <span class="number">0</span>; <span class="comment">// pInput-&gt;dwWidth;</span></span><br><span class="line">				cuda_memcpy2d.srcY = <span class="number">0</span>;</span><br><span class="line">				cuda_memcpy2d.WidthInBytes = oFrame_pitch;</span><br><span class="line"></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;\nCNvEncoderH264::EncodeCudaMemFrame(): cuMemcpy2D(src_pitch=%0u -&gt; dst_pitch=%0u)\n&quot;</span>,</span><br><span class="line">					oFrame_pitch, cuda_memcpy2d.dstPitch</span><br><span class="line">				);</span><br><span class="line">				result = <span class="built_in">cuMemcpy2D</span>(&amp;cuda_memcpy2d);</span><br><span class="line"><span class="comment">//				result = cuMemcpy2DUnaligned(&amp;cuda_memcpy2d);</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// source framebuffer and dest framebuffer have matching pitch,</span></span><br><span class="line">				<span class="comment">// we can use a simpler 1D-memcpy</span></span><br><span class="line">				<span class="keyword">if</span> (m_stEncoderInput.chromaFormatIDC == cudaVideoChromaFormat_444)</span><br><span class="line">					result = <span class="built_in">cuMemcpyDtoD</span>((CUdeviceptr)pInput-&gt;pExtAlloc, oDecodedFrame[<span class="number">0</span>], pInput-&gt;dwCuPitch*pInput-&gt;dwHeight * <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					result = <span class="built_in">cuMemcpyDtoD</span>((CUdeviceptr)pInput-&gt;pExtAlloc, oDecodedFrame[<span class="number">0</span>], (pInput-&gt;dwCuPitch*pInput-&gt;dwHeight*<span class="number">3</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="built_in">checkCudaErrors</span>(result);</span><br><span class="line">            <span class="built_in">cuCtxPopCurrent</span>(&amp;cuContextCurr);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> Grab a pointer GPU Device Memory (DX9) and then copy the result</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_DX9)</span><br><span class="line">       &#123;</span><br><span class="line">           IDirect3DSurface9 *pSurf = (IDirect3DSurface9 *)pInput-&gt;pExtAlloc;</span><br><span class="line">           pSurf-&gt;<span class="built_in">UnlockRect</span>();</span><br><span class="line">       &#125;</span><br><span class="line">		<span class="keyword">else</span>  <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_DX11)</span><br><span class="line">		&#123;</span><br><span class="line">			ID3D11Texture2D *pInputTextures = (ID3D11Texture2D *)pInput-&gt;pExtAlloc;</span><br><span class="line">			ID3D11DeviceContext *pImmediateContext = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">if</span> (m_pD3D11Device)</span><br><span class="line">			&#123;</span><br><span class="line">				m_pD3D11Device-&gt;<span class="built_in">GetImmediateContext</span>(&amp;pImmediateContext);</span><br><span class="line">				<span class="keyword">if</span> (NV_INPUT_ENC_FRAME_DX11 ==  pEncodeFrame-&gt;inputEncodeFrameDeviceType )</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//使用 GPU 将源资源的全部内容复制到目标资源。</span></span><br><span class="line">					ID3D11Texture2D *pSrcTextures = (ID3D11Texture2D*)pLuma;</span><br><span class="line">					pImmediateContext-&gt;<span class="built_in">CopyResource</span>(pInputTextures,pSrcTextures);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (NV_INPUT_ENC_FRAME_CPU == pEncodeFrame-&gt;inputEncodeFrameDeviceType)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//upload</span></span><br><span class="line">					HRESULT hr = S_OK;</span><br><span class="line"></span><br><span class="line">					D3D11_TEXTURE2D_DESC dstDesc;</span><br><span class="line">					D3D11_BOX d3d11box;</span><br><span class="line"></span><br><span class="line">					pInputTextures-&gt;<span class="built_in">GetDesc</span>(&amp;dstDesc);</span><br><span class="line">					d3d11box.front = <span class="number">0</span>; d3d11box.back = <span class="number">1</span>;</span><br><span class="line">					d3d11box.left = <span class="number">0</span>; d3d11box.top = <span class="number">0</span>;</span><br><span class="line">					d3d11box.right = dstDesc.Width;</span><br><span class="line">					d3d11box.bottom = dstDesc.Height;</span><br><span class="line">					<span class="keyword">if</span> (dstDesc.Format == (DXGI_FORMAT)<span class="number">103</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">//CPU 将数据从内存复制到在不可映射内存中创建的子资源</span></span><br><span class="line">						pImmediateContext-&gt;<span class="built_in">UpdateSubresource</span>(pInputTextures, <span class="number">0</span>, &amp;d3d11box, pInputSurface, dstDesc.Width, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (pImmediateContext)</span><br><span class="line">                pImmediateContext-&gt;<span class="built_in">Release</span>();</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line">		<span class="keyword">else</span>  <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_OPENGL)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//GPU的copy</span></span><br><span class="line">			<span class="keyword">if</span> (NV_INPUT_ENC_FRAME_OpenGL ==  pEncodeFrame-&gt;inputEncodeFrameDeviceType)</span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line">				NV_ENC_INPUT_RESOURCE_OPENGL_TEX *pResource = (NV_ENC_INPUT_RESOURCE_OPENGL_TEX *)pInput-&gt;pExtAlloc;</span><br><span class="line">				<span class="keyword">if</span>((pResource-&gt;target != GL_TEXTURE_2D) || (<span class="built_in">glIsTexture</span>(pResource-&gt;texture) == <span class="number">0</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				GLuint fboBuffer = <span class="number">0</span>;</span><br><span class="line">				<span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;fboBuffer);<span class="comment">//声明一个帧缓冲区</span></span><br><span class="line">				<span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, fboBuffer);<span class="comment">//绑定</span></span><br><span class="line">				<span class="comment">//将纹理附加到帧缓冲区上</span></span><br><span class="line">				<span class="built_in">glFramebufferTexture2D</span>(GL_READ_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class="line">									GL_TEXTURE_2D,  *((GLuint*)pLuma), <span class="number">0</span>);</span><br><span class="line">				<span class="built_in">glFramebufferTexture2D</span>(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT1,</span><br><span class="line">									GL_TEXTURE_2D, pResource-&gt;texture, <span class="number">0</span>);</span><br><span class="line">				</span><br><span class="line"></span><br><span class="line">				<span class="built_in">glReadBuffer</span>(GL_COLOR_ATTACHMENT0);</span><br><span class="line">				<span class="built_in">glDrawBuffer</span>(GL_COLOR_ATTACHMENT1);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//glBlitFramebuffer 一般用于帧缓冲区（颜色缓冲区）间高性能数据拷贝</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NV_ENC_BUFFER_FORMAT_NV12_TYPE	</span></span><br><span class="line">				<span class="built_in">glBlitFramebuffer</span>(<span class="number">0</span>, <span class="number">0</span>, pInput-&gt;dwWidth, pInput-&gt;dwHeight * <span class="number">3</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, pInput-&gt;dwWidth, pInput-&gt;dwHeight * <span class="number">3</span> / <span class="number">2</span>,</span><br><span class="line">								GL_COLOR_BUFFER_BIT, GL_NEAREST);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">				<span class="built_in">glBlitFramebuffer</span>(<span class="number">0</span>, <span class="number">0</span>, pInput-&gt;dwWidth, pInput-&gt;dwHeight, <span class="number">0</span>, <span class="number">0</span>, pInput-&gt;dwWidth, pInput-&gt;dwHeight,</span><br><span class="line">								GL_COLOR_BUFFER_BIT, GL_NEAREST);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">				<span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (NV_INPUT_ENC_FRAME_CPU == pEncodeFrame-&gt;inputEncodeFrameDeviceType)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//WIN32</span></span></span><br><span class="line">        <span class="built_in">SET_VER</span>(mapRes, NV_ENC_MAP_INPUT_RESOURCE);</span><br><span class="line">        mapRes.registeredResource  = pInput-&gt;hRegisteredHandle;</span><br><span class="line">        nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncMapInputResource</span>(m_hEncoder, &amp;mapRes);</span><br><span class="line">        pInput-&gt;hInputSurface = mapRes.mappedResource;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此时，我们已经调用了NvEncMapInputResource接口，如果返回成功的话，说明NV_ENC_MAP_INPUT_RESOURCE::mappedResource映射的句柄此时已经生效了</p>
<h3 id="4-3-2-分配输出的比特流缓冲区"><a href="#4-3-2-分配输出的比特流缓冲区" class="headerlink" title="4.3.2 分配输出的比特流缓冲区"></a>4.3.2 分配输出的比特流缓冲区</h3><p>分配输出的比特流缓冲区需要调用NvEncCreateBitstreamBuffer来进行分配。此时我们回到下NVENC_export&#x2F;Samples&#x2F;nvEncode2&#x2F;src文件夹中的CNvEncoder.cpp文件中的AllocateIOBuffers函数．<br>可以看出分配输出的比特流缓冲区的具体操作分为以下几个步骤：</p>
<ul>
<li>填充NV_ENC_CREATE_BITSTREAM_BUFFER结构体</li>
<li>调用nvEncCreateBitstreamBuffer接口，分配输出比特流缓冲区</li>
<li>设置视频编码接口的操作模式</li>
</ul>
<p>但是这个代码是有问题的，问题在于之前Guest在编写NVENC_export时候，只关注于Win端，因此没有注意到在Linux端是没办法使用异步操作模式的，也就是不能调用nvEncRegisterAsyncEvent接口，文档解释如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Modes of Operation</span><br><span class="line">The NVIDIA Video Encoder Interface supports the following two modes of operation.</span><br><span class="line"></span><br><span class="line">Asynchronous Mode</span><br><span class="line">This mode of operation is used for asynchronous output buffer processing. For this mode, the client allocates an event object and associates the event with an allocated output buffer. This event object is passed to the NVIDIA Encoder Interface as part of the NvEncEncodePicture API. The client can wait on the event in a separate thread. When the event is signaled, the client calls the NVIDIA Video Encoder Interface to copy output bitstream produced by the encoder. Note that the encoder supports asynchronous mode of operation only for Windows 7 and above, with driver running in WDDM mode. In Linux and Windows with TCC mode (TCC mode is available on Tesla boards1), ONLY synchronous mode is supported (refer to Section Synchronous Mode)</span><br><span class="line"></span><br><span class="line">The client should set the flag NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync to 1 to indicate that it wants to operate in asynchronous mode. After creating the event objects (one object for each output bitstream buffer allocated), the client needs to register them with the NVIDIA Video Encoder Interface using the NvEncRegisterAsyncEvent. The client is required to pass a bitstream buffer handle and the corresponding event handle as input to NvEncEncodePicture. The NVIDIA Video Encoder Interface will signal this event when the hardware encoder finishes encoding the current input data. The client can then call NvEncLockBitstream in non-blocking mode NV_ENC_LOCK_BITSTREAM::doNotWait flag set to 1 to fetch the output data.</span><br><span class="line"></span><br><span class="line">The client should call NvEncUnregisterAsyncEvent to unregister the Event handles before destroying the event objects. Whenever possible, NVIDIA recommends using the asynchronous mode of operation instead of synchronous mode.</span><br><span class="line"></span><br><span class="line">A step-by-step control flow for asynchronous mode is as follows:</span><br><span class="line"></span><br><span class="line">When working in asynchronous mode, the output sample must consist of an event + output buffer and clients must work in multi-threaded manner (D3D9 device should be created with MULTITHREADED flag).</span><br><span class="line">The output buffers are allocated using NvEncCreateBitstreamBuffer API. The NVIDIA Video Encoder Interface will return an opaque pointer to the output memory in NV_ENC_CREATE_BITSTREAM_BUFFER::bitstreambuffer. This opaque output pointer should be used in NvEncEncodePicture and NvEncLockBitsteam/ NvEncUnlockBitsteam calls. For accessing the output memory using CPU, client must call NvEncLockBitsteam API. The number of IO buffers should be at least 4 + number of B frames.</span><br><span class="line">The events are windows event handles allocated using Windows’ CreateEvent API and registered using the function NvEncRegisterAsyncEvent before encoding. The registering of events is required only once per encoding session. Clients must unregister the events using NvEncUnregisterAsyncEvent before destroying the event handles. The number of event handles must be same as number of output buffers as each output buffer is associated with an event.</span><br><span class="line">Client must create a secondary thread in which it can wait on the completion event and copy the bitstream data from the output sample. Client will have two threads: one is the main application thread which submits encoding work to NVIDIA Encoder while secondary thread waits on the completion events and copies the compressed bitstream data from the output buffer.</span><br><span class="line">Client must send the output buffer and event in NV_ENC_PIC_PARAMS::outputBitstream and NV_ENC_PIC_PARAMS:: completionEvent fields respectively as part of NvEncEncodePicture API call.</span><br><span class="line">Client should then wait on the event on the secondary thread in the same order in which it has called NvEncEncodePicture calls irrespective of input buffer re-ordering (encode order! = display order). When enablePTD = 1, NVIDIA Encoder takes care of the reordering in case of B frames in a way that is transparent to the encoder clients. For AV1, NVIDIA encoder also transparently performs frame bitstream packing, meaning it always concatenates into a single output buffer the bitstream corresponding to leading no-show frames with the bitstream of the first show frame that follows. Each output buffer therefore always contains a single frame to display along with all the preceding non-display frames in encode order since the previous frame to display.</span><br><span class="line">When the event gets signalled client must send down the output buffer of sample event it was waiting on in NV_ENC_LOCK_BITSTREAM::outputBitstream field as part of NvEncLockBitstream call.</span><br><span class="line">The NVIDIA Encoder Interface returns a CPU pointer and bitstream size in bytes as part of the NV_ENC_LOCK_BITSTREAM.</span><br><span class="line">After copying the bitstream data, client must call NvEncUnlockBitstream for the locked output bitstream buffer.</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The client will receive the event&#x27;s signal and output buffer in the same order in which they were queued.</span><br><span class="line">The NV_ENC_LOCK_BITSTREAM::pictureType notifies the output picture type to the clients.</span><br><span class="line">Both, the input and output sample (output buffer and the output completion event) are free to be reused once the NVIDIA Video Encoder Interface has signalled the event and the client has copied the data from the output buffer.</span><br><span class="line"></span><br><span class="line">Synchronous Mode</span><br><span class="line">This mode of operation is used for synchronous output buffer processing. In this mode the client makes a blocking call to the NVIDIA Video Encoder Interface to retrieve the output bitstream data from the encoder. The client sets the flag NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync to 0 for operation in synchronous mode. The client then must call NvEncEncodePicture without setting a completion event handle. The client must call NvEncLockBitstream with flag NV_ENC_LOCK_BITSTREAM::doNotWait set to 0, so that the lock call blocks until the hardware encoder finishes writing the output bitstream. The client can then operate on the generated bitstream data and call NvEncUnlockBitstream. This is the only mode supported on Linux.</span><br></pre></td></tr></table></figure>
<p>翻译一下大概意思：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">异步模式:</span><br><span class="line">这种操作模式用于异步输出缓冲区处理。对于这种模式，必须分配一个事件对象，并将事件与分配的输出缓冲区相关联。此事件对象作为 NVIDIA 编码器接口的一部分传递给NvEncEncodePicture应用程序接口。用户可以在单独的线程中等待事件。当事件发出信号时，用户调用 NVIDIA 视频编码器接口来复制编码器产生的输出比特流。请注意，编码器仅支持 Windows 7 及更高版本的异步操作模式，在 WDDM 模式下运行的驱动程序。</span><br><span class="line">用户应该设置标志NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync为1，表示它要在异步模式下运行。</span><br><span class="line">在创建事件对象（为每个输出比特流缓冲区分配一个对象）后，用户需要调用 NvEncRegisterAsyncEvent。</span><br><span class="line">用户需要将比特流缓冲区句柄和相应的事件句柄作为输入传递给NvEncEncodePicture。</span><br><span class="line">当硬件编码器完成对当前输入数据的编码时，NVIDIA 视频编码器接口将发出此事件信号。然后用户可以在非阻塞模式（NV_ENC_LOCK_BITSTREAM::doNotWait 标志设置为 1 ）下调用NvEncLockBitstream 以获取输出数据。</span><br><span class="line">在销毁事件对象之前，客户应该调用NvEncUnregisterAsyncEvent取消注册的事件句柄。只要有可能，NVIDIA 建议使用异步操作模式而不是同步模式。</span><br><span class="line">异步模式的分步控制流程如下：</span><br><span class="line"></span><br><span class="line">在异步模式下工作时，输出样本必须由事件 + 输出缓冲区组成，并且用户必须以多线程方式工作（D3D9 设备应使用 MULTITHREADED 标志创建）。</span><br><span class="line">输出缓冲区使用 NvEncCreateBitstreamBuffer来分配。它将返回一个指向输出内存的不透明指针 NV_ENC_CREATE_BITSTREAM_BUFFER::bitstreambuffer。这个不透明的输出指针应该用于NvEncEncodePicture 和 NvEncLockBitsteam/ NvEncUnlockBitsteam的调用中。要使用 CPU 访问输出存储器，用户必须调用NvEncLockBitsteam。IO 缓冲区的数量应至少为 4 + B 帧的数量。</span><br><span class="line">如果这些事件是使用CreateEvent分配的 Windows 事件句柄，则在编码前需要使用NvEncRegisterAsyncEvent进行注册。每个编码会话只需要注册一次事件。用户必须在销毁事件句柄之前，使用NvEncUnregisterAsyncEvent取消注册事件。事件句柄的数量必须与输出缓冲区的数量相同，因为每个输出缓冲区都与一个事件相关联。</span><br><span class="line">用户必须创建一个辅助线程，它可以在其中等待完成事件并从输出样本中复制比特流数据。用户将有两个线程：一个是主应用程序线程，它向 NVIDIA 编码器提交编码工作，而辅助线程等待完成事件并从输出缓冲区复制压缩的比特流数据。</span><br><span class="line">用户必须将输出缓冲区和事件发送到 NV_ENC_PIC_PARAMS::outputBitstream 和 NV_ENC_PIC_PARAMS::completionEvent字段，依次调用NvEncEncodePicture API。</span><br><span class="line">然后用户应该按照它调用的相同顺序在辅助线程上等待事件，NvEncEncodePicture调用与输入缓冲区重新排序无关（编码顺序 != 显示顺序）。NVIDIA Encoder 负责处理 B 帧的重新排序，并且应该对编码器用户透明。</span><br><span class="line">当事件得到信号时，用户必须向下发送它正在等待的样本事件的输出缓冲区，即调用NvEncLockBitstream的参数NV_ENC_LOCK_BITSTREAM::outputBitstream。</span><br><span class="line">NVIDIA 编码器接口返回作为NV_ENC_LOCK_BITSTREAM一部分的，以字节为单位的CPU指针和比特流大小。</span><br><span class="line">复制比特流数据后，对于锁定的输出比特流缓冲区，用户必须调用 NvEncUnlockBitstream。</span><br><span class="line">提示：</span><br><span class="line">用户将按照它们排队的相同顺序接收事件的信号和输出缓冲区。</span><br><span class="line">NV_ENC_LOCK_BITSTREAM::pictureType 将输出图片类型通知给用户。</span><br><span class="line">一旦 NVIDIA 视频编码器接口发出事件信号并且用户已从输出缓冲区复制数据，输入和输出样本（输出缓冲区和输出完成事件）都可以自由重用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">同步模式：</span><br><span class="line">这种操作模式用于同步输出缓冲处理。在这种模式下，用户对 NVIDIA 视频编码器接口进行阻塞调用，以从编码器检索输出比特流数据。</span><br><span class="line">同步模式下，用户设置标志NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync为 0。然后用户必须调用NvEncEncodePicture无需设置完成事件句柄。用户调用NvEncLockBitstream，NV_ENC_LOCK_BITSTREAM::doNotWait需设置为 0，以便阻塞和锁定调用，直到硬件编码器完成输出比特流的写入。然后用户可以对生成的比特流数据进行操作，然后调用NvEncUnlockBitstream。这是 Linux 上唯一支持的模式。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此我们将AllocateIOBuffers函数修改成以下内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//Allocate output surface</span></span><br><span class="line">        m_stBitstreamBuffer[i].dwSize = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">        NV_ENC_CREATE_BITSTREAM_BUFFER stAllocBitstream;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;stAllocBitstream, <span class="number">0</span>, <span class="built_in">sizeof</span>(stAllocBitstream));</span><br><span class="line">        <span class="built_in">SET_VER</span>(stAllocBitstream, NV_ENC_CREATE_BITSTREAM_BUFFER);</span><br><span class="line">        stAllocBitstream.size                      =  m_stBitstreamBuffer[i].dwSize;</span><br><span class="line">        stAllocBitstream.memoryHeap                = NV_ENC_MEMORY_HEAP_SYSMEM_CACHED;</span><br><span class="line"></span><br><span class="line">        status = m_pEncodeAPI-&gt;<span class="built_in">nvEncCreateBitstreamBuffer</span>(m_hEncoder, &amp;stAllocBitstream);</span><br><span class="line">        <span class="built_in">checkNVENCErrors</span>(status);</span><br><span class="line"></span><br><span class="line">        m_stBitstreamBuffer[i].hBitstreamBuffer    = stAllocBitstream.bitstreamBuffer;</span><br><span class="line">        m_stBitstreamBuffer[i].pBitstreamBufferPtr = stAllocBitstream.bitstreamBufferPtr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO : need to fix the ucode to set the bitstream position</span></span><br><span class="line">        <span class="keyword">if</span> (m_stEncoderInput.outBandSPSPPS == <span class="number">0</span>)</span><br><span class="line">            m_stBitstreamBuffer[i].pBitstreamBufferPtr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line"> 		NV_ENC_EVENT_PARAMS nvEventParams = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">SET_VER</span>(nvEventParams, NV_ENC_EVENT_PARAMS);</span><br><span class="line">        m_stBitstreamBuffer[i].hOutputEvent        = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">        nvEventParams.completionEvent              = m_stBitstreamBuffer[i].hOutputEvent;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Register the resource for interop with NVENC</span></span><br><span class="line">        nvEventParams.completionEvent              = m_stBitstreamBuffer[i].hOutputEvent;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        m_stBitstreamBuffer[i].hOutputEvent = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line">        m_pEncodeAPI-&gt;<span class="built_in">nvEncRegisterAsyncEvent</span>(m_hEncoder, &amp;nvEventParams);<span class="comment">//Linux端不支持异步模式，只能用同步模式</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        m_stOutputSurfQueue.<span class="built_in">Add</span>(&amp;m_stBitstreamBuffer[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_stEOSOutputBfr.bEOSFlag = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line"> 	NV_ENC_EVENT_PARAMS nvEventParams = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">SET_VER</span>(nvEventParams, NV_ENC_EVENT_PARAMS);</span><br><span class="line">    m_stEOSOutputBfr.hOutputEvent = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">    nvEventParams.completionEvent = m_stEOSOutputBfr.hOutputEvent;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    m_stEOSOutputBfr.hOutputEvent = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (NV_WINDOWS)</span></span><br><span class="line">    m_pEncodeAPI-&gt;<span class="built_in">nvEncRegisterAsyncEvent</span>(m_hEncoder, &amp;nvEventParams);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32 </span></span><br><span class="line">    <span class="comment">// intialize output thread</span></span><br><span class="line">    <span class="keyword">if</span> (hr == S_OK &amp;&amp; !m_pEncoderThread)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pEncoderThread = <span class="keyword">new</span> <span class="built_in">CNvEncoderThread</span>(<span class="built_in">reinterpret_cast</span>&lt;CNvEncoder*&gt;(<span class="keyword">this</span>), MAX_OUTPUT_QUEUE);</span><br><span class="line">        <span class="keyword">if</span> (!m_pEncoderThread)</span><br><span class="line">        &#123;</span><br><span class="line">            hr = E_FAIL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_pEncoderThread-&gt;<span class="built_in">ThreadStart</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>    </span></span><br><span class="line">	<span class="comment">///////</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// transfer the encoder-settings to m_sei_user_payload</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	m_sei_user_payload_str = oss.<span class="built_in">str</span>();</span><br><span class="line">	<span class="comment">//printf( &quot;m_sei_user_payload(%0u) = &#x27;%s&#x27;\n&quot;, m_sei_user_payload_str.length(), m_sei_user_payload_str.c_str() );</span></span><br><span class="line"></span><br><span class="line">	m_sei_user_payload.payloadType = <span class="number">5</span>;<span class="comment">// Annex D : Type 5 = &#x27;user data unregistered&#x27;</span></span><br><span class="line">	m_sei_user_payload.payloadSize = m_sei_user_payload_str.<span class="built_in">length</span>();<span class="comment">// fill in later</span></span><br><span class="line">	<span class="keyword">if</span> ( m_sei_user_payload.payload != <span class="literal">NULL</span> )</span><br><span class="line">		<span class="keyword">delete</span> [] m_sei_user_payload.payload;</span><br><span class="line"></span><br><span class="line">	m_sei_user_payload.payload = <span class="keyword">new</span> <span class="type">uint8_t</span>[ m_sei_user_payload.payloadSize ];</span><br><span class="line">	<span class="built_in">memcpy</span>( (<span class="type">char</span> *)m_sei_user_payload.payload, m_sei_user_payload_str.<span class="built_in">c_str</span>(), m_sei_user_payload.payloadSize );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hr == S_OK)</span><br><span class="line">        m_bEncoderInitialized = <span class="literal">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">HRESULT <span class="title">CNvEncoderH264::EncodeCudaMemFrame</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	EncodeFrameConfig *pEncodeFrame, CUdeviceptr oDecodedFrame[<span class="number">3</span>], <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> oFrame_pitch, <span class="type">bool</span> bFlush )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NVENCSTATUS nvStatus = NV_ENC_SUCCESS;</span><br><span class="line">    HRESULT hr = S_OK;</span><br><span class="line">    NV_ENC_MAP_INPUT_RESOURCE mapRes = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bFlush)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">FlushEncoder</span>();</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pEncodeFrame)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> E_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EncodeInputSurfaceInfo  *pInput;</span><br><span class="line">    EncodeOutputBuffer      *pOutputBitstream;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_stInputSurfQueue.<span class="built_in">Remove</span>(pInput, INFINITE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_stOutputSurfQueue.<span class="built_in">Remove</span>(pOutputBitstream, INFINITE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lockedPitch = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// encode width and height</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwWidth =  m_uMaxWidth; <span class="comment">//m_stEncoderInput.width;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwHeight = m_uMaxHeight;<span class="comment">//m_stEncoderInput.height;</span></span><br><span class="line">    <span class="comment">// Align 32 as driver does the same</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwSurfWidth  = (dwWidth + <span class="number">0x1f</span>) &amp; ~<span class="number">0x1f</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dwSurfHeight = (dwHeight + <span class="number">0x1f</span>) &amp; ~<span class="number">0x1f</span>;</span><br><span class="line">    <span class="comment">//unsigned char *pLuma    = pEncodeFrame-&gt;yuv[0];</span></span><br><span class="line">    <span class="comment">//unsigned char *pChromaU = pEncodeFrame-&gt;yuv[1];</span></span><br><span class="line">    <span class="comment">//unsigned char *pChromaV = pEncodeFrame-&gt;yuv[2];</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pInputSurface = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pInputSurfaceCh = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">const</span>    <span class="type">bool</span> need_2d_memcpy = (oFrame_pitch % pInput-&gt;dwCuPitch) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CUDA or DX9 interop with NVENC</span></span><br><span class="line">    <span class="keyword">if</span> (m_stEncoderInput.useMappedResources)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Here we copy from Host to Device Memory (CUDA)</span></span><br><span class="line">        <span class="keyword">if</span> (m_stEncoderInput.interfaceType == NV_ENC_CUDA)</span><br><span class="line">        &#123;</span><br><span class="line">            CUresult result;</span><br><span class="line">            <span class="built_in">cuCtxPushCurrent</span>(m_cuContext); <span class="comment">// Necessary to bind the </span></span><br><span class="line">            CUcontext cuContextCurr;</span><br><span class="line">			<span class="comment">// YUV444     : we don&#x27;t actually support this correctly.  Copy only the luma (Y) plane</span></span><br><span class="line">			<span class="comment">// NV12  (420): the #bytes to </span></span><br><span class="line">			<span class="keyword">if</span> ( need_2d_memcpy ) &#123;</span><br><span class="line">				<span class="comment">// The source-framebuffer and destination-framebuffer have different pitches.</span></span><br><span class="line">				<span class="comment">// (This seems to only happen when decoding HEVC-video using the DXVA/hybrid decoder.)</span></span><br><span class="line"></span><br><span class="line">				CUDA_MEMCPY2D cuda_memcpy2d;</span><br><span class="line">				<span class="built_in">memset</span>( (<span class="type">void</span> *)&amp;cuda_memcpy2d, <span class="number">0</span>, <span class="built_in">sizeof</span>(cuda_memcpy2d) );<span class="comment">// clear cuda_memcpy2d</span></span><br><span class="line"></span><br><span class="line">				cuda_memcpy2d.dstDevice   = (CUdeviceptr) pInput-&gt;pExtAlloc;</span><br><span class="line">				cuda_memcpy2d.dstMemoryType = CU_MEMORYTYPE_DEVICE;</span><br><span class="line">				cuda_memcpy2d.dstPitch    = pInput-&gt;dwCuPitch;</span><br><span class="line">				cuda_memcpy2d.dstXInBytes = <span class="number">0</span>; <span class="comment">// pInput-&gt;dwWidth;</span></span><br><span class="line">				cuda_memcpy2d.dstY = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> ( m_stEncoderInput.chromaFormatIDC == cudaVideoChromaFormat_444 )</span><br><span class="line">					cuda_memcpy2d.Height = pInput-&gt;dwHeight;           <span class="comment">// luma(Y) plane only</span></span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					cuda_memcpy2d.Height = (pInput-&gt;dwHeight * <span class="number">3</span>) &gt;&gt; <span class="number">1</span>;<span class="comment">// Y + UV plane</span></span><br><span class="line">				<span class="comment">//cuda_memcpy2d.srcArray </span></span><br><span class="line">				cuda_memcpy2d.srcDevice = oDecodedFrame[<span class="number">0</span>];</span><br><span class="line">				cuda_memcpy2d.srcHost = <span class="literal">NULL</span>;</span><br><span class="line">				cuda_memcpy2d.srcMemoryType = CU_MEMORYTYPE_DEVICE;</span><br><span class="line">				cuda_memcpy2d.srcPitch = oFrame_pitch;</span><br><span class="line">				cuda_memcpy2d.srcXInBytes = <span class="number">0</span>; <span class="comment">// pInput-&gt;dwWidth;</span></span><br><span class="line">				cuda_memcpy2d.srcY = <span class="number">0</span>;</span><br><span class="line">				cuda_memcpy2d.WidthInBytes = oFrame_pitch;</span><br><span class="line"></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;\nCNvEncoderH264::EncodeCudaMemFrame(): cuMemcpy2D(src_pitch=%0u -&gt; dst_pitch=%0u)\n&quot;</span>,</span><br><span class="line">					oFrame_pitch, cuda_memcpy2d.dstPitch</span><br><span class="line">				);</span><br><span class="line">				result = <span class="built_in">cuMemcpy2D</span>(&amp;cuda_memcpy2d);</span><br><span class="line"><span class="comment">//				result = cuMemcpy2DUnaligned(&amp;cuda_memcpy2d);</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// source framebuffer and dest framebuffer have matching pitch,</span></span><br><span class="line">				<span class="comment">// we can use a simpler 1D-memcpy</span></span><br><span class="line">				<span class="keyword">if</span> (m_stEncoderInput.chromaFormatIDC == cudaVideoChromaFormat_444)</span><br><span class="line">					result = <span class="built_in">cuMemcpyDtoD</span>((CUdeviceptr)pInput-&gt;pExtAlloc, oDecodedFrame[<span class="number">0</span>], pInput-&gt;dwCuPitch*pInput-&gt;dwHeight * <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					result = <span class="built_in">cuMemcpyDtoD</span>((CUdeviceptr)pInput-&gt;pExtAlloc, oDecodedFrame[<span class="number">0</span>], (pInput-&gt;dwCuPitch*pInput-&gt;dwHeight*<span class="number">3</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="built_in">checkCudaErrors</span>(result);</span><br><span class="line">            <span class="built_in">cuCtxPopCurrent</span>(&amp;cuContextCurr);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//#if defined(NV_WINDOWS)</span></span><br><span class="line"><span class="comment">//        // <span class="doctag">TODO:</span> Grab a pointer GPU Device Memory (DX9) and then copy the result</span></span><br><span class="line"><span class="comment">//        if (m_stEncoderInput.interfaceType == NV_ENC_DX9)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            IDirect3DSurface9 *pSurf = (IDirect3DSurface9 *)pInput-&gt;pExtAlloc;</span></span><br><span class="line"><span class="comment">//            pSurf-&gt;UnlockRect();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//#endif</span></span><br><span class="line">        <span class="built_in">SET_VER</span>(mapRes, NV_ENC_MAP_INPUT_RESOURCE);</span><br><span class="line">        mapRes.registeredResource  = pInput-&gt;hRegisteredHandle;</span><br><span class="line">        nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncMapInputResource</span>(m_hEncoder, &amp;mapRes);</span><br><span class="line">        pInput-&gt;hInputSurface = mapRes.mappedResource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// here we just pass the frame in system memory to NVENC</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CNvEncoderH264::EncodeCudaMemFrame ERROR !useMappedResources\n&quot;</span>);</span><br><span class="line">        <span class="built_in">UnlockInputBuffer</span>(pInput-&gt;hInputSurface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;m_stEncodePicParams, <span class="number">0</span>, <span class="built_in">sizeof</span>(m_stEncodePicParams));</span><br><span class="line">    <span class="built_in">SET_VER</span>(m_stEncodePicParams, NV_ENC_PIC_PARAMS);</span><br><span class="line">    m_stEncodePicParams.inputBuffer = pInput-&gt;hInputSurface;</span><br><span class="line">    m_stEncodePicParams.bufferFmt = pInput-&gt;bufferFmt;</span><br><span class="line">    m_stEncodePicParams.inputWidth = pInput-&gt;dwWidth;</span><br><span class="line">    m_stEncodePicParams.inputHeight = pInput-&gt;dwHeight;</span><br><span class="line">    m_stEncodePicParams.outputBitstream = pOutputBitstream-&gt;hBitstreamBuffer;</span><br><span class="line">    m_stEncodePicParams.completionEvent = m_bAsyncModeEncoding == <span class="literal">true</span> ? pOutputBitstream-&gt;hOutputEvent : <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( m_stEncoderInput.FieldEncoding == NV_ENC_PARAMS_FRAME_FIELD_MODE_FRAME ) &#123;</span><br><span class="line">        <span class="comment">// progressive-video encoding mode</span></span><br><span class="line">        m_stEncodePicParams.pictureStruct = NV_ENC_PIC_STRUCT_FRAME;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// interlaced-video encoding mode</span></span><br><span class="line">        <span class="comment">// In interlaced-mode, NVENC requires interlaced-input, even if the frames are progressive</span></span><br><span class="line">        <span class="comment">// pEncodeFrame-&gt;fieldPicflag ?</span></span><br><span class="line">        m_stEncodePicParams.pictureStruct = pEncodeFrame-&gt;topField ? </span><br><span class="line">            NV_ENC_PIC_STRUCT_FIELD_TOP_BOTTOM : NV_ENC_PIC_STRUCT_FIELD_BOTTOM_TOP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    m_stEncodePicParams.codecPicParams.h264PicParams.h264ExtPicParams.mvcPicParams.viewID = pEncodeFrame-&gt;viewId;    </span></span><br><span class="line">    m_stEncodePicParams.encodePicFlags = <span class="number">0</span>;</span><br><span class="line">    m_stEncodePicParams.inputTimeStamp = <span class="number">0</span>;</span><br><span class="line">    m_stEncodePicParams.inputDuration = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// For H264-only: embed encoder-settings (text-string) into the encoded videostream</span></span><br><span class="line">	<span class="keyword">if</span> (m_sei_user_payload_str.<span class="built_in">length</span>()) &#123; <span class="comment">// m_sei_user_payload.payloadSize ) &#123;</span></span><br><span class="line">		m_stEncodePicParams.codecPicParams.h264PicParams.seiPayloadArrayCnt = <span class="number">1</span>;</span><br><span class="line">		m_stEncodePicParams.codecPicParams.h264PicParams.seiPayloadArray = &amp;m_sei_user_payload;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Delete the payload.  This way, our user-sei is only embedded into the *first* frame</span></span><br><span class="line">		<span class="comment">// of the output-bitstream, and nothing subsequent.  While we really should mebed</span></span><br><span class="line">		<span class="comment">// it in every frame, that would bloat the output filesize, and MediaInfo only</span></span><br><span class="line">		<span class="comment">// needs the user-sei in the first-frame to display the info. </span></span><br><span class="line">		m_sei_user_payload_str.<span class="built_in">clear</span>();</span><br><span class="line">	&#125; <span class="comment">// sei</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!m_stInitEncParams.enablePTD)</span><br><span class="line">	&#123;</span><br><span class="line">		m_stEncodePicParams.codecPicParams.h264PicParams.refPicFlag = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//m_stEncodePicParams.codecPicParams.h264PicParams.frameNumSyntax = m_dwFrameNumInGOP;</span></span><br><span class="line">		m_stEncodePicParams.codecPicParams.h264PicParams.displayPOCSyntax = <span class="number">2</span> * m_dwFrameNumInGOP;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!m_stInitEncParams.enablePTD)</span><br><span class="line">		m_stEncodePicParams.pictureType = ((m_dwFrameNumInGOP % m_stEncoderInput.gopLength) == <span class="number">0</span>) ? NV_ENC_PIC_TYPE_IDR : NV_ENC_PIC_TYPE_P;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handling Dynamic Resolution Changing    </span></span><br><span class="line">    <span class="keyword">if</span> (pEncodeFrame-&gt;dynResChangeFlag)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ERROR, dynResChangeFlag != 0: is not supported&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handling Dynamic Bitrate Change</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pEncodeFrame-&gt;dynBitrateChangeFlag == DYN_DOWNSCALE)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ERROR, dynBitrateChangeFlag == DYN_UPSCALE: is not supported&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pEncodeFrame-&gt;dynBitrateChangeFlag == DYN_UPSCALE)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ERROR, dynBitrateChangeFlag == DYN_UPSCALE: is not supported&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((m_bAsyncModeEncoding == <span class="literal">false</span>) &amp;&amp; </span><br><span class="line">        (m_stInitEncParams.enablePTD == <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        EncoderThreadData stThreadData;</span><br><span class="line">        stThreadData.pOutputBfr = pOutputBitstream;</span><br><span class="line">        stThreadData.pInputBfr = pInput;</span><br><span class="line">        stThreadData.pOutputBfr-&gt;bDynResChangeFlag = pEncodeFrame-&gt;dynResChangeFlag == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        pOutputBitstream-&gt;bWaitOnEvent = <span class="literal">false</span>;</span><br><span class="line">        m_pEncodeFrameQueue.<span class="built_in">Add</span>(stThreadData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	nvStatus = m_pEncodeAPI-&gt;<span class="built_in">nvEncEncodePicture</span>(m_hEncoder, &amp;m_stEncodePicParams);</span><br><span class="line">    </span><br><span class="line">    m_dwFrameNumInGOP++;</span><br><span class="line">    <span class="keyword">if</span> ((m_bAsyncModeEncoding == <span class="literal">false</span>) &amp;&amp; </span><br><span class="line">        (m_stInitEncParams.enablePTD == <span class="number">1</span>))</span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="keyword">if</span> (nvStatus == NV_ENC_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            EncoderThreadData stThreadData;</span><br><span class="line">            <span class="keyword">while</span> (m_pEncodeFrameQueue.<span class="built_in">Remove</span>(stThreadData, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">                m_pEncoderThread-&gt;<span class="built_in">QueueSample</span>(stThreadData);<span class="comment">//只在Win下支持异步，所以Win下才能用m_pEncoderThread</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line">				<span class="keyword">this</span>-&gt;<span class="built_in">CopyBitstreamData</span>(stThreadData);<span class="comment">//Linux下只能同步，不需要线程</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">if</span> (nvStatus != NV_ENC_ERR_NEED_MORE_INPUT) &#123;</span><br><span class="line">				<span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="built_in">assert</span>(nvStatus == NV_ENC_ERR_NEED_MORE_INPUT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nvStatus == NV_ENC_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            EncoderThreadData stThreadData;</span><br><span class="line">            stThreadData.pOutputBfr = pOutputBitstream;</span><br><span class="line">            stThreadData.pInputBfr = pInput;</span><br><span class="line">            pOutputBitstream-&gt;bWaitOnEvent = <span class="literal">true</span>;</span><br><span class="line">            stThreadData.pOutputBfr-&gt;bDynResChangeFlag = pEncodeFrame-&gt;dynResChangeFlag == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32            </span></span><br><span class="line">            <span class="comment">// Queue o/p Sample</span></span><br><span class="line">            <span class="keyword">if</span> (!m_pEncoderThread-&gt;<span class="built_in">QueueSample</span>(stThreadData))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>            </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">			<span class="built_in">checkNVENCErrors</span>(nvStatus);</span><br><span class="line">            <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">吴健强</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/02/03/%E5%9F%BA%E4%BA%8ENvDec+CUDA+OpenGL+NvEnc%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8BGPU%E5%8A%A0%E9%80%9F%E6%96%B9%E6%A1%88/">http://example.com/2024/02/03/基于NvDec+CUDA+OpenGL+NvEnc的全流程GPU加速方案/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">吴健强のBLOG</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/IronMan/5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/assets/img/weixinpay.jpeg" target="_blank"><img class="post-qr-code-img" src="/assets/img/weixinpay.jpeg"/></a><div class="post-qr-code-desc"></div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/02/05/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E5%BC%95%E6%93%8E%E4%B9%8Bfilter%E9%93%BE%E8%B7%AF%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"><img class="prev-cover" src="/img/IronMan/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">音视频编解码引擎之filter链路的架构设计</div></div></a></div><div class="next-post pull-right"><a href="/2024/02/02/libyuv+OpenCV+IPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="/img/IronMan/2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">libyuv+OpenCV+IPP学习笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/IronMan/3.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">吴健强</div><div class="author-info__description">吴健强のBLOG</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">99</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wujianqiangCode"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wujianqiangCode" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:ijianqiangwu@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/assets/img/qq.jpg" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="/assets/img/weixin.jpeg" target="_blank" title="微信"><i class="fab fa-weixin"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">0 介绍：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">1 前期准备：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%AE%89%E8%A3%85CUDA-Toolkit"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 安装CUDA Toolkit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-NVIDIA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.2.</span> <span class="toc-text">1.1 NVIDIA驱动程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E9%AA%8C%E8%AF%81"><span class="toc-number">2.3.</span> <span class="toc-text">1.2 验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E9%AA%8C%E8%AF%81cuda%E6%98%AF%E5%90%A6%E8%83%BD%E6%AD%A3%E5%B8%B8%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">1.2.1 验证cuda是否能正常使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E9%AA%8C%E8%AF%81NvDec%E5%92%8CNvEnc%E6%98%AF%E5%90%A6%E8%83%BD%E6%AD%A3%E5%B8%B8%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.2.</span> <span class="toc-text">1.2.2 验证NvDec和NvEnc是否能正常使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%AE%89%E8%A3%85FFmpeg%E5%92%8C%E5%AF%B9%E5%BA%94%E7%9A%84nv-codec-headers"><span class="toc-number">2.4.</span> <span class="toc-text">1.3 安装FFmpeg和对应的nv-codec-headers</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%85%B7%E4%BD%93%E8%A7%A3%E7%A0%81%E6%B5%81%E7%A8%8B%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.</span> <span class="toc-text">2 具体解码流程步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 初始化设置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E5%8A%A0%E8%BD%BD%E5%AF%B9%E5%BA%94%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">3.1.1.</span> <span class="toc-text">2.1.1 加载对应头文件和动态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-CUDA%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.2.</span> <span class="toc-text">2.1.2 CUDA初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E7%9A%84%E5%85%B7%E4%BD%93%E5%90%AB%E4%B9%89%EF%BC%9A"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">相关参数的具体含义：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Flags%EF%BC%9A"><span class="toc-number">3.1.2.1.1.</span> <span class="toc-text">Flags：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cudaVersion%EF%BC%9A%EF%BC%9A"><span class="toc-number">3.1.2.1.2.</span> <span class="toc-text">cudaVersion：：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pHandleDriver%EF%BC%9A"><span class="toc-number">3.1.2.1.3.</span> <span class="toc-text">pHandleDriver：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dxtype%EF%BC%9A"><span class="toc-number">3.1.2.1.4.</span> <span class="toc-text">dxtype：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E8%A7%A3%E7%A0%81%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.3.</span> <span class="toc-text">2.1.3 解码器初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%88%9B%E5%BB%BACUDA%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 创建CUDA上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E6%98%BE%E5%8D%A1%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%E7%9A%84%E8%8E%B7%E5%8F%96%E4%BB%A5%E5%8F%8A%E6%98%BE%E5%8D%A1%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.2.1 显卡设备信息的获取以及显卡的选择</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E7%9A%84%E5%85%B7%E4%BD%93%E5%90%AB%E4%B9%89%EF%BC%9A-1"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">相关参数的具体含义：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#device%EF%BC%9A"><span class="toc-number">3.2.1.1.1.</span> <span class="toc-text">device：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ordinal%EF%BC%9A"><span class="toc-number">3.2.1.1.2.</span> <span class="toc-text">ordinal：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dev%EF%BC%9A"><span class="toc-number">3.2.1.1.3.</span> <span class="toc-text">dev：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#len%EF%BC%9A"><span class="toc-number">3.2.1.1.4.</span> <span class="toc-text">len：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E7%9A%84%E5%85%B7%E4%BD%93%E5%90%AB%E4%B9%89%EF%BC%9A-2"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">相关参数的具体含义：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pi"><span class="toc-number">3.2.1.2.1.</span> <span class="toc-text">pi:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#attrib"><span class="toc-number">3.2.1.2.2.</span> <span class="toc-text">attrib:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dev"><span class="toc-number">3.2.1.2.3.</span> <span class="toc-text">dev:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E7%9A%84%E5%85%B7%E4%BD%93%E8%AE%BE%E7%BD%AE%EF%BC%9A"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">相关参数的具体设置：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#major%E3%80%81minor%EF%BC%9A%EF%BC%9A"><span class="toc-number">3.2.1.3.1.</span> <span class="toc-text">major、minor：：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dev%EF%BC%9A-1"><span class="toc-number">3.2.1.3.2.</span> <span class="toc-text">dev：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E5%88%9B%E5%BB%BACUDA%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2.2 创建CUDA上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E7%9A%84%E5%85%B7%E4%BD%93%E8%AE%BE%E7%BD%AE%EF%BC%9A-1"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">相关参数的具体设置：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pCtx%EF%BC%9A"><span class="toc-number">3.2.2.1.1.</span> <span class="toc-text">pCtx：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Flags%EF%BC%9A-1"><span class="toc-number">3.2.2.1.2.</span> <span class="toc-text">Flags：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CUdevice%EF%BC%9A"><span class="toc-number">3.2.2.1.3.</span> <span class="toc-text">CUdevice：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Deprecated"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">Deprecated</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Description"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">Description</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Note"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">Note:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E7%9A%84%E5%85%B7%E4%BD%93%E8%AE%BE%E7%BD%AE%EF%BC%9A-2"><span class="toc-number">3.2.2.5.</span> <span class="toc-text">相关参数的具体设置：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pCtx%EF%BC%9A-1"><span class="toc-number">3.2.2.5.1.</span> <span class="toc-text">pCtx：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Flags%EF%BC%9A-2"><span class="toc-number">3.2.2.5.2.</span> <span class="toc-text">Flags：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CUdevice%EF%BC%9A-1"><span class="toc-number">3.2.2.5.3.</span> <span class="toc-text">CUdevice：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E9%AA%8C%E8%AF%81CUDA%E4%B8%8A%E4%B8%8B%E6%96%87%E6%98%AF%E5%90%A6%E6%88%90%E5%8A%9F%E5%88%9B%E5%BB%BA%E4%BB%A5%E5%8F%8A%E5%BD%93%E5%89%8D%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8F%AF%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E6%80%BB%E9%87%8F%E6%98%AF%E5%90%A6%E5%85%85%E8%B6%B3"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.2.3 验证CUDA上下文是否成功创建以及当前上下文可用的内存总量是否充足</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%9F%A5%E8%AF%A2%E7%A1%AC%E4%BB%B6%E8%A7%A3%E7%A0%81%E5%99%A8%E8%A7%A3%E7%A0%81%E8%83%BD%E5%8A%9B"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 查询硬件解码器解码能力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%88%9B%E5%BB%BA%E8%A7%A3%E7%A0%81%E5%99%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.4.</span> <span class="toc-text">2.4 创建解码器实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-CUVIDDECODECREATEINFO%E4%BF%A1%E6%81%AF%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-number">3.4.1.</span> <span class="toc-text">2.4.1 CUVIDDECODECREATEINFO信息的获取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E5%85%B7%E4%BD%93%E8%AE%BE%E7%BD%AE%EF%BC%9A"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">相关参数具体设置：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ulWidth%E3%80%81ulHeight%EF%BC%9A"><span class="toc-number">3.4.1.1.1.</span> <span class="toc-text">ulWidth、ulHeight：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ulNumDecodeSurfaces%EF%BC%9A"><span class="toc-number">3.4.1.1.2.</span> <span class="toc-text">ulNumDecodeSurfaces：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CodecType%EF%BC%9A"><span class="toc-number">3.4.1.1.3.</span> <span class="toc-text">CodecType：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ChromaFormat%EF%BC%9A"><span class="toc-number">3.4.1.1.4.</span> <span class="toc-text">ChromaFormat：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ulCreationFlags%EF%BC%9A"><span class="toc-number">3.4.1.1.5.</span> <span class="toc-text">ulCreationFlags：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OutputFormat%EF%BC%9A"><span class="toc-number">3.4.1.1.6.</span> <span class="toc-text">OutputFormat：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DeinterlaceMode%EF%BC%9A"><span class="toc-number">3.4.1.1.7.</span> <span class="toc-text">DeinterlaceMode：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bitDepthMinus8%EF%BC%9A"><span class="toc-number">3.4.1.1.8.</span> <span class="toc-text">bitDepthMinus8：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ulTargetWidth%EF%BC%8CulTargetHeight%EF%BC%9A"><span class="toc-number">3.4.1.1.9.</span> <span class="toc-text">ulTargetWidth，ulTargetHeight：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ulNumOutputSurfaces%EF%BC%9A"><span class="toc-number">3.4.1.1.10.</span> <span class="toc-text">ulNumOutputSurfaces：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vidLock%EF%BC%9A"><span class="toc-number">3.4.1.1.11.</span> <span class="toc-text">vidLock：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#target-rect"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">target_rect:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E5%88%9B%E5%BB%BA%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">3.4.2.</span> <span class="toc-text">2.4.2 创建视频解码器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E8%BD%AF%E4%BB%B6-%E5%A6%82FFMPEG-%E8%BF%9B%E8%A1%8CDemux"><span class="toc-number">3.5.</span> <span class="toc-text">2.5 使用第三方软件(如FFMPEG)进行Demux</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E4%BD%BF%E7%94%A8NVDECODE-API%E6%8F%90%E4%BE%9B%E7%9A%84%E8%A7%A3%E6%9E%90%E5%99%A8%E6%88%96%E7%AC%AC%E4%B8%89%E6%96%B9%E8%A7%A3%E6%9E%90%E5%99%A8%EF%BC%88%E5%A6%82FFmpeg%EF%BC%89%E8%A7%A3%E6%9E%90%E8%A7%86%E9%A2%91%E6%AF%94%E7%89%B9%E6%B5%81"><span class="toc-number">3.6.</span> <span class="toc-text">2.6 使用NVDECODE API提供的解析器或第三方解析器（如FFmpeg）解析视频比特流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-CUVIDPARSERPARAMS%E4%BF%A1%E6%81%AF%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-number">3.6.1.</span> <span class="toc-text">2.6.1 CUVIDPARSERPARAMS信息的获取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E5%85%B7%E4%BD%93%E8%AE%BE%E7%BD%AE%EF%BC%9A-1"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">相关参数具体设置：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CodecType"><span class="toc-number">3.6.1.1.1.</span> <span class="toc-text">CodecType</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ulMaxNumDecodeSurfaces"><span class="toc-number">3.6.1.1.2.</span> <span class="toc-text">ulMaxNumDecodeSurfaces</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ulClockRate%EF%BC%9A"><span class="toc-number">3.6.1.1.3.</span> <span class="toc-text">ulClockRate：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ulErrorThreshold"><span class="toc-number">3.6.1.1.4.</span> <span class="toc-text">ulErrorThreshold</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ulMaxDisplayDelay"><span class="toc-number">3.6.1.1.5.</span> <span class="toc-text">ulMaxDisplayDelay</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#uReserved1-5"><span class="toc-number">3.6.1.1.6.</span> <span class="toc-text">uReserved1[5]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pUserData"><span class="toc-number">3.6.1.1.7.</span> <span class="toc-text">pUserData</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pfnSequenceCallback"><span class="toc-number">3.6.1.1.8.</span> <span class="toc-text">pfnSequenceCallback</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pfnDecodePicture"><span class="toc-number">3.6.1.1.9.</span> <span class="toc-text">pfnDecodePicture</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pfnDisplayPicture"><span class="toc-number">3.6.1.1.10.</span> <span class="toc-text">pfnDisplayPicture</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pvReserved2"><span class="toc-number">3.6.1.1.11.</span> <span class="toc-text">pvReserved2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pExtVideoInfo"><span class="toc-number">3.6.1.1.12.</span> <span class="toc-text">pExtVideoInfo</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pfnGetOperatingPoint%EF%BC%88%E5%8F%AA%E9%92%88%E5%AF%B9avi%EF%BC%89"><span class="toc-number">3.6.1.1.13.</span> <span class="toc-text">pfnGetOperatingPoint（只针对avi）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pfnGetSEIMsg-%E4%B8%80%E8%88%AC%E7%94%A8%E4%B8%8D%E5%88%B0"><span class="toc-number">3.6.1.1.14.</span> <span class="toc-text">pfnGetSEIMsg(一般用不到)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-2-%E7%9B%B8%E5%85%B3%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.6.2.</span> <span class="toc-text">2.6.2 相关回调函数的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-1-pfnSequenceCallback%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">2.6.2.1 pfnSequenceCallback回调函数的设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-2-pfnDecodePicture%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.6.2.2.</span> <span class="toc-text">2.6.2.2 pfnDecodePicture回调函数的设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-3-pfnDisplayPicture%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.6.2.3.</span> <span class="toc-text">2.6.2.3 pfnDisplayPicture回调函数的设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-4-pfnGetOperatingPoint%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.6.2.4.</span> <span class="toc-text">2.6.2.4 pfnGetOperatingPoint回调函数的设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-5-pfnGetSEIMsg%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.6.2.5.</span> <span class="toc-text">2.6.2.5 pfnGetSEIMsg回调函数的设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-3-%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">3.6.3.</span> <span class="toc-text">2.6.3 解析器的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-4-%E4%BB%8E%E8%A7%A3%E5%A4%8D%E7%94%A8%E5%99%A8%E6%8F%90%E5%8F%96%E6%95%B0%E6%8D%AE%E5%8C%85%E8%BF%9B%E8%A1%8C%E8%A7%A3%E7%A0%81"><span class="toc-number">3.6.4.</span> <span class="toc-text">2.6.4 从解复用器提取数据包进行解码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E5%85%B7%E4%BD%93%E8%AE%BE%E7%BD%AE%EF%BC%9A-2"><span class="toc-number">3.6.4.1.</span> <span class="toc-text">相关参数具体设置：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#flags%EF%BC%9A"><span class="toc-number">3.6.4.1.1.</span> <span class="toc-text">flags：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#payload-size"><span class="toc-number">3.6.4.1.2.</span> <span class="toc-text">payload_size</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#payload"><span class="toc-number">3.6.4.1.3.</span> <span class="toc-text">payload</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#timestamp"><span class="toc-number">3.6.4.1.4.</span> <span class="toc-text">timestamp</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E5%85%B7%E4%BD%93%E8%AE%BE%E7%BD%AE%EF%BC%9A-3"><span class="toc-number">3.6.4.2.</span> <span class="toc-text">相关参数具体设置：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#format%EF%BC%9A"><span class="toc-number">3.6.4.2.1.</span> <span class="toc-text">format：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#raw-seqhdr-data%EF%BC%9A"><span class="toc-number">3.6.4.2.2.</span> <span class="toc-text">raw_seqhdr_data：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-%E6%A0%B9%E6%8D%AE%E8%A7%A3%E7%A0%81%E7%8A%B6%E6%80%81%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%A7%A3%E7%A0%81%E5%90%8E%E7%9A%84%E8%BE%93%E5%87%BA%E8%BF%9B%E8%A1%8C%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%9A%84%E5%A4%84%E7%90%86-%E5%A6%82%E6%B8%B2%E6%9F%93%E3%80%81%E5%90%8E%E5%A4%84%E7%90%86%E7%AD%89"><span class="toc-number">3.7.</span> <span class="toc-text">2.9 根据解码状态，使用解码后的输出进行进一步的处理(如渲染、后处理等)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%87%E7%94%A8OpenGL%E4%B8%8ECUDA%E4%BA%92%E6%93%8D%E4%BD%9C%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.7.1.</span> <span class="toc-text">2.9.1 为什么要采用OpenGL与CUDA互操作的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-2-CUDA%E4%B8%8EOpenGL%E4%BA%92%E6%93%8D%E4%BD%9C"><span class="toc-number">3.7.2.</span> <span class="toc-text">2.9.2 CUDA与OpenGL互操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-2-1-%E6%96%B9%E6%B3%95%E4%B8%80-VBO-VAO-%EF%BC%9A"><span class="toc-number">3.7.2.1.</span> <span class="toc-text">2.9.2.1 方法一(VBO+VAO)：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-9-2-1-1-VBO-VAO%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.7.2.1.1.</span> <span class="toc-text">2.9.2.1.1 VBO+VAO基础概念介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-9-2-1-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%BA%E4%BA%86%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%EF%BC%8C%E5%90%8C%E6%97%B6%E6%93%8D%E4%BD%9C%E4%B8%A4%E4%B8%AAVBO%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="toc-number">3.7.2.1.2.</span> <span class="toc-text">2.9.2.1.2 代码实现（为了提高效率，同时操作两个VBO数据）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-2-2-%E6%96%B9%E6%B3%95%E4%BA%8C-texture-%EF%BC%9A"><span class="toc-number">3.7.2.2.</span> <span class="toc-text">2.9.2.2 方法二(texture)：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-9-2-2-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%BA%E4%BA%86%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%EF%BC%8C%E5%90%8C%E6%97%B6%E6%93%8D%E4%BD%9C%E4%B8%A4%E4%B8%AATexture%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="toc-number">3.7.2.2.1.</span> <span class="toc-text">2.9.2.2.2 代码实现（为了提高效率，同时操作两个Texture数据）</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EF%BC%93-%E4%B8%AD%E9%97%B4%E6%B8%B2%E6%9F%93%E5%92%8Cfilter%E9%93%BE%E8%B7%AF%E7%9A%84%E6%9E%84%E5%BB%BA%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.</span> <span class="toc-text">３ 中间渲染和filter链路的构建的具体流程步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-OpenGL%E7%9A%84%E5%B1%8F%E5%B9%95%E7%BB%98%E5%88%B6%E5%92%8Cfilter%E9%93%BE%E8%B7%AF%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 OpenGL的屏幕绘制和filter链路的构建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-OpenGL%E7%9A%84filter%E9%93%BE%E8%B7%AF%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 OpenGL的filter链路的构建</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%85%B7%E4%BD%93%E7%BC%96%E7%A0%81%E6%B5%81%E7%A8%8B%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.</span> <span class="toc-text">4 具体编码流程步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BC%96%E7%A0%81%E5%99%A8"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 初始化编码器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E8%AE%BE%E7%BD%AE%E6%89%80%E9%9C%80%E7%9A%84%E7%BC%96%E7%A0%81%E5%8F%82%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 设置所需的编码参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E8%8E%B7%E5%8F%96%E7%BC%96%E7%A0%81%E4%BC%9A%E8%AF%9D%E5%8F%A5%E6%9F%84"><span class="toc-number">5.2.1.</span> <span class="toc-text">4.2.1 获取编码会话句柄</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E8%8E%B7%E5%8F%96%E7%BC%96%E7%A0%81%E5%99%A8%E4%BF%A1%E6%81%AF"><span class="toc-number">5.2.2.</span> <span class="toc-text">4.2.3 获取编码器信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-%E9%80%89%E6%8B%A9%E7%BC%96%E7%A0%81%E5%99%A8%E9%A2%84%E8%AE%BE%E9%85%8D%E7%BD%AE"><span class="toc-number">5.2.3.</span> <span class="toc-text">4.2.4 选择编码器预设配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-5-%E9%80%89%E6%8B%A9%E7%BC%96%E7%A0%81%E5%99%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.4.</span> <span class="toc-text">4.2.5 选择编码器配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-6-%E8%8E%B7%E5%8F%96%E6%94%AF%E6%8C%81%E7%9A%84%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F%E5%88%97%E8%A1%A8"><span class="toc-number">5.2.5.</span> <span class="toc-text">4.2.6 获取支持的输入格式列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-7-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A0%81%E5%99%A8%E4%BC%9A%E8%AF%9D"><span class="toc-number">5.2.6.</span> <span class="toc-text">4.2.7 初始化硬件编码器会话</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-7-1-%E7%BC%96%E7%A0%81%E4%BC%9A%E8%AF%9D%E5%B1%9E%E6%80%A7%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">5.2.6.1.</span> <span class="toc-text">4.2.7.1 编码会话属性的配置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-7-1-1-%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%BC%96%E7%A0%81%E4%BC%9A%E8%AF%9D%E5%8F%82%E6%95%B0"><span class="toc-number">5.2.6.1.1.</span> <span class="toc-text">4.2.7.1.1 基本的编码会话参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-7-1-2-%E9%AB%98%E7%BA%A7%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E7%BA%A7%E5%8F%82%E6%95%B0"><span class="toc-number">5.2.6.1.2.</span> <span class="toc-text">4.2.7.1.2 高级编解码器级参数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-7-2-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A0%81%E5%99%A8%E4%BC%9A%E8%AF%9D"><span class="toc-number">5.2.6.2.</span> <span class="toc-text">4.2.7.2 初始化硬件编码器会话</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%88%86%E9%85%8D%E8%BE%93%E5%85%A5-x2F-%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 分配输入&#x2F;输出缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E5%A4%96%E9%83%A8%E5%88%86%E9%85%8D%E7%9A%84%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">5.3.1.</span> <span class="toc-text">4.3.1 外部分配的输入缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-1-NV-ENC-REGISTER-RESOURCE%E7%9A%84%E5%A1%AB%E5%85%85%E5%92%8C%E6%B3%A8%E5%86%8C"><span class="toc-number">5.3.2.</span> <span class="toc-text">4.3.1.1 NV_ENC_REGISTER_RESOURCE的填充和注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-2-%E5%B0%86OpenGL%E5%88%86%E9%85%8D%E7%9A%84%E5%A4%96%E9%83%A8%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E6%98%A0%E5%B0%84%E5%88%B0NV-ENC%E4%B8%AD"><span class="toc-number">5.3.3.</span> <span class="toc-text">4.3.1.2 将OpenGL分配的外部输入缓冲区映射到NV_ENC中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E5%88%86%E9%85%8D%E8%BE%93%E5%87%BA%E7%9A%84%E6%AF%94%E7%89%B9%E6%B5%81%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">5.3.4.</span> <span class="toc-text">4.3.2 分配输出的比特流缓冲区</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/02/22/Linux%E7%AB%AFNVIDIA%E7%9A%84%E8%A7%86%E9%A2%91GPU%E5%8A%A0%E9%80%9F%E6%96%B9%E6%A1%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" title="Linux端NVIDIA的视频GPU加速方案开发笔记"><img src="/img/IronMan/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux端NVIDIA的视频GPU加速方案开发笔记"/></a><div class="content"><a class="title" href="/2024/02/22/Linux%E7%AB%AFNVIDIA%E7%9A%84%E8%A7%86%E9%A2%91GPU%E5%8A%A0%E9%80%9F%E6%96%B9%E6%A1%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" title="Linux端NVIDIA的视频GPU加速方案开发笔记">Linux端NVIDIA的视频GPU加速方案开发笔记</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/20/WebCodecs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="WebCodecs学习笔记"><img src="/img/IronMan/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebCodecs学习笔记"/></a><div class="content"><a class="title" href="/2024/02/20/WebCodecs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="WebCodecs学习笔记">WebCodecs学习笔记</a><time datetime="2024-02-19T16:00:00.000Z" title="发表于 2024-02-20 00:00:00">2024-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/18/OpenGL%E5%92%8CCUDA%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="OpenGL和CUDA的学习笔记"><img src="/img/IronMan/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenGL和CUDA的学习笔记"/></a><div class="content"><a class="title" href="/2024/02/18/OpenGL%E5%92%8CCUDA%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="OpenGL和CUDA的学习笔记">OpenGL和CUDA的学习笔记</a><time datetime="2024-02-17T16:00:00.000Z" title="发表于 2024-02-18 00:00:00">2024-02-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/16/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" title="音视频编解码系统的架构设计"><img src="/img/IronMan/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="音视频编解码系统的架构设计"/></a><div class="content"><a class="title" href="/2024/02/16/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" title="音视频编解码系统的架构设计">音视频编解码系统的架构设计</a><time datetime="2024-02-15T16:00:00.000Z" title="发表于 2024-02-16 00:00:00">2024-02-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="设计模式学习笔记"><img src="/img/IronMan/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式学习笔记"/></a><div class="content"><a class="title" href="/2024/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="设计模式学习笔记">设计模式学习笔记</a><time datetime="2024-02-14T16:00:00.000Z" title="发表于 2024-02-15 00:00:00">2024-02-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/IronMan/2.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 吴健强</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="66641056" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-lrcType="-1"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>